[
  {
    "idx": 157960,
    "project": "drm",
    "commit_id": "9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f",
    "project_url": "https://cgit.freedesktop.org/drm/drm-misc/commit/?id=9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f",
    "commit_url": "https://cgit.freedesktop.org/drm/drm-misc/commit/?id=9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f",
    "commit_message": "None",
    "label": 0,
    "func": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * If there are multiple edid files specified and separated\n\t * by commas, search through the list looking for one that\n\t * matches the connector.\n\t *\n\t * If there's one or more that doesn't specify a connector, keep\n \t * the last one found one as a fallback.\n \t */\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n\tif (!fwstr)\n\t\treturn ERR_PTR(-ENOMEM);\n \tedidstr = fwstr;\n \n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*edidname != '\\0') /* corner case: multiple ',' */\n\t\t\tfallback = edidname;\n\t}\n",
    "func_hash": 199051164919133436575414029938699656311,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2019-12382",
    "cve_desc": "An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-12382",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "connector_name",
          "by",
          "edid",
          "matches",
          "drm_load_edid_firmware",
          "edidname",
          "connector",
          "the"
        ],
        "arrays": [
          "edid_firmware"
        ],
        "size_variables": [],
        "all_variables": [
          "connector_name",
          "by",
          "edid_firmware",
          "edid",
          "matches",
          "drm_load_edid_firmware",
          "edidname",
          "connector",
          "the"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "connector",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r *connector_name = connector->name;\n\tchar *edidname, *"
            },
            {
              "variable": "drm_load_edid_firmware",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct edid *drm_load_edid_firmware(struct drm_connecto"
            },
            {
              "variable": "connector",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct drm_connector *connector)\n{\n\tconst char *con"
            },
            {
              "variable": "connector_name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctor)\n{\n\tconst char *connector_name = connector->name;"
            },
            {
              "variable": "edidname",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nector->name;\n\tchar *edidname, *last, *colon, *fw"
            },
            {
              "variable": "last",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e;\n\tchar *edidname, *last, *colon, *fwstr, *e"
            },
            {
              "variable": "colon",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r *edidname, *last, *colon, *fwstr, *edidstr,"
            },
            {
              "variable": "fwstr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ame, *last, *colon, *fwstr, *edidstr, *fallbac"
            },
            {
              "variable": "edidstr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st, *colon, *fwstr, *edidstr, *fallback = NULL;"
            },
            {
              "variable": "fallback",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", *fwstr, *edidstr, *fallback = NULL;\n\tstruct edi"
            },
            {
              "variable": "edid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL;\n\tstruct edid *edid;\n\n\tif (edid_firmwar"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TR(-ENOENT);\n\n\t/*\n\t * If there are multiple"
            },
            {
              "variable": "by",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ied and separated\n\t * by commas, search thro"
            },
            {
              "variable": "matches",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "king for one that\n\t * matches the connector.\n\t *"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "he connector.\n\t *\n\t * If there's one or more"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "connector, keep\n \t * the last one found one"
            },
            {
              "variable": "edidname",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n\t\t}\n\n\t\tif (*edidname != '\\0') /* corner"
            },
            {
              "variable": "corner",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*edidname != '\\0') /* corner case: multiple ','"
            },
            {
              "variable": "edid_firmware",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t edid *edid;\n\n\tif (edid_firmware[0] == '\\0')\n\t\treturn E"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 9,
        "pointer_count": 8,
        "array_count": 1,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\": [\"edid_firmware\"]}",
    "vulnerable_variables": [
      "edid_firmware"
    ],
    "vulnerable_variable": "edid_firmware",
    "variable_definitions": {
      "edid_firmware": "Definition not found"
    },
    "variable_types": {
      "edid_firmware": "char array"
    },
    "type_mapping": {
      "edid_firmware": "char array"
    }
  },
  {
    "idx": 157967,
    "project": "openssl",
    "commit_id": "d8541d7e9e63bf5f343af24644046c8d96498c17",
    "project_url": "https://github.com/openssl/openssl",
    "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=d8541d7e9e63bf5f343af24644046c8d96498c17",
    "commit_message": "Add PSS parameter check.\n\nAvoid seg fault by checking mgf1 parameter is not NULL. This can be\ntriggered during certificate verification so could be a DoS attack\nagainst a client or a server enabling client authentication.\n\nThanks to Loïc Jonas Etienne (Qnective AG) for discovering this bug.\n\nCVE-2015-3194\n\nReviewed-by: Matt Caswell <matt@openssl.org>",
    "label": 0,
    "func": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n     if (pss->maskGenAlgorithm) {\n         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param && param->type == V_ASN1_SEQUENCE) {\n             p = param->value.sequence->data;\n             plen = param->value.sequence->length;\n             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}\n",
    "func_hash": 338718658446842935098442076237481568312,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2015-3194",
    "cve_desc": "crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3194",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "param",
          "alg",
          "pss",
          "p",
          "rsa_pss_decode"
        ],
        "arrays": [],
        "size_variables": [
          "length",
          "plen"
        ],
        "all_variables": [
          "length",
          "plen",
          "param",
          "alg",
          "pss",
          "p",
          "rsa_pss_decode"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "h = NULL;\n\n    if (!alg->parameter || alg->parameter->"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(!alg->parameter || alg->parameter->type != V_ASN1_SEQ"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn NULL;\n    p = alg->parameter->value.sequence->da"
            },
            {
              "variable": "sequence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g->parameter->value.sequence->data;\n    plen = alg->pa"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e->data;\n    plen = alg->parameter->value.sequence->le"
            },
            {
              "variable": "sequence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g->parameter->value.sequence->length;\n    pss = d2i_RSA_"
            },
            {
              "variable": "pss",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "urn NULL;\n\n     if (pss->maskGenAlgorithm) {\n         ASN1_TY"
            },
            {
              "variable": "pss",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;"
            },
            {
              "variable": "pss",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_"
            },
            {
              "variable": "param",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& param && param->type == V_ASN1_SEQUENCE)"
            },
            {
              "variable": "param",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n             p = param->value.sequence->data;"
            },
            {
              "variable": "sequence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p = param->value.sequence->data;\n             plen"
            },
            {
              "variable": "param",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "plen = param->value.sequence->length;"
            },
            {
              "variable": "sequence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "plen = param->value.sequence->length;\n             *pmas"
            },
            {
              "variable": "rsa_pss_decode",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "atic RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *a"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de(const X509_ALGOR *alg,"
            },
            {
              "variable": "pmaskHash",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X509_ALGOR **pmaskHash)\n{\n    const unsign"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const unsigned char *p;\n    int plen;"
            },
            {
              "variable": "pss",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RSA_PSS_PARAMS *pss;\n\n    *pmaskHash ="
            },
            {
              "variable": "pmaskHash",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "S_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!a"
            },
            {
              "variable": "param",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ASN1_TYPE *param = pss->maskGenAlgor"
            },
            {
              "variable": "pmaskHash",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ength;\n             *pmaskHash = d2i_X509_ALGOR(NU"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 7,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"param\"]}",
    "vulnerable_variables": [
      "param"
    ],
    "vulnerable_variable": "param",
    "variable_definitions": {
      "param": "ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;"
    },
    "variable_types": {
      "param": "struct pointer"
    },
    "type_mapping": {
      "param": "struct pointer"
    }
  },
  {
    "idx": 157968,
    "project": "openssl",
    "commit_id": "c394a488942387246653833359a5c94b5832674e",
    "project_url": "https://github.com/openssl/openssl",
    "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=c394a488942387246653833359a5c94b5832674e",
    "commit_message": "Add PSS parameter check.\n\nAvoid seg fault by checking mgf1 parameter is not NULL. This can be\ntriggered during certificate verification so could be a DoS attack\nagainst a client or a server enabling client authentication.\n\nThanks to Loïc Jonas Etienne (Qnective AG) for discovering this bug.\n\nCVE-2015-3194\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
    "label": 0,
    "func": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {\n     const unsigned char *p;\n     int plen;\n    if (alg == NULL || alg->parameter == NULL)\n         return NULL;\n     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n         return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}\n",
    "func_hash": 184183702878896057031381637225428687008,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2015-3194",
    "cve_desc": "crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3194",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "alg",
          "p",
          "parameter",
          "rsa_mgf1_decode"
        ],
        "arrays": [],
        "size_variables": [
          "length",
          "plen"
        ],
        "all_variables": [
          "length",
          "rsa_mgf1_decode",
          "alg",
          "plen",
          "p",
          "parameter"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (alg == NULL || alg->parameter == NULL)\n         r"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn NULL;\n    if (alg->parameter->type != V_ASN1_SEQ"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "turn NULL;\n\n    p = alg->parameter->value.sequence->da"
            },
            {
              "variable": "sequence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g->parameter->value.sequence->data;\n    plen = alg->pa"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e->data;\n    plen = alg->parameter->value.sequence->le"
            },
            {
              "variable": "sequence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g->parameter->value.sequence->length;\n    return d2i_X50"
            },
            {
              "variable": "rsa_mgf1_decode",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1_decode(X509_ALGOR *alg)\n {\n     const unsi"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const unsigned char *p;\n     int plen;"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 4,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"alg\", \"parameter\"]}",
    "vulnerable_variables": [
      "alg",
      "parameter"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "alg": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)",
      "parameter": "Definition not found"
    },
    "variable_types": {
      "alg": "struct pointer",
      "parameter": "struct pointer_struct pointer"
    },
    "type_mapping": {
      "alg": "struct pointer",
      "parameter": "sp_sp"
    }
  },
  {
    "idx": 157994,
    "project": "savannah",
    "commit_id": "cb07844454d8cc9fb21f53ace75975f91185a120",
    "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls",
    "commit_url": "https://git.savannah.gnu.org/cgit/tar.git/commit/?id=cb07844454d8cc9fb21f53ace75975f91185a120",
    "commit_message": "None",
    "label": 0,
    "func": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n            b = find_next_block ();                                 \\\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n \t }                                                         \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n       start = current_block_ordinal ();\n       set_next_block_after (current_header);\n       blk = find_next_block ();\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}\n",
    "func_hash": 143151925619516221388066178344614236926,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2019-9923",
    "cve_desc": "pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-9923",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "endp",
          "file",
          "blk",
          "p",
          "dst"
        ],
        "arrays": [
          "nbuf",
          "dst"
        ],
        "size_variables": [
          "UINTMAX_STRSIZE_BOUND",
          "numeric",
          "size_t",
          "BLOCKSIZE",
          "dumped_size",
          "sizeof",
          "numbytes",
          "decode_num",
          "sparse_map_size"
        ],
        "all_variables": [
          "nbuf",
          "UINTMAX_STRSIZE_BOUND",
          "numeric",
          "numbytes",
          "size_t",
          "endp",
          "BLOCKSIZE",
          "decode_num",
          "dumped_size",
          "sizeof",
          "file",
          "blk",
          "p",
          "sparse_map_size",
          "dst"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "file *file)\n{\n  if (file->stat_info->sparse_major > 0)"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\\n   char *endp = b->buffer + BLOCKSIZE;"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ber\"), \\\n\t          file->stat_info->orig_file_name));"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\\n            src = b->buffer;"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\\n \t   endp = b->buffer + BLOCKSIZE;"
            },
            {
              "variable": "blk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ive\")));\n       p = blk->buffer;\n       COPY_BUF (b"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(size_t)))\n\t}\n      file->stat_info->sparse_map_size ="
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "map_size = u;\n      file->stat_info->sparse_map = xcall"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "arse_map = xcalloc (file->stat_info->sparse_map_size,"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sizeof (*file->stat_info->sparse_map));"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sparse_map));\n      file->stat_info->sparse_map_avail ="
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (i = 0; i < file->stat_info->sparse_map_size; i"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e member\"),\n\t\t      file->stat_info->orig_file_name));"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e member\"),\n\t\t      file->stat_info->orig_file_name));"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sparse_add_map (file->stat_info, &sp);\n\t}\n      set"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "after (blk);\n\n      file->dumped_size += BLOCKSIZE * (cur"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct tar_sparse_file *file)\n{\n  if (file->stat"
            },
            {
              "variable": "blk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n      union block *blk;\n      char *p;"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ck *blk;\n      char *p;\n      size_t i;"
            },
            {
              "variable": "endp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\\n   char *endp = b->buffer + BLOCK"
            },
            {
              "variable": "dst",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\\n   char *dst = buf;"
            },
            {
              "variable": "dst",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\\n   while (*dst++ != '\\n');"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_"
            },
            {
              "variable": "nbuf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "max_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 15,
        "pointer_count": 5,
        "array_count": 2,
        "size_variable_count": 9
      }
    },
    "predict": "{\"vulnerable_variables\":[\"decode_num\",\"sparse_map_size\"]}",
    "vulnerable_variables": [
      "decode_num",
      "sparse_map_size"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "decode_num": "Definition not found",
      "sparse_map_size": "Definition not found"
    },
    "variable_types": {
      "decode_num": "unknown",
      "sparse_map_size": "integer"
    },
    "type_mapping": {
      "decode_num": "unknown",
      "sparse_map_size": "Integer"
    }
  },
  {
    "idx": 158075,
    "project": "poppler",
    "commit_id": "5c9b08a875b07853be6c44e43ff5f7f059df666a",
    "project_url": "https://github.com/freedesktop/poppler",
    "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=5c9b08a875b07853be6c44e43ff5f7f059df666a",
    "commit_message": "pdfunite: Fix crash with broken documents\n\nSometimes we can't parse pages so check before accessing them\n\nThanks to Jiaqi Peng for the report\n\nFixes bugs #101153 and #101149",
    "label": 0,
    "func": "int main (int argc, char *argv[])\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n     catDict->lookup(\"OutputIntents\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj);\n     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n    if (!afObj.isNull() && refPage) {\n       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &ocObj);\n    if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookup(\"Names\", &names);\n    if (!names.isNull() && names.isDict() && refPage) {\n       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n \n   for (i = 0; i < (int) docs.size(); i++) {\n     for (j = 1; j <= docs[i]->getNumPages(); j++) {\n      if (!docs[i]->getCatalog()->getPage(j)) {\n        continue;\n      }\n\n       PDFRectangle *cropBox = NULL;\n       if (docs[i]->getCatalog()->getPage(j)->isCropped())\n         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}\n",
    "func_hash": 4674050423349651754578522671885372804,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-7511",
    "cve_desc": "poppler since version 0.17.3 has been vulnerable to NULL pointer dereference in pdfunite triggered by specially crafted documents.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-7511",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "newResource",
          "key",
          "argv",
          "gidf",
          "outStr",
          "resDict",
          "doc",
          "f",
          "pageDict",
          "cropBox",
          "pageCatDict",
          "catDict",
          "gpgidf",
          "gfileName",
          "yRef",
          "refPage",
          "pagecatDict",
          "fileName",
          "trailerDict"
        ],
        "arrays": [
          "Kids",
          "pages",
          "offsets",
          "argv",
          "docs",
          "OutputIntents"
        ],
        "size_variables": [
          "gfileName",
          "num",
          "numOffset",
          "getFileName",
          "objectsCount",
          "getLength",
          "numbering",
          "rootNum",
          "fileName",
          "countRef",
          "getNumObjects",
          "arrayGetLength",
          "Count",
          "getNumPages",
          "size"
        ],
        "all_variables": [
          "Kids",
          "pages",
          "newResource",
          "key",
          "offsets",
          "argv",
          "getNumObjects",
          "gidf",
          "docs",
          "arrayGetLength",
          "outStr",
          "resDict",
          "doc",
          "f",
          "pageDict",
          "cropBox",
          "pageCatDict",
          "num",
          "numOffset",
          "getFileName",
          "numbering",
          "rootNum",
          "countRef",
          "Count",
          "getLength",
          "catDict",
          "gpgidf",
          "size",
          "gfileName",
          "yRef",
          "refPage",
          "objectsCount",
          "pagecatDict",
          "fileName",
          "trailerDict",
          "OutputIntents",
          "getNumPages"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ULL, NULL);\n    if (doc->isOk() && !doc->isEncryp"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (doc->isOk() && !doc->isEncrypted()) {\n      docs.pus"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ack(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "majorVersion = doc->getPDFMajorVersion();\n        minorVer"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "minorVersion = doc->getPDFMinorVersion();\n      } else if"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n      } else if (doc->getPDFMajorVersion() == majorVersion)"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "minorVersion = doc->getPDFMinorVersion();\n        }"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    } else if (doc->isOk()) {\n      error(er"
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Ref = new XRef();\n  yRef->add(0, 65535, 0, gFalse"
            },
            {
              "variable": "catDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Obj.getDict();\n     catDict->lookup(\"OutputIntents\", &i"
            },
            {
              "variable": "catDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj)"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "yRef, countRef, 0, refPage->num, refPage->num);"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f, 0, refPage->num, refPage->num);\n     }\n     catDi"
            },
            {
              "variable": "catDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &oc"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "yRef, countRef, 0, refPage->num, refPage->num);"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f, 0, refPage->num, refPage->num);\n     }\n     catDi"
            },
            {
              "variable": "catDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->num);\n     }\n     catDict->lookup(\"Names\", &names);"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "yRef, countRef, 0, refPage->num, refPage->num);"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f, 0, refPage->num, refPage->num);\n     }\n     if (i"
            },
            {
              "variable": "pagecatDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".getDict();\n        pagecatDict->lookup(\"OutputIntents\", &p"
            },
            {
              "variable": "gpgidf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (gpgidf->cmp(gidf) == 0) {"
            },
            {
              "variable": "gidf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gidf->getCString(), docs[i]->getFile"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "]->getXRef()->fetch(refPage->num, refPage->gen, &pag"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fetch(refPage->num, refPage->gen, &page);\n      Dict"
            },
            {
              "variable": "newResource",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "w Object();\n        newResource->initDict(resDict);\n        p"
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t(resDict);\n        pageDict->set(\"Resources\", newRes"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ountRef, numOffset, refPage->num, refPage->num);"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fset, refPage->num, refPage->num);\n      Object anno"
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsOb"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ountRef, numOffset, refPage->num, refPage->num);"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fset, refPage->num, refPage->num);\n        annotsObj"
            },
            {
              "variable": "pageCatDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames"
            },
            {
              "variable": "pageCatDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageFo"
            },
            {
              "variable": "pageCatDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj)"
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootN"
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add("
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NumObjects() + 1;\n  yRef->add(rootNum, 0, outStr-"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootN"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Length() > 0) {\n    outStr->printf(\" /OutputIntents [\""
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Obj.isNull()) {\n    outStr->printf(\" /AcroForm \");"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Obj.isDict()) {\n    outStr->printf(\" /OCProperties \");"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mes.isDict()) {\n    outStr->printf(\" /Names \");\n    PD"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");"
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "objectsCount++;\n\n  yRef->add(rootNum + 1, 0, out"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootN"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /K"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\n"
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".size(); i++) {\n    yRef->add(rootNum + i + 2, 0,"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outS"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootN"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "otNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *p"
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (j = 0; j < pageDict->getLength(); j++) {\n      if"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n      if (j > 0)\n\toutStr->printf(\" \");\n      const c"
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char *key = pageDict->getKey(j);\n      Object va"
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Object value;\n      pageDict->getValNF(j, &value);\n      i"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", r"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "} else {\n        outStr->printf(\"/%s \", key);"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fileName, outStr->getPos());\n  PDFDoc::write"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ete trailerDict;\n\n  outStr->close();\n  delete outStr;"
            },
            {
              "variable": "argv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ain (int argc, char *argv[])\n{\n  int objectsC"
            },
            {
              "variable": "yRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt> offsets;\n  XRef *yRef, *countRef;\n  FILE"
            },
            {
              "variable": "countRef",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutSt"
            },
            {
              "variable": "f",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", *countRef;\n  FILE *f;\n  OutStream *outSt"
            },
            {
              "variable": "outStr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ILE *f;\n  OutStream *outStr;\n  int i;\n  int j,"
            },
            {
              "variable": "fileName",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Version = 0;\n  char *fileName = argv[argc - 1];"
            },
            {
              "variable": "gfileName",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "++) {\n    GooString *gfileName = new GooString(arg"
            },
            {
              "variable": "doc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rgv[i]);\n    PDFDoc *doc = new PDFDoc(gfileN"
            },
            {
              "variable": "catDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(&catObj);\n    Dict *catDict = catObj.getDict();"
            },
            {
              "variable": "refPage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", &afObj);\n     Ref *refPage = docs[0]->getCatal"
            },
            {
              "variable": "pagecatDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tObj);\n        Dict *pagecatDict = pagecatObj.getDic"
            },
            {
              "variable": "gidf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GooString *gidf = idf.getString();"
            },
            {
              "variable": "gpgidf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GooString *gpgidf = pgidf.getString()"
            },
            {
              "variable": "cropBox",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PDFRectangle *cropBox = NULL;\n       if ("
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&page);\n      Dict *pageDict = page.getDict();"
            },
            {
              "variable": "resDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tDict();\n      Dict *resDict = docs[i]->getCatal"
            },
            {
              "variable": "newResource",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t) {\n        Object *newResource = new Object();"
            },
            {
              "variable": "pageCatDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "geCatObj);\n    Dict *pageCatDict = pageCatObj.getDic"
            },
            {
              "variable": "pageDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tf(\"<< \");\n    Dict *pageDict = pages[i].getDict("
            },
            {
              "variable": "key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n      const char *key = pageDict->getKey("
            },
            {
              "variable": "trailerDict",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTra"
            },
            {
              "variable": "argv",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ame = new GooString(argv[i]);\n    PDFDoc *doc ="
            },
            {
              "variable": "argv",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "d files ('{0:s}')\", argv[i]);\n      return -1;"
            },
            {
              "variable": "argv",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "cuments ('{0:s}')\", argv[i]);\n      return -1;"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "Object catObj;\n    docs[0]->getXRef()->getCata"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "Ref *refPage = docs[0]->getCatalog()->getP"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "& refPage) {\n       docs[0]->markAcroForm(&afOb"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "& refPage) {\n       docs[0]->markPageObjects(oc"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "& refPage) {\n       docs[0]->markPageObjects(na"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ageintents;\n        docs[i]->getXRef()->getCata"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "gidf->getCString(), docs[i]->getFileName()->get"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "Dict()) {\n          docs[0]->markPageObjects(in"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "for (j = 1; j <= docs[i]->getNumPages(); j++"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "; j++) {\n      if (!docs[i]->getCatalog()->getP"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "= NULL;\n       if (docs[i]->getCatalog()->getP"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "cropBox = docs[i]->getCatalog()->getP"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "Object page;\n      docs[i]->getXRef()->fetch(r"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "Dict *resDict = docs[i]->getCatalog()->getP"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "k(numOffset);\n      docs[i]->markPageObjects(pa"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "isNull()) {\n        docs[i]->markAnnotations(&a"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ames, pageForm;\n    docs[i]->getXRef()->getCata"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "doMergeNameDict(docs[i], yRef, countRef, 0,"
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "objectsCount += docs[i]->writePageObjects(o"
            },
            {
              "variable": "pages",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "Dict *pageDict = pages[i].getDict();\n    for"
            },
            {
              "variable": "offsets",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "alue, outStr, yRef, offsets[i], NULL, cryptRC4, 0,"
            },
            {
              "variable": "pages",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pages.size (); j++) pages[j].free();\n  for (i ="
            },
            {
              "variable": "docs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ize (); i++) delete docs[i];\n  delete globalPar"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 37,
        "pointer_count": 19,
        "array_count": 6,
        "size_variable_count": 15
      }
    },
    "predict": "{\"vulnerable_variables\": [\"refPage\"]}",
    "vulnerable_variables": [
      "refPage"
    ],
    "vulnerable_variable": "refPage",
    "variable_definitions": {
      "refPage": "Ref *refPage = docs[0]->getCatalog()->getPageRef(1);"
    },
    "variable_types": {
      "refPage": "struct pointer"
    },
    "type_mapping": {
      "refPage": "struct pointer"
    }
  },
  {
    "idx": 158092,
    "project": "libav",
    "commit_id": "136f55207521f0b03194ef5b55ba70f1635d6aee",
    "project_url": "https://github.com/libav/libav",
    "commit_url": "https://git.libav.org/?p=libav.git;a=commit;h=136f55207521f0b03194ef5b55ba70f1635d6aee",
    "commit_message": "mpegvideo_motion: Handle edge emulation even without unrestricted_mv\n\nFix out of bounds read.\n\nBug-Id: 962\nFound by: F4B3CD@STARLAB and Agostino Sarubbo\nSigned-off-by: Vittorio Giovara <vittorio.giovara@gmail.com>",
    "label": 0,
    "func": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n\n    /* WARNING: do no forget half pels */\n    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?\n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n \n    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                 s->linesize, s->linesize,\n                                 9, 9, src_x, src_y,\n                                 s->h_edge_pos, s->v_edge_pos);\n        src = s->sc.edge_emu_buffer;\n        emu = 1;\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }\n",
    "func_hash": 104050017138290810308559131153118862587,
    "file_name": "mpegvideo_motion.c",
    "file_hash": 61191799423593899189428309227505355299,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-7424",
    "cve_desc": "The put_no_rnd_pixels8_xy2_mmx function in x86/rnd_template.c in libav 11.7 and earlier allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted MP3 file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7424",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "s",
          "src",
          "dest",
          "pix_op"
        ],
        "arrays": [
          "pix_op"
        ],
        "size_variables": [
          "linesize"
        ],
        "all_variables": [
          "linesize",
          "dest",
          "s",
          "src",
          "pix_op"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_clip(src_x, -16, s->width); // FIXME unneeded"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "u?\n    if (src_x != s->width)\n        dxy |= mot"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_clip(src_y, -16, s->height);\n    if (src_y !="
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n    if (src_y != s->height)\n         dxy |= (m"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "src += src_y * s->linesize + src_x;\n \n    if ("
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "igned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) -"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "igned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) -"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- 8, 0)) {\n        s->vdsp.emulated_edge_mc(s-"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sp.emulated_edge_mc(s->sc.edge_emu_buffer, sr"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->linesize, s->linesize,"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->linesize, s->linesize,"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->h_edge_pos, s->v_edge_pos);"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->h_edge_pos, s->v_edge_pos);\n        src = s->"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pos);\n        src = s->sc.edge_emu_buffer;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_op[dxy](dest, src, s->linesize, 8);\n     return em"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tion(MpegEncContext *s,"
            },
            {
              "variable": "dest",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uint8_t *dest, uint8_t *src,"
            },
            {
              "variable": "src",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t8_t *dest, uint8_t *src,"
            },
            {
              "variable": "pix_op",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "op_pixels_func *pix_op,"
            },
            {
              "variable": "WARNING",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "otion_y >> 1;\n\n    /* WARNING: do no forget half"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n     src += src_y * s->linesize + src_x;"
            },
            {
              "variable": "pix_op",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "mu = 1;\n     }\n     pix_op[dxy](dest, src, s->lines"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 5,
        "pointer_count": 4,
        "array_count": 1,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\": [\"pix_op\"]}",
    "vulnerable_variables": [
      "pix_op"
    ],
    "vulnerable_variable": "pix_op",
    "variable_definitions": {
      "pix_op": "op_pixels_func *pix_op,"
    },
    "variable_types": {
      "pix_op": "struct pointer"
    },
    "type_mapping": {
      "pix_op": "struct pointer"
    }
  },
  {
    "idx": 158094,
    "project": "openssl",
    "commit_id": "6e629b5be45face20b4ca71c4fcbfed78b864a2e",
    "project_url": "https://github.com/openssl/openssl",
    "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=6e629b5be45face20b4ca71c4fcbfed78b864a2e",
    "commit_message": "Add some sanity checks when checking CRL scores\n\nNote: this was accidentally omitted from OpenSSL 1.0.2 branch.\nWithout this fix any attempt to use CRLs will crash.\n\nCVE-2016-7052\n\nThanks to Bruce Stephens and Thomas Jakobi for reporting this issue.\n\nReviewed-by: Stephen Henson <steve@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "label": 0,
    "func": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score || crl_score == 0)\n             continue;\n         /* If current CRL is equivalent use it if it is newer */\n        if (crl_score == best_score && best_crl != NULL) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            /*\n             * ASN1_TIME_diff never returns inconsistent signs for |day|\n             * and |sec|.\n             */\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}\n",
    "func_hash": 282685569527671381524876751964696218430,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-7052",
    "cve_desc": "crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7052",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "x",
          "crl",
          "best_crl",
          "ctx",
          "preasons",
          "crl_issuer",
          "pscore"
        ],
        "arrays": [],
        "size_variables": [
          "sk_X509_CRL_num",
          "equivalent"
        ],
        "all_variables": [
          "sk_X509_CRL_num",
          "x",
          "equivalent",
          "crl",
          "best_crl",
          "ctx",
          "preasons",
          "crl_issuer",
          "pscore"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl,"
            },
            {
              "variable": "best_crl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X50"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "l_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X"
            },
            {
              "variable": "pcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,"
            },
            {
              "variable": "pdcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "L **pcrl, X509_CRL **pdcrl,"
            },
            {
              "variable": "pissuer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X509 **pissuer, int *pscore, unsig"
            },
            {
              "variable": "pscore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X509 **pissuer, int *pscore, unsigned int *prea"
            },
            {
              "variable": "preasons",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "score, unsigned int *preasons,"
            },
            {
              "variable": "crls",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_s"
            },
            {
              "variable": "pscore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "score, best_score = *pscore;\n    unsigned int r"
            },
            {
              "variable": "x",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "asons = 0;\n    X509 *x = ctx->current_cert"
            },
            {
              "variable": "crl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_cert;\n    X509_CRL *crl, *best_crl = NULL;"
            },
            {
              "variable": "best_crl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X509_CRL *crl, *best_crl = NULL;\n    X509 *c"
            },
            {
              "variable": "crl_issuer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_i"
            },
            {
              "variable": "best_crl_issuer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i"
            },
            {
              "variable": "preasons",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reasons = *preasons;\n         crl_score"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "continue;\n         /* If current CRL is equi"
            },
            {
              "variable": "ASN1_TIME_diff",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n             * ASN1_TIME_diff never returns incon"
            },
            {
              "variable": "and",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|day|\n             * and |sec|."
            },
            {
              "variable": "pcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_crl) {\n        if (*pcrl)\n            X509_C"
            },
            {
              "variable": "pcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X509_CRL_free(*pcrl);\n        *pcrl = b"
            },
            {
              "variable": "pcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ree(*pcrl);\n        *pcrl = best_crl;"
            },
            {
              "variable": "pissuer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= best_crl;\n        *pissuer = best_crl_issuer;"
            },
            {
              "variable": "pscore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "crl_issuer;\n        *pscore = best_score;"
            },
            {
              "variable": "preasons",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "best_score;\n        *preasons = best_reasons;"
            },
            {
              "variable": "pdcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "9_CRL);\n        if (*pdcrl) {\n            X509"
            },
            {
              "variable": "pdcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X509_CRL_free(*pdcrl);\n            *pdcr"
            },
            {
              "variable": "pdcrl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pdcrl);\n            *pdcrl = NULL;\n        }"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 9,
        "pointer_count": 7,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"crl\", \"best_crl\"]}",
    "vulnerable_variables": [
      "crl",
      "best_crl"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "crl": "X509_CRL *crl, *best_crl = NULL;",
      "best_crl": "X509_CRL *crl, *best_crl = NULL;"
    },
    "variable_types": {
      "crl": "struct pointer",
      "best_crl": "struct pointer"
    },
    "type_mapping": {
      "crl": "struct pointer",
      "best_crl": "struct pointer"
    }
  },
  {
    "idx": 158100,
    "project": "virglrenderer",
    "commit_id": "0a5dff15912207b83018485f83e067474e818bab",
    "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer",
    "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=0a5dff15912207b83018485f83e067474e818bab",
    "commit_message": "vrend: never destroy context 0 in vrend_renderer_context_destroy\n\nThere will be a crash if the guest destroy context 0. As the context 0 is\nallocate in renderer init, not destroy in vrend_renderer_context_destroy.\nThe context will be freed in renderer fini by calling vrend_decode_reset.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>",
    "label": 0,
    "func": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/\n   if (handle == 0) {\n      return;\n   }\n\n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}\n",
    "func_hash": 154473925672822272321889471335487355877,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-6210",
    "cve_desc": "The vrend_decode_reset function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (NULL pointer dereference and QEMU process crash) by destroying context 0 (zero).",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6210",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "ctx"
        ],
        "arrays": [
          "dec_ctx"
        ],
        "size_variables": [],
        "all_variables": [
          "ctx",
          "dec_ctx"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct vrend_decode_ctx *ctx;\n   bool ret;"
            },
            {
              "variable": "never",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return;\n \n   /* never destroy context 0 h"
            },
            {
              "variable": "dec_ctx",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "rn;\n   }\n\n    ctx = dec_ctx[handle];\n    if (!ctx)"
            },
            {
              "variable": "dec_ctx",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "d_hw_switch_context(dec_ctx[0]->grctx, true);\n}"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 2,
        "pointer_count": 1,
        "array_count": 1,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\": [\"dec_ctx\"]}",
    "vulnerable_variables": [
      "dec_ctx"
    ],
    "vulnerable_variable": "dec_ctx",
    "variable_definitions": {
      "dec_ctx": "Definition not found"
    },
    "variable_types": {
      "dec_ctx": "struct pointer array"
    },
    "type_mapping": {
      "dec_ctx": "struct pointer array"
    }
  },
  {
    "idx": 158133,
    "project": "savannah",
    "commit_id": "f290f48a621867084884bfff87f8093c15195e6a",
    "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls",
    "commit_url": "https://git.savannah.gnu.org/cgit/patch.git/commit/?id=f290f48a621867084884bfff87f8093c15195e6a",
    "commit_message": "None",
    "label": 0,
    "func": "intuit_diff_type (bool need_header, mode_t *p_file_type)\n{\n    file_offset this_line = 0;\n    file_offset first_command_line = -1;\n    char first_ed_command_letter = 0;\n    lin fcl_line = 0; /* Pacify 'gcc -W'.  */\n    bool this_is_a_command = false;\n    bool stars_this_line = false;\n    bool extended_headers = false;\n    enum nametype i;\n    struct stat st[3];\n    int stat_errno[3];\n    int version_controlled[3];\n    enum diff retval;\n    mode_t file_type;\n    size_t indent = 0;\n\n    for (i = OLD;  i <= INDEX;  i++)\n      if (p_name[i]) {\n\t  free (p_name[i]);\n\t  p_name[i] = 0;\n        }\n    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)\n\tinvalid_names[i] = NULL;\n    for (i = OLD; i <= NEW; i++)\n      if (p_timestr[i])\n\t{\n\t  free(p_timestr[i]);\n\t  p_timestr[i] = 0;\n\t}\n    for (i = OLD; i <= NEW; i++)\n      if (p_sha1[i])\n\t{\n\t  free (p_sha1[i]);\n\t  p_sha1[i] = 0;\n\t}\n    p_git_diff = false;\n    for (i = OLD; i <= NEW; i++)\n      {\n\tp_mode[i] = 0;\n\tp_copy[i] = false;\n\tp_rename[i] = false;\n      }\n\n    /* Ed and normal format patches don't have filename headers.  */\n    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)\n      need_header = false;\n\n    version_controlled[OLD] = -1;\n    version_controlled[NEW] = -1;\n    version_controlled[INDEX] = -1;\n    p_rfc934_nesting = 0;\n    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;\n    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;\n    Fseek (pfp, p_base, SEEK_SET);\n    p_input_line = p_bline - 1;\n    for (;;) {\n\tchar *s;\n\tchar *t;\n\tfile_offset previous_line = this_line;\n\tbool last_line_was_command = this_is_a_command;\n\tbool stars_last_line = stars_this_line;\n\tsize_t indent_last_line = indent;\n\tchar ed_command_letter;\n\tbool strip_trailing_cr;\n\tsize_t chars_read;\n\n\tindent = 0;\n\tthis_line = file_tell (pfp);\n\tchars_read = pget_line (0, 0, false, false);\n\tif (chars_read == (size_t) -1)\n\t  xalloc_die ();\n\tif (! chars_read) {\n\t    if (first_ed_command_letter) {\n\t\t\t\t\t/* nothing but deletes!? */\n\t\tp_start = first_command_line;\n\t\tp_sline = fcl_line;\n\t\tretval = ED_DIFF;\n\t\tgoto scan_exit;\n\t    }\n\t    else {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\tif (extended_headers)\n\t\t  {\n\t\t    /* Patch contains no hunks; any diff type will do. */\n\t\t    retval = UNI_DIFF;\n\t\t    goto scan_exit;\n\t\t  }\n\t\treturn NO_DIFF;\n\t    }\n\t}\n\tstrip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\\r';\n\tfor (s = buf; *s == ' ' || *s == '\\t' || *s == 'X'; s++) {\n\t    if (*s == '\\t')\n\t\tindent = (indent + 8) & ~7;\n\t    else\n\t\tindent++;\n\t}\n\tif (ISDIGIT (*s))\n\t  {\n\t    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)\n\t      /* do nothing */ ;\n\t    if (*t == 'd' || *t == 'c' || *t == 'a')\n\t      {\n\t\tfor (t++;  ISDIGIT (*t) || *t == ',';  t++)\n\t\t  /* do nothing */ ;\n\t\tfor (; *t == ' ' || *t == '\\t'; t++)\n\t\t  /* do nothing */ ;\n\t\tif (*t == '\\r')\n\t\t  t++;\n\t\tthis_is_a_command = (*t == '\\n');\n\t      }\n\t  }\n\tif (! need_header\n\t    && first_command_line < 0\n\t    && ((ed_command_letter = get_ed_command_letter (s))\n\t\t|| this_is_a_command)) {\n\t    first_command_line = this_line;\n\t    first_ed_command_letter = ed_command_letter;\n\t    fcl_line = p_input_line;\n\t    p_indent = indent;\t\t/* assume this for now */\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t}\n\tif (!stars_last_line && strnEQ(s, \"*** \", 4))\n\t  {\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t  }\n\telse if (strnEQ(s, \"+++ \", 4))\n\t  {\n\t    /* Swap with NEW below.  */\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Index:\", 6))\n\t  {\n\t    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Prereq:\", 7))\n\t  {\n\t    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)\n\t      /* do nothing */ ;\n\t    revision = t;\n\t    for (t = revision;  *t;  t++)\n\t      if (ISSPACE ((unsigned char) *t))\n\t\t{\n\t\t  char const *u;\n\t\t  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)\n\t\t    /* do nothing */ ;\n\t\t  if (*u)\n\t\t    {\n\t\t      char numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\t      say (\"Prereq: with multiple words at line %s of patch\\n\",\n\t\t\t   format_linenum (numbuf, this_line));\n\t\t    }\n\t\t  break;\n\t\t}\n\t    if (t == revision)\n\t\trevision = 0;\n\t    else {\n\t\tchar oldc = *t;\n\t\t*t = '\\0';\n\t\trevision = xstrdup (revision);\n\t\t*t = oldc;\n\t    }\n\t  }\n\telse if (strnEQ (s, \"diff --git \", 11))\n\t  {\n\t    char const *u;\n\n\t    if (extended_headers)\n\t      {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\t/* Patch contains no hunks; any diff type will do. */\n\t\tretval = UNI_DIFF;\n\t\tgoto scan_exit;\n\t      }\n\n\t    for (i = OLD; i <= NEW; i++)\n\t      {\n\t\tfree (p_name[i]);\n\t\tp_name[i] = 0;\n\t      }\n\t    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))\n\t\t   && ISSPACE ((unsigned char) *u)\n\t\t   && (p_name[NEW] = parse_name (u, strippath, &u))\n\t\t   && (u = skip_spaces (u), ! *u)))\n\t      for (i = OLD; i <= NEW; i++)\n\t\t{\n\t\t  free (p_name[i]);\n\t\t  p_name[i] = 0;\n\t\t}\n\t    p_git_diff = true;\n\t    need_header = false;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"index \", 6))\n\t  {\n\t    char const *u, *v;\n\t    if ((u = skip_hex_digits (s + 6))\n\t\t&& u[0] == '.' && u[1] == '.'\n\t\t&& (v = skip_hex_digits (u + 2))\n\t\t&& (! *v || ISSPACE ((unsigned char) *v)))\n\t      {\n\t\tget_sha1(&p_sha1[OLD], s + 6, u);\n\t\tget_sha1(&p_sha1[NEW], u + 2, v);\n\t\tp_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);\n\t\tp_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);\n\t\tif (*(v = skip_spaces (v)))\n\t\t  p_mode[OLD] = p_mode[NEW] = fetchmode (v);\n\t\textended_headers = true;\n\t      }\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"old mode \", 9))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new mode \", 9))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"deleted file mode \", 18))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 18);\n\t    p_says_nonexistent[NEW] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new file mode \", 14))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 14);\n\t    p_says_nonexistent[OLD] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename from \", 12))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename to \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy from \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy to \", 8))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"GIT binary patch\", 16))\n\t  {\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = GIT_BINARY_DIFF;\n\t    goto scan_exit;\n\t  }\n\telse\n\t  {\n\t    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)\n\t      /* do nothing */ ;\n\t    if (strnEQ(t, \"--- \", 4))\n\t      {\n\t\tstruct timespec timestamp;\n\t\ttimestamp.tv_sec = -1;\n\t\tfetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],\n\t\t\t   &timestamp);\n\t\tneed_header = false;\n\t\tif (timestamp.tv_sec != -1)\n\t\t  {\n\t\t    p_timestamp[NEW] = timestamp;\n\t\t    p_rfc934_nesting = (t - s) >> 1;\n\t\t  }\n\t\tp_strip_trailing_cr = strip_trailing_cr;\n\t      }\n\t  }\n\tif (need_header)\n\t  continue;\n\tif ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&\n\t  first_command_line >= 0 &&\n\t  strEQ(s, \".\\n\") ) {\n\t    p_start = first_command_line;\n\t    p_sline = fcl_line;\n\t    retval = ED_DIFF;\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == UNI_DIFF)\n\t    && strnEQ(s, \"@@ -\", 4)) {\n\n\t    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;\n\t       swap them.  */\n\t    struct timespec ti = p_timestamp[OLD];\n\t    p_timestamp[OLD] = p_timestamp[NEW];\n\t    p_timestamp[NEW] = ti;\n\t    t = p_name[OLD];\n\t    p_name[OLD] = p_name[NEW];\n\t    p_name[NEW] = t;\n\t    t = p_timestr[OLD];\n\t    p_timestr[OLD] = p_timestr[NEW];\n\t    p_timestr[NEW] = t;\n\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    while (*s != ' ' && *s != '\\n')\n\t      s++;\n\t    while (*s == ' ')\n\t      s++;\n\t    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))\n\t      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t    p_indent = indent;\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = UNI_DIFF;\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for unified diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tstars_this_line = strnEQ(s, \"********\", 8);\n\tif ((diff_type == NO_DIFF\n\t     || diff_type == CONTEXT_DIFF\n\t     || diff_type == NEW_CONTEXT_DIFF)\n\t    && stars_last_line && indent_last_line == indent\n\t    && strnEQ (s, \"*** \", 4)) {\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    /* if this is a new context diff the character just before */\n\t    /* the newline is a '*'. */\n\t    while (*s != '\\n')\n\t\ts++;\n\t    p_indent = indent;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);\n\n\t    {\n\t      /* Scan the first hunk to see whether the file contents\n\t\t appear to have been deleted.  */\n\t      file_offset saved_p_base = p_base;\n\t      lin saved_p_bline = p_bline;\n\t      Fseek (pfp, previous_line, SEEK_SET);\n\t      p_input_line -= 2;\n\t      if (another_hunk (retval, false)\n\t\t  && ! p_repl_lines && p_newfirst == 1)\n\t\tp_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t      next_intuit_at (saved_p_base, saved_p_bline);\n\t    }\n\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for context diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&\n\t  last_line_was_command &&\n\t  (strnEQ(s, \"< \", 2) || strnEQ(s, \"> \", 2)) ) {\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    p_indent = indent;\n\t    retval = NORMAL_DIFF;\n\t    goto scan_exit;\n\t}\n    }\n\n  scan_exit:\n\n    /* The old, new, or old and new file types may be defined.  When both\n       file types are defined, make sure they are the same, or else assume\n       we do not know the file type.  */\n    file_type = p_mode[OLD] & S_IFMT;\n    if (file_type)\n      {\n\tmode_t new_file_type = p_mode[NEW] & S_IFMT;\n\tif (new_file_type && file_type != new_file_type)\n\t  file_type = 0;\n      }\n    else\n      {\n\tfile_type = p_mode[NEW] & S_IFMT;\n\tif (! file_type)\n\t  file_type = S_IFREG;\n      }\n    *p_file_type = file_type;\n\n    /* To intuit 'inname', the name of the file to patch,\n       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599\n       (with some modifications if posixly_correct is zero):\n\n       - Take the old and new names from the context header if present,\n\t and take the index name from the 'Index:' line if present and\n\t if either the old and new names are both absent\n\t or posixly_correct is nonzero.\n\t Consider the file names to be in the order (old, new, index).\n       - If some named files exist, use the first one if posixly_correct\n\t is nonzero, the best one otherwise.\n       - If patch_get is nonzero, and no named files exist,\n\t but an RCS or SCCS master file exists,\n\t use the first named file with an RCS or SCCS master.\n       - If no named files exist, no RCS or SCCS master was found,\n\t some names are given, posixly_correct is zero,\n\t and the patch appears to create a file, then use the best name\n\t requiring the creation of the fewest directories.\n       - Otherwise, report failure by setting 'inname' to 0;\n\t this causes our invoker to ask the user for a file name.  */\n\n    i = NONE;\n\n    if (!inname)\n      {\n\tenum nametype i0 = NONE;\n\n\tif (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])\n\t  {\n\t    free (p_name[INDEX]);\n\t    p_name[INDEX] = 0;\n\t  }\n\n\tfor (i = OLD;  i <= INDEX;  i++)\n\t  if (p_name[i])\n\t    {\n\t      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)\n\t\t{\n\t\t  /* It's the same name as before; reuse stat results.  */\n\t\t  stat_errno[i] = stat_errno[i0];\n\t\t  if (! stat_errno[i])\n\t\t    st[i] = st[i0];\n\t\t}\n\t      else\n\t\t{\n\t\t  stat_errno[i] = stat_file (p_name[i], &st[i]);\n\t\t  if (! stat_errno[i])\n\t\t    {\n\t\t      if (lookup_file_id (&st[i]) == DELETE_LATER)\n\t\t\tstat_errno[i] = ENOENT;\n\t\t      else if (posixly_correct && name_is_valid (p_name[i]))\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t      i0 = i;\n\t    }\n\n\tif (! posixly_correct)\n\t  {\n\t    /* The best of all existing files. */\n\t    i = best_name (p_name, stat_errno);\n\n\t    if (i == NONE && patch_get)\n\t      {\n\t\tenum nametype nope = NONE;\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      char const *cs;\n\t\t      char *getbuf;\n\t\t      char *diffbuf;\n\t\t      bool readonly = (outfile\n\t\t\t\t       && strcmp (outfile, p_name[i]) != 0);\n\n\t\t      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)\n\t\t\t{\n\t\t\t  cs = (version_controller\n\t\t\t        (p_name[i], readonly, (struct stat *) 0,\n\t\t\t\t &getbuf, &diffbuf));\n\t\t\t  version_controlled[i] = !! cs;\n\t\t\t  if (cs)\n\t\t\t    {\n\t\t\t      if (version_get (p_name[i], cs, false, readonly,\n\t\t\t\t\t       getbuf, &st[i]))\n\t\t\t\tstat_errno[i] = 0;\n\t\t\t      else\n\t\t\t\tversion_controlled[i] = 0;\n\n\t\t\t      free (getbuf);\n\t\t\t      free (diffbuf);\n\n\t\t\t      if (! stat_errno[i])\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t      nope = i;\n\t\t    }\n\t      }\n\n\t    if (i0 != NONE\n\t\t&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)\n\t\t&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,\n\t\t\t\t  i == NONE || st[i].st_size == 0)\n\t\t&& i == NONE)\n\t      i = i0;\n\n\t    if (i == NONE && p_says_nonexistent[reverse])\n\t      {\n\t\tint newdirs[3];\n\t\tint newdirs_min = INT_MAX;\n\t\tint distance_from_minimum[3];\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      newdirs[i] = (prefix_components (p_name[i], false)\n\t\t\t\t    - prefix_components (p_name[i], true));\n\t\t      if (newdirs[i] < newdirs_min)\n\t\t\tnewdirs_min = newdirs[i];\n\t\t    }\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    distance_from_minimum[i] = newdirs[i] - newdirs_min;\n\n\t\t/* The best of the filenames which create the fewest directories. */\n\t\ti = best_name (p_name, distance_from_minimum);\n\t      }\n\t  }\n      }\n\n     if ((pch_rename () || pch_copy ())\n \t&& ! inname\n \t&& ! ((i == OLD || i == NEW) &&\n\t      p_name[reverse] && p_name[! reverse] &&\n\t      name_is_valid (p_name[reverse]) &&\n \t      name_is_valid (p_name[! reverse])))\n       {\n \tsay (\"Cannot %s file without two valid file names\\n\", pch_rename () ? \"rename\" : \"copy\");\n      }\n\n    if (i == NONE)\n      {\n\tif (inname)\n\t  {\n\t    inerrno = stat_file (inname, &instat);\n\t    if (inerrno || (instat.st_mode & S_IFMT) == file_type)\n\t      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);\n\t  }\n\telse\n          inerrno = -1;\n      }\n    else\n      {\n\tinname = xstrdup (p_name[i]);\n\tinerrno = stat_errno[i];\n\tinvc = version_controlled[i];\n\tinstat = st[i];\n      }\n\n    return retval;\n}\n",
    "func_hash": 146473763077753726031355449366744801662,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-6951",
    "cve_desc": "An issue was discovered in GNU patch through 2.7.6. There is a segmentation fault, associated with a NULL pointer dereference, leading to a denial of service in the intuit_diff_type function in pch.c, aka a \"mangled rename\" issue.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-6951",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "u",
          "p_file_type",
          "s",
          "getbuf",
          "cs",
          "diffbuf",
          "t"
        ],
        "arrays": [
          "u",
          "invalid_names",
          "s",
          "version_controlled",
          "p_sha1",
          "p_name",
          "p_timestamp",
          "numbuf",
          "st",
          "distance_from_minimum",
          "p_rename",
          "newdirs",
          "p_copy",
          "stat_errno",
          "p_timestr",
          "p_says_nonexistent",
          "buf",
          "p_mode",
          "t"
        ],
        "size_variables": [
          "st_size",
          "format_linenum",
          "size_t",
          "filenames",
          "numbuf",
          "enum",
          "LINENUM_LENGTH_BOUND",
          "filename",
          "ARRAY_SIZE"
        ],
        "all_variables": [
          "u",
          "st_size",
          "s",
          "invalid_names",
          "size_t",
          "version_controlled",
          "p_sha1",
          "LINENUM_LENGTH_BOUND",
          "p_name",
          "format_linenum",
          "p_timestamp",
          "filenames",
          "numbuf",
          "enum",
          "st",
          "diffbuf",
          "getbuf",
          "distance_from_minimum",
          "p_rename",
          "newdirs",
          "p_copy",
          "stat_errno",
          "filename",
          "ARRAY_SIZE",
          "p_file_type",
          "p_timestr",
          "cs",
          "p_says_nonexistent",
          "buf",
          "p_mode",
          "t"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "p_file_type",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "need_header, mode_t *p_file_type)\n{\n    file_offset"
            },
            {
              "variable": "Pacify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lin fcl_line = 0; /* Pacify 'gcc -W'.  */\n    b"
            },
            {
              "variable": "Ed",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "alse;\n      }\n\n    /* Ed and normal format p"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (;;) {\n\tchar *s;\n\tchar *t;\n\tfile_of"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") {\n\tchar *s;\n\tchar *t;\n\tfile_offset previ"
            },
            {
              "variable": "nothing",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "and_letter) {\n\t\t\t\t\t/* nothing but deletes!? */"
            },
            {
              "variable": "Patch",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "aders)\n\t\t  {\n\t\t    /* Patch contains no hunks;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\r';\n\tfor (s = buf; *s == ' ' || *s == '\\t"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= buf; *s == ' ' || *s == '\\t' || *s == 'X"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "' || *s == '\\t' || *s == 'X'; s++) {"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "X'; s++) {\n\t    if (*s == '\\t')\n\t\tindent ="
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+;\n\t}\n\tif (ISDIGIT (*s))\n\t  {\n\t    for (t"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = s + 1; ISDIGIT (*t) || *t == ',';  t++"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1; ISDIGIT (*t) || *t == ',';  t++)"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "',';  t++)\n\t      /* do nothing */ ;\n\t    i"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "thing */ ;\n\t    if (*t == 'd' || *t == 'c'"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (*t == 'd' || *t == 'c' || *t == 'a'"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "'d' || *t == 'c' || *t == 'a')\n\t      {"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (t++;  ISDIGIT (*t) || *t == ',';  t++"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+;  ISDIGIT (*t) || *t == ',';  t++)\n\t\t  /"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "== ',';  t++)\n\t\t  /* do nothing */ ;\n\t\tfor"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "thing */ ;\n\t\tfor (; *t == ' ' || *t == '\\t"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (; *t == ' ' || *t == '\\t'; t++)\n\t\t  /"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "== '\\t'; t++)\n\t\t  /* do nothing */ ;\n\t\tif ("
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nothing */ ;\n\t\tif (*t == '\\r')\n\t\t  t++;"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "his_is_a_command = (*t == '\\n');\n\t      }"
            },
            {
              "variable": "assume",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_indent = indent;\t\t/* assume this for now */"
            },
            {
              "variable": "Swap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+ \", 4))\n\t  {\n\t    /* Swap with NEW below.  */"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CE ((unsigned char) *t);  t++)\n\t      /* d"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*t);  t++)\n\t      /* do nothing */ ;\n\t    r"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (t = revision;  *t;  t++)\n\t      if (I"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CE ((unsigned char) *t))\n\t\t{\n\t\t  char cons"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t\t  char const *u;\n\t\t  for (u = t + 1"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CE ((unsigned char) *u);  u++)\n\t\t    /* do"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") *u);  u++)\n\t\t    /* do nothing */ ;\n\t\t  if"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "othing */ ;\n\t\t  if (*u)\n\t\t    {\n\t\t      ch"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lse {\n\t\tchar oldc = *t;\n\t\t*t = '\\0';\n\t\trev"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char oldc = *t;\n\t\t*t = '\\0';\n\t\trevision"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "trdup (revision);\n\t\t*t = oldc;\n\t    }\n\t  }"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t    char const *u;\n\n\t    if (extended"
            },
            {
              "variable": "Patch",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= p_input_line;\n\t\t/* Patch contains no hunks;"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CE ((unsigned char) *u)\n\t\t   && (p_name[NE"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skip_spaces (u), ! *u)))\n\t      for (i ="
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t    char const *u, *v;\n\t    if ((u ="
            },
            {
              "variable": "v",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char const *u, *v;\n\t    if ((u = skip"
            },
            {
              "variable": "v",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ts (u + 2))\n\t\t&& (! *v || ISSPACE ((unsign"
            },
            {
              "variable": "v",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CE ((unsigned char) *v)))\n\t      {\n\t\tget_s"
            },
            {
              "variable": "Git",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\", 12))\n\t  {\n\t    /* Git leaves out the pref"
            },
            {
              "variable": "Git",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\", 10))\n\t  {\n\t    /* Git leaves out the pref"
            },
            {
              "variable": "Git",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\", 10))\n\t  {\n\t    /* Git leaves out the pref"
            },
            {
              "variable": "Git",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o \", 8))\n\t  {\n\t    /* Git leaves out the pref"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "';  t += 2)\n\t      /* do nothing */ ;\n\t    i"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tv_sec;\n\t    while (*s != ' ' && *s != '\\n"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "while (*s != ' ' && *s != '\\n')\n\t      s++"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s++;\n\t    while (*s == ' ')\n\t      s++;"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ust before */\n\t    /* the newline is a '*'. *"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "'*'. */\n\t    while (*s != '\\n')\n\t\ts++;"
            },
            {
              "variable": "Scan",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "F);\n\n\t    {\n\t      /* Scan the first hunk to s"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "scan_exit:\n\n    /* The old, new, or old an"
            },
            {
              "variable": "p_file_type",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_IFREG;\n      }\n    *p_file_type = file_type;\n\n    /"
            },
            {
              "variable": "To",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= file_type;\n\n    /* To intuit 'inname', th"
            },
            {
              "variable": "It",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "[i]) == 0)\n\t\t{\n\t\t  /* It's the same name as"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "correct)\n\t  {\n\t    /* The best of all existin"
            },
            {
              "variable": "cs",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char const *cs;\n\t\t      char *getb"
            },
            {
              "variable": "getbuf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t *cs;\n\t\t      char *getbuf;\n\t\t      char *diff"
            },
            {
              "variable": "diffbuf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "etbuf;\n\t\t      char *diffbuf;\n\t\t      bool reado"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- newdirs_min;\n\n\t\t/* The best of the filenam"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i;\n    struct stat st[3];\n    int stat_errno"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "stat st[3];\n    int stat_errno[3];\n    int version_co"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t_errno[3];\n    int version_controlled[3];\n    enum diff retv"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "EX;  i++)\n      if (p_name[i]) {\n\t  free (p_name["
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "name[i]) {\n\t  free (p_name[i]);\n\t  p_name[i] = 0;"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ree (p_name[i]);\n\t  p_name[i] = 0;\n        }"
            },
            {
              "variable": "invalid_names",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "valid_names); i++)\n\tinvalid_names[i] = NULL;\n    for (i"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NEW; i++)\n      if (p_timestr[i])\n\t{\n\t  free(p_times"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "estr[i])\n\t{\n\t  free(p_timestr[i]);\n\t  p_timestr[i] ="
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e(p_timestr[i]);\n\t  p_timestr[i] = 0;\n\t}\n    for (i"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NEW; i++)\n      if (p_sha1[i])\n\t{\n\t  free (p_sha1"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ha1[i])\n\t{\n\t  free (p_sha1[i]);\n\t  p_sha1[i] = 0;"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ree (p_sha1[i]);\n\t  p_sha1[i] = 0;\n\t}\n    p_git_d"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NEW; i++)\n      {\n\tp_mode[i] = 0;\n\tp_copy[i] = f"
            },
            {
              "variable": "p_copy",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n\tp_mode[i] = 0;\n\tp_copy[i] = false;\n\tp_rename["
            },
            {
              "variable": "p_rename",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "p_copy[i] = false;\n\tp_rename[i] = false;\n      }"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "eader = false;\n\n    version_controlled[OLD] = -1;\n    version_c"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "lled[OLD] = -1;\n    version_controlled[NEW] = -1;\n    version_c"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "lled[NEW] = -1;\n    version_controlled[INDEX] = -1;\n    p_rfc934_"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "34_nesting = 0;\n    p_timestamp[OLD].tv_sec = p_timestam"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "stamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;\n    p_"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "W].tv_sec = -1;\n    p_says_nonexistent[OLD] = p_says_nonexisten"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;\n    Fseek (pfp"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e (s+4, strippath, &p_name[OLD], &p_timestr[OLD],"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timest"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "str[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e (s+4, strippath, &p_name[OLD], &p_timestr[OLD],"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timest"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "str[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e (s+6, strippath, &p_name[INDEX], (char **) 0, NULL)"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "+)\n\t      {\n\t\tfree (p_name[i]);\n\t\tp_name[i] = 0;"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "free (p_name[i]);\n\t\tp_name[i] = 0;\n\t      }"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "}\n\t    if (! ((p_name[OLD] = parse_name (s + 1"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "char) *u)\n\t\t   && (p_name[NEW] = parse_name (u, st"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i++)\n\t\t{\n\t\t  free (p_name[i]);\n\t\t  p_name[i] = 0"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ee (p_name[i]);\n\t\t  p_name[i] = 0;\n\t\t}\n\t    p_git"
            },
            {
              "variable": "u",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "igits (s + 6))\n\t\t&& u[0] == '.' && u[1] == '"
            },
            {
              "variable": "u",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&& u[0] == '.' && u[1] == '.'\n\t\t&& (v = sk"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n\t\tget_sha1(&p_sha1[OLD], s + 6, u);\n\t\tget_s"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "6, u);\n\t\tget_sha1(&p_sha1[NEW], u + 2, v);\n\t\tp_say"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[NEW], u + 2, v);\n\t\tp_says_nonexistent[OLD] = sha1_says_nonexis"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "1_says_nonexistent (p_sha1[OLD]);\n\t\tp_says_nonexist"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "nt (p_sha1[OLD]);\n\t\tp_says_nonexistent[NEW] = sha1_says_nonexis"
            },
            {
              "variable": "p_sha1",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "1_says_nonexistent (p_sha1[NEW]);\n\t\tif (*(v = skip_"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ip_spaces (v)))\n\t\t  p_mode[OLD] = p_mode[NEW] = fet"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ")\n\t\t  p_mode[OLD] = p_mode[NEW] = fetchmode (v);"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "de \", 9))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 9)"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "de \", 9))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 9)"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e \", 18))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 18"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "mode (s + 18);\n\t    p_says_nonexistent[NEW] = 2;\n\t    extended_"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e \", 14))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 14"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "mode (s + 14);\n\t    p_says_nonexistent[OLD] = 2;\n\t    extended_"
            },
            {
              "variable": "p_rename",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "file name.  */\n\t    p_rename[OLD] = true;\n\t    extend"
            },
            {
              "variable": "p_rename",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "file name.  */\n\t    p_rename[NEW] = true;\n\t    extend"
            },
            {
              "variable": "p_copy",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "file name.  */\n\t    p_copy[OLD] = true;\n\t    extend"
            },
            {
              "variable": "p_copy",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "file name.  */\n\t    p_copy[NEW] = true;\n\t    extend"
            },
            {
              "variable": "t",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n\t    for (t = s;  t[0] == '-' && t[1] == '"
            },
            {
              "variable": "t",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "s;  t[0] == '-' && t[1] == ' ';  t += 2)"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e (t+4, strippath, &p_name[NEW], &p_timestr[NEW],"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ath, &p_name[NEW], &p_timestr[NEW],\n\t\t\t   &timestamp);"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "!= -1)\n\t\t  {\n\t\t    p_timestamp[NEW] = timestamp;"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "truct timespec ti = p_timestamp[OLD];\n\t    p_timestamp[O"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "imestamp[OLD];\n\t    p_timestamp[OLD] = p_timestamp[NEW];"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "p_timestamp[OLD] = p_timestamp[NEW];\n\t    p_timestamp[N"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "imestamp[NEW];\n\t    p_timestamp[NEW] = ti;\n\t    t = p_na"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NEW] = ti;\n\t    t = p_name[OLD];\n\t    p_name[OLD] ="
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "= p_name[OLD];\n\t    p_name[OLD] = p_name[NEW];"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "p_name[OLD] = p_name[NEW];\n\t    p_name[NEW] ="
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "= p_name[NEW];\n\t    p_name[NEW] = t;\n\t    t = p_tim"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[NEW] = t;\n\t    t = p_timestr[OLD];\n\t    p_timestr[OLD"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_timestr[OLD];\n\t    p_timestr[OLD] = p_timestr[NEW];"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "p_timestr[OLD] = p_timestr[NEW];\n\t    p_timestr[NEW"
            },
            {
              "variable": "p_timestr",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_timestr[NEW];\n\t    p_timestr[NEW] = t;\n\n\t    s += 4;"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "s += 4;\n\t    if (s[0] == '0' && !ISDIGIT"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "== '0' && !ISDIGIT (s[1]))\n\t      p_says_non"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "IGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "istent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    while"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "s++;\n\t    if (s[0] == '+' && s[1] == '"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (s[0] == '+' && s[1] == '0' && !ISDIGIT"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "== '0' && !ISDIGIT (s[2]))\n\t      p_says_non"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "IGIT (s[2]))\n\t      p_says_nonexistent[NEW] = 1 + ! p_timestamp"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "istent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t    p_inde"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_DIFF;\n\t    if (! ((p_name[OLD] || ! p_timestamp[OL"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "D].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NE"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "& (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_n"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "EW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "s += 4;\n\t    if (s[0] == '0' && !ISDIGIT"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "== '0' && !ISDIGIT (s[1]))\n\t      p_says_non"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "IGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "istent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    /* if"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "p_newfirst == 1)\n\t\tp_says_nonexistent[NEW] = 1 + ! p_timestamp"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "istent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t      next"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "}\n\n\t    if (! ((p_name[OLD] || ! p_timestamp[OL"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "D].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NE"
            },
            {
              "variable": "p_timestamp",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "& (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_n"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "EW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "*/\n    file_type = p_mode[OLD] & S_IFMT;\n    if (f"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e_t new_file_type = p_mode[NEW] & S_IFMT;\n\tif (new_"
            },
            {
              "variable": "p_mode",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n\tfile_type = p_mode[NEW] & S_IFMT;\n\tif (! fi"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "posixly_correct && (p_name[OLD] || p_name[NEW]) &&"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&& (p_name[OLD] || p_name[NEW]) && p_name[INDEX])"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "|| p_name[NEW]) && p_name[INDEX])\n\t  {\n\t    free (p_"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "X])\n\t  {\n\t    free (p_name[INDEX]);\n\t    p_name[INDEX"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_name[INDEX]);\n\t    p_name[INDEX] = 0;\n\t  }\n\n\tfor (i"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "INDEX;  i++)\n\t  if (p_name[i])\n\t    {\n\t      if ("
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "!= NONE && strcmp (p_name[i0], p_name[i]) == 0)"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "strcmp (p_name[i0], p_name[i]) == 0)\n\t\t{\n\t\t  /* I"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "at results.  */\n\t\t  stat_errno[i] = stat_errno[i0];"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "stat_errno[i] = stat_errno[i0];\n\t\t  if (! stat_err"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "rrno[i0];\n\t\t  if (! stat_errno[i])\n\t\t    st[i] = st[i"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tat_errno[i])\n\t\t    st[i] = st[i0];\n\t\t}"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "o[i])\n\t\t    st[i] = st[i0];\n\t\t}\n\t      else"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "else\n\t\t{\n\t\t  stat_errno[i] = stat_file (p_name"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "rno[i] = stat_file (p_name[i], &st[i]);\n\t\t  if (!"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t_file (p_name[i], &st[i]);\n\t\t  if (! stat_er"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&st[i]);\n\t\t  if (! stat_errno[i])\n\t\t    {\n\t\t      if"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "f (lookup_file_id (&st[i]) == DELETE_LATER)"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "== DELETE_LATER)\n\t\t\tstat_errno[i] = ENOENT;\n\t\t      e"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t && name_is_valid (p_name[i]))\n\t\t\tbreak;\n\t\t    }"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      ch"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&& strcmp (outfile, p_name[i]) != 0);\n\n\t\t      if"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "== NONE || strcmp (p_name[nope], p_name[i]) != 0)"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "rcmp (p_name[nope], p_name[i]) != 0)\n\t\t\t{\n\t\t\t  cs"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "troller\n\t\t\t        (p_name[i], readonly, (struct"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "f, &diffbuf));\n\t\t\t  version_controlled[i] = !! cs;\n\t\t\t  if (c"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (version_get (p_name[i], cs, false, readonl"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "getbuf, &st[i]))\n\t\t\t\tstat_errno[i]"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "etbuf, &st[i]))\n\t\t\t\tstat_errno[i] = 0;\n\t\t\t      else"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n\t\t\t      else\n\t\t\t\tversion_controlled[i] = 0;\n\n\t\t\t      free"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "f);\n\n\t\t\t      if (! stat_errno[i])\n\t\t\t\tbreak;"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&& (i == NONE || (st[i].st_mode & S_IFMT) ="
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i == NONE || st[i].st_size == 0)\n\t\t&&"
            },
            {
              "variable": "p_says_nonexistent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (i == NONE && p_says_nonexistent[reverse])\n\t      {\n\t\tint new"
            },
            {
              "variable": "newdirs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "se])\n\t      {\n\t\tint newdirs[3];\n\t\tint newdirs_min"
            },
            {
              "variable": "distance_from_minimum",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "in = INT_MAX;\n\t\tint distance_from_minimum[3];\n\n\t\tfor (i = OLD;"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      ne"
            },
            {
              "variable": "newdirs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i])\n\t\t    {\n\t\t      newdirs[i] = (prefix_component"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(prefix_components (p_name[i], false)\n\t\t\t\t    - p"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "prefix_components (p_name[i], true));\n\t\t      if"
            },
            {
              "variable": "newdirs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "true));\n\t\t      if (newdirs[i] < newdirs_min)\n\t\t\tn"
            },
            {
              "variable": "newdirs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "n)\n\t\t\tnewdirs_min = newdirs[i];\n\t\t    }\n\n\t\tfor (i"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    distance_fro"
            },
            {
              "variable": "distance_from_minimum",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "f (p_name[i])\n\t\t    distance_from_minimum[i] = newdirs[i] - newd"
            },
            {
              "variable": "newdirs",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e_from_minimum[i] = newdirs[i] - newdirs_min;\n\n\t\t/"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i == NEW) &&\n\t      p_name[reverse] && p_name[! reverse"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "name_is_valid (p_name[reverse]) &&\n \t      name_is"
            },
            {
              "variable": "p_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "inname = xstrdup (p_name[i]);\n\tinerrno = stat_e"
            },
            {
              "variable": "stat_errno",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ame[i]);\n\tinerrno = stat_errno[i];\n\tinvc = version_co"
            },
            {
              "variable": "version_controlled",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t_errno[i];\n\tinvc = version_controlled[i];\n\tinstat = st[i];"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "olled[i];\n\tinstat = st[i];\n      }\n\n    retur"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 31,
        "pointer_count": 7,
        "array_count": 19,
        "size_variable_count": 9
      }
    },
    "predict": "{\"vulnerable_variables\": [\"p_file_type\", \"p_name\"]}",
    "vulnerable_variables": [
      "p_file_type",
      "p_name"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "p_file_type": "mode_t *p_file_type",
      "p_name": "Definition not found"
    },
    "variable_types": {
      "p_file_type": "integer pointer",
      "p_name": "char pointer array"
    },
    "type_mapping": {
      "p_file_type": "integer pointer",
      "p_name": "char pointer array"
    }
  },
  {
    "idx": 158134,
    "project": "savannah",
    "commit_id": "29c759284e305ec428703c9a5831d0b1fc3497ef",
    "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls",
    "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=29c759284e305ec428703c9a5831d0b1fc3497ef",
    "commit_message": "None",
    "label": 0,
    "func": "  Ins_GETVARIATION( TT_ExecContext  exc,\n                    FT_Long*        args )\n  {\n    FT_UInt    num_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;\n\n    FT_UInt  i;\n\n\n    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n       return;\n     }\n \n    if ( coords )\n    {\n      for ( i = 0; i < num_axes; i++ )\n        args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */\n    }\n    else\n    {\n      for ( i = 0; i < num_axes; i++ )\n        args[i] = 0;\n    }\n   }\n",
    "func_hash": 159806780920376373711216124732552440560,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-6942",
    "cve_desc": "An issue was discovered in FreeType 2 through 2.9. A NULL pointer dereference in the Ins_GETVARIATION() function within ttinterp.c could lead to DoS via a crafted font file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-6942",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "coords",
          "args"
        ],
        "arrays": [
          "coords",
          "args"
        ],
        "size_variables": [
          "num_axes",
          "stackSize",
          "num_axis",
          "blend"
        ],
        "all_variables": [
          "num_axes",
          "num_axis",
          "blend",
          "stackSize",
          "coords",
          "args"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "exc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_UInt    num_axes = exc->face->blend->num_axis;"
            },
            {
              "variable": "blend",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coo"
            },
            {
              "variable": "exc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_Fixed*  coords   = exc->face->blend->normalizedc"
            },
            {
              "variable": "blend",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ords   = exc->face->blend->normalizedcoords;\n\n    FT_UInt  i;"
            },
            {
              "variable": "exc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )"
            },
            {
              "variable": "exc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xc->stackSize + 1 - exc->top ) )\n    {\n      exc"
            },
            {
              "variable": "exc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "top ) )\n    {\n      exc->error = FT_THROW( Stack_O"
            },
            {
              "variable": "args",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "FT_Long*        args )\n  {\n    FT_UInt"
            },
            {
              "variable": "coords",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_axis;\n    FT_Fixed*  coords   = exc->face->blen"
            },
            {
              "variable": "convert",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= coords[i] >> 2; /* convert 16.16 to 2.14 forma"
            },
            {
              "variable": "args",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "axes; i++ )\n        args[i] = coords[i] >> 2; /"
            },
            {
              "variable": "coords",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ")\n        args[i] = coords[i] >> 2; /* convert 16"
            },
            {
              "variable": "args",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "axes; i++ )\n        args[i] = 0;\n    }\n   }"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 2,
        "array_count": 2,
        "size_variable_count": 4
      }
    },
    "predict": "{\"vulnerable_variables\": [\"blend\"]}",
    "vulnerable_variables": [
      "blend"
    ],
    "vulnerable_variable": "blend",
    "variable_definitions": {
      "blend": "Definition not found"
    },
    "variable_types": {
      "blend": "struct pointer_struct pointer"
    },
    "type_mapping": {
      "blend": "sp_sp"
    }
  },
  {
    "idx": 158266,
    "project": "ghostscript",
    "commit_id": "d621292fb2c8157d9899dcd83fd04dd250e30fe4",
    "project_url": "http://git.ghostscript.com/?p=mupdf",
    "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=d621292fb2c8157d9899dcd83fd04dd250e30fe4",
    "commit_message": "None",
    "label": 0,
    "func": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n     gx_color_index drawn_comps = pdev->drawn_comps;\n     bool nonicc_conversion = true;\n \n    if (nos == NULL)\n        return_error(gs_error_unknownerror);  /* Unmatched group pop */\n\n     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n     tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}\n",
    "func_hash": 180828718983298005628671948012539861831,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-10218",
    "cve_desc": "The pdf14_pop_transparency_group function in base/gdevp14.c in the PDF Transparency module in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10218",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "curr_icc_profile",
          "icc_profile",
          "have",
          "data",
          "pgs",
          "mask_stack",
          "ctx",
          "dev",
          "pdev",
          "pblend_procs",
          "tos",
          "icc_link",
          "nos_num_color_comp",
          "parent_color_mapping_procs",
          "the",
          "new_data_buf",
          "nos",
          "maskbuf",
          "tos_num_color_comp",
          "rc_mask",
          "new_num_planes",
          "num_noncolor_planes"
        ],
        "arrays": [],
        "size_variables": [
          "num_components",
          "num_spots",
          "blend",
          "pblend_procs",
          "tos_num_color_comp",
          "blending",
          "num_rows",
          "nos_num_color_comp",
          "parent_blending_procs",
          "num_cols",
          "new_num_planes",
          "sizes",
          "smask_blend",
          "size",
          "pdf14_nonseparable_blending_procs_t",
          "num_noncolor_planes"
        ],
        "all_variables": [
          "curr_icc_profile",
          "num_spots",
          "icc_profile",
          "blend",
          "blending",
          "num_rows",
          "have",
          "data",
          "pdf14_nonseparable_blending_procs_t",
          "pgs",
          "mask_stack",
          "ctx",
          "dev",
          "smask_blend",
          "num_cols",
          "pdev",
          "pblend_procs",
          "tos",
          "icc_link",
          "nos_num_color_comp",
          "parent_color_mapping_procs",
          "sizes",
          "size",
          "the",
          "num_components",
          "new_data_buf",
          "nos",
          "maskbuf",
          "tos_num_color_comp",
          "rc_mask",
          "parent_blending_procs",
          "new_num_planes",
          "num_noncolor_planes"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *mas"
            },
            {
              "variable": "pdev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "bool overprint = pdev->overprint;\n     gx_color_inde"
            },
            {
              "variable": "pdev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "index drawn_comps = pdev->drawn_comps;\n     bool nonicc_c"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "os_num_color_comp - tos->num_spots;\n    if (mask_stack"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rect_intersect(tos->dirty, tos->rect);\n    re"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tersect(tos->dirty, tos->rect);\n    rect_intersec"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "wn. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y)"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y)"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x)"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x)"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">rect.q.x);\n    if (ctx->mask_stack) {\n        /* This"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "put\n           into ctx->masbuf, since it is still"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_po"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "roup\");\n        if (ctx->mask_stack->rc_mask == NULL ){"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gs_free_object(ctx->memory, ctx->mask_stack, \""
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transpa"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n        }\n        ctx->mask_stack = NULL;\n    }\n    c"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* R"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rency_group. */\n    tos->mask_stack = NULL;        /* C"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "to ctx. */\n    if (tos->idle)\n        goto exit;"
            },
            {
              "variable": "maskbuf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(maskbuf != NULL && maskbuf->data == NULL && maskbuf-"
            },
            {
              "variable": "maskbuf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uf->data == NULL && maskbuf->alpha == 255)\n        got"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dump_raw_buffer(ctx->stack->rect.q.y-ctx->stac"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tx->stack->rect.q.y-ctx->stack->rect.p.y,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".y,\n                ctx->stack->rowstride, ctx->st"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->stack->rowstride, ctx->stack->n_planes,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es,\n                ctx->stack->planestride, ctx->"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "stack->planestride, ctx->stack->rowstride,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* N"
            },
            {
              "variable": "icc_profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_color_info_procs->icc_profile->hashcode !="
            },
            {
              "variable": "curr_icc_profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "curr_icc_profile->hashcode);\n    } else {"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_noncolor_planes = tos->n_planes - tos_num_color_com"
            },
            {
              "variable": "pgs",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&rendering_params, pgs->memory, false);"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uf = gs_alloc_bytes(ctx->memory,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride * new_num_planes,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mcpy(new_data_buf + tos->planestride * nos_num_color_com"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->data + tos->planestride"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->data + tos->planestride * tos_num_color_com"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride * num_noncolor_plan"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "new_data_buf = tos->data;"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_rows = tos->rect.q.y - tos->rect.p.y"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s = tos->rect.q.y - tos->rect.p.y;"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_cols = tos->rect.q.x - tos->rect.p.x"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s = tos->rect.q.x - tos->rect.p.x;"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride, tos->rowstride,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride, tos->rowstride,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "false, false, true, tos->planestride,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->rowstride, num_rows, num_cols"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&output_buff_desc, tos->data,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gs_free_object(ctx->memory, tos->data,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "object(ctx->memory, tos->data,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->data = new_data_buf;"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uf = gs_alloc_bytes(ctx->memory,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride * new_num_planes,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "olor_buffer_generic(tos->data, tos->rowstride,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_generic(tos->data, tos->rowstride,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride, tos_num_color_comp"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos_num_color_comp, tos->rect,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gs_free_object(ctx->memory, tos->data,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "object(ctx->memory, tos->data,"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n                 tos->data = new_data_buf;"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "now */\n             tos->n_chan = nos->n_chan;"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_chan;\n             tos->n_planes = nos->n_planes;\n#i"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dump_raw_buffer(ctx->stack->rect.q.y-ctx->stac"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tx->stack->rect.q.y-ctx->stack->rect.p.y,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx->stack->rowstride, ctx->st"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->stack->rowstride, ctx->stack->n_chan,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx->stack->planestride, ctx->"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "stack->planestride, ctx->stack->rowstride,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ns_Group_ColorConv\",ctx->stack->data);\n#endif"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "false, drawn_comps, ctx->memory, dev);\n        }"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx->additive, pblend_procs, over"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "drawn_comps, ctx->memory, dev);\n    }\nexit:"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "v);\n    }\nexit:\n    ctx->stack = nos;\n    /* We wa"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != N"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oftmasks */\n        ctx->smask_blend = true;\n    }\n    i"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if_debug1m('v', ctx->memory, \"[v]pop buf, idle="
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "op buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_fre"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}"
            },
            {
              "variable": "pgs",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ncy_group(gs_gstate *pgs, pdf14_ctx *ctx,"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ate *pgs, pdf14_ctx *ctx,\n    const pdf14_no"
            },
            {
              "variable": "pblend_procs",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "le_blending_procs_t * pblend_procs,\n    int tos_num_co"
            },
            {
              "variable": "curr_icc_profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_profile, gx_device *dev)\n{\n    pdf14_buf *t"
            },
            {
              "variable": "tos",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ev)\n{\n    pdf14_buf *tos = ctx->stack;\n    p"
            },
            {
              "variable": "maskbuf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0"
            },
            {
              "variable": "pdev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c;\n    pdf14_device *pdev = (pdf14_device *)d"
            },
            {
              "variable": "Unmatched",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "or_unknownerror);  /* Unmatched group pop */"
            },
            {
              "variable": "Sanitise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r_rangecheck);\n    /* Sanitise the dirty rectangle"
            },
            {
              "variable": "have",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "awing routines\n     * have made them overly la"
            },
            {
              "variable": "dirty",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y, nos->rect);\n    /* dirty = the marked bbox."
            },
            {
              "variable": "Everything",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the buffer. */\n    /* Everything marked on tos that"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k_stack) {\n        /* This can occur when we h"
            },
            {
              "variable": "Restore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ack = mask_stack;  /* Restore the mask saved by p"
            },
            {
              "variable": "Clean",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ack = NULL;        /* Clean the pointer sinse t"
            },
            {
              "variable": "Dump",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "#if RAW_DUMP\n    /* Dump the current buffer"
            },
            {
              "variable": "Note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ack->data);\n#endif\n/* Note currently if a patt"
            },
            {
              "variable": "Let",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "} else {\n        /* Let the other tests mak"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= false;\n    }\n    /* If the color spaces ar"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y1) {\n            /* The NOS blending color"
            },
            {
              "variable": "See",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "comp;\n\n            /* See if we are doing ICC"
            },
            {
              "variable": "Use",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n                /* Use the ICC color manag"
            },
            {
              "variable": "Define",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n                /* Define the rendering inten"
            },
            {
              "variable": "Request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "T;\n                /* Request the ICC link for th"
            },
            {
              "variable": "Note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n                /* Note that if pgs is NULL"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* If the link is the ide"
            },
            {
              "variable": "Before",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Before we do any allocatio"
            },
            {
              "variable": "FIXME",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* FIXME: RJW: Could we get"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "* the area that's actuall"
            },
            {
              "variable": "Different",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Different size.  We will need"
            },
            {
              "variable": "new_num_planes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride * new_num_planes,"
            },
            {
              "variable": "Copy",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Copy over the noncolor p"
            },
            {
              "variable": "nos_num_color_comp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+ tos->planestride * nos_num_color_comp,"
            },
            {
              "variable": "tos_num_color_comp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+ tos->planestride * tos_num_color_comp,"
            },
            {
              "variable": "num_noncolor_planes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride * num_noncolor_planes);"
            },
            {
              "variable": "In",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* In place color convers"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Set up the buffer descr"
            },
            {
              "variable": "Transform",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Transform the data. Since the"
            },
            {
              "variable": "Release",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Release the link */"
            },
            {
              "variable": "free",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* free the old object if t"
            },
            {
              "variable": "Non",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n                /* Non ICC based transform"
            },
            {
              "variable": "new_num_planes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tos->planestride * new_num_planes,"
            },
            {
              "variable": "Free",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n                /* Free the old object */"
            },
            {
              "variable": "Adjust",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n             /* Adjust the plane and chann"
            },
            {
              "variable": "Dump",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "W_DUMP\n            /* Dump the current buffer"
            },
            {
              "variable": "compose",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "endif\n             /* compose. never do overprint"
            },
            {
              "variable": "Group",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "} else {\n        /* Group color spaces are th"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->stack = nos;\n    /* We want to detect the"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= NULL) {\n        /* Set the trigger so that"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 33,
        "pointer_count": 22,
        "array_count": 0,
        "size_variable_count": 16
      }
    },
    "predict": "{\"vulnerable_variables\":[\"ctx\",\"tos\",\"dev\",\"pdev\",\"curr_icc_profile\",\"pgs\",\"rc_mask\"]}",
    "vulnerable_variables": [
      "ctx",
      "tos",
      "dev",
      "pdev",
      "curr_icc_profile",
      "pgs",
      "rc_mask"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "ctx": "pdf14_ctx *ctx",
      "tos": "pdf14_buf *tos = ctx->stack;",
      "dev": "gx_device *dev",
      "pdev": "pdf14_device *pdev = (pdf14_device *)dev;",
      "curr_icc_profile": "cmm_profile_t *curr_icc_profile",
      "pgs": "gs_gstate *pgs",
      "rc_mask": "Definition not found"
    },
    "variable_types": {
      "ctx": "struct pointer",
      "tos": "struct pointer",
      "dev": "struct pointer",
      "pdev": "struct pointer",
      "curr_icc_profile": "struct pointer",
      "pgs": "struct pointer",
      "rc_mask": "struct pointer_struct pointer"
    },
    "type_mapping": {
      "ctx": "struct pointer",
      "tos": "struct pointer",
      "dev": "struct pointer",
      "pdev": "struct pointer",
      "curr_icc_profile": "struct pointer",
      "pgs": "struct pointer",
      "rc_mask": "sp_sp"
    }
  },
  {
    "idx": 158418,
    "project": "busybox",
    "commit_id": "1de25a6e87e0e627aa34298105a3d17c60a1f44e",
    "project_url": "http://git.busybox.net/busybox",
    "commit_url": "http://git.busybox.net/busybox/commit/?id=1de25a6e87e0e627aa34298105a3d17c60a1f44e",
    "commit_message": "unzip: test for bad archive SEGVing\n\nfunction                                             old     new   delta\nhuft_build                                          1296    1300      +4\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>",
    "label": 0,
    "func": "static int huft_build(const unsigned *b, const unsigned n,\n\t\t\tconst unsigned s, const unsigned short *d,\n\t\t\tconst unsigned char *e, huft_t **t, unsigned *m)\n{\n\tunsigned a;             /* counter for codes of length k */\n\tunsigned c[BMAX + 1];   /* bit length count table */\n\tunsigned eob_len;       /* length of end-of-block code (value 256) */\n\tunsigned f;             /* i repeats in table every f entries */\n\tint g;                  /* maximum code length */\n\tint htl;                /* table level */\n \tunsigned i;             /* counter, current code */\n \tunsigned j;             /* counter */\n \tint k;                  /* number of bits in current code */\n\tconst unsigned *p;      /* pointer into c[], b[], or v[] */\n \thuft_t *q;              /* points to current table */\n \thuft_t r;               /* table entry for structure assignment */\n \thuft_t *u[BMAX];        /* table stack */\n \tunsigned v[N_MAX];      /* values in order of bit length */\n\tunsigned v_end;\n \tint ws[BMAX + 1];       /* bits decoded stack */\n \tint w;                  /* bits decoded */\n \tunsigned x[BMAX + 1];   /* bit offsets, then code stack */\n\tint y;                  /* number of dummy codes added */\n\tunsigned z;             /* number of entries in current table */\n\n\t/* Length of EOB code, if any */\n\teob_len = n > 256 ? b[256] : BMAX;\n\n\t*t = NULL;\n\n \n \t/* Generate counts for each bit length */\n \tmemset(c, 0, sizeof(c));\n\tp = b;\n \ti = n;\n \tdo {\n \t\tc[*p]++; /* assume all entries <= BMAX */\n\t} while (--i);\n\tif (c[0] == n) {  /* null input - all zero length codes */\n\t\t*m = 0;\n\t\treturn 2;\n\t}\n\n\t/* Find minimum and maximum length, bound *m by those */\n\tfor (j = 1; (j <= BMAX) && (c[j] == 0); j++)\n\t\tcontinue;\n\tk = j; /* minimum code length */\n\tfor (i = BMAX; (c[i] == 0) && i; i--)\n\t\tcontinue;\n\tg = i; /* maximum code length */\n\t*m = (*m < j) ? j : ((*m > i) ? i : *m);\n\n\t/* Adjust last length count to fill out codes, if needed */\n\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\ty -= c[j];\n\t\tif (y < 0)\n\t\t\treturn 2; /* bad input: more codes than bits */\n\t}\n\ty -= c[i];\n\tif (y < 0)\n\t\treturn 2;\n\tc[i] += y;\n\n\t/* Generate starting offsets into the value table for each length */\n\tx[1] = j = 0;\n\tp = c + 1;\n\txp = x + 2;\n\twhile (--i) { /* note that i == g from above */\n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}\n \t}\n",
    "func_hash": 332336069584062609022522679219430996770,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2015-9261",
    "cve_desc": "huft_build in archival/libarchive/decompress_gunzip.c in BusyBox before 1.27.2 misuses a pointer, causing segfaults and an application crash during an unzip operation on a specially crafted ZIP file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-9261",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "u",
          "q",
          "d",
          "m",
          "e",
          "p",
          "b"
        ],
        "arrays": [
          "u",
          "x",
          "ws",
          "v",
          "c",
          "b"
        ],
        "size_variables": [
          "length",
          "count",
          "counts",
          "counter",
          "Length",
          "sizeof",
          "eob_len",
          "number"
        ],
        "all_variables": [
          "u",
          "number",
          "b",
          "counts",
          "d",
          "eob_len",
          "e",
          "length",
          "x",
          "count",
          "ws",
          "v",
          "c",
          "q",
          "counter",
          "Length",
          "sizeof",
          "m",
          "p"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uild(const unsigned *b, const unsigned n,"
            },
            {
              "variable": "d",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "onst unsigned short *d,\n\t\t\tconst unsigned"
            },
            {
              "variable": "e",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const unsigned char *e, huft_t **t, unsign"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ed char *e, huft_t **t, unsigned *m)\n{\n\tun"
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uft_t **t, unsigned *m)\n{\n\tunsigned a;"
            },
            {
              "variable": "counter",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned a;             /* counter for codes of length"
            },
            {
              "variable": "bit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned c[BMAX + 1];   /* bit length count table"
            },
            {
              "variable": "length",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned eob_len;       /* length of end-of-block cod"
            },
            {
              "variable": "i",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned f;             /* i repeats in table ev"
            },
            {
              "variable": "maximum",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";                  /* maximum code length */\n\tint"
            },
            {
              "variable": "table",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tl;                /* table level */\n \tunsigned"
            },
            {
              "variable": "counter",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned i;             /* counter, current code */"
            },
            {
              "variable": "counter",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned j;             /* counter */\n \tint k;"
            },
            {
              "variable": "number",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";                  /* number of bits in current"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n\tconst unsigned *p;      /* pointer in"
            },
            {
              "variable": "pointer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unsigned *p;      /* pointer into c[], b[], or v"
            },
            {
              "variable": "q",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "or v[] */\n \thuft_t *q;              /* po"
            },
            {
              "variable": "points",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t *q;              /* points to current table */"
            },
            {
              "variable": "table",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t r;               /* table entry for structure"
            },
            {
              "variable": "u",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ignment */\n \thuft_t *u[BMAX];        /* ta"
            },
            {
              "variable": "table",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t *u[BMAX];        /* table stack */\n \tunsigned"
            },
            {
              "variable": "values",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned v[N_MAX];      /* values in order of bit len"
            },
            {
              "variable": "bits",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s[BMAX + 1];       /* bits decoded stack */"
            },
            {
              "variable": "bits",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";                  /* bits decoded */\n \tunsign"
            },
            {
              "variable": "bit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned x[BMAX + 1];   /* bit offsets, then code"
            },
            {
              "variable": "number",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";                  /* number of dummy codes adde"
            },
            {
              "variable": "number",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned z;             /* number of entries in curre"
            },
            {
              "variable": "Length",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "current table */\n\n\t/* Length of EOB code, if any"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "? b[256] : BMAX;\n\n\t*t = NULL;\n\n \n \t/* Gen"
            },
            {
              "variable": "Generate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*t = NULL;\n\n \n \t/* Generate counts for each bit"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "i = n;\n \tdo {\n \t\tc[*p]++; /* assume all e"
            },
            {
              "variable": "assume",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "do {\n \t\tc[*p]++; /* assume all entries <= BMAX"
            },
            {
              "variable": "null",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (c[0] == n) {  /* null input - all zero le"
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o length codes */\n\t\t*m = 0;\n\t\treturn 2;\n\t}"
            },
            {
              "variable": "Find",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\treturn 2;\n\t}\n\n\t/* Find minimum and maximum"
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ximum length, bound *m by those */\n\tfor (j"
            },
            {
              "variable": "minimum",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "continue;\n\tk = j; /* minimum code length */\n\tfor"
            },
            {
              "variable": "maximum",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "continue;\n\tg = i; /* maximum code length */\n\t*m"
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mum code length */\n\t*m = (*m < j) ? j : (("
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de length */\n\t*m = (*m < j) ? j : ((*m > i"
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= (*m < j) ? j : ((*m > i) ? i : *m);\n\n\t/"
            },
            {
              "variable": "m",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "j : ((*m > i) ? i : *m);\n\n\t/* Adjust last"
            },
            {
              "variable": "Adjust",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "> i) ? i : *m);\n\n\t/* Adjust last length count t"
            },
            {
              "variable": "bad",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "< 0)\n\t\t\treturn 2; /* bad input: more codes t"
            },
            {
              "variable": "Generate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n 2;\n\tc[i] += y;\n\n\t/* Generate starting offsets in"
            },
            {
              "variable": "note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "2;\n\twhile (--i) { /* note that i == g from ab"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rom above */\n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}"
            },
            {
              "variable": "xp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e */\n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}\n \t}"
            },
            {
              "variable": "u",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "gnment */\n \thuft_t *u[BMAX];        /* table st"
            },
            {
              "variable": "v",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "stack */\n \tunsigned v[N_MAX];      /* values in"
            },
            {
              "variable": "b",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "eob_len = n > 256 ? b[256] : BMAX;\n\n\t*t = NULL"
            },
            {
              "variable": "c",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "} while (--i);\n\tif (c[0] == n) {  /* null in"
            },
            {
              "variable": "c",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "1; (j <= BMAX) && (c[j] == 0); j++)\n\t\tconti"
            },
            {
              "variable": "c",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "*/\n\tfor (i = BMAX; (c[i] == 0) && i; i--)"
            },
            {
              "variable": "c",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ", y <<= 1) {\n\t\ty -= c[j];\n\t\tif (y < 0)\n\t\t\tre"
            },
            {
              "variable": "c",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "an bits */\n\t}\n\ty -= c[i];\n\tif (y < 0)\n\t\tretu"
            },
            {
              "variable": "c",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "y < 0)\n\t\treturn 2;\n\tc[i] += y;\n\n\t/* Generate"
            },
            {
              "variable": "x",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "for each length */\n\tx[1] = j = 0;\n\tp = c + 1"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 19,
        "pointer_count": 7,
        "array_count": 6,
        "size_variable_count": 8
      }
    },
    "predict": "{\"vulnerable_variables\":[\"b\"]}",
    "vulnerable_variables": [
      "b"
    ],
    "vulnerable_variable": "b",
    "variable_definitions": {
      "b": "const unsigned *b"
    },
    "variable_types": {
      "b": "integer pointer"
    },
    "type_mapping": {
      "b": "integer pointer"
    }
  },
  {
    "idx": 158512,
    "project": "linux",
    "commit_id": "c8e252586f8d5de906385d8cf6385fee289a825e",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c8e252586f8d5de906385d8cf6385fee289a825e",
    "commit_message": "regset: Prevent null pointer reference on readonly regsets\n\nThe regset common infrastructure assumed that regsets would always\nhave .get and .set methods, but not necessarily .active methods.\nUnfortunately people have since written regsets without .set methods.\n\nRather than putting in stub functions everywhere, handle regsets with\nnull .get or .set methods explicitly.\n\nSigned-off-by: H. Peter Anvin <hpa@zytor.com>\nReviewed-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: Roland McGrath <roland@hack.frob.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "label": 0,
    "func": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n \tfor (i = 1; i < view->n; ++i) {\n \t\tconst struct user_regset *regset = &view->regsets[i];\n \t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n \t\t    (!regset->active || regset->active(t->task, regset))) {\n \t\t\tint ret;\n \t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n",
    "func_hash": 176058176946205072087516860096873462643,
    "file_name": "binfmt_elf.c",
    "file_hash": 71468904637537324253537338197819212471,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2012-1097",
    "cve_desc": "The regset (aka register set) feature in the Linux kernel before 3.2.10 does not properly handle the absence of .get and .set methods, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via a (1) PTRACE_GETREGSET or (2) PTRACE_SETREGSET ptrace call.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-1097",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "view",
          "than",
          "that",
          "goes",
          "regset",
          "data",
          "total",
          "t"
        ],
        "arrays": [
          "notes",
          "regsets"
        ],
        "size_variables": [
          "size_t",
          "notesize",
          "sizeof",
          "size"
        ],
        "all_variables": [
          "view",
          "than",
          "regsets",
          "notes",
          "notesize",
          "that",
          "size_t",
          "goes",
          "sizeof",
          "regset",
          "data",
          "total",
          "size",
          "t"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n\tfill_prstatus(&t->prstatus, t->task, signr);"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tatus(&t->prstatus, t->task, signr);\n\t(void) vi"
            },
            {
              "variable": "view",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sk, signr);\n\t(void) view->regsets[0].get(t->task, &vi"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "iew->regsets[0].get(t->task, &view->regsets[0],"
            },
            {
              "variable": "view",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ts[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, size"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfi"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRST"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "zeof(t->prstatus), &t->prstatus);\n\t*total += notesi"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*total += notesize(&t->notes[0]);\n\n\tdo_thread_re"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ad_regset_writeback(t->task, &view->regsets[0])"
            },
            {
              "variable": "view",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "inactive, we leave t->notes[i]\n\t * all zero and"
            },
            {
              "variable": "view",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/\n \tfor (i = 1; i < view->n; ++i) {\n \t\tconst st"
            },
            {
              "variable": "view",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r_regset *regset = &view->regsets[i];\n \t\tdo_thread_re"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ad_regset_writeback(t->task, regset);\n\t\tif (reg"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ask, regset);\n\t\tif (regset->core_note_type && regset->get &&"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->core_note_type && regset->get &&\n \t\t    (!regset-"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "et->get &&\n \t\t    (!regset->active || regset->active(t"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(!regset->active || regset->active(t->task, regset)))"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e || regset->active(t->task, regset))) {\n \t\t\tin"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n \t\t\tsize_t size = regset->n * regset->size;"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "size = regset->n * regset->size;\n\t\t\tvoid *data = km"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return 0;\n\t\t\tret = regset->get(t->task, regset,"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ret = regset->get(t->task, regset,\n\t\t\t\t\t  0,"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "EG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\","
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "a);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\","
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}"
            },
            {
              "variable": "t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lf_thread_core_info *t,\n\t\t\t\t const struct"
            },
            {
              "variable": "view",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct user_regset_view *view,\n\t\t\t\t long signr, s"
            },
            {
              "variable": "total",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "long signr, size_t *total)\n{\n\tunsigned int i;"
            },
            {
              "variable": "NT_PRSTATUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "igned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special"
            },
            {
              "variable": "goes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e the regset data\n\t * goes into the pr_reg fie"
            },
            {
              "variable": "than",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "contents, rather\n\t * than being the whole not"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "he reset in here.\n\t * We assume that regset"
            },
            {
              "variable": "total",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s), &t->prstatus);\n\t*total += notesize(&t->not"
            },
            {
              "variable": "Each",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "regsets[0]);\n\n\t/*\n\t * Each other regset might"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "For each regset\n\t * that has no core_note_ty"
            },
            {
              "variable": "all",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "leave t->notes[i]\n\t * all zero and we'll know"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct user_regset *regset = &view->regsets[i]"
            },
            {
              "variable": "regset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_t size = regset->n * regset->size;\n\t\t\tvoid *dat"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gset->size;\n\t\t\tvoid *data = kmalloc(size, GFP"
            },
            {
              "variable": "total",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->not"
            },
            {
              "variable": "regsets",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "gnr);\n\t(void) view->regsets[0].get(t->task, &view-"
            },
            {
              "variable": "regsets",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof("
            },
            {
              "variable": "notes",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "L);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATU"
            },
            {
              "variable": "notes",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tal += notesize(&t->notes[0]);\n\n\tdo_thread_regse"
            },
            {
              "variable": "regsets",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ack(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each oth"
            },
            {
              "variable": "notes",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "active, we leave t->notes[i]\n\t * all zero and we"
            },
            {
              "variable": "regsets",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "et *regset = &view->regsets[i];\n \t\tdo_thread_regse"
            },
            {
              "variable": "notes",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "fill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  r"
            },
            {
              "variable": "notes",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "fill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT"
            },
            {
              "variable": "notes",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tal += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tret"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 14,
        "pointer_count": 8,
        "array_count": 2,
        "size_variable_count": 4
      }
    },
    "predict": "{\"vulnerable_variables\": [\"view\", \"regsets\"]}",
    "vulnerable_variables": [
      "view",
      "regsets"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "view": "const struct user_regset_view *view,",
      "regsets": "Definition not found"
    },
    "variable_types": {
      "view": "struct pointer",
      "regsets": "struct pointer_struct array"
    },
    "type_mapping": {
      "view": "struct pointer",
      "regsets": "struct pointer_struct array"
    }
  },
  {
    "idx": 158535,
    "project": "linux",
    "commit_id": "bc909d9ddbf7778371e36a651d6e4194b1cc7d4c",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c",
    "commit_message": "sendmmsg/sendmsg: fix unsafe user pointer access\n\nDereferencing a user pointer directly from kernel-space without going\nthrough the copy_from_user family of functions is a bad idea. Two of\nsuch usages can be found in the sendmsg code path called from sendmmsg,\nadded by\n\ncommit c71d8ebe7a4496fb7231151cb70a6baa0cb56f9a upstream.\ncommit 5b47b8038f183b44d2d8ff1c7d11a5c1be706b34 in the 3.0-stable tree.\n\nUsages are performed through memcmp() and memcpy() directly. Fix those\nby using the already copied msg_sys structure instead of the __user *msg\nstructure. Note that msg_sys can be set to NULL by verify_compat_iovec()\nor verify_iovec(), which requires additional NULL pointer checks.\n\nSigned-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>\nSigned-off-by: David Goulet <dgoulet@ev0ke.net>\nCC: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCC: Anton Blanchard <anton@samba.org>\nCC: David S. Miller <davem@davemloft.net>\nCC: stable <stable@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "label": 0,
    "func": "static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n \t * used_address->name_len is initialized to UINT_MAX so that the first\n \t * destination address never matches.\n \t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n \t\t    used_address->name_len)) {\n \t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n \t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n \t */\n \tif (used_address && err >= 0) {\n \t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n \t}\n \n out_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n",
    "func_hash": 124041052438755652701426559811498970926,
    "file_name": "socket.c",
    "file_hash": 73985084319012855648809021734124803602,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2011-4594",
    "cve_desc": "The __sys_sendmsg function in net/socket.c in the Linux kernel before 3.1 allows local users to cause a denial of service (system crash) via crafted use of the sendmmsg system call, leading to an incorrect pointer dereference.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4594",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "used_address",
          "sock",
          "ctl_buf",
          "successful",
          "checking",
          "msg",
          "sizeof",
          "msg_sys",
          "previously",
          "destination",
          "msg_compat"
        ],
        "arrays": [
          "iovstack",
          "ctl"
        ],
        "size_variables": [
          "__kernel_size_t",
          "iov_size",
          "msg_controllen",
          "name_len",
          "EMSGSIZE",
          "sizeof",
          "msg_namelen",
          "ctl_len",
          "msg_iovlen",
          "size",
          "total_len"
        ],
        "all_variables": [
          "iovstack",
          "iov_size",
          "ctl",
          "msg_controllen",
          "EMSGSIZE",
          "msg_namelen",
          "total_len",
          "used_address",
          "ctl_buf",
          "successful",
          "msg",
          "destination",
          "ctl_len",
          "checking",
          "msg_compat",
          "size",
          "__kernel_size_t",
          "sock",
          "name_len",
          "previously",
          "sizeof",
          "msg_sys",
          "msg_iovlen"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgot"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iov"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "iov = sock_kmalloc(sock->sk, iov_size, GFP_KERN"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto o"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COM"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "at_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     si"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sy"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ontrol;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_le"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNE"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reful! Before this, msg_sys->msg_control contains a user poi"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "id __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "trol = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lags = flags;\n\n\tif (sock->file->f_flags & O_NONBLO"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SM's decision.\n \t * used_address->name_len is initialized to U"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (used_address && msg_sys->msg_name &&\n\t    used_addres"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->msg_name &&\n\t    used_address->name_len == msg_sys->msg_nam"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ddress->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&us"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "en &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "used_address->name, msg_sys->msg_name,\n \t\t    used_addres"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->msg_name,\n \t\t    used_address->name_len)) {\n \t\terr = sock_s"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s && err >= 0) {\n \t\tused_address->name_len = msg_sys->msg_name"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_ad"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "used_address->name, msg_sys->msg_name,\n\t\t\t       used_add"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "msg_name,\n\t\t\t       used_address->name_len);\n \t}\n \n out_freect"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nou"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ndmsg(struct socket *sock, struct msghdr __us"
            },
            {
              "variable": "msg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct msghdr __user *msg,\n\t\t\t struct msghdr"
            },
            {
              "variable": "msg_sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t\t\t struct msghdr *msg_sys, unsigned flags,"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct used_address *used_address)\n{\n\tstruct compat_m"
            },
            {
              "variable": "msg_compat",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ompat_msghdr __user *msg_compat =\n\t    (struct comp"
            },
            {
              "variable": "iov",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "stack[UIO_FASTIOV], *iov = iovstack;\n\tunsign"
            },
            {
              "variable": "20",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ernel_size_t))));\n\t/* 20 is size of ipv6_pkt"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return -EFAULT;\n\n\t/* do not move before msg"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "IOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate"
            },
            {
              "variable": "sizeof",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto out;\n\t}\n\n\t/* This will also move the"
            },
            {
              "variable": "Careful",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_s"
            },
            {
              "variable": "Afterwards",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "a user pointer.\n\t\t * Afterwards, it will be a kerne"
            },
            {
              "variable": "checking",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ompiler-assisted\n\t\t * checking falls down on this."
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg()"
            },
            {
              "variable": "previously",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ddress is same as\n\t * previously succeeded address,"
            },
            {
              "variable": "used_address",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LSM's decision.\n \t * used_address->name_len is initia"
            },
            {
              "variable": "destination",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o that the first\n \t * destination address never match"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", total_len);\n\t/*\n\t * If this is sendmmsg()"
            },
            {
              "variable": "successful",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ation address was\n\t * successful, remember it.\n \t */"
            },
            {
              "variable": "iovstack",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ress;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 23,
        "pointer_count": 11,
        "array_count": 2,
        "size_variable_count": 11
      }
    },
    "predict": "{\"vulnerable_variables\":[\"msg_namelen\",\"name_len\"]}",
    "vulnerable_variables": [
      "msg_namelen",
      "name_len"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "msg_namelen": "Definition not found",
      "name_len": "Definition not found"
    },
    "variable_types": {
      "msg_namelen": "integer",
      "name_len": "unknown"
    },
    "type_mapping": {
      "msg_namelen": "Integer",
      "name_len": "unknown"
    }
  },
  {
    "idx": 158788,
    "project": "FFmpeg",
    "commit_id": "c94f9e854228e0ea00e1de8769d8d3f7cab84a55",
    "project_url": "https://github.com/FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c94f9e854228e0ea00e1de8769d8d3f7cab84a55",
    "commit_message": "avutil/mem: Fix flipped condition\n\nFixes return code and later null pointer dereference\n\nFound-by: Laurent Butti <laurentb@gmail.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "label": 0,
    "func": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n {\n     void **ptrptr = ptr;\n     *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && nmemb && size)\n         return AVERROR(ENOMEM);\n     return 0;\n }\n",
    "func_hash": 249553250920400348047891283724726781231,
    "file_name": "mem.c",
    "file_hash": 148629479801131881617327319113404690656,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2013-4265",
    "cve_desc": "The av_reallocp_array function in libavutil/mem.c in FFmpeg before 2.0.1 has an unspecified impact and remote vectors related to a \"wrong return code\" and a resultant NULL pointer dereference.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4265",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "ptr"
        ],
        "arrays": [],
        "size_variables": [
          "size_t",
          "size"
        ],
        "all_variables": [
          "ptr",
          "size_t",
          "size"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "ptr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reallocp_array(void *ptr, size_t nmemb, size"
            },
            {
              "variable": "ptrptr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "size)\n {\n     void **ptrptr = ptr;\n     *ptrptr"
            },
            {
              "variable": "ptrptr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*ptrptr = ptr;\n     *ptrptr = av_realloc_f(*ptr"
            },
            {
              "variable": "ptrptr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rptr = av_realloc_f(*ptrptr, nmemb, size);"
            },
            {
              "variable": "ptrptr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mb, size);\n    if (!*ptrptr && nmemb && size)"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 3,
        "pointer_count": 1,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"size\"]}",
    "vulnerable_variables": [
      "size"
    ],
    "vulnerable_variable": "size",
    "variable_definitions": {
      "size": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)"
    },
    "variable_types": {
      "size": "integer"
    },
    "type_mapping": {
      "size": "Integer"
    }
  },
  {
    "idx": 158874,
    "project": "krb5",
    "commit_id": "f249555301940c6df3a2cdda13b56b5674eebc2e",
    "project_url": "https://github.com/krb5/krb5",
    "commit_url": "https://github.com/krb5/krb5/commit/f249555301940c6df3a2cdda13b56b5674eebc2e",
    "commit_message": "PKINIT null pointer deref [CVE-2013-1415]\n\nDon't dereference a null pointer when cleaning up.\n\nThe KDC plugin for PKINIT can dereference a null pointer when a\nmalformed packet causes processing to terminate early, leading to\na crash of the KDC process.  An attacker would need to have a valid\nPKINIT certificate or have observed a successful PKINIT authentication,\nor an unauthenticated attacker could execute the attack if anonymous\nPKINIT is enabled.\n\nCVSSv2 vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:P/RL:O/RC:C\n\nThis is a minimal commit for pullup; style fixes in a followup.\n[kaduk@mit.edu: reformat and edit commit message]\n\n(cherry picked from commit c773d3c775e9b2d88bcdff5f8a8ba88d7ec4e8ed)\n\nticket: 7570\nversion_fixed: 1.11.1\nstatus: resolved",
    "label": 0,
    "func": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n     pkiDebug(\"found kdcPkId in AS REQ\\n\");\n     is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n     if (is == NULL)\n        return retval;\n \n     status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n     if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n     }\n \n     retval = 0;\n     X509_NAME_free(is->issuer);\n     ASN1_INTEGER_free(is->serial);\n     free(is);\n\n    return retval;\n}\n",
    "func_hash": 143213392633765950942454228028940041067,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2013-1415",
    "cve_desc": "The pkinit_check_kdc_pkid function in plugins/preauth/pkinit/pkinit_crypto_openssl.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 and 1.11.x before 1.11.1 does not properly handle errors during extraction of fields from an X.509 certificate, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a malformed KRB5_PADATA_PK_AS_REQ AS-REQ request.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1415",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "kdc_cert",
          "valid_kdcPkId",
          "is",
          "pdid_buf",
          "p"
        ],
        "arrays": [],
        "size_variables": [
          "pkid_len",
          "X509_get_serialNumber"
        ],
        "all_variables": [
          "kdc_cert",
          "valid_kdcPkId",
          "is",
          "pkid_len",
          "pdid_buf",
          "X509_get_serialNumber",
          "p"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "id_cryptoctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert"
            },
            {
              "variable": "id_cryptoctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPk"
            },
            {
              "variable": "pdid_buf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unsigned char *pdid_buf,"
            },
            {
              "variable": "valid_kdcPkId",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int *valid_kdcPkId)\n{\n    krb5_error_c"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const unsigned char *p = pdid_buf;\n    int"
            },
            {
              "variable": "kdc_cert",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tatus = 1;\n    X509 *kdc_cert = sk_X509_value(id_"
            },
            {
              "variable": "valid_kdcPkId",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->cert_index);\n\n    *valid_kdcPkId = 0;\n     pkiDebug("
            },
            {
              "variable": "valid_kdcPkId",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "status)\n            *valid_kdcPkId = 1;\n     }"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 7,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\":[\"pdid_buf\",\"pkid_len\"]}",
    "vulnerable_variables": [
      "pdid_buf",
      "pkid_len"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "pdid_buf": "unsigned char *pdid_buf,",
      "pkid_len": "unsigned int pkid_len,"
    },
    "variable_types": {
      "pdid_buf": "char pointer",
      "pkid_len": "integer"
    },
    "type_mapping": {
      "pdid_buf": "char pointer",
      "pkid_len": "Integer"
    }
  },
  {
    "idx": 158927,
    "project": "krb5",
    "commit_id": "db64ca25d661a47b996b4e2645998b5d7f0eb52c",
    "project_url": "https://github.com/krb5/krb5",
    "commit_url": "https://github.com/krb5/krb5/commit/db64ca25d661a47b996b4e2645998b5d7f0eb52c",
    "commit_message": "PKINIT (draft9) null ptr deref [CVE-2012-1016]\n\nDon't check for an agility KDF identifier in the non-draft9 reply\nstructure when we're building a draft9 reply, because it'll be NULL.\n\nThe KDC plugin for PKINIT can dereference a null pointer when handling\na draft9 request, leading to a crash of the KDC process.  An attacker\nwould need to have a valid PKINIT certificate, or an unauthenticated\nattacker could execute the attack if anonymous PKINIT is enabled.\n\nCVSSv2 vector: AV:N/AC:M/Au:N/C:N/I:N/A:P/E:P/RL:O/RC:C\n\n[tlyu@mit.edu: reformat comment and edit log message]\n\n(back ported from commit cd5ff932c9d1439c961b0cf9ccff979356686aff)\n\nticket: 7527 (new)\nversion_fixed: 1.10.4\nstatus: resolved",
    "label": 0,
    "func": "pkinit_server_return_padata(krb5_context context,\n                            krb5_pa_data * padata,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_kdc_rep * reply,\n                            krb5_keyblock * encrypting_key,\n                            krb5_pa_data ** send_pa,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_modreq modreq)\n{\n    krb5_error_code retval = 0;\n    krb5_data scratch = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i = 0;\n\n    unsigned char *subjectPublicKey = NULL;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int subjectPublicKey_len = 0;\n    unsigned int server_key_len = 0, dh_pubkey_len = 0;\n\n    krb5_kdc_dh_key_info dhkey_info;\n    krb5_data *encoded_dhkey_info = NULL;\n    krb5_pa_pk_as_rep *rep = NULL;\n    krb5_pa_pk_as_rep_draft9 *rep9 = NULL;\n    krb5_data *out_data = NULL;\n    krb5_octet_data secret;\n\n    krb5_enctype enctype = -1;\n\n    krb5_reply_key_pack *key_pack = NULL;\n    krb5_reply_key_pack_draft9 *key_pack9 = NULL;\n    krb5_data *encoded_key_pack = NULL;\n\n    pkinit_kdc_context plgctx;\n    pkinit_kdc_req_context reqctx;\n\n    int fixed_keypack = 0;\n\n    *send_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {\n        return return_pkinit_kx(context, request, reply,\n                                encrypting_key, send_pa);\n    }\n    if (padata->length <= 0 || padata->contents == NULL)\n        return 0;\n\n    if (modreq == NULL) {\n        pkiDebug(\"missing request context \\n\");\n        return EINVAL;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        pkiDebug(\"Unable to locate correct realm context\\n\");\n        return ENOENT;\n    }\n\n    pkiDebug(\"pkinit_return_padata: entered!\\n\");\n    reqctx = (pkinit_kdc_req_context)modreq;\n\n    if (encrypting_key->contents) {\n        free(encrypting_key->contents);\n        encrypting_key->length = 0;\n        encrypting_key->contents = NULL;\n    }\n\n    for(i = 0; i < request->nktypes; i++) {\n        enctype = request->ktype[i];\n        if (!krb5_c_valid_enctype(enctype))\n            continue;\n        else {\n            pkiDebug(\"KDC picked etype = %d\\n\", enctype);\n            break;\n        }\n    }\n\n    if (i == request->nktypes) {\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        init_krb5_pa_pk_as_rep(&rep);\n        if (rep == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        /* let's assume it's RSA. we'll reset it to DH if needed */\n        rep->choice = choice_pa_pk_as_rep_encKeyPack;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        init_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (rep9 == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n        break;\n    default:\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep->choice = choice_pa_pk_as_rep_dhInfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&\n               reqctx->rcv_auth_pack9->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;\n    }\n\n    /* if this DH, then process finish computing DH key */\n    if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||\n                        rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {\n        pkiDebug(\"received DH key delivery AS REQ\\n\");\n        retval = server_process_dh(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,\n                                   subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,\n                                   &server_key, &server_key_len);\n        if (retval) {\n            pkiDebug(\"failed to process/create dh paramters\\n\");\n            goto cleanup;\n        }\n    }\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /*\n         * This is DH, so don't generate the key until after we\n         * encode the reply, because the encoded reply is needed\n         * to generate the key in some cases.\n         */\n\n        dhkey_info.subjectPublicKey.length = dh_pubkey_len;\n        dhkey_info.subjectPublicKey.data = dh_pubkey;\n        dhkey_info.nonce = request->nonce;\n        dhkey_info.dhKeyExpiration = 0;\n\n        retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,\n                                                   &encoded_dhkey_info);\n        if (retval) {\n            pkiDebug(\"encode_krb5_kdc_dh_key_info failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_dhkey_info->data,\n                         encoded_dhkey_info->length,\n                         \"/tmp/kdc_dh_key_info\");\n#endif\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep->u.dh_Info.dhSignedData.data,\n                                           &rep->u.dh_Info.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep9->u.dhSignedData.data,\n                                           &rep9->u.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        }\n\n    } else {\n        pkiDebug(\"received RSA key delivery AS REQ\\n\");\n\n        retval = krb5_c_make_random_key(context, enctype, encrypting_key);\n        if (retval) {\n            pkiDebug(\"unable to make a session key\\n\");\n            goto cleanup;\n        }\n\n        /* check if PA_TYPE of 132 is present which means the client is\n         * requesting that a checksum is send back instead of the nonce\n         */\n        for (i = 0; request->padata[i] != NULL; i++) {\n            pkiDebug(\"%s: Checking pa_type 0x%08x\\n\",\n                     __FUNCTION__, request->padata[i]->pa_type);\n            if (request->padata[i]->pa_type == 132)\n                fixed_keypack = 1;\n        }\n        pkiDebug(\"%s: return checksum instead of nonce = %d\\n\",\n                 __FUNCTION__, fixed_keypack);\n\n        /* if this is an RFC reply or draft9 client requested a checksum\n         * in the reply instead of the nonce, create an RFC-style keypack\n         */\n        if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {\n            init_krb5_reply_key_pack(&key_pack);\n            if (key_pack == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n\n            retval = krb5_c_make_checksum(context, 0,\n                                          encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                          req_pkt, &key_pack->asChecksum);\n            if (retval) {\n                pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size = %d\\n\", req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"checksum size = %d\\n\", key_pack->asChecksum.length);\n            print_buffer(key_pack->asChecksum.contents,\n                         key_pack->asChecksum.length);\n            pkiDebug(\"encrypting key (%d)\\n\", encrypting_key->length);\n            print_buffer(encrypting_key->contents, encrypting_key->length);\n#endif\n\n            krb5_copy_keyblock_contents(context, encrypting_key,\n                                        &key_pack->replyKey);\n\n            retval = k5int_encode_krb5_reply_key_pack(key_pack,\n                                                      &encoded_key_pack);\n            if (retval) {\n                pkiDebug(\"failed to encode reply_key_pack\\n\");\n                goto cleanup;\n            }\n        }\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            rep->choice = choice_pa_pk_as_rep_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            /* if the request is from the broken draft9 client that\n             * expects back a nonce, create it now\n             */\n            if (!fixed_keypack) {\n                init_krb5_reply_key_pack_draft9(&key_pack9);\n                if (key_pack9 == NULL) {\n                    retval = ENOMEM;\n                    goto cleanup;\n                }\n                key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;\n                krb5_copy_keyblock_contents(context, encrypting_key,\n                                            &key_pack9->replyKey);\n\n                retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,\n                                                                 &encoded_key_pack);\n                if (retval) {\n                    pkiDebug(\"failed to encode reply_key_pack\\n\");\n                    goto cleanup;\n                }\n            }\n\n            rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);\n            break;\n        }\n        if (retval) {\n            pkiDebug(\"failed to create pkcs7 enveloped data: %s\\n\",\n                     error_message(retval));\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_key_pack->data,\n                         encoded_key_pack->length,\n                         \"/tmp/kdc_key_pack\");\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            print_buffer_bin(rep->u.encKeyPack.data,\n                             rep->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            print_buffer_bin(rep9->u.encKeyPack.data,\n                             rep9->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        }\n#endif\n    }\n\n    if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != NULL))) {\n\n        /* If using the alg-agility KDF, put the algorithm in the reply\n         * before encoding it.\n         */\n        if (reqctx->rcv_auth_pack != NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != NULL) {\n            retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,\n                                         &(rep->u.dh_Info.kdfID));\n            if (retval) {\n                pkiDebug(\"pkinit_pick_kdf_alg failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);\n        break;\n    }\n    if (retval) {\n        pkiDebug(\"failed to encode AS_REP\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    if (out_data != NULL)\n        print_buffer_bin((unsigned char *)out_data->data, out_data->length,\n                         \"/tmp/kdc_as_rep\");\n#endif\n\n    /* If this is DH, we haven't computed the key yet, so do it now. */\n    if ((rep9 != NULL &&\n          rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n         (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n \n        /* If we're not doing draft 9, and mutually supported KDFs were found,\n         * use the algorithm agility KDF. */\n        if (rep != NULL && rep->u.dh_Info.kdfID) {\n            secret.data = (char *)server_key;\n             secret.length = server_key_len;\n \n             retval = pkinit_alg_agility_kdf(context, &secret,\n                                            rep->u.dh_Info.kdfID,\n                                            request->client, request->server,\n                                            enctype,\n                                            (krb5_octet_data *)req_pkt,\n                                            (krb5_octet_data *)out_data,\n                                            encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_alg_agility_kdf failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n\n            /* Otherwise, use the older octetstring2key() function */\n        } else {\n            retval = pkinit_octetstring2key(context, enctype, server_key,\n                                            server_key_len, encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_octetstring2key failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    *send_pa = malloc(sizeof(krb5_pa_data));\n    if (*send_pa == NULL) {\n        retval = ENOMEM;\n        free(out_data->data);\n        free(out_data);\n        out_data = NULL;\n        goto cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_DATA;\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;\n        break;\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;\n        break;\n    }\n    (*send_pa)->length = out_data->length;\n    (*send_pa)->contents = (krb5_octet *) out_data->data;\n\ncleanup:\n    pkinit_fini_kdc_req_context(context, reqctx);\n    free(scratch.data);\n    free(out_data);\n    if (encoded_dhkey_info != NULL)\n        krb5_free_data(context, encoded_dhkey_info);\n    if (encoded_key_pack != NULL)\n        krb5_free_data(context, encoded_key_pack);\n    free(dh_pubkey);\n    free(server_key);\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free_krb5_pa_pk_as_rep(&rep);\n        free_krb5_reply_key_pack(&key_pack);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n        free_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (!fixed_keypack)\n            free_krb5_reply_key_pack_draft9(&key_pack9);\n        else\n            free_krb5_reply_key_pack(&key_pack);\n        break;\n    }\n\n    if (retval)\n        pkiDebug(\"pkinit_verify_padata failure\");\n\n    return retval;\n}\n",
    "func_hash": 254088971941613466573789144235178130975,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2012-1016",
    "cve_desc": "The pkinit_server_return_padata function in plugins/preauth/pkinit/pkinit_srv.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 attempts to find an agility KDF identifier in inappropriate circumstances, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted Draft 9 request.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-1016",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "req_pkt",
          "clientPublicValue",
          "encrypting_key",
          "to",
          "key_pack9",
          "subjectPublicKey",
          "reqp9",
          "request",
          "rep9",
          "before",
          "rcv_auth_pack",
          "padata",
          "requesting",
          "reply",
          "contents",
          "dh_pubkey",
          "rcv_auth_pack9",
          "in",
          "modreq",
          "send_pa",
          "plgctx",
          "encode",
          "rep",
          "out_data",
          "supportedKDFs",
          "expects",
          "encoded_dhkey_info",
          "encoded_key_pack",
          "reqp",
          "key_pack"
        ],
        "arrays": [
          "ktype",
          "padata"
        ],
        "size_variables": [
          "length",
          "subjectPublicKey_len",
          "sizeof",
          "server_key_len",
          "dh_pubkey_len",
          "size"
        ],
        "all_variables": [
          "subjectPublicKey_len",
          "server_key_len",
          "req_pkt",
          "clientPublicValue",
          "encrypting_key",
          "to",
          "dh_pubkey_len",
          "key_pack9",
          "subjectPublicKey",
          "ktype",
          "reqp9",
          "request",
          "rep9",
          "before",
          "rcv_auth_pack",
          "padata",
          "requesting",
          "reply",
          "length",
          "contents",
          "dh_pubkey",
          "rcv_auth_pack9",
          "in",
          "modreq",
          "send_pa",
          "plgctx",
          "encode",
          "size",
          "rep",
          "out_data",
          "supportedKDFs",
          "expects",
          "encoded_dhkey_info",
          "encoded_key_pack",
          "reqp",
          "sizeof",
          "key_pack"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKIN"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_pa);\n    }\n    if (padata->length <= 0 || padata->con"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ata->length <= 0 || padata->contents == NULL)\n        re"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t(context, moddata, request->server);\n    if (plgctx =="
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xt)modreq;\n\n    if (encrypting_key->contents) {\n        free(enc"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nts) {\n        free(encrypting_key->contents);\n        encryptin"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">contents);\n        encrypting_key->length = 0;\n        encryp"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "length = 0;\n        encrypting_key->contents = NULL;\n    }"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for(i = 0; i < request->nktypes; i++) {\n        enc"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n        enctype = request->ktype[i];\n        if (!kr"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    if (i == request->nktypes) {\n        retval ="
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PA"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "icKey =\n            reqctx->rcv_auth_pack->clientPublicValue-"
            },
            {
              "variable": "clientPublicValue",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subje"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_len =\n            reqctx->rcv_auth_pack->clientPublicValue-"
            },
            {
              "variable": "clientPublicValue",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "L &&\n               reqctx->rcv_auth_pack9->clientPublicValue"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "icKey =\n            reqctx->rcv_auth_pack9->clientPublicValue-"
            },
            {
              "variable": "clientPublicValue",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subje"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_len =\n            reqctx->rcv_auth_pack9->clientPublicValue-"
            },
            {
              "variable": "clientPublicValue",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reqctx->cryptoctx, plgctx->idctx, sub"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dhkey_info.nonce = request->nonce;\n        dhkey_info"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "switch ((int)padata->pa_type) {\n        case KRB"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reqctx->cryptoctx, plgctx->idctx, CMS"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reqctx->cryptoctx, plgctx->idctx, CMS"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (i = 0; request->padata[i] != NULL; i++) {"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__FUNCTION__, request->padata[i]->pa_type);"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e);\n            if (request->padata[i]->pa_type == 132)"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n        if ((int)padata->pa_type == KRB5_PADATA_PK_A"
            },
            {
              "variable": "req_pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n buf size = %d\\n\", req_pkt->length);\n            print"
            },
            {
              "variable": "req_pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "print_buffer(req_pkt->data, req_pkt->length);"
            },
            {
              "variable": "req_pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ffer(req_pkt->data, req_pkt->length);\n            pkiDe"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ypting key (%d)\\n\", encrypting_key->length);\n            print"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "print_buffer(encrypting_key->contents, encrypting_key->le"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ting_key->contents, encrypting_key->length);\n#endif"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "switch ((int)padata->pa_type) {\n        case KRB"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reqctx->cryptoctx, plgctx->idctx, pad"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx, plgctx->idctx, padata->pa_type, 1,"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.no"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reqctx->cryptoctx, plgctx->idctx, pad"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctx, plgctx->idctx, padata->pa_type, 1,"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "switch ((int)padata->pa_type) {\n        case KRB"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != N"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n        if (reqctx->rcv_auth_pack != NULL &&"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != N"
            },
            {
              "variable": "reqctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ck_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PA"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "request->client, request->server,"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "request->client, request->server,"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "A;\n    switch ((int)padata->pa_type) {\n    case KRB5_PA"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PA"
            },
            {
              "variable": "padata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_pa_data * padata,"
            },
            {
              "variable": "req_pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_data *req_pkt,"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_kdc_req * request,"
            },
            {
              "variable": "reply",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_kdc_rep * reply,"
            },
            {
              "variable": "encrypting_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_keyblock * encrypting_key,"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_pa_data ** send_pa,"
            },
            {
              "variable": "reqp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa"
            },
            {
              "variable": "reqp9",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i ="
            },
            {
              "variable": "subjectPublicKey",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unsigned char *subjectPublicKey = NULL;\n    unsigne"
            },
            {
              "variable": "dh_pubkey",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    unsigned char *dh_pubkey = NULL, *server_key"
            },
            {
              "variable": "server_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*dh_pubkey = NULL, *server_key = NULL;\n    unsigne"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d_keypack = 0;\n\n    *send_pa = NULL;\n    if (pad"
            },
            {
              "variable": "let",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n        /* let's assume it's RSA."
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n         * This is DH, so don't gen"
            },
            {
              "variable": "encode",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "l after we\n         * encode the reply, because"
            },
            {
              "variable": "to",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "is needed\n         * to generate the key in"
            },
            {
              "variable": "check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        /* check if PA_TYPE of 132 i"
            },
            {
              "variable": "requesting",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "client is\n         * requesting that a checksum is"
            },
            {
              "variable": "in",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "a checksum\n         * in the reply instead o"
            },
            {
              "variable": "expects",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t that\n             * expects back a nonce, creat"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL))) {\n\n        /* If using the alg-agili"
            },
            {
              "variable": "before",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the reply\n         * before encoding it."
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rep\");\n#endif\n\n    /* If this is DH, we have"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Info)) {\n \n        /* If we're not doing dra"
            },
            {
              "variable": "use",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ere found,\n         * use the algorithm agili"
            },
            {
              "variable": "Otherwise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n            /* Otherwise, use the older octe"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n    *send_pa = malloc(sizeof(krb"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_pa_data));\n    if (*send_pa == NULL) {"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_D"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PA"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "S_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PA"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n    }\n    (*send_pa)->length = out_data"
            },
            {
              "variable": "send_pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_data->length;\n    (*send_pa)->contents = (krb5_"
            },
            {
              "variable": "ktype",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "enctype = request->ktype[i];\n        if (!krb5_"
            },
            {
              "variable": "padata",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "or (i = 0; request->padata[i] != NULL; i++) {"
            },
            {
              "variable": "padata",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "UNCTION__, request->padata[i]->pa_type);"
            },
            {
              "variable": "padata",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (request->padata[i]->pa_type == 132)"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 37,
        "pointer_count": 30,
        "array_count": 2,
        "size_variable_count": 6
      }
    },
    "predict": "{\"vulnerable_variables\": [\"rcv_auth_pack\", \"supportedKDFs\"]}",
    "vulnerable_variables": [
      "rcv_auth_pack",
      "supportedKDFs"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "rcv_auth_pack": "Definition not found",
      "supportedKDFs": "Definition not found"
    },
    "variable_types": {
      "rcv_auth_pack": "struct pointer",
      "supportedKDFs": "unknown"
    },
    "type_mapping": {
      "rcv_auth_pack": "struct pointer",
      "supportedKDFs": "unknown"
    }
  },
  {
    "idx": 158943,
    "project": "linux",
    "commit_id": "ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d",
    "commit_message": "[SCTP]: Fix assertion (!atomic_read(&sk->sk_rmem_alloc)) failed message\n\nIn current implementation, LKSCTP does receive buffer accounting for\ndata in sctp_receive_queue and pd_lobby. However, LKSCTP don't do\naccounting for data in frag_list when data is fragmented. In addition,\nLKSCTP doesn't do accounting for data in reasm and lobby queue in\nstructure sctp_ulpq.\nWhen there are date in these queue, assertion failed message is printed\nin inet_sock_destruct because sk_rmem_alloc of oldsk does not become 0\nwhen socket is destroyed.\n\nSigned-off-by: Tsutomu Fujii <t-fujii@nb.jp.nec.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "label": 0,
    "func": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n \tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n \t\tevent = sctp_skb2event(skb);\n \t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n \t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n \t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n \t\t}\n \t}\n \n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n \t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n \t\t\tevent = sctp_skb2event(skb);\n \t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n \t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n \t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n \t\t\t}\n \t\t}\n \n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n \n \t}\n \n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n \t/* Set the type of socket to indicate that it is peeled off from the\n \t * original UDP-style socket or created with the accept() call on a\n \t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}\n",
    "func_hash": 229565381021276082282941171621828949635,
    "file_name": "socket.c",
    "file_hash": 276551155803624493413320102657949842882,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2011-2482",
    "cve_desc": "A certain Red Hat patch to the sctp_sock_migrate function in net/sctp/socket.c in the Linux kernel before 2.6.21, as used in Red Hat Enterprise Linux (RHEL) 5, allows remote attackers to cause a denial of service (NULL pointer dereference and OOPS) via a crafted SCTP packet.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2482",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "pp",
          "delivery",
          "queued",
          "on",
          "event",
          "peeled",
          "TCP",
          "oldsk",
          "that",
          "new",
          "skb",
          "newep",
          "assoc",
          "backlog",
          "copy",
          "queue",
          "newsk",
          "newsp",
          "endpoint",
          "oldsp",
          "need",
          "original"
        ],
        "arrays": [],
        "size_variables": [
          "num",
          "sizes"
        ],
        "all_variables": [
          "pp",
          "delivery",
          "queued",
          "on",
          "event",
          "peeled",
          "TCP",
          "oldsk",
          "that",
          "new",
          "skb",
          "newep",
          "num",
          "assoc",
          "backlog",
          "copy",
          "sizes",
          "queue",
          "newsk",
          "newsp",
          "endpoint",
          "oldsp",
          "need",
          "original"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p_endpoint *newep = newsp->ep;\n\tstruct sk_buff *s"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "* new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;"
            },
            {
              "variable": "oldsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "newsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;"
            },
            {
              "variable": "oldsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "newsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force co"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hm"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "newsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook t"
            },
            {
              "variable": "pp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tfl"
            },
            {
              "variable": "sk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADD"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tfla"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tfla"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ctp_bind_addr_copy(&newsp->ep->base.bind_addr,"
            },
            {
              "variable": "oldsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,"
            },
            {
              "variable": "oldsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n \t\tevent ="
            },
            {
              "variable": "event",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "2event(skb);\n \t\tif (event->asoc == assoc) {\n\t\t\tsctp"
            },
            {
              "variable": "oldsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__skb_unlink(skb, &oldsk->sk_receive_queue);\n \t\t\t__skb_queue_t"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through"
            },
            {
              "variable": "oldsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n \t\t\tevent ="
            },
            {
              "variable": "event",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "event(skb);\n \t\t\tif (event->asoc == assoc) {\n\t\t\t\tsct"
            },
            {
              "variable": "oldsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__skb_unlink(skb, &oldsp->pd_lobby);\n \t\t\t\t__skb_queue_"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_cl"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsct"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsct"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tyle socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark t"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tyle(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISH"
            },
            {
              "variable": "oldsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "migrate(struct sock *oldsk, struct sock *newsk"
            },
            {
              "variable": "newsk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*oldsk, struct sock *newsk,\n\t\t\t      struct sc"
            },
            {
              "variable": "assoc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct sctp_association *assoc,\n\t\t\t      sctp_sock"
            },
            {
              "variable": "oldsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);"
            },
            {
              "variable": "newsp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\tstruct sctp_sock *newsp = sctp_sk(newsk);"
            },
            {
              "variable": "pp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct sctp_bind_bucket *pp; /* hash list port"
            },
            {
              "variable": "hash",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p_bind_bucket *pp; /* hash list port iterator"
            },
            {
              "variable": "newep",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct sctp_endpoint *newep = newsp->ep;\n\tstruc"
            },
            {
              "variable": "skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp"
            },
            {
              "variable": "tmp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct sk_buff *skb, *tmp;\n\tstruct sctp_ulpev"
            },
            {
              "variable": "event",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct sctp_ulpevent *event;\n\tint flags = 0;"
            },
            {
              "variable": "Migrate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int flags = 0;\n\n\t/* Migrate socket buffer sizes"
            },
            {
              "variable": "new",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "el options to the\n\t * new socket.\n\t */\n\tnewsk"
            },
            {
              "variable": "Brute",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp"
            },
            {
              "variable": "Restore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t(newsk, oldsk);\n\n\t/* Restore the ep value that w"
            },
            {
              "variable": "copy",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e above structure\n\t * copy.\n\t */\n\tnewsp->ep ="
            },
            {
              "variable": "Hook",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sp->hmac = NULL;\n\n\t/* Hook this new socket in"
            },
            {
              "variable": "Copy",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list"
            },
            {
              "variable": "endpoint",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dpoint to the new\n\t * endpoint so that we can hand"
            },
            {
              "variable": "Move",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_KERNEL, flags);\n\n\t/* Move any messages in the"
            },
            {
              "variable": "peeled",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "that are for the\n\t * peeled off association to"
            },
            {
              "variable": "Clean",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ewsk);\n \t\t}\n \t}\n \n\t/* Clean up any messages pen"
            },
            {
              "variable": "delivery",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ry due to partial\n\t * delivery.   Three cases:\n\t *"
            },
            {
              "variable": "1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y.   Three cases:\n\t * 1) No partial deliver"
            },
            {
              "variable": "2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eliver;  no work.\n\t * 2) Peeling off partia"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "in new pd_lobby.\n\t * 3) Peeling off non-pa"
            },
            {
              "variable": "queue",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct sk_buff_head *queue;\n\n\t\t/* Decide which"
            },
            {
              "variable": "Decide",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ff_head *queue;\n\n\t\t/* Decide which queue to move"
            },
            {
              "variable": "Walk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_receive_queue;\n\n\t\t/* Walk through the pd_lobb"
            },
            {
              "variable": "need",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng for skbs that\n\t\t * need moved to the new so"
            },
            {
              "variable": "Clear",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k);\n \t\t\t}\n \t\t}\n \n\t\t/* Clear up any skbs waiting"
            },
            {
              "variable": "delivery",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for the partial\n\t\t * delivery to finish.\n\t\t */"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skb, newsk);\n\t}\n\n \t/* Set the type of socket"
            },
            {
              "variable": "original",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "led off from the\n \t * original UDP-style socket or"
            },
            {
              "variable": "TCP",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cept() call on a\n \t * TCP-style socket..\n\t */"
            },
            {
              "variable": "Mark",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sp->type = type;\n\n\t/* Mark the new socket \"in-"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "that any packets\n\t * that may arrive on the a"
            },
            {
              "variable": "queued",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e've moved it are\n\t * queued to the backlog.  Th"
            },
            {
              "variable": "backlog",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tial race between\n\t * backlog processing on the o"
            },
            {
              "variable": "on",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "packet processing\n\t * on the new socket.\n\t *"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(assoc, newsk);\n\n\t/* If the association on"
            },
            {
              "variable": "is",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d before accept()\n\t * is called, set RCV_SHU"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 24,
        "pointer_count": 22,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"pp\"]}",
    "vulnerable_variables": [
      "pp"
    ],
    "vulnerable_variable": "pp",
    "variable_definitions": {
      "pp": "struct sctp_bind_bucket *pp; /* hash list port iterator */"
    },
    "variable_types": {
      "pp": "struct pointer"
    },
    "type_mapping": {
      "pp": "struct pointer"
    }
  },
  {
    "idx": 159339,
    "project": "libgsf",
    "commit_id": "95a8351a75758cf10b3bf6abae0b6b461f90d9e5",
    "project_url": "https://github.com/GNOME/libgsf",
    "commit_url": "https://github.com/GNOME/libgsf/commit/95a8351a75758cf10b3bf6abae0b6b461f90d9e5",
    "commit_message": "tar: fix crash on broken tar file.",
    "label": 0,
    "func": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\t/* Find a directory component, if any.  */\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\t/* This is deliberately slash-only.  */\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n\t\t\t\t\t: dir;\n \t\t\t\t/* Undo the ref. */\n \t\t\t\tg_object_unref (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n\n\t\tg_free (dirname);\n\t}\n}\n",
    "func_hash": 244595410542327609021083523879684465103,
    "file_name": "gsf-infile-tar.c",
    "file_hash": 87848459456219215492559613857880462228,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-9888",
    "cve_desc": "An error within the \"tar_directory_for_file()\" function (gsf-infile-tar.c) in GNOME Structured File Library before 1.14.41 can be exploited to trigger a Null pointer dereference and subsequently cause a crash via a crafted TAR file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9888",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "s0",
          "name",
          "s",
          "subdir",
          "dir",
          "dirname"
        ],
        "arrays": [],
        "size_variables": [],
        "all_variables": [
          "s0",
          "name",
          "s",
          "subdir",
          "dir",
          "dirname"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "dir",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_file (GsfInfileTar *dir, const char *name,"
            },
            {
              "variable": "name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ar *dir, const char *name, gboolean last)\n{"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "last)\n{\n\tconst char *s = name;\n\n\twhile (1)"
            },
            {
              "variable": "s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirnam"
            },
            {
              "variable": "dirname",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "har *s0 = s;\n\t\tchar *dirname;\n\n\t\t/* Find a direc"
            },
            {
              "variable": "Find",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char *dirname;\n\n\t\t/* Find a directory compone"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "while (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (las"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn dir;\n\t\t\t}\n\t\t\t/* This is deliberately sla"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sh-only.  */\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;"
            },
            {
              "variable": "subdir",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= 0) {\n\t\t\tGsfInput *subdir =\n \t\t\t\tgsf_infile_c"
            },
            {
              "variable": "Undo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ")\n\t\t\t\t\t: dir;\n \t\t\t\t/* Undo the ref. */\n \t\t\t\tg_"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 6,
        "array_count": 0,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\":[\"dir\"]}",
    "vulnerable_variables": [
      "dir"
    ],
    "vulnerable_variable": "dir",
    "variable_definitions": {
      "dir": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)"
    },
    "variable_types": {
      "dir": "struct pointer"
    },
    "type_mapping": {
      "dir": "struct pointer"
    }
  },
  {
    "idx": 159368,
    "project": "linux",
    "commit_id": "4afa5f9617927453ac04b24b584f6c718dfb4f45",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45",
    "commit_message": "crypto: algif_hash - Only export and import on sockets with data\n\nThe hash_accept call fails to work on sockets that have not received\nany data.  For some algorithm implementations it may cause crashes.\n\nThis patch fixes this by ensuring that we only export and import on\nsockets that have received data.\n\nCc: stable@vger.kernel.org\nReported-by: Harsh Jain <harshjain.prof@gmail.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nTested-by: Stephan Mueller <smueller@chronox.de>",
    "label": 0,
    "func": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n\tbool more;\n \tint err;\n \n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n \tif (err)\n \t\treturn err;\n \n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n \n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}\n",
    "func_hash": 258640263284650473523318248947813699316,
    "file_name": "algif_hash.c",
    "file_hash": 282276849918189682478033728035949755490,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-8646",
    "cve_desc": "The hash_accept function in crypto/algif_hash.c in the Linux kernel before 4.3.6 allows local users to cause a denial of service (OOPS) by attempting to trigger use of in-kernel hash algorithms for a socket that has received zero bytes of data.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-8646",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "sock",
          "newsock",
          "sk2",
          "sk",
          "ctx",
          "ask2",
          "ctx2",
          "ask",
          "req"
        ],
        "arrays": [
          "state"
        ],
        "size_variables": [
          "crypto_ahash_statesize"
        ],
        "all_variables": [
          "sock",
          "newsock",
          "crypto_ahash_statesize",
          "sk2",
          "state",
          "sk",
          "ctx",
          "ask2",
          "ctx2",
          "ask",
          "req"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct sock *sk = sock->sk;\n\tstruct alg_sock *"
            },
            {
              "variable": "ask",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct hash_ctx *ctx = ask->private;\n\tstruct ahash_requ"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ash_request *req = &ctx->req;\n\tchar state[crypto"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k_sock(sk);\n\tmore = ctx->more;\n\terr = more ? cryp"
            },
            {
              "variable": "ask",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "err = af_alg_accept(ask->parent, newsock);\n\tif (err"
            },
            {
              "variable": "newsock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn err;\n\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk"
            },
            {
              "variable": "ask2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = more"
            },
            {
              "variable": "ctx2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more"
            },
            {
              "variable": "ctx2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rypto_ahash_import(&ctx2->req, state);\n \tif (err)"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ccept(struct socket *sock, struct socket *new"
            },
            {
              "variable": "newsock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sock, struct socket *newsock, int flags)\n{\n\tstru"
            },
            {
              "variable": "sk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct"
            },
            {
              "variable": "ask",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstru"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n\tstruct hash_ctx *ctx = ask->private;\n\tst"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct ahash_request *req = &ctx->req;\n\tchar"
            },
            {
              "variable": "sk2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "q))];\n \tstruct sock *sk2;\n \tstruct alg_sock"
            },
            {
              "variable": "ask2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx"
            },
            {
              "variable": "ctx2",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n \tstruct hash_ctx *ctx2;\n\tbool more;\n \tint"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 11,
        "pointer_count": 9,
        "array_count": 1,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\": [\"crypto_ahash_statesize\", \"state\"]}",
    "vulnerable_variables": [
      "crypto_ahash_statesize",
      "state"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "crypto_ahash_statesize": "Definition not found",
      "state": "char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];"
    },
    "variable_types": {
      "crypto_ahash_statesize": "integer",
      "state": "char array"
    },
    "type_mapping": {
      "crypto_ahash_statesize": "Integer",
      "state": "char array"
    }
  },
  {
    "idx": 159629,
    "project": "krb5",
    "commit_id": "93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7",
    "project_url": "https://github.com/krb5/krb5",
    "commit_url": "https://github.com/krb5/krb5/commit/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7",
    "commit_message": "Fix S4U2Self KDC crash when anon is restricted\n\nIn validate_as_request(), when enforcing restrict_anonymous_to_tgt,\nuse client.princ instead of request->client; the latter is NULL when\nvalidating S4U2Self requests.\n\nCVE-2016-3120:\n\nIn MIT krb5 1.9 and later, an authenticated attacker can cause krb5kdc\nto dereference a null pointer if the restrict_anonymous_to_tgt option\nis set to true, by making an S4U2Self request.\n\n  CVSSv2 Vector: AV:N/AC:H/Au:S/C:N/I:N/A:C/E:H/RL:OF/RC:C\n\nticket: 8458 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next",
    "label": 0,
    "func": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n",
    "func_hash": 136032537230883076128435680877393698262,
    "file_name": "kdc_util.c",
    "file_hash": 172188382554751224053848223012620920003,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-3120",
    "cve_desc": "The validate_as_request function in kdc_util.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.13.6 and 1.4.x before 1.14.3, when restrict_anonymous_to_tgt is enabled, uses an incorrect client data structure, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via an S4U2Self request.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3120",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "pwchange",
          "contents",
          "request",
          "KDC_ERR_POLICY",
          "preauthentication",
          "policy",
          "client",
          "data",
          "kdc_active_realm"
        ],
        "arrays": [],
        "size_variables": [],
        "all_variables": [
          "pwchange",
          "contents",
          "request",
          "KDC_ERR_POLICY",
          "preauthentication",
          "policy",
          "client",
          "data",
          "kdc_active_realm"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "in.\n     */\n    if (request->kdc_options & AS_INVALID_OPTION"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POST"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "isflagset(request->kdc_options, KDC_OPT_POSTDATED)"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE)"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ealm, client.princ, request->server) != 0) {\n         *"
            },
            {
              "variable": "kdc_active_realm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "request(kdc_realm_t *kdc_active_realm,"
            },
            {
              "variable": "request",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gister krb5_kdc_req *request, krb5_db_entry clie"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char **status, krb5_pa_data ***e_"
            },
            {
              "variable": "e_data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tus, krb5_pa_data ***e_data)\n{\n    int errcode;"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e ret;\n\n    /*\n     * If an option is set th"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_OPTIONS) {\n        *status = \"INVALID AS OPTIO"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OPTION;\n    }\n\n    /* The client must not be"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kdc_time) {\n        *status = \"CLIENT EXPIRED\";"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "E_EXP);\n    }\n\n    /* The client's password m"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SERVICE)) {\n        *status = \"CLIENT KEY EXPIR"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Y_EXP);\n    }\n\n    /* The server must not be"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kdc_time) {\n        *status = \"SERVICE EXPIRED\""
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * If the client requires"
            },
            {
              "variable": "pwchange",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "only allow the\n     * pwchange service.\n     */"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SERVICE)) {\n        *status = \"REQUIRED PWCHANG"
            },
            {
              "variable": "Client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Y_EXP);\n    }\n\n    /* Client and server must all"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TDATED))) {\n        *status = \"POSTDATE NOT ALL"
            },
            {
              "variable": "A",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * A Windows KDC will re"
            },
            {
              "variable": "KDC_ERR_POLICY",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RED instead of\n     * KDC_ERR_POLICY in the following ca"
            },
            {
              "variable": "policy",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ions but local\n     *     policy has KRB5_KDB_DISALL"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LE set for the\n     *     client, and;\n     *   - KR"
            },
            {
              "variable": "preauthentication",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the client but\n     *     preauthentication data is absent in t"
            },
            {
              "variable": "Hence",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "equest.\n     *\n     * Hence, this check most be"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ck for preauth\n     * data, and is now perform"
            },
            {
              "variable": "contents",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ardable() (the\n     * contents of which were previ"
            },
            {
              "variable": "Client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "low).\n     */\n\n    /* Client and server must all"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "XIABLE))) {\n        *status = \"PROXIABLE NOT AL"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OLICY);\n    }\n\n    /* Check to see if client is"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ALL_TIX)) {\n        *status = \"CLIENT LOCKED OU"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "VOKED);\n    }\n\n    /* Check to see if server is"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ALL_TIX)) {\n        *status = \"SERVICE LOCKED O"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "KNOWN);\n    }\n\n    /* Check to see if server is"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LOW_SVR)) {\n        *status = \"SERVICE NOT ALLO"
            },
            {
              "variable": "status",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r) != 0) {\n         *status = \"ANONYMOUS NOT AL"
            },
            {
              "variable": "Perform",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LICY);\n     }\n\n    /* Perform KDB module policy c"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rotocol(ret);\n\n    /* Check against local polic"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 9,
        "pointer_count": 9,
        "array_count": 0,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\":[\"request\",\"client\"]}",
    "vulnerable_variables": [
      "request",
      "client"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "request": "register krb5_kdc_req *request",
      "client": "krb5_db_entry client"
    },
    "variable_types": {
      "request": "struct pointer",
      "client": "struct"
    },
    "type_mapping": {
      "request": "struct pointer",
      "client": "struct"
    }
  },
  {
    "idx": 159700,
    "project": "linux",
    "commit_id": "951b6a0717db97ce420547222647bcc40bf1eacd",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/951b6a0717db97ce420547222647bcc40bf1eacd",
    "commit_message": "Bluetooth: Fix potential NULL dereference in RFCOMM bind callback\n\naddr can be NULL and it should not be dereferenced before NULL checking.\n\nSigned-off-by: Jaganath Kanakkassery <jaganath.k@samsung.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
    "label": 0,
    "func": " static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n\tstruct sockaddr_rc sa;\n \tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n \n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n \tlock_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n \n \twrite_lock(&rfcomm_sk_list.lock);\n \n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n \t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n \n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
    "func_hash": 12834457401814281506929915896622649045,
    "file_name": "sock.c",
    "file_hash": 331786115828217437231220610191097778667,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2015-8956",
    "cve_desc": "The rfcomm_sock_bind function in net/bluetooth/rfcomm/sock.c in the Linux kernel before 4.2 allows local users to obtain sensitive information or cause a denial of service (NULL pointer dereference) via vectors involving a bind system call on a Bluetooth RFCOMM socket.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8956",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "sock",
          "sk",
          "addr"
        ],
        "arrays": [],
        "size_variables": [
          "addr_len",
          "sizeof",
          "len"
        ],
        "all_variables": [
          "sock",
          "sk",
          "addr",
          "sizeof",
          "addr_len",
          "len"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct sock *sk = sock->sk;\n\tint len, err = 0;"
            },
            {
              "variable": "addr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0;\n \n \tif (!addr || addr->sa_family != AF_BLUETOOTH)"
            },
            {
              "variable": "sk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n\t\terr"
            },
            {
              "variable": "sk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {"
            },
            {
              "variable": "sk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= sa.rc_channel;\n \t\tsk->sk_state = BT_BOUND;\n \t}"
            },
            {
              "variable": "sock",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_bind(struct socket *sock, struct sockaddr *a"
            },
            {
              "variable": "addr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ck, struct sockaddr *addr, int addr_len)\n {"
            },
            {
              "variable": "sk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c sa;\n \tstruct sock *sk = sock->sk;\n\tint le"
            },
            {
              "variable": "Save",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "USE;\n \t} else {\n \t\t/* Save source address */"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 3,
        "array_count": 0,
        "size_variable_count": 3
      }
    },
    "predict": "{\"vulnerable_variables\": [\"sk\"]}",
    "vulnerable_variables": [
      "sk"
    ],
    "vulnerable_variable": "sk",
    "variable_definitions": {
      "sk": "struct sock *sk = sock->sk;"
    },
    "variable_types": {
      "sk": "struct pointer"
    },
    "type_mapping": {
      "sk": "struct pointer"
    }
  },
  {
    "idx": 159842,
    "project": "tcmu-runner",
    "commit_id": "bb80e9c7a798f035768260ebdadffb6eb0786178",
    "project_url": "https://github.com/open-iscsi/tcmu-runner",
    "commit_url": "https://github.com/open-iscsi/tcmu-runner/commit/bb80e9c7a798f035768260ebdadffb6eb0786178",
    "commit_message": "only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS\n\nTrying to unregister an internal handler ended up in a SEGFAULT, because\nthe tcmur_handler->opaque was NULL. Way to reproduce:\n\ndbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow\n\nwe use a newly introduced boolean in struct tcmur_handler for keeping\ntrack of external handlers. As suggested by mikechristie adjusting the\npublic data structure is acceptable.",
    "label": 0,
    "func": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n\telse if (handler->_is_dbus_handler != 1) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n\t\t\t\t      \"cannot unregister internal handler\"));\n\t\treturn TRUE;\n\t}\n\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_dbus_handler(handler);\n\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n",
    "func_hash": 83492717642476912060314368172336178006,
    "file_name": "main.c",
    "file_hash": 201881436655674370591182337987185647182,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-1000200",
    "cve_desc": "tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-1000200",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "handler",
          "subtype",
          "interface",
          "info",
          "invocation"
        ],
        "arrays": [],
        "size_variables": [],
        "all_variables": [
          "handler",
          "subtype",
          "interface",
          "info",
          "invocation"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "handler",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o *info = handler ? handler->opaque : NULL;\n\n\tif (!hand"
            },
            {
              "variable": "handler",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TRUE;\n \t}\n\telse if (handler->_is_dbus_handler != 1) {\n\t\tg_dbus_me"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_bus_unwatch_name(info->watcher_id);\n \tg_free(info);"
            },
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ice1HandlerManager1 *interface,\n\t\t      GDBusMetho"
            },
            {
              "variable": "invocation",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "BusMethodInvocation *invocation,\n\t\t      gchar *sub"
            },
            {
              "variable": "subtype",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tion,\n\t\t      gchar *subtype,\n\t\t      gpointer u"
            },
            {
              "variable": "handler",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct tcmur_handler *handler = find_handler_by_s"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\tstruct dbus_info *info = handler ? handler"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 5,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\": [\"info\"]}",
    "vulnerable_variables": [
      "info"
    ],
    "vulnerable_variable": "info",
    "variable_definitions": {
      "info": "struct dbus_info *info = handler ? handler->opaque : NULL;"
    },
    "variable_types": {
      "info": "struct pointer"
    },
    "type_mapping": {
      "info": "struct pointer"
    }
  },
  {
    "idx": 159855,
    "project": "heimdal",
    "commit_id": "1a6a6e462dc2ac6111f9e02c6852ddec4849b887",
    "project_url": "https://github.com/heimdal/heimdal",
    "commit_url": "https://github.com/heimdal/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887",
    "commit_message": "Security: Avoid NULL structure pointer member dereference\n\nThis can happen in the error path when processing malformed AS\nrequests with a NULL client name.  Bug originally introduced on\nFri Feb 13 09:26:01 2015 +0100 in commit:\n\n    a873e21d7c06f22943a90a41dc733ae76799390d\n\n    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()\n\nOriginal patch by Jeffrey Altman <jaltman@secure-endpoints.com>",
    "label": 0,
    "func": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}\n",
    "func_hash": 297562828868585021097570748636516473983,
    "file_name": "kerberos5.c",
    "file_hash": 84947840765583906481894145492071131751,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-17439",
    "cve_desc": "In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-17439",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "r",
          "fixed_client_name",
          "config",
          "from",
          "from_addr",
          "cname",
          "supported",
          "b",
          "that",
          "armor_crypto",
          "decrypt",
          "as",
          "val",
          "padata",
          "reply",
          "uncomplicated",
          "skey",
          "incapable",
          "msg",
          "pa",
          "sname",
          "validate",
          "the",
          "rtime",
          "ckey",
          "with",
          "sizeof",
          "both",
          "enctype",
          "req"
        ],
        "arrays": [
          "val",
          "pat"
        ],
        "size_variables": [
          "length",
          "size_t",
          "lengths",
          "sizeof",
          "len",
          "max_datagram_reply_length"
        ],
        "all_variables": [
          "r",
          "fixed_client_name",
          "size_t",
          "config",
          "from",
          "from_addr",
          "cname",
          "supported",
          "b",
          "that",
          "armor_crypto",
          "decrypt",
          "as",
          "val",
          "padata",
          "reply",
          "length",
          "uncomplicated",
          "skey",
          "incapable",
          "msg",
          "pa",
          "sname",
          "validate",
          "the",
          "rtime",
          "pat",
          "lengths",
          "ckey",
          "with",
          "sizeof",
          "both",
          "enctype",
          "len",
          "max_datagram_reply_length",
          "req"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "5_context context = r->context;\n    krb5_kdc_confi"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "iguration *config = r->config;\n    KDC_REQ *req ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ut;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_opt"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->req_body;\n    f = b->kdc_options;\n\n    if (f.canonic"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KR"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "er_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm)"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "parse_name(context, r->server_princ, &r->server_name);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", r->server_princ, &r->server_name);\n    }\n    if (ret"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o out;\n    }\n    if(b->cname == NULL){\n\tret = KR"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm)"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    go"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "parse_name(context, r->client_princ, &r->client_name);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", r->client_princ, &r->client_name);\n    }\n    if (ret"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "om %s for %s\",\n\t    r->client_name, from, r->server_na"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">client_name, from, r->server_name);\n\n    /*\n     *"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_a"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s client name: %s\", r->client_name);\n\tret = KRB5KDC_ER"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIEN"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "| flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "parse_name(context, r->client->entry.principal,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "EALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_bod"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->r"
            },
            {
              "variable": "principal",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVE"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gs,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "erver_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->cli"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "on_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->e"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SE,\n\t\t\t  r->client, b->etype.val, b->etype.len,"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ient, b->etype.val, b->etype.len, &r->sessionety"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the session key\",\n\t\tr->client_name, from);\n\tgoto out;"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing\n     */\n\n    if(req->padata){\n\tunsigned int n;"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es(context, config, req->padata);\n\n\t/* Check if pre"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "continue;\n\t    if (r->armor_crypto == NULL && (pat[n]."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- %s\", pat[n].name, r->client_name);\n\t    i = 0;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent ="
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "key, TRUE,\n\t\t\t      r->client, b->etype.val, b->e"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->client, b->etype.val, b->etype.len,"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ient, b->etype.val, b->etype.len, NULL, &ckey);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_keyblock_contents(r->context,  &r->reply_key);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tents(r->context,  &r->reply_key);\n\tret = krb5_copy_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_keyblock_contents(r->context, &ckey->key, &r->re"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntext, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    go"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(co"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uth_status(context, r->clientdb, r->client,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntext, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ss(context, config, r->client, r->client_name,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "config, r->client, r->client_name,\n\t\t\t    r->server,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "client_name,\n\t\t\t    r->server, r->server_name,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntext, config,\n\t\t\t\t r->server, r->server_name,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ig,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &ske"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_anonymous(context, r->client_princ)) {\n\tRealm anon_rea"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ret = copy_Realm(&r->client->entry.principal->r"
            },
            {
              "variable": "principal",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m(&r->client->entry.principal->realm, &rep.crealm);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "palname(&rep.cname, r->client->entry.principal);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ret = copy_Realm(&r->server->entry.principal->r"
            },
            {
              "variable": "principal",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m(&r->server->entry.principal->realm, &rep.ticket.realm)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticket.sname,\n\t\t\t\t  r->server->entry.principal);"
            },
            {
              "variable": "sname",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t.sname.name_type = b->sname->name_type;\n#undef"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pe;\n#undef CNT\n\n    r->et.flags.initial = 1;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "initial = 1;\n    if(r->client->entry.flags.forwar"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lags.forwardable && r->server->entry.flags.forwar"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "flags.forwardable)\n\tr->et.flags.forwardable ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o out;\n    }\n    if(r->client->entry.flags.proxia"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".flags.proxiable && r->server->entry.flags.proxia"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y.flags.proxiable)\n\tr->et.flags.proxiable = f"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o out;\n    }\n    if(r->client->entry.flags.postda"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y.flags.postdate && r->server->entry.flags.postda"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ry.flags.postdate)\n\tr->et.flags.may_postdate"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es(context, config, b->addresses, from_addr)) {\n\t_kd"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "alName(&rep.cname, &r->et.cname);\n    if (ret"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Realm(&rep.crealm, &r->et.crealm);\n    if (re"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ime_t t;\n\t\n\tstart = r->et.authtime = kdc_time"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if(f.postdated && req->req_body.from){\n\t    ALLOC(r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y.from){\n\t    ALLOC(r->et.starttime);\n\t    st"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ime);\n\t    start = *r->et.starttime = *req->r"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*r->et.starttime = *req->req_body.from;\n\t    r->et.fl"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "req_body.from;\n\t    r->et.flags.invalid = 1;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s.invalid = 1;\n\t    r->et.flags.postdated = 1"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "me(&b->till);\n\tt = *b->till;\n\n\t/* be careful no"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "overflowing */\n\n\tif(r->client->entry.max_life)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t + min(t - start, *r->client->entry.max_life);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntry.max_life);\n\tif(r->server->entry.max_life)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t + min(t - start, *r->server->entry.max_life);\n#"
            },
            {
              "variable": "realm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = min(t, start + realm->max_life);\n#endif\n\tr->et.end"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f(f.renewable_ok && r->et.endtime < *b->till)"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& r->et.endtime < *b->till){\n\t    f.renewable"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->r"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "time < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif("
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ill)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if(f.renewable && b->rtime){\n\t    t = *b->rtim"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= MAX_TIME;\n\t    if(r->client->entry.max_renew)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t + min(t - start, *r->client->entry.max_renew);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "max_renew);\n\t    if(r->server->entry.max_renew)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t + min(t - start, *r->server->entry.max_renew);"
            },
            {
              "variable": "realm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".renew_till);\n\t    *r->et.renew_till = t;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "enew_till = t;\n\t    r->et.flags.renewable = 1"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s_anon_request(b))\n\tr->et.flags.anonymous = 1"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.cadd"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostA"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "copy_HostAddresses(b->addresses, r->et.caddr);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "esses(b->addresses, r->et.caddr);\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".caddr);\n    }\n\n    r->et.transited.tr_type ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_data_zero(&r->et.transited.contents)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mmy lr.\n     */\n    r->ek.last_req.val = mall"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "malloc(2 * sizeof(*r->ek.last_req.val));"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_req.val));\n    if (r->ek.last_req.val == NUL"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto out;\n    }\n    r->ek.last_req.len = 0;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eq.len = 0;\n    if (r->client->entry.pw_end\n\t&& ("
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_ti"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|| kdc_time + config->kdc_warn_pwexpire >= *r->client->entr"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_warn_pwexpire >= *r->client->entry.pw_end)) {"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.last_req.val[r->ek.last_req.len].lr_ty"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.last_req.val[r->ek.last_req.len].lr_va"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eq.len].lr_value = *r->client->entry.pw_end;\n\t++r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t->entry.pw_end;\n\t++r->ek.last_req.len;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".len;\n    }\n    if (r->client->entry.valid_end) {"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "entry.valid_end) {\n\tr->ek.last_req.val[r->ek."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.last_req.val[r->ek.last_req.len].lr_ty"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.last_req.val[r->ek.last_req.len].lr_va"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eq.len].lr_value = *r->client->entry.valid_end;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "entry.valid_end;\n\t++r->ek.last_req.len;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".len;\n    }\n    if (r->ek.last_req.len == 0)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st_req.len == 0) {\n\tr->ek.last_req.val[r->ek."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.last_req.val[r->ek.last_req.len].lr_ty"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.last_req.val[r->ek.last_req.len].lr_va"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n].lr_value = 0;\n\t++r->ek.last_req.len;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_req.len;\n    }\n    r->ek.nonce = b->nonce;"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    r->ek.nonce = b->nonce;\n    if (r->client-"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= b->nonce;\n    if (r->client->entry.valid_end ||"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">entry.valid_end || r->client->entry.pw_end) {\n\tA"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\ti"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_expiration);\n\tif (r->client->entry.valid_end) {"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t->entry.pw_end)\n\t\t*r->ek.key_expiration = mi"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_expiration = min(*r->client->entry.valid_end,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_end);\n\t    else\n\t\t*r->ek.key_expiration = *r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k.key_expiration = *r->client->entry.valid_end;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_end;\n\t} else\n\t    *r->ek.key_expiration = *r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k.key_expiration = *r->client->entry.pw_end;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pw_end;\n    } else\n\tr->ek.key_expiration = NU"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "iration = NULL;\n    r->ek.flags = r->et.flags"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    r->ek.flags = r->et.flags;\n    r->ek.au"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= r->et.flags;\n    r->ek.authtime = r->et.au"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.authtime = r->et.authtime;\n    if (r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t.authtime;\n    if (r->et.starttime) {\n\tALLOC"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.starttime);\n\t*r->ek.starttime = *r->et."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*r->ek.starttime = *r->et.starttime;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tarttime;\n    }\n    r->ek.endtime = r->et.end"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.endtime = r->et.endtime;\n    if (r-"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "et.endtime;\n    if (r->et.renew_till) {\n\tALLO"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "enew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->ek.renew_till);\n\t*r->ek.renew_till = *r->et"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.renew_till = *r->et.renew_till;\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&rep.ticket.realm, &r->ek.srealm);\n    if (re"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&rep.ticket.sname, &r->ek.sname);\n    if (ret"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ")\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostA"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "copy_HostAddresses(r->et.caddr, r->ek.caddr)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "resses(r->et.caddr, r->ek.caddr);\n    }"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ys\n     */\n\n    if (r->session_key.keytype == ETYPE_NU"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_keyblock(context, r->sessionetype, &r->session_key);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", r->sessionetype, &r->session_key);\n\tif (ret)\n\t    go"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NU"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "copy_EncryptionKey(&r->session_key, &r->et.key);\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y(&r->session_key, &r->et.key);\n    if (ret)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "copy_EncryptionKey(&r->session_key, &r->ek.key);\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y(&r->session_key, &r->ek.key);\n    if (ret)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep."
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif ("
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", config, \"AS-REQ\", r->et.authtime, r->et.sta"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Q\", r->et.authtime, r->et.starttime,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "starttime,\n\t\t       r->et.endtime, r->et.rene"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->et.endtime, r->et.renew_till);\n\n    /"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "setype,\n\t\t\t\t  r->client->entry.principal,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgot"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eq(context, config, r->reply_key.keytype, setype, b)"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pa-rep\n     */\n\n    r->et.flags.enc_pa_rep ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".flags.enc_pa_rep = r->ek.flags.enc_pa_rep ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "5_get_error_message(r->context, ret);\n\t    _kdc_r_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_free_error_message(r->context, msg);\n\t    goto ou"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ext, config,\n\t\t\t    r->armor_crypto, req->req_body.nonc"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "once,\n\t\t\t    &rep, &r->et, &r->ek, setype, r-"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&rep, &r->et, &r->ek, setype, r->server-"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "et, &r->ek, setype, r->server->entry.kvno,"
            },
            {
              "variable": "skey",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "entry.kvno,\n\t\t\t    &skey->key, r->client->entry.k"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&skey->key, r->client->entry.kvno,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, rep"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&r->reply_key, 0, &r->e_text, reply);\n    if (re"
            },
            {
              "variable": "reply",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(datagram_reply && reply->length > config->max_datag"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free("
            },
            {
              "variable": "reply",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "R_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kd"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_bo"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rmor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_te"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eq_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_pr"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t, r->e_text,\n \t\t\t\t r->server_princ,\n\t\t\t\t r->client_pri"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">server_princ,\n\t\t\t\t r->client_princ ?"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&r->client_princ->name : NULL,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->name : NULL,\n\t\t\t\t r->client_princ ?"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&r->client_princ->realm : NULL,"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "free_EncTicketPart(&r->et);\n    free_EncKDCRe"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "free_EncKDCRepPart(&r->ek);\n    free_KDCFastS"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "free_KDCFastState(&r->fast);\n\n    if (error_me"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "or_method);\n    if (r->outpadata.len)\n\tfree_METHOD_D"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "free_METHOD_DATA(&r->outpadata);\n    if (r->client"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "outpadata);\n    if (r->client_princ) {\n\tkrb5_free_princ"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_principal(context, r->client_princ);\n\tr->client_princ"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->client_princ);\n\tr->client_princ = NULL;\n    }\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lient_name) {\n\tfree(r->client_name);\n\tr->client_name ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(r->client_name);\n\tr->client_name = NULL;\n    }\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_princi"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_principal(context, r->server_princ);\n\tr->server_princ"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->server_princ);\n\tr->server_princ = NULL;\n    }\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "erver_name) {\n\tfree(r->server_name);\n\tr->server_name ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(r->server_name);\n\tr->server_name = NULL;\n    }\n    i"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(con"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_free_ent(context, r->client);\n    if (r->server"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->client);\n    if (r->server)\n\t_kdc_free_ent(con"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_free_ent(context, r->server);\n    if (r->armor_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_des"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "krb5_crypto_destroy(r->context, r->armor_crypto);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "destroy(r->context, r->armor_crypto);\n\tr->armor_crypto"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    k"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_keyblock_contents(r->context, &r->reply_key);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntents(r->context, &r->reply_key);\n    krb5_free_key"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_keyblock_contents(r->context, &r->session_key);"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntents(r->context, &r->session_key);\n    return ret;\n}"
            },
            {
              "variable": "reply",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t r,\n\t    krb5_data *reply,\n\t    const char *f"
            },
            {
              "variable": "from",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ly,\n\t    const char *from,\n\t    struct sockad"
            },
            {
              "variable": "from_addr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct sockaddr *from_addr,\n\t    int datagram_"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "5_kdc_configuration *config = r->config;\n    KD"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "config;\n    KDC_REQ *req = &r->req;\n    KDC_"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "q;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP"
            },
            {
              "variable": "skey",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de ret = 0;\n    Key *skey;\n    int found_pa ="
            },
            {
              "variable": "pa",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    const PA_DATA *pa;\n\n    memset(&rep,"
            },
            {
              "variable": "Look",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NULL;\n\n    /*\n     * Look for FAST armor and"
            },
            {
              "variable": "fixed_client_name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb"
            },
            {
              "variable": "msg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f(ret){\n\tconst char *msg = krb5_get_error_me"
            },
            {
              "variable": "msg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f(ret){\n\tconst char *msg = krb5_get_error_me"
            },
            {
              "variable": "Select",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * Select a session enctype f"
            },
            {
              "variable": "supported",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "crypto system\n     * supported enctypes that is su"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "and is one of\n     * the enctype of the enct"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rbtgt).\n     *\n     * The latter is used as a"
            },
            {
              "variable": "to",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "l KDC support,\n     * to make sure a newer v"
            },
            {
              "variable": "enctype",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rate a session\n     * enctype that an older versi"
            },
            {
              "variable": "decrypt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "me realm can't\n     * decrypt.\n     */\n\n    ret ="
            },
            {
              "variable": "Pre",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * Pre-auth processing"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g, req->padata);\n\n\t/* Check if preauth matching"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto out;\n\t}\n\n\t/*\n\t * If there is a client k"
            },
            {
              "variable": "RFC4120",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * -"
            },
            {
              "variable": "both",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es, then send\n\t     *   both info replies (we se"
            },
            {
              "variable": "enctype",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s about 'new'\n\t     *   enctype types, then only se"
            },
            {
              "variable": "Before",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eply.\n\t     *\n\t     * Before we send the full li"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "data, we pick\n\t     * the client key we would"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ow, just pick\n\t     * that instead.\n\t     */"
            },
            {
              "variable": "send",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oto out;\n\t}\n\n\t/* \n\t * send requre preauth is i"
            },
            {
              "variable": "anon",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "non is requested,\n\t * anon is today only allow"
            },
            {
              "variable": "Verify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * Verify flags after the use"
            },
            {
              "variable": "with",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e its identity\n     * with in a preauth mech."
            },
            {
              "variable": "Select",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o out;\n\n    /*\n     * Select the best encryption"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "out regard to\n     * the client since the cl"
            },
            {
              "variable": "Build",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * Build reply\n     */"
            },
            {
              "variable": "java",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ry.principal);\n    /* java 1.6 expects the nam"
            },
            {
              "variable": "uncomplicated",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ets allow that\n     * uncomplicated name-types. */\n#def"
            },
            {
              "variable": "check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "to out;\n    }\n\n    /* check for valid set of ad"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "time);\n\t    start = *r->et.starttime = *re"
            },
            {
              "variable": "req",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*r->et.starttime = *req->req_body.from;"
            },
            {
              "variable": "XXX",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ime(&b->till);\n\tt = *b->till;\n\n\t/* be care"
            },
            {
              "variable": "be",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\tt = *b->till;\n\n\t/* be careful not overflo"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rt + min(t - start, *r->client->entry.max_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rt + min(t - start, *r->server->entry.max_"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& r->et.endtime < *b->till){\n\t    f.rene"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 0;\n\t    }\n\t    if(*b->rtime < *b->till)"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if(*b->rtime < *b->till)\n\t\t*b->rtime"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rtime < *b->till)\n\t\t*b->rtime = *b->till;"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.ren"
            },
            {
              "variable": "b",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "b->rtime){\n\t    t = *b->rtime;\n\t    if(t ="
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rt + min(t - start, *r->client->entry.max_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rt + min(t - start, *r->server->entry.max_"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t.renew_till);\n\t    *r->et.renew_till = t;"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ed.contents);\n\n    /* The MIT ASN.1 library ("
            },
            {
              "variable": "as",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "engths encoded\n     * as 0 and as 0x80 (mean"
            },
            {
              "variable": "incapable",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t, and is thus\n     * incapable of correctly decodi"
            },
            {
              "variable": "To",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "length.\n     *\n     * To fix this, always se"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ast_req\n     *\n     * If there's a pw_end or"
            },
            {
              "variable": "otherwise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "will use that,\n     * otherwise just a dummy lr."
            },
            {
              "variable": "sizeof",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_req.val = malloc(2 * sizeof(*r->ek.last_req.val"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= malloc(2 * sizeof(*r->ek.last_req.val));"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dc_warn_pwexpire >= *r->client->entry.pw_e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "req.len].lr_value = *r->client->entry.pw_e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "req.len].lr_value = *r->client->entry.vali"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt->entry.pw_end)\n\t\t*r->ek.key_expiration"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ey_expiration = min(*r->client->entry.vali"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "w_end);\n\t    else\n\t\t*r->ek.key_expiration"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ek.key_expiration = *r->client->entry.vali"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d_end;\n\t} else\n\t    *r->ek.key_expiration"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ek.key_expiration = *r->client->entry.pw_e"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(r->ek.starttime);\n\t*r->ek.starttime = *r-"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*r->ek.starttime = *r->et.starttime;"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r->ek.renew_till);\n\t*r->ek.renew_till = *r"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*r->ek.renew_till = *r->et.renew_till;"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * Check and session and rep"
            },
            {
              "variable": "Add",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "to out;\n    }\n\n    /* Add the PAC */\n    if ("
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".renew_till);\n\n    /* do this as the last th"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e, b);\n\n    /*\n     * We always say we suppo"
            },
            {
              "variable": "Add",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if c"
            },
            {
              "variable": "msg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") {\n\t    const char *msg = krb5_get_error_me"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o out;\n\n    /*\n     * Check if message too larg"
            },
            {
              "variable": "In",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ep);\n\n     /*\n      * In case of a non proxy"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "izeof(pat) / sizeof(pat[0]); n++) {\n\t    if (p"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "]); n++) {\n\t    if (pat[n].validate == NULL)"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_crypto == NULL && (pat[n].flags & PA_REQ_FAST"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "%s pa-data -- %s\", pat[n].name, r->client_nam"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ind_padata(req, &i, pat[n].type);\n\t    if (pa)"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (pa) {\n\t\tret = pat[n].validate(r, pa);"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ucceeded -- %s\",\n\t\t\tpat[n].name, r->client_nam"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "izeof(pat) / sizeof(pat[0]); n++) {\n\t    if (("
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE"
            },
            {
              "variable": "pat",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "error_method,\n\t\t\t\t  pat[n].type, NULL, 0);"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 36,
        "pointer_count": 30,
        "array_count": 2,
        "size_variable_count": 6
      }
    },
    "predict": "{\"vulnerable_variables\":[\"cname\"]}",
    "vulnerable_variables": [
      "cname"
    ],
    "vulnerable_variable": "cname",
    "variable_definitions": {
      "cname": "Definition not found"
    },
    "variable_types": {
      "cname": "struct pointer_struct pointer"
    },
    "type_mapping": {
      "cname": "sp_sp"
    }
  },
  {
    "idx": 159904,
    "project": "linux",
    "commit_id": "ac64115a66c18c01745bbd3c47a36b124e5fd8c0",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0",
    "commit_message": "KVM: PPC: Fix oops when checking KVM_CAP_PPC_HTM\n\nThe following program causes a kernel oops:\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <linux/kvm.h>\n\nmain()\n{\n    int fd = open(\"/dev/kvm\", O_RDWR);\n    ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_PPC_HTM);\n}\n\nThis happens because when using the global KVM fd with\nKVM_CHECK_EXTENSION, kvm_vm_ioctl_check_extension() gets\ncalled with a NULL kvm argument, which gets dereferenced\nin is_kvmppc_hv_enabled(). Spotted while reading the code.\n\nLet's use the hv_enabled fallback variable, like everywhere\nelse in this function.\n\nFixes: 23528bb21ee2 (\"KVM: PPC: Introduce KVM_CAP_PPC_HTM\")\nCc: stable@vger.kernel.org # v4.7+\nSigned-off-by: Greg Kurz <groug@kaod.org>\nReviewed-by: David Gibson <david@gibson.dropbear.id.au>\nReviewed-by: Thomas Huth <thuth@redhat.com>\nSigned-off-by: Paul Mackerras <paulus@ozlabs.org>",
    "label": 0,
    "func": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n \t\tbreak;\n #endif\n \tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n \t\tbreak;\n \tdefault:\n \t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n",
    "func_hash": 283547472272319669235050845927855853852,
    "file_name": "powerpc.c",
    "file_hash": 54352689664727623703019890194307994327,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-15306",
    "cve_desc": "The kvm_vm_ioctl_check_extension function in arch/powerpc/kvm/powerpc.c in the Linux kernel before 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) via a KVM_CHECK_EXTENSION KVM_CAP_PPC_HTM ioctl call to /dev/kvm.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15306",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "kvm",
          "that",
          "return",
          "will",
          "implementations"
        ],
        "arrays": [],
        "size_variables": [
          "num_present_cpus",
          "num_online_cpus",
          "count",
          "KVM_CAP_SPAPR_RESIZE_HPT",
          "number"
        ],
        "all_variables": [
          "num_present_cpus",
          "num_online_cpus",
          "count",
          "kvm",
          "that",
          "return",
          "will",
          "implementations",
          "KVM_CAP_SPAPR_RESIZE_HPT",
          "number"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "kvm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)"
            },
            {
              "variable": "kvm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\te"
            },
            {
              "variable": "kvm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else"
            },
            {
              "variable": "kvm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xtension(struct kvm *kvm, long ext)\n{\n\tint r"
            },
            {
              "variable": "Assume",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng ext)\n{\n\tint r;\n\t/* Assume we're using HV mode"
            },
            {
              "variable": "Hooray",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng on. Depend on\n\t\t * that rather than the gue"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "P_SW_TLB:\n#endif\n\t\t/* We support this only f"
            },
            {
              "variable": "fallthrough",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "AP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SP"
            },
            {
              "variable": "CONFIG_PPC_BOOK3S_64",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KV"
            },
            {
              "variable": "P9",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells,"
            },
            {
              "variable": "Recommending",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "P_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is"
            },
            {
              "variable": "will",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "HV (since a host\n\t\t * will have secondary thre"
            },
            {
              "variable": "implementations",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nd for other KVM\n\t\t * implementations just count online C"
            },
            {
              "variable": "Disable",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 unti"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 10,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 5
      }
    },
    "predict": "{\"vulnerable_variables\": [\"kvm\"]}",
    "vulnerable_variables": [
      "kvm"
    ],
    "vulnerable_variable": "kvm",
    "variable_definitions": {
      "kvm": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)"
    },
    "variable_types": {
      "kvm": "struct pointer"
    },
    "type_mapping": {
      "kvm": "struct pointer"
    }
  },
  {
    "idx": 159912,
    "project": "linux",
    "commit_id": "94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6",
    "commit_message": "crypto: rng - Remove old low-level rng interface\n\nNow that all rng implementations have switched over to the new\ninterface, we can remove the old low-level interface.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
    "label": 0,
    "func": " int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n \t\tseed = buf;\n \t}\n \n\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n}\n",
    "func_hash": 219672799958391934099788105944191157779,
    "file_name": "rng.c",
    "file_hash": 298812781419508468910995942614400844512,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-15116",
    "cve_desc": "The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15116",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "tfm",
          "buf",
          "seed"
        ],
        "arrays": [],
        "size_variables": [
          "slen"
        ],
        "all_variables": [
          "tfm",
          "buf",
          "seed",
          "slen"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "tfm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t(struct crypto_rng *tfm, const u8 *seed, un"
            },
            {
              "variable": "seed",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_rng *tfm, const u8 *seed, unsigned int slen)"
            },
            {
              "variable": "buf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d int slen)\n {\n \tu8 *buf = NULL;\n\tint err;"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 4,
        "pointer_count": 3,
        "array_count": 0,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\": [\"seed\", \"slen\"]}",
    "vulnerable_variables": [
      "seed",
      "slen"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "seed": "const u8 *seed",
      "slen": "unsigned int slen"
    },
    "variable_types": {
      "seed": "integer pointer",
      "slen": "integer"
    },
    "type_mapping": {
      "seed": "integer pointer",
      "slen": "Integer"
    }
  },
  {
    "idx": 159917,
    "project": "linux",
    "commit_id": "2fae9e5a7babada041e2e161699ade2447a01989",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2fae9e5a7babada041e2e161699ade2447a01989",
    "commit_message": "usb: misc: legousbtower: Fix NULL pointer deference\n\nThis patch fixes a NULL pointer dereference caused by a race codition in\nthe probe function of the legousbtower driver. It re-structures the\nprobe function to only register the interface after successfully reading\nthe board's firmware ID.\n\nThe probe function does not deregister the usb interface after an error\nreceiving the devices firmware ID. The device file registered\n(/dev/usb/legousbtower%d) may be read/written globally before the probe\nfunction returns. When tower_delete is called in the probe function\n(after an r/w has been initiated), core dev structures are deleted while\nthe file operation functions are still running. If the 0 address is\nmappable on the machine, this vulnerability can be used to create a\nLocal Priviege Escalation exploit via a write-what-where condition by\nremapping dev->interrupt_out_buffer in tower_write. A forged USB device\nand local program execution would be required for LPE. The USB device\nwould have to delay the control message in tower_probe and accept\nthe control urb in tower_open whilst guest code initiated a write to the\ndevice file as tower_delete is called from the error in tower_probe.\n\nThis bug has existed since 2003. Patch tested by emulated device.\n\nReported-by: James Patrick-Evans <james@jmp-e.com>\nTested-by: James Patrick-Evans <james@jmp-e.com>\nSigned-off-by: James Patrick-Evans <james@jmp-e.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "label": 0,
    "func": "static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct device *idev = &interface->dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct lego_usb_tower *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor* endpoint;\n\tstruct tower_get_version_reply get_version_reply;\n\tint i;\n\tint retval = -ENOMEM;\n\tint result;\n\n\t/* allocate memory for our device state and initialize it */\n\n\tdev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\n\n\tif (!dev)\n\t\tgoto exit;\n\n\tmutex_init(&dev->lock);\n\n\tdev->udev = udev;\n\tdev->open_count = 0;\n\n\tdev->read_buffer = NULL;\n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tspin_lock_init (&dev->read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\n\tinit_waitqueue_head (&dev->read_wait);\n\tinit_waitqueue_head (&dev->write_wait);\n\n\tdev->interrupt_in_buffer = NULL;\n\tdev->interrupt_in_endpoint = NULL;\n\tdev->interrupt_in_urb = NULL;\n\tdev->interrupt_in_running = 0;\n\tdev->interrupt_in_done = 0;\n\n\tdev->interrupt_out_buffer = NULL;\n\tdev->interrupt_out_endpoint = NULL;\n\tdev->interrupt_out_urb = NULL;\n\tdev->interrupt_out_busy = 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (usb_endpoint_dir_in(endpoint))\n\t\t\t\tdev->interrupt_in_endpoint = endpoint;\n\t\t\telse\n\t\t\t\tdev->interrupt_out_endpoint = endpoint;\n\t\t}\n\t}\n\tif(dev->interrupt_in_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt in endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\tdev_err(idev, \"interrupt out endpoint not found\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n \tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n \t/* get the firmware version and log it */\n \tresult = usb_control_msg (udev,\n \t\t\t\t  usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  LEGO_USB_TOWER_REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &get_version_reply,\n\t\t\t\t  sizeof(get_version_reply),\n\t\t\t\t  1000);\n\tif (result < 0) {\n\t\tdev_err(idev, \"LEGO USB Tower get version control request failed\\n\");\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\tdev_info(&interface->dev, \"LEGO USB Tower firmware version is %d.%d \"\n\t\t \"build %d\\n\", get_version_reply.major,\n \t\t get_version_reply.minor,\n \t\t le16_to_cpu(get_version_reply.build_no));\n \n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata (interface, dev);\n\n\tretval = usb_register_dev (interface, &tower_class);\n\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata (interface, NULL);\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;\n\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n\t\t USB_MAJOR, dev->minor);\n \n exit:\n \treturn retval;\n\nerror:\n\ttower_delete(dev);\n\treturn retval;\n}\n",
    "func_hash": 326809293201765126874388168732705316612,
    "file_name": "legousbtower.c",
    "file_hash": 340134827935846703952692589344655463350,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-15102",
    "cve_desc": "The tower_probe function in drivers/usb/misc/legousbtower.c in the Linux kernel before 4.8.1 allows local users (who are physically proximate for inserting a crafted USB device) to gain privileges by leveraging a write-what-where condition that occurs after a race condition and a NULL pointer dereference.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15102",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "interrupt_in_endpoint",
          "iface_desc",
          "id",
          "udev",
          "idev",
          "endpoint",
          "interrupt_out_endpoint",
          "dev",
          "interface"
        ],
        "arrays": [
          "endpoint"
        ],
        "size_variables": [
          "read_buffer_length",
          "write_buffer_size",
          "bNumEndpoints",
          "sizeof",
          "open_count",
          "read_buffer_size",
          "read_packet_length"
        ],
        "all_variables": [
          "read_buffer_length",
          "interrupt_in_endpoint",
          "iface_desc",
          "id",
          "udev",
          "idev",
          "write_buffer_size",
          "endpoint",
          "bNumEndpoints",
          "interrupt_out_endpoint",
          "sizeof",
          "dev",
          "interface",
          "open_count",
          "read_buffer_size",
          "read_packet_length"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct device *idev = &interface->dev;\n\tstruct usb_device"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "exit;\n\n\tmutex_init(&dev->lock);\n\n\tdev->udev = ude"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "init(&dev->lock);\n\n\tdev->udev = udev;\n\tdev->open_"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dev->udev = udev;\n\tdev->open_count = 0;\n\n\tdev->read_bu"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->open_count = 0;\n\n\tdev->read_buffer = NULL;\n\tdev->read_"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ead_buffer = NULL;\n\tdev->read_buffer_length = 0;\n\tdev->read_pac"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tspin_lock_ini"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\tspin_lock_init (&dev->read_buffer_lock);\n\tdev->packet_time"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies("
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\n\tinit_w"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "it_waitqueue_head (&dev->read_wait);\n\tinit_waitqueue_h"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "it_waitqueue_head (&dev->write_wait);\n\n\tdev->interrupt_"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dev->write_wait);\n\n\tdev->interrupt_in_buffer = NULL;\n\tdev->inter"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_in_buffer = NULL;\n\tdev->interrupt_in_endpoint = NULL;\n\tdev->inter"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n_endpoint = NULL;\n\tdev->interrupt_in_urb = NULL;\n\tdev->inter"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "upt_in_urb = NULL;\n\tdev->interrupt_in_running = 0;\n\tdev->interrup"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pt_in_running = 0;\n\tdev->interrupt_in_done = 0;\n\n\tdev->interru"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rupt_in_done = 0;\n\n\tdev->interrupt_out_buffer = NULL;\n\tdev->inter"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "out_buffer = NULL;\n\tdev->interrupt_out_endpoint = NULL;\n\tdev->inter"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_endpoint = NULL;\n\tdev->interrupt_out_urb = NULL;\n\tdev->inter"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pt_out_urb = NULL;\n\tdev->interrupt_out_busy = 0;\n\n\tiface_desc ="
            },
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\t/* set up the en"
            },
            {
              "variable": "iface_desc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i)"
            },
            {
              "variable": "iface_desc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r_in(endpoint))\n\t\t\t\tdev->interrupt_in_endpoint = endpoint;\n\t\t\telse"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dpoint;\n\t\t\telse\n\t\t\t\tdev->interrupt_out_endpoint = endpoint;\n\t\t}\n\t}"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ndpoint;\n\t\t}\n\t}\n\tif(dev->interrupt_in_endpoint == NULL) {\n\t\tdev_er"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto error;\n\t}\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\tdev_er"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto error;\n\t}\n\n\tdev->read_buffer = kmalloc (read_buf"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc (usb_endp"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0,"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc (write_bu"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0,"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n \tde"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rb)\n\t\tgoto error;\n \tdev->interrupt_in_interval = interrupt_in_inte"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "point->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_int"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n \t/*"
            },
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rror;\n\t}\n\tdev_info(&interface->dev, \"LEGO USB Tower fi"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;"
            },
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r;\n\t}\n\tdev->minor = interface->minor;\n\n\t/* let the user"
            },
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ed to */\n\tdev_info(&interface->dev, \"LEGO USB Tower #%"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MI"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ASE),\n\t\t USB_MAJOR, dev->minor);\n \n exit:\n \treturn"
            },
            {
              "variable": "interface",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct usb_interface *interface, const struct usb_d"
            },
            {
              "variable": "id",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct usb_device_id *id)\n{\n\tstruct device *"
            },
            {
              "variable": "idev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d)\n{\n\tstruct device *idev = &interface->dev;"
            },
            {
              "variable": "udev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct usb_device *udev = interface_to_usbd"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ruct lego_usb_tower *dev = NULL;\n\tstruct usb"
            },
            {
              "variable": "iface_desc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "usb_host_interface *iface_desc;\n\tstruct usb_endpoi"
            },
            {
              "variable": "endpoint",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_endpoint_descriptor* endpoint;\n\tstruct tower_get_"
            },
            {
              "variable": "allocate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "EM;\n\tint result;\n\n\t/* allocate memory for our devi"
            },
            {
              "variable": "set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">cur_altsetting;\n\n\t/* set up the endpoint inf"
            },
            {
              "variable": "get",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt->bInterval;\n \n \t/* get the firmware versio"
            },
            {
              "variable": "we",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ply.build_no));\n \n\t/* we can register the de"
            },
            {
              "variable": "something",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (retval) {\n\t\t/* something prevented us from r"
            },
            {
              "variable": "let",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nterface->minor;\n\n\t/* let the user know what"
            },
            {
              "variable": "endpoint",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "oint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_en"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 16,
        "pointer_count": 9,
        "array_count": 1,
        "size_variable_count": 7
      }
    },
    "predict": "{\"vulnerable_variables\":[\"bNumEndpoints\",\"endpoint\",\"interrupt_in_endpoint\",\"interrupt_out_endpoint\"]}",
    "vulnerable_variables": [
      "bNumEndpoints",
      "endpoint",
      "interrupt_in_endpoint",
      "interrupt_out_endpoint"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "bNumEndpoints": "Definition not found",
      "endpoint": "struct usb_endpoint_descriptor* endpoint;",
      "interrupt_in_endpoint": "Definition not found",
      "interrupt_out_endpoint": "Definition not found"
    },
    "variable_types": {
      "bNumEndpoints": "struct.integer",
      "endpoint": "struct pointer",
      "interrupt_in_endpoint": "struct pointer_struct pointer",
      "interrupt_out_endpoint": "struct pointer_struct pointer"
    },
    "type_mapping": {
      "bNumEndpoints": "st.i",
      "endpoint": "struct pointer",
      "interrupt_in_endpoint": "sp_sp",
      "interrupt_out_endpoint": "sp_sp"
    }
  },
  {
    "idx": 159956,
    "project": "linux",
    "commit_id": "bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205",
    "commit_message": "net: check and errout if res->fi is NULL when RTM_F_FIB_MATCH is set\n\nSyzkaller hit 'general protection fault in fib_dump_info' bug on\ncommit 4.13-rc5..\n\nGuilty file: net/ipv4/fib_semantics.c\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 0 PID: 2808 Comm: syz-executor0 Not tainted 4.13.0-rc5 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nUbuntu-1.8.2-1ubuntu1 04/01/2014\ntask: ffff880078562700 task.stack: ffff880078110000\nRIP: 0010:fib_dump_info+0x388/0x1170 net/ipv4/fib_semantics.c:1314\nRSP: 0018:ffff880078117010 EFLAGS: 00010206\nRAX: dffffc0000000000 RBX: 00000000000000fe RCX: 0000000000000002\nRDX: 0000000000000006 RSI: ffff880078117084 RDI: 0000000000000030\nRBP: ffff880078117268 R08: 000000000000000c R09: ffff8800780d80c8\nR10: 0000000058d629b4 R11: 0000000067fce681 R12: 0000000000000000\nR13: ffff8800784bd540 R14: ffff8800780d80b5 R15: ffff8800780d80a4\nFS:  00000000022fa940(0000) GS:ffff88007fc00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000004387d0 CR3: 0000000079135000 CR4: 00000000000006f0\nCall Trace:\n  inet_rtm_getroute+0xc89/0x1f50 net/ipv4/route.c:2766\n  rtnetlink_rcv_msg+0x288/0x680 net/core/rtnetlink.c:4217\n  netlink_rcv_skb+0x340/0x470 net/netlink/af_netlink.c:2397\n  rtnetlink_rcv+0x28/0x30 net/core/rtnetlink.c:4223\n  netlink_unicast_kernel net/netlink/af_netlink.c:1265 [inline]\n  netlink_unicast+0x4c4/0x6e0 net/netlink/af_netlink.c:1291\n  netlink_sendmsg+0x8c4/0xca0 net/netlink/af_netlink.c:1854\n  sock_sendmsg_nosec net/socket.c:633 [inline]\n  sock_sendmsg+0xca/0x110 net/socket.c:643\n  ___sys_sendmsg+0x779/0x8d0 net/socket.c:2035\n  __sys_sendmsg+0xd1/0x170 net/socket.c:2069\n  SYSC_sendmsg net/socket.c:2080 [inline]\n  SyS_sendmsg+0x2d/0x50 net/socket.c:2076\n  entry_SYSCALL_64_fastpath+0x1a/0xa5\n  RIP: 0033:0x4512e9\n  RSP: 002b:00007ffc75584cc8 EFLAGS: 00000216 ORIG_RAX:\n  000000000000002e\n  RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00000000004512e9\n  RDX: 0000000000000000 RSI: 0000000020f2cfc8 RDI: 0000000000000003\n  RBP: 000000000000000e R08: 0000000000000000 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000000216 R12: fffffffffffffffe\n  R13: 0000000000718000 R14: 0000000020c44ff0 R15: 0000000000000000\n  Code: 00 0f b6 8d ec fd ff ff 48 8b 85 f0 fd ff ff 88 48 17 48 8b 45\n  28 48 8d 78 30 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03\n  <0f>\n  b6 04 02 84 c0 74 08 3c 03 0f 8e cb 0c 00 00 48 8b 45 28 44\n  RIP: fib_dump_info+0x388/0x1170 net/ipv4/fib_semantics.c:1314 RSP:\n  ffff880078117010\n---[ end trace 254a7af28348f88b ]---\n\nThis patch adds a res->fi NULL check.\n\nexample run:\n$ip route get 0.0.0.0 iif virt1-0\nbroadcast 0.0.0.0 dev lo\n    cache <local,brd> iif virt1-0\n\n$ip route get 0.0.0.0 iif virt1-0 fibmatch\nRTNETLINK answers: No route to host\n\nReported-by: idaifish <idaifish@gmail.com>\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nFixes: b61798130f1b (\"net: ipv4: RTM_GETROUTE: return matched fib result when requested\")\nSigned-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "label": 0,
    "func": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tif (!res.fi) {\n\t\t\terr = fib_props[res.type].error;\n\t\t\tif (!err)\n\t\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto errout_free;\n\t\t}\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\t} else {\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n \tif (err < 0)\n \t\tgoto errout_free;\n \n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}\n",
    "func_hash": 140101208040104087448849519275682114368,
    "file_name": "route.c",
    "file_hash": 109183270291583298862063483346249234436,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-13686",
    "cve_desc": "net/ipv4/route.c in the Linux kernel 4.13-rc1 through 4.13-rc6 is too late to check for a NULL fi field when RTM_F_FIB_MATCH is set, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via crafted system calls. NOTE: this does not affect any stable release.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-13686",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "in_skb",
          "skb",
          "rtm",
          "nlh",
          "not",
          "tb",
          "dev",
          "extack",
          "rt",
          "net"
        ],
        "arrays": [
          "tb",
          "fib_props"
        ],
        "size_variables": [
          "prefixlen",
          "sizeof",
          "NLMSG_GOODSIZE"
        ],
        "all_variables": [
          "in_skb",
          "skb",
          "rtm",
          "NLMSG_GOODSIZE",
          "nlh",
          "not",
          "prefixlen",
          "tb",
          "dev",
          "sizeof",
          "fib_props",
          "extack",
          "rt",
          "net"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "in_skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rt"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif ="
            },
            {
              "variable": "skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);"
            },
            {
              "variable": "skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark"
            },
            {
              "variable": "skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st.error)\n\t\t\terr = -rt->dst.error;\n\t} else {"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tg"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\tr"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RTCF_NOTIFY;\n\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABL"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ABLE)\n \t\ttable_id = rt->rt_table_id;\n \n\tif (rtm->rtm_fl"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rt_table_id;\n \n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)"
            },
            {
              "variable": "nlh",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "b).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, tabl"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.pr"
            },
            {
              "variable": "nlh",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n \tif (err < 0)"
            },
            {
              "variable": "in_skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oute(struct sk_buff *in_skb, struct nlmsghdr *n"
            },
            {
              "variable": "nlh",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kb, struct nlmsghdr *nlh,\n\t\t\t     struct net"
            },
            {
              "variable": "extack",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct netlink_ext_ack *extack)\n{\n\tstruct net *net"
            },
            {
              "variable": "net",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tack)\n{\n\tstruct net *net = sock_net(in_skb->"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb"
            },
            {
              "variable": "tb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct"
            },
            {
              "variable": "rt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{};\n\tstruct rtable *rt = NULL;\n\tstruct flo"
            },
            {
              "variable": "skb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rk;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT"
            },
            {
              "variable": "rtm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_"
            },
            {
              "variable": "Reserve",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto errout;\n\t}\n\n\t/* Reserve room for dummy head"
            },
            {
              "variable": "Bugfix",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "current_uid());\n\n\t/* Bugfix: need to give ip_ro"
            },
            {
              "variable": "not",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f an IP header to\n\t * not gag.\n\t */\n\tip_hdr(s"
            },
            {
              "variable": "dev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct net_device *dev;\n\n\t\tdev = dev_get_b"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "eader(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(t"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "A_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(t"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "A_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RT"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RT"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RT"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_U"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "TA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid("
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "r_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (i"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RT"
            },
            {
              "variable": "tb",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_m"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 14,
        "pointer_count": 10,
        "array_count": 2,
        "size_variable_count": 3
      }
    },
    "predict": "{\"vulnerable_variables\": [\"rtm\"]}",
    "vulnerable_variables": [
      "rtm"
    ],
    "vulnerable_variable": "rtm",
    "variable_definitions": {
      "rtm": "struct rtmsg *rtm;"
    },
    "variable_types": {
      "rtm": "struct pointer"
    },
    "type_mapping": {
      "rtm": "struct pointer"
    }
  },
  {
    "idx": 160058,
    "project": "linux",
    "commit_id": "ea6789980fdaa610d7eb63602c746bf6ec70cd2b",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea6789980fdaa610d7eb63602c746bf6ec70cd2b",
    "commit_message": "assoc_array: Fix a buggy node-splitting case\n\nThis fixes CVE-2017-12193.\n\nFix a case in the assoc_array implementation in which a new leaf is\nadded that needs to go into a node that happens to be full, where the\nexisting leaves in that node cluster together at that level to the\nexclusion of new leaf.\n\nWhat needs to happen is that the existing leaves get moved out to a new\nnode, N1, at level + 1 and the existing node needs replacing with one,\nN0, that has pointers to the new leaf and to N1.\n\nThe code that tries to do this gets this wrong in two ways:\n\n (1) The pointer that should've pointed from N0 to N1 is set to point\n     recursively to N0 instead.\n\n (2) The backpointer from N0 needs to be set correctly in the case N0 is\n     either the root node or reached through a shortcut.\n\nFix this by removing this path and using the split_node path instead,\nwhich achieves the same end, but in a more general way (thanks to Eric\nBiggers for spotting the redundancy).\n\nThe problem manifests itself as:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n  IP: assoc_array_apply_edit+0x59/0xe5\n\nFixes: 3cb989501c26 (\"Add a generic associative array implementation.\")\nReported-and-tested-by: WU Fan <u3536072@connect.hku.hk>\nSigned-off-by: David Howells <dhowells@redhat.com>\nCc: stable@vger.kernel.org [v3.13-rc1+]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "label": 0,
    "func": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n \t\t\tgoto all_leaves_cluster_together;\n \n\t\t/* Otherwise all the old leaves cluster in the same slot, but\n\t\t * the new leaf wants to go into a different slot - so we\n\t\t * create a new node (n0) to hold the new leaf and a pointer to\n\t\t * a new node (n1) holding all the old leaves.\n\t\t *\n\t\t * This can be done by falling through to the node splitting\n\t\t * path.\n \t\t */\n\t\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n \t}\n \n split_node:\n \tpr_devel(\"split node\\n\");\n \n\t/* We need to split the current node.  The node must contain anything\n\t * from a single leaf (in the one leaf case, this leaf will cluster\n\t * with the new leaf) and the rest meta-pointers, to all leaves, some\n\t * of which may cluster.\n\t *\n\t * It won't contain the case in which all the current leaves plus the\n\t * new leaves want to cluster in the same slot.\n \t *\n \t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.  The current meta pointers can\n\t * just be copied as they shouldn't cluster with any of the leaves.\n \t *\n \t * We need a new node (n0) to replace the current one and a new node to\n \t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n \tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n \treturn true;\n \n all_leaves_cluster_together:\n \t/* All the leaves, new and old, want to cluster together in this node\n \t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}\n",
    "func_hash": 81118548884591777093981057333740287417,
    "file_name": "assoc_array.c",
    "file_hash": 22003643060369242779877648252755300563,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-12193",
    "cve_desc": "The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.13.11 mishandles node splitting, which allows local users to cause a denial of service (NULL pointer dereference and panic) via a crafted application, as demonstrated by the keyring key type, and key addition and link creation operations.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-12193",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "result",
          "nodes",
          "distribute",
          "from",
          "index_key",
          "to",
          "any",
          "would",
          "leaf",
          "pointer",
          "that",
          "those",
          "new",
          "ops",
          "shortcut",
          "needs",
          "path",
          "take",
          "edit",
          "it",
          "in",
          "bit",
          "create",
          "ptr",
          "remaining",
          "a",
          "of",
          "the",
          "skip",
          "behind",
          "them",
          "when",
          "just",
          "ASSOC_ARRAY_KEY_CHUNK_SIZE",
          "with",
          "sizeof",
          "node",
          "leaves",
          "need",
          "want"
        ],
        "arrays": [
          "set_backpointers",
          "x",
          "set",
          "d",
          "ok",
          "excised_meta",
          "segment_cache",
          "index_key",
          "off",
          "slots",
          "new_meta"
        ],
        "size_variables": [
          "size_t",
          "keylen",
          "ASSOC_ARRAY_KEY_CHUNK_SIZE",
          "adjust_count_on",
          "sizeof"
        ],
        "all_variables": [
          "result",
          "nodes",
          "distribute",
          "size_t",
          "from",
          "adjust_count_on",
          "index_key",
          "off",
          "to",
          "any",
          "would",
          "leaf",
          "pointer",
          "that",
          "d",
          "ok",
          "excised_meta",
          "those",
          "new",
          "ops",
          "shortcut",
          "needs",
          "set_backpointers",
          "x",
          "set",
          "path",
          "take",
          "edit",
          "it",
          "in",
          "bit",
          "create",
          "ptr",
          "remaining",
          "slots",
          "a",
          "of",
          "new_meta",
          "the",
          "skip",
          "behind",
          "them",
          "when",
          "just",
          "keylen",
          "ASSOC_ARRAY_KEY_CHUNK_SIZE",
          "with",
          "sizeof",
          "node",
          "segment_cache",
          "leaves",
          "need",
          "want"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "result",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= resu"
            },
            {
              "variable": "result",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segme"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT"
            },
            {
              "variable": "result",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "edit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_l"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "edit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<-"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit-"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel("
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_no"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_no"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_arr"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Y_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASS"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ty = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "them.\n\t\t */\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointe"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_sl"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ode->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "w_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_poin"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to ca"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_o"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "T + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgo"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "C_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metada"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slo"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i]"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "new_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON("
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tne"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ts[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "continue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tne"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "he[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_l"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL)"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_dev"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL)"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[fr"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit-"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[ne"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedi"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "N_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tpt"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "== 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_po"
            },
            {
              "variable": "side",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tsh"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->bac"
            },
            {
              "variable": "shortcut",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit-"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "inter;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->arr"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "edit->set[0].ptr = &edit->array->root;\n\telse if (as"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_arr"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_arr"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_no"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "T; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_k"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_sh"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointe"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_sl"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ode->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "w_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_short"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to ca"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~A"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_ke"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSO"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~bla"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = op"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ts[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Y_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASS"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "AY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT"
            },
            {
              "variable": "edit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct assoc_array_edit *edit,\n\t\t\t\t\t\t  const stru"
            },
            {
              "variable": "ops",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void"
            },
            {
              "variable": "index_key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const void *index_key,\n\t\t\t\t\t\t  struct ass"
            },
            {
              "variable": "result",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_array_walk_result *result)\n{\n\tstruct assoc_ar"
            },
            {
              "variable": "shortcut",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ssoc_array_shortcut *shortcut, *new_s0;\n\tstruct a"
            },
            {
              "variable": "new_s0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "shortcut *shortcut, *new_s0;\n\tstruct assoc_arra"
            },
            {
              "variable": "node",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct assoc_array_node *node, *new_n0, *new_n1,"
            },
            {
              "variable": "new_n0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c_array_node *node, *new_n0, *new_n1, *side;\n\ts"
            },
            {
              "variable": "new_n1",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ode *node, *new_n0, *new_n1, *side;\n\tstruct ass"
            },
            {
              "variable": "side",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", *new_n0, *new_n1, *side;\n\tstruct assoc_arra"
            },
            {
              "variable": "ptr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct assoc_array_ptr *ptr;\n\tunsigned long dis"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ")\\n\", __func__);\n\n\t/* We arrived at a node w"
            },
            {
              "variable": "pointer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "node or shortcut\n\t * pointer that we have to fol"
            },
            {
              "variable": "want",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t (a) the leaf we\n\t * want must go here (eithe"
            },
            {
              "variable": "need",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cement) or (b) we\n\t * need to split this node"
            },
            {
              "variable": "Firstly",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "free_slot = -1;\n\n\t/* Firstly, we have to check t"
            },
            {
              "variable": "a",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "to see if there's\n\t * a matching one we sho"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "urn true;\n\t\t}\n\t}\n\n\t/* If there is a free slo"
            },
            {
              "variable": "leaf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n just insert the\n\t * leaf here.\n\t */\n\tif (fre"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return true;\n\t}\n\n\t/* The node has no spare s"
            },
            {
              "variable": "it",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "to have to split\n\t * it or insert another n"
            },
            {
              "variable": "Whatever",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "de before it.\n\t *\n\t * Whatever, we're going to nee"
            },
            {
              "variable": "those",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "des - so allocate\n\t * those now.  We may also n"
            },
            {
              "variable": "when",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "we deal with that\n\t * when we need it.\n\t */\n\tn"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_to_ptr(new_n1);\n\n\t/* We need to find out ho"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o split_node;\n\t}\n\n\t/* The node contains only"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "AN_MASK) == 0) {\n\t\t/* The old leaves all clus"
            },
            {
              "variable": "to",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t.  We will need\n\t\t * to insert a shortcut i"
            },
            {
              "variable": "Otherwise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ster_together;\n \n\t\t/* Otherwise all the old leaves"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e same slot, but\n\t\t * the new leaf wants to g"
            },
            {
              "variable": "create",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ent slot - so we\n\t\t * create a new node (n0) to"
            },
            {
              "variable": "a",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "and a pointer to\n\t\t * a new node (n1) holdi"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "old leaves.\n\t\t *\n\t\t * This can be done by fall"
            },
            {
              "variable": "path",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e node splitting\n\t\t * path.\n \t\t */\n\t\tpr_devel("
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "split node\\n\");\n \n\t/* We need to split the c"
            },
            {
              "variable": "from",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "contain anything\n\t * from a single leaf (in t"
            },
            {
              "variable": "with",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "leaf will cluster\n\t * with the new leaf) and t"
            },
            {
              "variable": "of",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "all leaves, some\n\t * of which may cluster."
            },
            {
              "variable": "It",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "may cluster.\n\t *\n\t * It won't contain the c"
            },
            {
              "variable": "new",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t leaves plus the\n\t * new leaves want to clus"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "same slot.\n \t *\n \t * We need to expel at le"
            },
            {
              "variable": "leaves",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "consisting of the\n\t * leaves in the node and the"
            },
            {
              "variable": "just",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "meta pointers can\n\t * just be copied as they s"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the leaves.\n \t *\n \t * We need a new node (n0"
            },
            {
              "variable": "take",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nd a new node to\n \t * take the expelled nodes"
            },
            {
              "variable": "Need",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">parent_slot = -1; /* Need to calculate this *"
            },
            {
              "variable": "Begin",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s_on_branch = 0;\n\n\t/* Begin by finding two matc"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o be at least two\n\t * that match - even if the"
            },
            {
              "variable": "would",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "use any leaf that\n\t * would match a slot with a"
            },
            {
              "variable": "behind",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "must be somewhere\n\t * behind that meta pointer a"
            },
            {
              "variable": "remaining",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Further, given N\n\t * remaining leaf slots, we now"
            },
            {
              "variable": "Metadata",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ent_slot = slot;\n\n\t/* Metadata pointers cannot cha"
            },
            {
              "variable": "Filter",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers b"
            },
            {
              "variable": "All",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "luster_together:\n \t/* All the leaves, new and"
            },
            {
              "variable": "in",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "her in this node\n \t * in the same slot, so w"
            },
            {
              "variable": "skip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ith a shortcut to\n\t * skip over the identical"
            },
            {
              "variable": "nodes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n place a pair of\n\t * nodes, one inside the oth"
            },
            {
              "variable": "distribute",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the shortcut and\n\t * distribute the keys between th"
            },
            {
              "variable": "Firstly",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "between them.\n\t *\n\t * Firstly we need to work out"
            },
            {
              "variable": "bit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rt diverging as a\n\t * bit position into their"
            },
            {
              "variable": "needs",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "big the shortcut\n\t * needs to be.\n\t *\n\t * We o"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "needs to be.\n\t *\n\t * We only need to make a"
            },
            {
              "variable": "any",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "leaves because if\n\t * any keys differ between"
            },
            {
              "variable": "them",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n at least one of\n\t * them must also differ wi"
            },
            {
              "variable": "sizeof",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rtcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP"
            },
            {
              "variable": "Need",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">parent_slot = -1; /* Need to calculate this *"
            },
            {
              "variable": "ASSOC_ARRAY_KEY_CHUNK_SIZE",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_M"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- 1] &= ~blank;\n\n\t/* This now reduces to a no"
            },
            {
              "variable": "to",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "which we'll need\n\t * to regenerate the disp"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tf"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "it->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s"
            },
            {
              "variable": "ok",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\tr"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "it->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_cou"
            },
            {
              "variable": "ok",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\tre"
            },
            {
              "variable": "new_meta",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "eturn false;\n\tedit->new_meta[0] = assoc_array_node_"
            },
            {
              "variable": "new_meta",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "eturn false;\n\tedit->new_meta[1] = assoc_array_node_"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_met"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < A"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "similarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_de"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "*/\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)"
            },
            {
              "variable": "set",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "s (n1).\n\t */\n\tedit->set[0].to = assoc_array_no"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "+) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "y_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots["
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "LL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "!= NULL);\n\tnew_n0->slots[slot] = assoc_array_node_"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "y_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ntinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ext_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leav"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "= NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel("
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->l"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_cou"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr ="
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "f) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_ar"
            },
            {
              "variable": "set_backpointers",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ode(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_point"
            },
            {
              "variable": "set_backpointers",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "cut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_p"
            },
            {
              "variable": "set",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (!ptr)\n\t\tedit->set[0].ptr = &edit->array-"
            },
            {
              "variable": "set",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_"
            },
            {
              "variable": "set",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "lot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_"
            },
            {
              "variable": "excised_meta",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "->next_node;\n\tedit->excised_meta[0] = assoc_array_node_"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "y_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key)"
            },
            {
              "variable": "new_meta",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "eturn false;\n\tedit->new_meta[2] = assoc_array_short"
            },
            {
              "variable": "set",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tr(new_s0);\n\n\tedit->set[0].to = assoc_array_sh"
            },
            {
              "variable": "index_key",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "len; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_c"
            },
            {
              "variable": "slots",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_"
            },
            {
              "variable": "segment_cache",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 53,
        "pointer_count": 40,
        "array_count": 11,
        "size_variable_count": 5
      }
    },
    "predict": "{\"vulnerable_variables\":[\"index_key\",\"segment_cache\",\"new_meta\",\"keylen\"]}",
    "vulnerable_variables": [
      "index_key",
      "segment_cache",
      "new_meta",
      "keylen"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "index_key": "Definition not found",
      "segment_cache": "Definition not found",
      "new_meta": "Definition not found",
      "keylen": "size_t keylen;"
    },
    "variable_types": {
      "index_key": "unknown",
      "segment_cache": "struct pointer_integer array",
      "new_meta": "unknown",
      "keylen": "integer"
    },
    "type_mapping": {
      "index_key": "unknown",
      "segment_cache": "struct pointer_integer array",
      "new_meta": "unknown",
      "keylen": "Integer"
    }
  },
  {
    "idx": 160077,
    "project": "ImageMagick",
    "commit_id": "816ecab6c532ae086ff4186b3eaf4aa7092d536f",
    "project_url": "https://github.com/ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/816ecab6c532ae086ff4186b3eaf4aa7092d536f",
    "commit_message": "https://github.com/ImageMagick/ImageMagick/issues/58",
    "label": 0,
    "func": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"  Enter WriteOnePNGImage()\");\n \n   image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  if (image == (Image *) NULL)\n    return(MagickFalse);\n   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n   if (image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n \n   /* Define these outside of the following \"if logging()\" block so they will\n    * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}\n",
    "func_hash": 19355422623847821428259367918496362115,
    "file_name": "png.c",
    "file_hash": 30611584455442042892014136590615966927,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-11522",
    "cve_desc": "The WriteOnePNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-11522",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "r",
          "colors",
          "and",
          "ping",
          "ping_profile",
          "palette",
          "ping_pixels",
          "PNG",
          "if",
          "s",
          "isn",
          "eliminate",
          "image_info",
          "data",
          "channel",
          "ping_info",
          "even",
          "to",
          "DirectClass",
          "that",
          "transparent",
          "colormap",
          "but",
          "opacity",
          "mng_info",
          "as",
          "timestamp",
          "are",
          "IMimage",
          "needed",
          "pixels",
          "number_colors",
          "RGBA",
          "IMimage_info",
          "zero",
          "Throwing",
          "background",
          "verify",
          "excluded",
          "profile",
          "name",
          "we",
          "image",
          "show",
          "q",
          "them",
          "pixel",
          "when",
          "quantum_info",
          "block",
          "volatile",
          "exception",
          "p",
          "color"
        ],
        "arrays": [
          "libpng_vers",
          "sRGB_info",
          "opaque",
          "semitransparent",
          "s",
          "ping_trans_alpha",
          "palette",
          "colormap",
          "transparent",
          "ping_pixels",
          "text",
          "PLTE",
          "chunk",
          "im_vers",
          "tRNS",
          "libpng_runv",
          "zlib_vers",
          "zlib_runv"
        ],
        "size_variables": [
          "GetStringInfoLength",
          "size_t",
          "ping_num_trans",
          "text_length",
          "BlendPixelTrait",
          "number",
          "number_opaque",
          "number_transparent",
          "ssize_t",
          "MaxColormapSize",
          "length",
          "strlen",
          "number_colors",
          "png_set_compression_buffer_size",
          "num_passes",
          "num_trans",
          "png_size_t",
          "filename",
          "LocaleNCompare",
          "Number",
          "size",
          "number_semitransparent",
          "sizeof",
          "png_alloc_size_t",
          "len"
        ],
        "all_variables": [
          "s",
          "ping_pixels",
          "isn",
          "image_info",
          "ping_trans_alpha",
          "but",
          "MaxColormapSize",
          "length",
          "pixels",
          "strlen",
          "RGBA",
          "excluded",
          "size",
          "we",
          "image",
          "q",
          "pixel",
          "block",
          "png_alloc_size_t",
          "exception",
          "libpng_vers",
          "semitransparent",
          "ping_profile",
          "ping_num_trans",
          "size_t",
          "text_length",
          "even",
          "number",
          "number_opaque",
          "transparent",
          "text",
          "as",
          "timestamp",
          "IMimage",
          "sRGB_info",
          "needed",
          "number_colors",
          "png_set_compression_buffer_size",
          "zero",
          "png_size_t",
          "LocaleNCompare",
          "background",
          "im_vers",
          "opaque",
          "show",
          "when",
          "volatile",
          "libpng_runv",
          "zlib_vers",
          "r",
          "ping",
          "palette",
          "eliminate",
          "if",
          "BlendPixelTrait",
          "number_transparent",
          "ssize_t",
          "colormap",
          "opacity",
          "num_passes",
          "IMimage_info",
          "num_trans",
          "chunk",
          "profile",
          "Number",
          "zlib_runv",
          "name",
          "them",
          "quantum_info",
          "PLTE",
          "len",
          "colors",
          "and",
          "GetStringInfoLength",
          "PNG",
          "channel",
          "data",
          "tRNS",
          "ping_info",
          "to",
          "DirectClass",
          "that",
          "mng_info",
          "are",
          "Throwing",
          "filename",
          "verify",
          "number_semitransparent",
          "sizeof",
          "p",
          "color"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caN"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHR"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_dat"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXI"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAM"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCC"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHY"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRG"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEX"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIM"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCC"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCC"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_c"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iC"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colort"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ICC profile and set image->rendering_intent.\n   * Note that thi"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "omething other than image->rendering_intent to record the fact"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (image->rendering_intent==UndefinedIntent)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->rendering_intent="
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "se)\n    {\n      if (image->storage_class == UndefinedClass)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(),\n          \"    image->storage_class=UndefinedClass\");"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dClass\");\n      if (image->storage_class == DirectClass)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(),\n          \"    image->storage_class=DirectClass\");"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tClass\");\n      if (image->storage_class == PseudoClass)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e(),\n          \"    image->storage_class=PseudoClass\");"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",GetMagickModule(), image->taint ?\n          \"    im"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt ?\n          \"    image->taint=MagickTrue\":"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ue\":\n          \"    image->taint=MagickFalse\");"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lse\");\n    }\n\n  if (image->storage_class == PseudoClass &&"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "seudoClass &&\n     (mng_info->write_png8 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info->write_png8 || mng_info->write_png24 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png24 || mng_info->write_png32 ||\n     mng_info->w"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "write_png32 ||\n     mng_info->write_png48 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png48 || mng_info->write_png64 ||\n     (mng_info->"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rite_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_in"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e,exception);\n      image->storage_class = DirectClass;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "se)\n    {\n      if (image->storage_class != PseudoClass && i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s != PseudoClass && image->colormap != NULL)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "inquishMagickMemory(image->colormap);\n           image-"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lormap);\n           image->colormap=NULL;\n        }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ompatibleColorspace(image->colorspace) == MagickFalse)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "values.\n  */\n  if (image->depth <= 8 && image->tain"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage->depth <= 8 && image->taint && image->storage_c"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& image->taint && image->storage_class == PseudoClass)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "M_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Q8 build.\");\n\n      image->depth=8;\n    }\n#endif"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pth option */\n  if (image->depth < 4)\n    {\n       r"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*r;\n\n       if (image->depth > 2)\n         {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR04PacketRGBO(image->background_color);\n\n           for ("
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n           {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n           if (image->storage_class == PseudoClass && i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s == PseudoClass && image->colormap != NULL)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(i=0; i < (ssize_t) image->colors; i++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR04PacketRGBO(image->colormap[i]);\n             }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n       else if (image->depth > 1)\n         {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR02PacketRGBO(image->background_color);\n\n           for ("
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n           {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n           if (image->storage_class == PseudoClass && i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s == PseudoClass && image->colormap != NULL)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(i=0; i < (ssize_t) image->colors; i++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR02PacketRGBO(image->colormap[i]);\n             }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR01PacketRGBO(image->background_color);\n\n           for ("
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n           {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n           if (image->storage_class == PseudoClass && i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s == PseudoClass && image->colormap != NULL)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(i=0; i < (ssize_t) image->colors; i++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR01PacketRGBO(image->colormap[i]);\n             }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tiple of 8 */\n  if (image->depth < 8)\n     image->de"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ge->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f lossy\n   */\n  if (image->depth > 8)\n      image->d"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MA"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /*"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e properly */\n      image->depth=16;\n    }\n\n  if (im"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "th=16;\n    }\n\n  if (image->depth == 16 && mng_info->"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "epth != 16)\n    if (mng_info->write_png8 ||\n        Lossless"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MagickFalse)\n      image->depth = 8;\n#endif\n\n  imag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage_colors = (int) image->colors;\n  number_opaque ="
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mber_opaque = (int) image->colors;\n  number_transpare"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->w"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_in"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lortype < 4 &&\n     image->alpha_trait == UndefinedPixelTr"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_h"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTr"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s.\n     *\n     * If image->alpha_trait is MagickFalse, we"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"      image->columns=%.20g\",(double) ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mns=%.20g\",(double) image->columns);\n       (void) Log"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"      image->rows=%.20g\",(double) ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ows=%.20g\",(double) image->rows);\n       (void) Log"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"      image->alpha_trait=%.20g\",(double) ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ait=%.20g\",(double) image->alpha_trait);\n       (void) Log"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"      image->depth=%.20g\",(double) ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pth=%.20g\",(double) image->depth);\n\n       if (image"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "depth);\n\n       if (image->storage_class == PseudoClass && i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s == PseudoClass && image->colormap != NULL)\n       {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].red,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].green,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].blue,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].alpha);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n         for (i=image->colors - 10; i < (ssize_t)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- 10; i < (ssize_t) image->colors; i++)\n         {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].red,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].green,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].blue,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].alpha);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n           \"      image->colors=%d\",(int) image->co"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e->colors=%d\",(int) image->colors);\n\n       if (image"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "olors);\n\n       if (image->colors == 0)\n         (voi"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n     {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)\n       {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n           if (image->alpha_trait == UndefinedPixelTr"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->background_color.red,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->background_color.green,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->background_color.blue);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f (opaque[i].red == image->background_color.red &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "opaque[i].green == image->background_color.green &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "opaque[i].blue == image->background_color.blue)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "opaque[i] = image->background_color;\n               pin"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't n"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ompatibleColorspace(image->colorspace) == MagickFalse)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") &&\n            (((mng_info->write_png_colortype-1) ==\n            P"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TE) ||\n            (mng_info->write_png_colortype == 0)))\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n            image->colors = image_colors;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "i++)\n               image->colormap[i] = colormap[i];"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"      image->colors=%d (%d)\","
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colors, image_colors);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n            {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if ((image->alpha_trait == UndefinedPixelTr"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap[i].alpha == GetPixe"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap[i].red == GetPixelR"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap[i].green == GetPixe"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap[i].blue == GetPixel"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"      image->colors=%d\", (int) image->c"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->colors=%d\", (int) image->colors);\n\n         if (ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ors);\n\n         if (image->colormap != NULL)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(i=0; i < (ssize_t) image->colors; i++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0 || i >= (ssize_t) image->colors - 10)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].red,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].green,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].blue,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->colormap[i].alpha);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage_colors != 0 && image->colormap != NULL &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ge\n     * them into image->background_color.\n     */\n    if (nu"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ViaPixelInfo(image,&image->background_color,r);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "256 &&\n             image->colormap != NULL)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "++)\n                image->colormap[i].alpha ="
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(image->colormap[i].alpha > Transpar"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR04PacketRGB(image->background_color);\n\n        if (logg"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "4-4\");\n\n        if (image->colormap == NULL)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)\n            {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR04PacketRGB(image->colormap[i]);\n          }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR03PacketRGB(image->background_color);\n\n        if (logg"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "3-1\");\n\n        if (image->colormap == NULL)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)\n            {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR03PacketRGB(image->colormap[i]);\n          }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR02PacketBlue(image->background_color);\n\n        if (logg"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "2-1\");\n\n        if (image->colormap == NULL)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)\n            {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LBR02PacketBlue(image->colormap[i]);\n          }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(ScaleQuantumToChar(image->background_color.red) == 0x49 &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToChar(image->background_color.green) == 0x00 &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToChar(image->background_color.blue) == 0x00)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0)\n      {\n         image->background_color.red=ScaleCharToQuan"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "3-2-1\");\n\n      if (image->colormap == NULL)\n      {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ticPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToChar(image->colormap[i].green) == 0x00 &"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToChar(image->colormap[i].blue) == 0x00)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n               image->colormap[i].red=ScaleCharToQ"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "* PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "igned int colortype=mng_info->write_png_colortype;\n\n      if (ping_ha"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "agickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else\n        mng_info->write_png_colortype = 7;\n\n      if (col"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pe != 0 &&\n         mng_info->write_png_colortype != colortype)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "arent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       p"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "> 256 ||\n           image->colormap == NULL)\n         {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n           {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ualPixels(image,0,y,image->columns,1, exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(x=0; x < (ssize_t) image->columns; x++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Assuming that image->colormap[0] is the one trans"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (image->colormap[i].red == image->co"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">colormap[i].red == image->colormap[0].red &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap[i].green == image->"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "olormap[i].green == image->colormap[0].green &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap[i].blue == image->c"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "colormap[i].blue == image->colormap[0].blue)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lse;\n\n  image_depth=image->depth;\n\n  quantum_info ="
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image_colors=(int) image->colors;\n  image_matte=imag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lors;\n  image_matte=image->alpha_trait !=\n        Undefine"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_colortype < 5)\n    mng_info->IsPalette=image->storage_clas"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mng_info->IsPalette=image->storage_class == PseudoClass &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ge_colors <= 256 && image->colormap != NULL;\n  else"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "agickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->w"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_colortype == 4 || mng_info->write_png8) &&\n     (image->co"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rite_png8) &&\n     (image->colors == 0 || image->colo"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age->colors == 0 || image->colormap == NULL))\n    {"
            },
            {
              "variable": "IMimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\",\n          \"`%s'\",IMimage->filename);\n      return(Magi"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PNG_DEBUG\n     if (image_info->verbose)\n        (void) pri"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) pn"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_em"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "width=(png_uint_32) image->columns;\n  ping_height=(png"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eight=(png_uint_32) image->rows;\n\n  if (mng_info->w"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info->write_png8 || mng_info->write_png24 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png24 || mng_info->write_png32)\n     image_depth=8"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png48 || mng_info->write_png64)\n     image_depth=1"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ge_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_de"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust reque"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tte=%.20g\",(double) image->alpha_trait);\n     (void) LogMa"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ule(),\n        \"    image->depth=%.20g\",(double) ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pth=%.20g\",(double) image->depth);\n     (void) LogMa"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckFalse)\n  {\n  if ((image->resolution.x != 0) && (image->"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "olution.x != 0) && (image->resolution.y != 0) &&\n      (!"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info->write_mng || !mng_info->equal_physs))\n    {\n      if (l"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk\");\n\n      if (image->units == PixelsPerInchRes"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_uint_32) ((100.0*image->resolution.x+0.5)/2.54);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_uint_32) ((100.0*image->resolution.y+0.5)/2.54);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n      else if (image->units == PixelsPerCentime"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png_uint_32) (100.0*image->resolution.x+0.5);\n          p"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png_uint_32) (100.0*image->resolution.y+0.5);\n        }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ution=(png_uint_32) image->resolution.x;\n          ping_p"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ution=(png_uint_32) image->resolution.y;\n        }"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsi"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToShort(image->background_color.red) & mask);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToShort(image->background_color.green) & mask);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToShort(image->background_color.blue) & mask);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_info->IsPalette && mng_info->write_png8)\n    {\n      /* To"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=ScaleQuantumToChar(image->colormap[i].red);\n        pa"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=ScaleQuantumToChar(image->colormap[i].green);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=ScaleQuantumToChar(image->colormap[i].blue);\n        i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n          assert(image->colormap != NULL);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ual(ping_background,image->colormap[i]))\n            br"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png24 || mng_info->write_png48 ||\n      mng_info->"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rite_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png32 || mng_info->write_png64 ||\n      mng_info->"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rite_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "A;\n    }\n\n  else /* mng_info->write_pngNN not specified */"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lor_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (p"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GB);\n\n          if (image_info->type == TrueColorType)"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n          if (image_info->type == TrueColorAlphaTy"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n          if (image_info->type == PaletteType ||"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pe ||\n              image_info->type == PaletteAlphaType"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TTE;\n\n          if (mng_info->write_png_colortype == 0 &&"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 0 &&\n             image_info->type == UndefinedType)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          if (image->alpha_trait == UndefinedPixelTr"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=1;\n\n           if (image->colors == 0)\n           {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_dep"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ule(),\n        \"    image_info->type: %.20g\",(double) im"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pe: %.20g\",(double) image_info->type);\n\n      (void) Log"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "le(),\n\n        \"    image->depth: %.20g\",(double) im"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "th: %.20g\",(double) image->depth);\n\n      (void) Log"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "se)\n    {\n      if (mng_info->IsPalette)\n        {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          if (mng_info->write_png_colortype == 0)\n            {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (mng_info->write_png_colortype == 0)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToShort(image->colormap[0].red) & mask);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToShort(image->colormap[0].green) & mask);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToShort(image->colormap[0].blue) & mask);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image->colormap)) & mask);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n              if (mng_info->write_png_colortype == 0)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_inf"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Palette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if(!mng_info->write_png_depth)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&&\n                mng_info->IsPalette)\n              {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=ScaleQuantumToChar(image->colormap[i].red);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (depth_1_ok && mng_info->write_png_depth <= 1)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e if (depth_2_ok && mng_info->write_png_depth <= 2)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e if (depth_4_ok && mng_info->write_png_depth <= 4)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else\n\n      if (mng_info->IsPalette)\n      {\n        nu"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (!(mng_info->have_write_global_plte && matte == MagickF"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=ScaleQuantumToChar(image->colormap[i].red);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToChar(image->colormap[i].green);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "=ScaleQuantumToChar(image->colormap[i].blue);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n            if (mng_info->write_png_depth == 0)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ScaleQuantumToChar(image->colormap[i].alpha);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adju"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(image,\n           &image->background_color))) +.5)));"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (IsPNGColorEqual(image->background_color,image->colormap[i])"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e->background_color,image->colormap[i]))\n            br"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".\n\n   */\n\n  quality=image_info->quality == UndefinedCompres"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ality ? 75UL :\n     image_info->quality;\n\n  if (quality <="
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "vel+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEG"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ilter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ")\n    {\n        if (mng_info->write_png_compression_level)\n          (void) L"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mn"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "el-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) L"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (vo"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n        else if (mng_info->write_png_compression_filter == 0 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                 mng_info->write_png_compression_filter == 1)\n          (vo"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mn"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "er-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_c"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "on_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ilter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if def"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ERENCING)\n      if (mng_info->write_mng)\n      {\n         i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_f"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_f"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "R_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_c"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interla"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_interlace_method=image_info->interlace != NoInterlace;"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_by"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "olor-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "type &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_typ"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n          if (mng_info->write_png_depth)\n            {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n                  mng_info->write_png_depth,"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n          if (mng_info->write_png_colortype)\n            {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n                  mng_info->write_png_colortype-1,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e != MagickFalse && image->alpha_trait == UndefinedPixelTr"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "te channel */\n      image->alpha_trait = BlendPixelTrait;"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "B_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tent(\n              image->rendering_intent)));\n\n          ping"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "False ||\n          (image->gamma < .45 || image->gam"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age->gamma < .45 || image->gamma > .46)))\n      {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n      if ((mng_info->have_write_global_gama == 0) && (image->ga"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "obal_gama == 0) && (image->gamma != 0.0))\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gAMA(ping,ping_info,image->gamma);\n        }\n      }"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          if ((mng_info->have_write_global_chrm == 0) &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") &&\n              (image->chromaticity.red_primary.x != 0."
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "wp=image->chromaticity.white_point;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n               rp=image->chromaticity.red_primary;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n               gp=image->chromaticity.green_primary;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n               bp=image->chromaticity.blue_primary;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mestamp;\n\n      if (image->taint == MagickFalse)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e)\n    {\n      if ((image->page.width != 0 && image"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">page.width != 0 && image->page.width != image->col"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage->page.width != image->columns) ||\n          (imag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "umns) ||\n          (image->page.height != 0 && imag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "page.height != 0 && image->page.height != image->ro"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age->page.height != image->rows) ||\n          image"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">rows) ||\n          image->page.x != 0 || image->pa"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age->page.x != 0 || image->page.y != 0)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk+4,(png_uint_32) image->page.width);\n          P"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk+8,(png_uint_32) image->page.height);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk+12,(png_int_32) image->page.x);\n          PNGsL"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk+16,(png_int_32) image->page.y);\n          (void"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "se)\n    {\n      if (image->page.x || image->page.y)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f (image->page.x || image->page.y)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_info,(png_int_32) image->page.x,\n              (p"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(png_int_32) image->page.y, 0);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(int) image->page.x, (int) image->pag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage->page.x, (int) image->page.y);\n        }\n    }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e)\n    {\n      if ((image->page.width != 0 && image"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">page.width != 0 && image->page.width != image->col"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage->page.width != image->columns) ||\n          (imag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "umns) ||\n          (image->page.height != 0 && imag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "page.height != 0 && image->page.height != image->ro"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age->page.height != image->rows))\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk+4,(png_uint_32) image->page.width);\n          P"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk+8,(png_uint_32) image->page.height);"
            },
            {
              "variable": "ping",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ry.\n  */\n  rowbytes=image->columns;\n  if (image_depth"
            },
            {
              "variable": "quantum_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "um_info failed\");\n  quantum_info->format=UndefinedQuantumFor"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png8 && !mng_info->write_png24 &&\n       !mng_info"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "te_png24 &&\n       !mng_info->write_png48 && !mng_info->write"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fo->write_png48 && !mng_info->write_png64 &&\n       !mng_info"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "te_png64 &&\n       !mng_info->write_png32) &&\n       (mng_inf"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_png32) &&\n       (mng_info->IsPalette ||\n       (image_in"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sPalette ||\n       (image_info->type == BilevelType)) &&"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n        {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ualPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eak;\n\n          if (mng_info->IsPalette)\n            {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&\n                  mng_info->write_png_depth &&"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&\n                  mng_info->write_png_depth != old_bit_depth)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(i=0; i < (ssize_t) image->columns; i++)"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(i=0; i < (ssize_t) image->columns; i++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);\n\n          if (st"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/\n    {\n      if ((!mng_info->write_png8 && !mng_info->write"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png8 && !mng_info->write_png24 &&\n          !mng_i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png24 &&\n          !mng_info->write_png48 && !mng_info->write"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fo->write_png48 && !mng_info->write_png64 &&\n          !mng_i"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png64 &&\n          !mng_info->write_png32) && (image_matte !="
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PTH)) &&\n          (mng_info->IsPalette) && ping_have_color"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)\n          {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ualPixels(image,0,y,image->columns,1,exception);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (mng_info->IsPalette)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);\n\n            if ("
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                mng_info->write_png24 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                mng_info->write_png32 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                mng_info->write_png48 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                mng_info->write_png64 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|\n                (!mng_info->write_png8 && !mng_info->IsPal"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png8 && !mng_info->IsPalette))\n            {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ualPixels(image,0,y,image->columns,1, exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (image->storage_class == DirectClass)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                mng_info->write_png24 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png24 || mng_info->write_png32 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "||\n                mng_info->write_png48 || mng_info->write_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png48 || mng_info->write_png64 ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|\n                (!mng_info->write_png8 && !mng_info->IsPal"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo->write_png8 && !mng_info->IsPalette))\n             */"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(y=0; y < (ssize_t) image->rows; y++)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ualPixels(image,0,y,image->columns,1, exception);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(image,quantum_info,image->depth);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "height);\n\n      if (mng_info->write_png_depth)\n        {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png:bit-depth: %d\",mng_info->write_png_depth);\n        }"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_depth);\n\n      if (mng_info->write_png_colortype)\n        {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png:color-type: %d\",mng_info->write_png_colortype-1);\n        }"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "text[0].compression=image_info->compression == NoCompression ||"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|\n                 (image_info->compression == UndefinedCompres"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",ping_info);\n\n  if (mng_info->need_fram && (int) image->dis"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">need_fram && (int) image->dispose == BackgroundDispos"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "se)\n    {\n      if (mng_info->page.x || mng_info->page"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mng_info->page.x || mng_info->page.y ||\n          (pin"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(ping_width != mng_info->page.width) ||"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(ping_height != mng_info->page.height))\n        {"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k+15,(png_uint_32) (mng_info->page.x)); /* left cb */"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(png_uint_32) (mng_info->page.x + ping_width));"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k+23,(png_uint_32) (mng_info->page.y)); /* top cb */"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(png_uint_32) (mng_info->page.y + ping_height));"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk,31));\n          mng_info->old_framing_mode=4;\n          mng_in"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_mode=4;\n          mng_info->framing_mode=1;\n        }"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else\n        mng_info->framing_mode=3;\n    }\n  if (mng_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info->write_mng && !mng_info->need_fram &&\n      ((int) ima"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ram &&\n      ((int) image->dispose == 3))\n     png_err"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "OnePNGImage(MngInfo *mng_info,\n  const ImageInfo"
            },
            {
              "variable": "IMimage_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n  const ImageInfo *IMimage_info,Image *IMimage,Exce"
            },
            {
              "variable": "IMimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*IMimage_info,Image *IMimage,ExceptionInfo *exce"
            },
            {
              "variable": "exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image,ExceptionInfo *exception)\n{\n  char\n    im_ve"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];"
            },
            {
              "variable": "name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\n  const char\n    *name,\n    *property,"
            },
            {
              "variable": "property",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char\n    *name,\n    *property,\n    *value;\n\n  con"
            },
            {
              "variable": "value",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*property,\n    *value;\n\n  const StringInf"
            },
            {
              "variable": "profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "onst StringInfo\n    *profile;\n\n  int\n    num_pas"
            },
            {
              "variable": "ping_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "or;\n\n  png_info\n    *ping_info;\n\n  png_struct"
            },
            {
              "variable": "ping",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\n  png_struct\n    *ping;\n\n  png_uint_32"
            },
            {
              "variable": "ping_exclude_EXIF",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclud"
            },
            {
              "variable": "ping_exclude_iTXt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclud"
            },
            {
              "variable": "ping_exclude_tRNS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclud"
            },
            {
              "variable": "hex",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_zCCP, /* hex-encoded iCCP */"
            },
            {
              "variable": "volatile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  Quan"
            },
            {
              "variable": "quantum_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo"
            },
            {
              "variable": "ping_pixels",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unsigned char\n    *ping_pixels;\n\n  volatile int"
            },
            {
              "variable": "Define",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tionFailed\");\n \n   /* Define these outside of th"
            },
            {
              "variable": "show",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ck so they will\n    * show in debuggers.\n   */"
            },
            {
              "variable": "im_vers",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "debuggers.\n   */\n  *im_vers='\\0';\n  (void) Conc"
            },
            {
              "variable": "libpng_vers",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) Conc"
            },
            {
              "variable": "libpng_runv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "G_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) Conc"
            },
            {
              "variable": "zlib_vers",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) Conc"
            },
            {
              "variable": "zlib_runv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) Conc"
            },
            {
              "variable": "Initialize",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n  /* Initialize some stuff */\n  pin"
            },
            {
              "variable": "ping_exclude_iTXt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_excl"
            },
            {
              "variable": "ping_exclude_tRNS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_excl"
            },
            {
              "variable": "hex",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ping_exclude_zCCP; /* hex-encoded iCCP in zTX"
            },
            {
              "variable": "Recognize",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= MagickFalse;\n\n  /* Recognize the ICC sRGB profil"
            },
            {
              "variable": "i",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the sRGB chunk,\n   * i.e., eliminate the I"
            },
            {
              "variable": "Note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "endering_intent.\n   * Note that this will not"
            },
            {
              "variable": "but",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "he actual pixels\n   * but merely passes infor"
            },
            {
              "variable": "PNG",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ad the resulting\n   * PNG image.\n   *\n   * To"
            },
            {
              "variable": "To",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PNG image.\n   *\n   * To do: recognize other"
            },
            {
              "variable": "verify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "using the CRC to\n   * verify all recognized vari"
            },
            {
              "variable": "Work",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eady known.\n   *\n   * Work around libpng16+ re"
            },
            {
              "variable": "Use",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "profiles\".\n   *\n   * Use something other tha"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "record the fact\n   * that the sRGB profile wa"
            },
            {
              "variable": "Record",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "was found.\n   *\n   * Record the ICC version (cu"
            },
            {
              "variable": "profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ncoming sRGB ICC\n   * profile.  Record the Blackp"
            },
            {
              "variable": "name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char\n        *name;\n\n      const Strin"
            },
            {
              "variable": "profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "StringInfo\n        *profile;\n\n      ResetImageP"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*data;"
            },
            {
              "variable": "Free",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          /* Free the bogus colormap;"
            },
            {
              "variable": "Sometimes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ace,exception);\n\n  /*\n    Sometimes we get PseudoClass"
            },
            {
              "variable": "Respect",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "8;\n    }\n#endif\n\n  /* Respect the -depth option *"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "er Quantum\n         *r;\n\n       if (image-"
            },
            {
              "variable": "Scale",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n           /* Scale to 4-bit */"
            },
            {
              "variable": "Scale",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n           /* Scale to 2-bit */"
            },
            {
              "variable": "Scale",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n           /* Scale to 1-bit */"
            },
            {
              "variable": "To",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n  /* To do: set to next hig"
            },
            {
              "variable": "PNG",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NTUM_DEPTH > 16)\n  /* PNG does not handle dep"
            },
            {
              "variable": "To",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "h > 8)\n    {\n      /* To do: fill low byte p"
            },
            {
              "variable": "Avoid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lTrait)))\n  {\n     /* Avoid the expensive BUILD"
            },
            {
              "variable": "are",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sure that we\n      * are not going to need t"
            },
            {
              "variable": "BUILD_PALETTE",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally"
            },
            {
              "variable": "Normally",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ILD_PALETTE\n   *\n   * Normally we run this just on"
            },
            {
              "variable": "we",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "of writing PNG8\n   * we reduce the transpar"
            },
            {
              "variable": "are",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n, then if there\n   * are still too many colo"
            },
            {
              "variable": "RGBA",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "-1, then 3-3-3-1\n   * RGBA palette and run aga"
            },
            {
              "variable": "palette",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ple 3-3-2-1 RGBA\n   * palette.  Then (To do) we t"
            },
            {
              "variable": "needed",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ion that is only\n   * needed if there are still"
            },
            {
              "variable": "transparent",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "of them has both\n   * transparent and opaque instance"
            },
            {
              "variable": "Sometimes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "++)\n  {\n    /*\n     * Sometimes we get DirectClass"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lors or fewer.\n     * This code will build a c"
            },
            {
              "variable": "Also",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lormap.\n     *\n     * Also, sometimes we get P"
            },
            {
              "variable": "colormap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "an out-of-date\n     * colormap.  This code will re"
            },
            {
              "variable": "Sometimes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ith a new one.\n     * Sometimes we get PseudoClass"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "an 256 colors.\n     * This code will delete th"
            },
            {
              "variable": "DirectClass",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e the image to\n     * DirectClass.\n     *\n     * If i"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tClass.\n     *\n     * If image->alpha_trait"
            },
            {
              "variable": "even",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "alpha channel\n     * even though it sometimes"
            },
            {
              "variable": "Also",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "values.\n     *\n     * Also we gather some info"
            },
            {
              "variable": "and",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", transparent,\n     * and semitransparent pix"
            },
            {
              "variable": "pixels",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s any non-gray\n     * pixels or only black-and-w"
            },
            {
              "variable": "Even",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "later.\n     *\n     * Even if the user wants t"
            },
            {
              "variable": "we",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ortype 4 or 6)\n     * we need to check for b"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const Quantum\n     *s;\n\n   register Quant"
            },
            {
              "variable": "q",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gister Quantum\n     *q,\n     *r;\n\n   if (l"
            },
            {
              "variable": "r",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "antum\n     *q,\n     *r;\n\n   if (logging !="
            },
            {
              "variable": "Add",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n         /* Add the background colo"
            },
            {
              "variable": "isn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "te, if it\n          * isn't already there."
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_colortype != 7) /* We won't need this inf"
            },
            {
              "variable": "Worst",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k;\n\n               /* Worst case is black-and-w"
            },
            {
              "variable": "pixel",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ery\n                * pixel twice."
            },
            {
              "variable": "Initialize",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n          * Initialize image colormap."
            },
            {
              "variable": "Sort",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lormap\");\n\n        /* Sort palette, transparen"
            },
            {
              "variable": "image_colors",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "parent);\n\n         /* image_colors < 257; search the c"
            },
            {
              "variable": "to",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "he pixels\n          * to get ping_have_color"
            },
            {
              "variable": "Sync",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n            /* Sync the pixel indices w"
            },
            {
              "variable": "Make",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ")\n      break;\n\n   /* Make any reductions nece"
            },
            {
              "variable": "PNG8",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n\n    /* PNG8 can't have semitran"
            },
            {
              "variable": "opacity",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "threshold the\n     * opacity to 0 or OpaqueOpaci"
            },
            {
              "variable": "transparent",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "only have one\n     * transparent color so if more th"
            },
            {
              "variable": "them",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "arent we merge\n     * them into image->backgro"
            },
            {
              "variable": "PNG8",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ntinue;\n    }\n\n    /* PNG8 can't have more tha"
            },
            {
              "variable": "background",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the pixels and\n     * background color to the 4-4-4-"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lette.  If the\n     * image is mostly gray, the"
            },
            {
              "variable": "colors",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nd up with 256\n     * colors or less.\n     */"
            },
            {
              "variable": "Should",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        else /* Should not reach this; col"
            },
            {
              "variable": "Should",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        else /* Should not reach this; col"
            },
            {
              "variable": "Red",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gickTrue;\n\n        /* Red and green were alre"
            },
            {
              "variable": "channel",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e the blue\n         * channel\n         */"
            },
            {
              "variable": "Should",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        else /* Should not reach this; col"
            },
            {
              "variable": "Take",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "> 256)\n    {\n      /* Take care of special cas"
            },
            {
              "variable": "color",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "transparent\n       * color.  We don't need to"
            },
            {
              "variable": "eliminate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "only need to\n       * eliminate one color, so we'll"
            },
            {
              "variable": "colors",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "darkest red\n       * colors (0x49, 0, 0) -> (0x"
            },
            {
              "variable": "END",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UILD_PALETTE */\n\n  /* If we are excluding th"
            },
            {
              "variable": "then",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "is transparency,\n   * then we must write a Gra"
            },
            {
              "variable": "PNG",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "A (color-type 6)\n   * PNG.\n   */\n  if (mng_in"
            },
            {
              "variable": "See",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ickTrue;\n\n    }\n\n  /* See if cheap transparen"
            },
            {
              "variable": "when",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "is only possible\n   * when there is a single t"
            },
            {
              "variable": "color",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "semitransparent\n   * color, and no opaque colo"
            },
            {
              "variable": "as",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e RGB components\n   * as the transparent col"
            },
            {
              "variable": "we",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s information if\n   * we are writing a PNG w"
            },
            {
              "variable": "excluded",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "and we have not\n   * excluded the tRNS chunk."
            },
            {
              "variable": "q",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uantum\n             *q;\n\n           for (y"
            },
            {
              "variable": "Assuming",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n            /* Assuming that image->colorma"
            },
            {
              "variable": "and",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "color\n             * and that all others are"
            },
            {
              "variable": "Allocate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckFalse);\n    }\n\n  /*\n    Allocate the PNG structures"
            },
            {
              "variable": "PNG",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing)))\n    {\n      /*\n        PNG write failed."
            },
            {
              "variable": "block",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ck.  Within this\n   *    block, use png_error() in"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ption, to ensure\n   *    that libpng is able to c"
            },
            {
              "variable": "Allow",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ERRORS_SUPPORTED\n  /* Allow benign errors */"
            },
            {
              "variable": "Reject",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LIMITS_SUPPORTED\n  /* Reject images with too man"
            },
            {
              "variable": "PNG_SET_USER_LIMITS_SUPPORTED",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "esource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepar"
            },
            {
              "variable": "Prepare",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing."
            },
            {
              "variable": "Disable",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DEX_SUPPORTED\n     /* Disable new libpng-1.5.10 f"
            },
            {
              "variable": "zero",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "a MNG because\n      * zero-length PLTE is OK"
            },
            {
              "variable": "Adjust",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rite_png_depth;\n\n  /* Adjust requested depth to"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png_uint_32) ((100.0*image->resolution.x+0.5)/"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "png_uint_32) ((100.0*image->resolution.y+0.5)/"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(png_uint_32) (100.0*image->resolution.x+0.5);"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(png_uint_32) (100.0*image->resolution.y+0.5);"
            },
            {
              "variable": "Select",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  *"
            },
            {
              "variable": "To",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_png8)\n    {\n      /* To do: make this a fun"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "agickFalse;\n\n      /*\n        Set image palette."
            },
            {
              "variable": "Identify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          /*\n            Identify which colormap entr"
            },
            {
              "variable": "Identify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n       /*\n        * Identify which colormap entr"
            },
            {
              "variable": "number_colors",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "size_t) MagickMax(1L*number_colors-1L,1L); i++)"
            },
            {
              "variable": "end",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n      }\n    } /* end of write_png8 */"
            },
            {
              "variable": "mng_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PHA;\n    }\n\n  else /* mng_info->write_pngNN not sp"
            },
            {
              "variable": "write_png_colortype",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n      else /* write_png_colortype not specified */"
            },
            {
              "variable": "DO",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n              /* DO SOMETHING */"
            },
            {
              "variable": "Determine",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n           * Determine if there is any tra"
            },
            {
              "variable": "No",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n              /*\n                No transparent pixels"
            },
            {
              "variable": "Determine",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n               * Determine if there is one and"
            },
            {
              "variable": "and",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "olor\n               * and if so if it is full"
            },
            {
              "variable": "changes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lor_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n              /* Check if grayscale is red"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n            /*\n              Set image palette."
            },
            {
              "variable": "color_type",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n            /* color_type is PNG_COLOR_TYPE_P"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n                 * Set up trans_colors arr"
            },
            {
              "variable": "Adjust",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "te_png_depth;\n\n    /*\n      Adjust background and tran"
            },
            {
              "variable": "Identify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "E)\n      {\n        /*\n           Identify which colormap entr"
            },
            {
              "variable": "number_colors",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "size_t) MagickMax(1L*number_colors,1L); i++)"
            },
            {
              "variable": "Can",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        else  /* Can't happen */"
            },
            {
              "variable": "Initialize",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing_color_type);\n  /*\n    Initialize compression level a"
            },
            {
              "variable": "Untangle",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "level(ping, 9);\n\n  /* Untangle the \"-quality\" sett"
            },
            {
              "variable": "Z_RLE",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1"
            },
            {
              "variable": "Bail",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_bytes(ping,8);\n\n  /* Bail out if cannot meet"
            },
            {
              "variable": "Add",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Trait)\n    {\n      /* Add an opaque matte cha"
            },
            {
              "variable": "Only",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n  /* Only write the iCCP chun"
            },
            {
              "variable": "Do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Do not write hex-encod"
            },
            {
              "variable": "WRITE_iCCP",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n#endif /* WRITE_iCCP */\n\n            if"
            },
            {
              "variable": "Do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Do not write hex-encod"
            },
            {
              "variable": "Note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          /*\n            Note image rendering int"
            },
            {
              "variable": "Note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          /*\n            Note image gamma."
            },
            {
              "variable": "Note",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n              /*\n                Note image chromaticity."
            },
            {
              "variable": "timestamp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char\n        *timestamp;\n\n      if (image->"
            },
            {
              "variable": "write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n  /* write any png-chunk-b pro"
            },
            {
              "variable": "write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing,ping_info);\n\n  /* write any PNG-chunk-m pro"
            },
            {
              "variable": "write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= MagickFalse;\n\n  /* write caNv chunk */\n  if"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ULong(image,16L);  /* data length=8 */"
            },
            {
              "variable": "write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n#endif\n\n  /* write vpAg chunk (depreca"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "BULong(image,9L);  /* data length=8 */"
            },
            {
              "variable": "unit",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[12]=0;   /* unit = pixels */"
            },
            {
              "variable": "avoid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_VER == 10206)\n    /* avoid libpng-1.2.6 bug by"
            },
            {
              "variable": "Allocate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowb"
            },
            {
              "variable": "ping_pixels",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info"
            },
            {
              "variable": "Initialize",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ob(pixel_info);\n\n  /*\n    Initialize image scanlines."
            },
            {
              "variable": "Palette",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "False)\n    {\n      /* Palette, Bilevel, or Opaque"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nst Quantum\n        *p;\n\n      SetQuantumD"
            },
            {
              "variable": "Convert",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+)\n      {\n        /*\n          Convert PseudoClass image t"
            },
            {
              "variable": "Undo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/* Undo pixel scaling */"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckOffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);"
            },
            {
              "variable": "Not",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n  else   /* Not Palette, Bilevel, o"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Quantum\n            *p;\n\n          for (pa"
            },
            {
              "variable": "PNG_COLOR_TYPE_GRAY_ALPHA",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckOffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Quantum\n            *p;\n\n          for (pa"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckOffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);"
            },
            {
              "variable": "not",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else\n            /* not ((image_depth > 8)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckOffsetType) (pass * image->rows + y),"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "num_passes * image->rows);"
            },
            {
              "variable": "Generate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_method);\n    }\n  /*\n    Generate text chunks after I"
            },
            {
              "variable": "Don",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "exception);\n\n      /* Don't write any \"png:\""
            },
            {
              "variable": "Suppress",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0) &&\n\n\n          /* Suppress density and units i"
            },
            {
              "variable": "Suppress",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= 0) &&\n\n          /* Suppress the IM-generated Da"
            },
            {
              "variable": "write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age);\n    }\n  }\n\n  /* write any PNG-chunk-e pro"
            },
            {
              "variable": "write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nk-e\",logging);\n\n  /* write exIf profile */\n  i"
            },
            {
              "variable": "name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char\n        *name;\n\n      ResetImageP"
            },
            {
              "variable": "profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gInfo\n              *profile;\n\n            profi"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n                  *data;\n\n               St"
            },
            {
              "variable": "ping_profile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fo\n                 *ping_profile;\n\n               (v"
            },
            {
              "variable": "otherwise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;  /* otherwise crashes */"
            },
            {
              "variable": "skip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n               /* skip the \"Exif\\0\\0\" JFIF"
            },
            {
              "variable": "Write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nk[32];\n\n          /*\n            Write FRAM 4 with clippin"
            },
            {
              "variable": "data",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ULong(image,27L);  /* data length=27 */"
            },
            {
              "variable": "frame",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[5]=0;  /* frame name separator (no"
            },
            {
              "variable": "flag",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[6]=1;  /* flag for changing delay,"
            },
            {
              "variable": "flag",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[7]=0;  /* flag for changing frame"
            },
            {
              "variable": "flag",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[8]=1;  /* flag for changing frame"
            },
            {
              "variable": "flag",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[9]=0;  /* flag for changing frame"
            },
            {
              "variable": "temporary",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_uint_32) (0L)); /* temporary 0 delay */"
            },
            {
              "variable": "clipping",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk[14]=0; /* clipping boundaries delta ty"
            },
            {
              "variable": "left",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_info->page.x)); /* left cb */\n          PNG"
            },
            {
              "variable": "top",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng_info->page.y)); /* top cb */\n          PNG"
            },
            {
              "variable": "Free",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */"
            },
            {
              "variable": "Store",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oyImage(image);\n\n  /* Store bit depth actually"
            },
            {
              "variable": "Throwing",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lock. Revert to\n    *    Throwing an Exception when a"
            },
            {
              "variable": "End",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn(MagickTrue);\n/*  End write one PNG image"
            },
            {
              "variable": "im_vers",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ption)\n{\n  char\n    im_vers[32],\n    libpng_runv[32"
            },
            {
              "variable": "libpng_runv",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32"
            },
            {
              "variable": "libpng_vers",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ibpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],"
            },
            {
              "variable": "zlib_runv",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ibpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];"
            },
            {
              "variable": "zlib_vers",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *imag"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e_info;\n\n  char\n    s[2];\n\n  const char"
            },
            {
              "variable": "ping_trans_alpha",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "v;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n\n  png_color\n     palette[257];\n\n  png_color_16"
            },
            {
              "variable": "sRGB_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "for (icheck=0; sRGB_info[icheck].len > 0; icheck++)"
            },
            {
              "variable": "sRGB_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (length == sRGB_info[icheck].len)"
            },
            {
              "variable": "sRGB_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (profile_crc == sRGB_info[icheck].crc)"
            },
            {
              "variable": "sRGB_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "sRGB_info[icheck].intent));"
            },
            {
              "variable": "sRGB_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "sRGB_info[icheck].intent);"
            },
            {
              "variable": "sRGB_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (sRGB_info[icheck].len == 0)"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "04PacketRGBO(image->colormap[i]);\n             }"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "02PacketRGBO(image->colormap[i]);\n             }"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "01PacketRGBO(image->colormap[i]);\n             }"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "PixelInfo\n     opaque[260],\n     semitranspare"
            },
            {
              "variable": "semitransparent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "opaque[260],\n     semitransparent[260],\n     transparent[2"
            },
            {
              "variable": "transparent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "nsparent[260],\n     transparent[260];\n\n   register const"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].red,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].green,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].blue,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].alpha);\n         }"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].red,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].green,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].blue,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].alpha);"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "opaque[0].alpha=OpaqueAlpha;"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "opaque[i].alpha=OpaqueAlpha;"
            },
            {
              "variable": "semitransparent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "semitransparent[i].alpha)"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n             if (opaque[i].red == image->backg"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&&\n                 opaque[i].green == image->bac"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&&\n                 opaque[i].blue == image->back"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n               opaque[i] = image->background"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ixelInfo\n           colormap[260];\n\n         /*"
            },
            {
              "variable": "transparent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "colormap[n++] = transparent[i];\n\n         for (i=0"
            },
            {
              "variable": "semitransparent",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "colormap[n++] = semitransparent[i];\n\n         for (i=0"
            },
            {
              "variable": "opaque",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "colormap[n++] = opaque[i];\n\n         ping_bac"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (colormap[i].red != colormap[i]."
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(colormap[i].red != colormap[i].green ||"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "colormap[i].red != colormap[i]."
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "colormap[i].red != colormap[i].blue)"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (colormap[i].red != 0 && colorma"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "rmap[i].red != 0 && colormap[i].red != QuantumRange"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i] = colormap[i];"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "mage->colormap[i] = colormap[i];\n\n            if (l"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].alpha == GetPixelAl"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].red == GetPixelRed("
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].green == GetPixelGr"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].blue == GetPixelBlu"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].red,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].green,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].blue,"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) image->colormap[i].alpha);"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].alpha ="
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(image->colormap[i].alpha > Transparent"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "R04PacketRGB(image->colormap[i]);\n          }"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "R03PacketRGB(image->colormap[i]);\n          }"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "02PacketBlue(image->colormap[i]);\n          }"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].red) == 0x49 &&"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].green) == 0x00 &&"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].blue) == 0x00)"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].red=ScaleCharToQuan"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ssuming that image->colormap[0] is the one transpar"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (image->colormap[i].red == image->color"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ap[i].red == image->colormap[0].red &&"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].green == image->col"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[i].green == image->colormap[0].green &&"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "image->colormap[i].blue == image->colo"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "p[i].blue == image->colormap[0].blue)"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "++)\n      {\n        palette[i].red=ScaleQuantumToC"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].red);\n        palet"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ap[i].red);\n        palette[i].green=ScaleQuantumT"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].green);\n        pal"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[i].green);\n        palette[i].blue=ScaleQuantumTo"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].blue);\n        if ("
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(long) i,palette[i].red,palette[i].gree"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "g) i,palette[i].red,palette[i].green,palette[i].bl"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ed,palette[i].green,palette[i].blue);\n\n      }"
            },
            {
              "variable": "ping_trans_alpha",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "g_background,image->colormap[i]))\n            break"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "antumToShort(image->colormap[0].red) & mask);"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "antumToShort(image->colormap[0].green) & mask);"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "antumToShort(image->colormap[0].blue) & mask);"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].red);"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n                  palette[i].red=ScaleQuantumToC"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].red);"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n                  palette[i].green="
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].green);"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n                  palette[i].blue=ScaleQuantumTo"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].blue);"
            },
            {
              "variable": "ping_trans_alpha",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ping_trans_alpha[i]= (png_byte)"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uantumToChar(image->colormap[i].alpha);"
            },
            {
              "variable": "colormap",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ground_color,image->colormap[i]))\n            break"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) palette[i].red,"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) palette[i].green,"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) palette[i].blue,"
            },
            {
              "variable": "ping_trans_alpha",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) ping_trans_alpha[i]);\n             else"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) palette[i].red,"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) palette[i].green,"
            },
            {
              "variable": "palette",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int) palette[i].blue);\n           }"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ed char\n            chunk[20];\n\n          (void)"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ed char\n            chunk[14];\n\n          (void)"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ".height);\n          chunk[12]=0;   /* unit = pixe"
            },
            {
              "variable": "ping_pixels",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "\"  ping_pixels[0]=%d,ping_pixels[1]=%"
            },
            {
              "variable": "ping_pixels",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ping_pixels[0]=%d,ping_pixels[1]=%d\","
            },
            {
              "variable": "ping_pixels",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(int)ping_pixels[0],(int)ping_pixels[1]"
            },
            {
              "variable": "ping_pixels",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ping_pixels[0],(int)ping_pixels[1]);"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "#endif\n            text[0].key=(char *) proper"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "operty;\n            text[0].text=(char *) value"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "value;\n            text[0].text_length=strlen("
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "lse)\n               text[0].compression=PNG_TEX"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "lse)\n               text[0].compression=PNG_TEX"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n               text[0].compression=image_i"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&&\n                 text[0].text_length < 128)"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "\"    keyword: '%s'\",text[0].key);"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "r\n                  chunk[4],"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ed char\n            chunk[32];\n\n          /*"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "RAM,27L);\n          chunk[4]=4;\n          chunk["
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "unk[4]=4;\n          chunk[5]=0;  /* frame name s"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "name) */\n          chunk[6]=1;  /* flag for cha"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e only */\n          chunk[7]=0;  /* flag for cha"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "imeout */\n          chunk[8]=1;  /* flag for cha"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "frame */\n          chunk[9]=0;  /* flag for cha"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "delay */\n          chunk[14]=0; /* clipping boun"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tually written */\n  s[0]=(char) ping_bit_dep"
            },
            {
              "variable": "s",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ") ping_bit_depth;\n  s[1]='\\0';\n\n  (void) Set"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 91,
        "pointer_count": 54,
        "array_count": 18,
        "size_variable_count": 25
      }
    },
    "predict": "{\"vulnerable_variables\": [\"text\"]}",
    "vulnerable_variables": [
      "text"
    ],
    "vulnerable_variable": "text",
    "variable_definitions": {
      "text": "png_textp"
    },
    "variable_types": {
      "text": "struct pointer"
    },
    "type_mapping": {
      "text": "struct pointer"
    }
  },
  {
    "idx": 160153,
    "project": "oniguruma",
    "commit_id": "b690371bbf97794b4a1d3f295d4fb9a8b05d402d",
    "project_url": "https://github.com/kkos/oniguruma",
    "commit_url": "https://github.com/kkos/oniguruma/commit/b690371bbf97794b4a1d3f295d4fb9a8b05d402d",
    "commit_message": "fix #59 : access to invalid address by reg->dmax value",
    "label": 0,
    "func": "forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n     }\n     else {\n       if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n         }\n         else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n         }\n       }\n     }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n",
    "func_hash": 29297642222852118297597184806129854704,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-9229",
    "cve_desc": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A SIGSEGV occurs in left_adjust_char_head() during regular expression compilation. Invalid handling of reg->dmax in forward_search_range() could result in an invalid pointer dereference, normally as an immediate denial-of-service condition.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9229",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "high",
          "str",
          "reg",
          "range",
          "s",
          "q",
          "low_prev",
          "end",
          "p",
          "prev"
        ],
        "arrays": [],
        "size_variables": [
          "enclen"
        ],
        "all_variables": [
          "high",
          "str",
          "reg",
          "range",
          "s",
          "q",
          "low_prev",
          "end",
          "enclen",
          "p",
          "prev"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIG"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "IGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg-"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">enc)) {\n      p += reg->dmin;\n    }\n    else {"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UChar *q = p + reg->dmin;\n\n      if (q >= en"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n re"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "retry:\n  switch (reg->optimize) {\n  case ONIG_OPTI"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p = slow_search(reg->enc, reg->exact, reg->e"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ow_search(reg->enc, reg->exact, reg->exact_end, p,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "g->enc, reg->exact, reg->exact_end, p, end, range);"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p = slow_search_ic(reg->enc, reg->case_fold_fla"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "search_ic(reg->enc, reg->case_fold_flag,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reg->exact, reg->exact_end, p,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reg->exact, reg->exact_end, p, end, range);"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p = bm_search(reg, reg->exact, reg->exact_end, p,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ch(reg, reg->exact, reg->exact_end, p, end, range);"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_search_notrev(reg, reg->exact, reg->exact_end, p,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ev(reg, reg->exact, reg->exact_end, p, end, range);"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p = map_search(reg->enc, reg->map, p, range"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ap_search(reg->enc, reg->map, p, range);\n    bre"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ange) {\n    if (p - reg->dmin < s) {\n    retry_ga"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n      p += enclen(reg->enc, p);\n      goto ret"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "try;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* pre"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rev;\n\n      switch (reg->sub_anchor) {\n      case ANCHO"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GENC_IS_MBC_NEWLINE(reg->enc, prev, end))"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GENC_IS_MBC_NEWLINE(reg->enc, prev, end))"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n    if (reg->dmax == 0) {\n      *low"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc, s, p);\n        els"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else {\n       if (reg->dmax != ONIG_INFINITE_DI"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (p - str < reg->dmax) {\n          *low ="
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc, str, *low);"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*low = p - reg->dmax;\n          if (*low"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char_head_with_prev(reg->enc, s,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_get_prev_char_head(reg->enc,"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int )(*high - str), reg->dmin, reg->dmax);\n#endif"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "- str), reg->dmin, reg->dmax);\n#endif\n    return"
            },
            {
              "variable": "reg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "search_range(regex_t* reg, const UChar* str,"
            },
            {
              "variable": "str",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_t* reg, const UChar* str, const UChar* end,"
            },
            {
              "variable": "end",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ar* str, const UChar* end, UChar* s,\n\t\t     U"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st UChar* end, UChar* s,\n\t\t     UChar* rang"
            },
            {
              "variable": "range",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "har* s,\n\t\t     UChar* range, UChar** low, UChar"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UChar* range, UChar** low, UChar** high, UCha"
            },
            {
              "variable": "high",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UChar** low, UChar** high, UChar** low_prev)"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "UChar** high, UChar** low_prev)\n{\n  UChar *p, *ppr"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "low_prev)\n{\n  UChar *p, *pprev = (UChar* )"
            },
            {
              "variable": "pprev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#"
            },
            {
              "variable": "q",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else {\n      UChar *q = p + reg->dmin;"
            },
            {
              "variable": "fail",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">= end) return 0; /* fail */\n      while (p <"
            },
            {
              "variable": "prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nchor) {\n      UChar* prev;\n\n      switch (reg"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">dmax == 0) {\n      *low = p;\n      if (low_"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "prev) {\n        if (*low > s)\n          *low"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*low > s)\n          *low_prev = onigenc_get_prev_"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else\n          *low_prev = onigenc_get_prev_"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->dmax) {\n          *low = (UChar* )str;"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "w_prev)\n            *low_prev = onigenc_get_prev_"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "head(reg->enc, str, *low);\n         }"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "else {\n          *low = p - reg->dmax;"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dmax;\n          if (*low > s) {"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "> s) {\n            *low = onigenc_get_right"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*low, (const UChar** )lo"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "low_prev && IS_NULL(*low_prev))\n              *lo"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rev))\n              *low_prev = onigenc_get_prev_"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pprev ? pprev : s), *low);\n          }"
            },
            {
              "variable": "low_prev",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "prev)\n              *low_prev = onigenc_get_prev_"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rev ? pprev : str), *low);\n          }"
            },
            {
              "variable": "no",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n     }\n    /* no needs to adjust *hi"
            },
            {
              "variable": "high",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "no needs to adjust *high, *high is used as r"
            },
            {
              "variable": "high",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ds to adjust *high, *high is used as range ch"
            },
            {
              "variable": "high",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e check only */\n    *high = p - reg->dmin;\n\n#"
            },
            {
              "variable": "low",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "%d\\n\",\n\t    (int )(*low - str), (int )(*hig"
            },
            {
              "variable": "high",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*low - str), (int )(*high - str), reg->dmin,"
            },
            {
              "variable": "success",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ndif\n    return 1; /* success */\n  }\n\n  return 0;"
            },
            {
              "variable": "fail",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/\n  }\n\n  return 0; /* fail */\n}"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 11,
        "pointer_count": 10,
        "array_count": 0,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\":[\"reg\"]}",
    "vulnerable_variables": [
      "reg"
    ],
    "vulnerable_variable": "reg",
    "variable_definitions": {
      "reg": "regex_t* reg"
    },
    "variable_types": {
      "reg": "struct pointer"
    },
    "type_mapping": {
      "reg": "struct pointer"
    }
  },
  {
    "idx": 160156,
    "project": "linux",
    "commit_id": "9933e113c2e87a9f46a40fde8dafbf801dca1ab9",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9933e113c2e87a9f46a40fde8dafbf801dca1ab9",
    "commit_message": "crypto: skcipher - Add missing API setkey checks\n\nThe API setkey checks for key sizes and alignment went AWOL during the\nskcipher conversion.  This patch restores them.\n\nCc: <stable@vger.kernel.org>\nFixes: 4e6c3df4d729 (\"crypto: skcipher - Add low-level skcipher...\")\nReported-by: Baozeng <sploving1@gmail.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
    "label": 0,
    "func": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n \n\tskcipher->setkey = skcipher_setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}\n",
    "func_hash": 97835912823249892703274804410553838691,
    "file_name": "skcipher.c",
    "file_hash": 184424225580849190280796606900972535359,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-9211",
    "cve_desc": "The crypto_skcipher_init_tfm function in crypto/skcipher.c in the Linux kernel through 4.11.2 relies on a setkey function that lacks a key-size check, which allows local users to cause a denial of service (NULL pointer dereference) via a crafted application.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9211",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "alg",
          "tfm",
          "skcipher"
        ],
        "arrays": [],
        "size_variables": [
          "ivsize",
          "max_keysize",
          "keysize"
        ],
        "all_variables": [
          "tfm",
          "skcipher",
          "alg",
          "keysize",
          "max_keysize",
          "ivsize"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "tfm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypt"
            },
            {
              "variable": "tfm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypt"
            },
            {
              "variable": "tfm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ipher_type ||\n \t    tfm->__crt_alg->cra_type == &crypt"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ablkcipher(tfm);\n \n\tskcipher->setkey = skcipher_setkey;"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skcipher_setkey;\n \tskcipher->encrypt = alg->encrypt;\n \ts"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skcipher->encrypt = alg->encrypt;\n \tskcipher->decryp"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \ts"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n\tskc"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skcipher->ivsize = alg->ivsize;\n\tskcipher->keysize"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "skcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.e"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (alg->exit)\n\t\tskcipher->base.exit = crypto_skcip"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "her_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn"
            },
            {
              "variable": "tfm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m(struct crypto_tfm *tfm)\n{\n\tstruct crypto_s"
            },
            {
              "variable": "skcipher",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uct crypto_skcipher *skcipher = __crypto_skcipher"
            },
            {
              "variable": "alg",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct skcipher_alg *alg = crypto_skcipher_a"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 3,
        "array_count": 0,
        "size_variable_count": 3
      }
    },
    "predict": "{\"vulnerable_variables\": [\"keysize\"]}",
    "vulnerable_variables": [
      "keysize"
    ],
    "vulnerable_variable": "keysize",
    "variable_definitions": {
      "keysize": "Definition not found"
    },
    "variable_types": {
      "keysize": "struct pointer_integer"
    },
    "type_mapping": {
      "keysize": "sp_integer"
    }
  },
  {
    "idx": 160223,
    "project": "libav",
    "commit_id": "fe6eea99efac66839052af547426518efd970b24",
    "project_url": "https://github.com/libav/libav",
    "commit_url": "https://github.com/libav/libav/commit/fe6eea99efac66839052af547426518efd970b24",
    "commit_message": "nsvdec: don't ignore the return value of av_get_packet()\n\nFixes invalid reads with corrupted files.\n\nCC: libav-stable@libav.org\nBug-Id: 1039",
    "label": 0,
    "func": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n    int ret;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                        bps, channels, samplerate);\n             }\n         }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n",
    "func_hash": 7951642061843571098731453623555073803,
    "file_name": "nsvdec.c",
    "file_hash": 58686573162961861326892957329633773118,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-9051",
    "cve_desc": "libav before 12.1 is vulnerable to an invalid read of size 1 due to NULL pointer dereferencing in the nsv_read_chunk function in libavformat/nsvdec.c.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9051",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "s",
          "pb",
          "nsv",
          "st",
          "pkt",
          "nst"
        ],
        "arrays": [
          "st",
          "data",
          "streams",
          "ahead"
        ],
        "size_variables": [
          "asize",
          "num",
          "vsize",
          "auxcount",
          "sizeof",
          "auxsize",
          "number"
        ],
        "all_variables": [
          "asize",
          "num",
          "s",
          "pb",
          "streams",
          "vsize",
          "nsv",
          "auxcount",
          "number",
          "sizeof",
          "data",
          "auxsize",
          "st",
          "pkt",
          "nst",
          "ahead"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NSVContext *nsv = s->priv_data;\n    AVIOContext *p"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "AVIOContext *pb = s->pb;\n    AVStream *st[2"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int ret;\n \n     if (nsv->ahead[0].data || nsv->ahe"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "v->ahead[0].data || nsv->ahead[1].data)\n         r"
            },
            {
              "variable": "pb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hunk_retry:\n    if (pb->eof_reached)\n        return -1;"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS &&"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return err;\n    if (nsv->state == NSV_FOUND_NSVS)"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return err;\n    if (nsv->state != NSV_HAS_READ_NSV"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)"
            },
            {
              "variable": "pb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d */\n    }\n\n    if (pb->eof_reached)\n        return -1;"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "& !asize) {\n        nsv->state = NSV_UNSYNC;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s to v,a */\n    if (s->nb_streams > 0)\n        st[s->"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ams > 0)\n        st[s->streams[0]->id] = s->stream"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->streams[0]->id] = s->streams[0];\n    if (s->nb_s"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "streams[0];\n    if (s->nb_streams > 1)\n        st[s->"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ams > 1)\n        st[s->streams[1]->id] = s->stream"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->streams[1]->id] = s->streams[1];\n\n     if (vsize"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ta;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn ret;\n         pkt->stream_index = st[NSV_ST_VIDEO]-"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_ST_VIDEO;\n         pkt->dts = nst->frame_offset"
            },
            {
              "variable": "nst",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pkt->dts = nst->frame_offset;\n         pkt->flag"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "me_offset;\n         pkt->flags |= nsv->state == NS"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pkt->flags |= nsv->state == NSV_HAS_READ_NSV"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "i, pkt->data[i]);\n    }\n    if(s"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ata;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];"
            },
            {
              "variable": "codecpar",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "& st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C',"
            },
            {
              "variable": "codecpar",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U"
            },
            {
              "variable": "codecpar",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st[NSV_ST_AUDIO]->codecpar->channels = channels;"
            },
            {
              "variable": "codecpar",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn ret;\n         pkt->stream_index = st[NSV_ST_AUDIO]-"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_ST_AUDIO;\n         pkt->flags |= nsv->state == NS"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pkt->flags |= nsv->state == NSV_HAS_READ_NSV"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ame */\n         if( nsv->state == NSV_HAS_READ_NSV"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sync */\n            pkt->dts = (((NSVStream*)st["
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "set-1);\n            pkt->dts *= (int64_t)1000"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t64_t)1000        * nsv->framerate.den;\n            pk"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "te.den;\n            pkt->dts += (int64_t)nsv->av"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kt->dts += (int64_t)nsv->avsync * nsv->framerate.nu"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t64_t)nsv->avsync * nsv->framerate.num;\n            av"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nsv->avsync, pkt->dts);"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nsv->avsync, pkt->dts);\n        }"
            },
            {
              "variable": "nst",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ffset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    r"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "unk(AVFormatContext *s, int fill_header)\n{"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "r)\n{\n    NSVContext *nsv = s->priv_data;"
            },
            {
              "variable": "pb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ta;\n    AVIOContext *pb = s->pb;\n    AVStre"
            },
            {
              "variable": "st",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s->pb;\n    AVStream *st[2] = {NULL, NULL};"
            },
            {
              "variable": "nst",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ULL};\n    NSVStream *nst;\n    AVPacket *pkt;"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*nst;\n    AVPacket *pkt;\n    int i, err = 0"
            },
            {
              "variable": "number",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uint8_t auxcount; /* number of aux metadata, al"
            },
            {
              "variable": "hey",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return 0; //-1; /* hey! eat what you've in"
            },
            {
              "variable": "skip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "vsize, asize);\n    /* skip aux stuff */\n    fo"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sizeof(uint32_t); /* that's becoming brain-de"
            },
            {
              "variable": "map",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_retry;\n    }\n\n    /* map back streams to v,a"
            },
            {
              "variable": "keyframe",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_PKT_FLAG_KEY : 0; /* keyframe only likely on a sy"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ST_AUDIO];\n        /* read raw audio specific"
            },
            {
              "variable": "on",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hunk... */\n        /* on ALL audio chunks ??"
            },
            {
              "variable": "we",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "STREAM_PARSE_NONE; /* we know everything */"
            },
            {
              "variable": "UGH",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "samplerate /= 4;/* UGH ??? XXX */"
            },
            {
              "variable": "keyframe",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_PKT_FLAG_KEY : 0; /* keyframe only likely on a sy"
            },
            {
              "variable": "on",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "O] ) {\n            /* on a nsvs frame we hav"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int64_t)1000        * nsv->framerate.den;"
            },
            {
              "variable": "nsv",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int64_t)nsv->avsync * nsv->framerate.num;"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "->pb;\n    AVStream *st[2] = {NULL, NULL};"
            },
            {
              "variable": "ahead",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "et;\n \n     if (nsv->ahead[0].data || nsv->ahead["
            },
            {
              "variable": "ahead",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ead[0].data || nsv->ahead[1].data)\n         retu"
            },
            {
              "variable": "streams",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "> 0)\n        st[s->streams[0]->id] = s->streams[0"
            },
            {
              "variable": "streams",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "treams[0]->id] = s->streams[0];\n    if (s->nb_stre"
            },
            {
              "variable": "streams",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "> 1)\n        st[s->streams[1]->id] = s->streams[1"
            },
            {
              "variable": "streams",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "treams[1]->id] = s->streams[1];\n\n     if (vsize &&"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (vsize && st[NSV_ST_VIDEO]) {\n         nst = s"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;"
            },
            {
              "variable": "ahead",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret ="
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VID"
            },
            {
              "variable": "data",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "i, pkt->data[i]);\n    }\n    if(st[N"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "a[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStrea"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "O]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;"
            },
            {
              "variable": "ahead",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read ra"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (asize && st[NSV_ST_AUDIO]->codecpar->codec_ta"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ") {\n                st[NSV_ST_AUDIO]->need_parsing = AVS"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "st[NSV_ST_AUDIO]->codecpar->codec_id"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "1;\n                st[NSV_ST_AUDIO]->codecpar->channels"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ls;\n                st[NSV_ST_AUDIO]->codecpar->sample_r"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUD"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "SV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /*"
            },
            {
              "variable": "st",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 16,
        "pointer_count": 6,
        "array_count": 4,
        "size_variable_count": 7
      }
    },
    "predict": "{\"vulnerable_variables\": [\"vsize\"]}",
    "vulnerable_variables": [
      "vsize"
    ],
    "vulnerable_variable": "vsize",
    "variable_definitions": {
      "vsize": "uint32_t vsize;"
    },
    "variable_types": {
      "vsize": "integer"
    },
    "type_mapping": {
      "vsize": "Integer"
    }
  },
  {
    "idx": 160229,
    "project": "libetpan",
    "commit_id": "1fe8fbc032ccda1db9af66d93016b49c16c1f22d",
    "project_url": "https://github.com/dinhviethoa/libetpan",
    "commit_url": "https://github.com/dinhviethoa/libetpan/commit/1fe8fbc032ccda1db9af66d93016b49c16c1f22d",
    "commit_message": "Fixed crash #274",
    "label": 0,
    "func": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n   struct mailimf_group * group;\n   int r;\n   int res;\n  clist * list;\n \n   cur_token = * indx;\n \n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n       res = r;\n       goto free_display_name;\n     }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n     break;\n   default:\n     res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}\n",
    "func_hash": 248198546306903348686389947535018213451,
    "file_name": "mailimf.c",
    "file_hash": 46172292755855096048078809940458478908,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-8825",
    "cve_desc": "A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-8825",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "indx",
          "message",
          "display_name",
          "group",
          "mailbox_list",
          "list"
        ],
        "arrays": [],
        "size_variables": [
          "size_t",
          "length"
        ],
        "all_variables": [
          "indx",
          "message",
          "length",
          "size_t",
          "display_name",
          "group",
          "mailbox_list",
          "list"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "message",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "up_parse(const char * message, size_t length,"
            },
            {
              "variable": "indx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "h,\n\t\t\t       size_t * indx,\n\t\t\t       struct m"
            },
            {
              "variable": "result",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ruct mailimf_group ** result)\n{\n  size_t cur_tok"
            },
            {
              "variable": "display_name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t cur_token;\n  char * display_name;\n  struct mailimf_m"
            },
            {
              "variable": "indx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t;\n \n   cur_token = * indx;\n \n  mailbox_list ="
            },
            {
              "variable": "indx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ailbox_list;\n  }\n\n  * indx = cur_token;\n  * re"
            },
            {
              "variable": "result",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "indx = cur_token;\n  * result = group;\n\n  return"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 8,
        "pointer_count": 6,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"mailbox_list\"]}",
    "vulnerable_variables": [
      "mailbox_list"
    ],
    "vulnerable_variable": "mailbox_list",
    "variable_definitions": {
      "mailbox_list": "struct mailimf_mailbox_list * mailbox_list;"
    },
    "variable_types": {
      "mailbox_list": "struct pointer"
    },
    "type_mapping": {
      "mailbox_list": "struct pointer"
    }
  },
  {
    "idx": 160293,
    "project": "radare2",
    "commit_id": "7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf",
    "project_url": "https://github.com/radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf",
    "commit_message": "Fix #7152 - Null deref in cms",
    "label": 0,
    "func": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}\n",
    "func_hash": 83242632775142770247509294112025144935,
    "file_name": "r_pkcs7.c",
    "file_hash": 130413232395949982846642727901028945384,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-7274",
    "cve_desc": "The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-7274",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "buffer",
          "object",
          "r_pkcs7_parse_cms",
          "container"
        ],
        "arrays": [
          "objects"
        ],
        "size_variables": [
          "length"
        ],
        "all_variables": [
          "length",
          "container",
          "buffer",
          "r_pkcs7_parse_cms",
          "objects",
          "object"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "h);\n\tif (!object || object->list.length != 2 || !obj"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ist.length != 2 || !object->list.objects ||\n\t\t!objec"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">list.objects ||\n\t\t!object->list.objects[0] || !obje"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "list.objects[0] || !object->list.objects[1] ||\n\t\tobj"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ist.objects[1] ||\n\t\tobject->list.objects[1]->list.le"
            },
            {
              "variable": "container",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "asn1_stringify_oid (object->list.objects[0]->sector,"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "objects[0]->sector, object->list.objects[0]->length)"
            },
            {
              "variable": "container",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_parse_signeddata (&container->signedData, object->list.objec"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tainer->signedData, object->list.objects[1]->list.ob"
            },
            {
              "variable": "r_pkcs7_parse_cms",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer,"
            },
            {
              "variable": "buffer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "arse_cms (const ut8 *buffer, ut32 length) {\n\tRA"
            },
            {
              "variable": "object",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gth) {\n\tRASN1Object *object;\n\tRCMS *container;"
            },
            {
              "variable": "container",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ject *object;\n\tRCMS *container;\n\tif (!buffer || !l"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "||\n\t\t!object->list.objects[0] || !object->list.ob"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "0] || !object->list.objects[1] ||\n\t\tobject->list.o"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "] ||\n\t\tobject->list.objects[1]->list.length != 1)"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "y_oid (object->list.objects[0]->sector, object->li"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ector, object->list.objects[0]->length);\n\tr_pkcs7_"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "dData, object->list.objects[1]->list.objects[0]);"
            },
            {
              "variable": "objects",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "st.objects[1]->list.objects[0]);\n\tr_asn1_free_obje"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 4,
        "array_count": 1,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\": [\"objects\"]}",
    "vulnerable_variables": [
      "objects"
    ],
    "vulnerable_variable": "objects",
    "variable_definitions": {
      "objects": "Definition not found"
    },
    "variable_types": {
      "objects": "struct pointer array"
    },
    "type_mapping": {
      "objects": "struct pointer array"
    }
  },
  {
    "idx": 160325,
    "project": "ImageMagick",
    "commit_id": "d31fec57e9dfb0516deead2053a856e3c71e9751",
    "project_url": "https://github.com/ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/d31fec57e9dfb0516deead2053a856e3c71e9751",
    "commit_message": "None",
    "label": 0,
    "func": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n   }\n \n   (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n}\n",
    "func_hash": 333919329295391241590879679806368893963,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-6501",
    "cve_desc": "An issue was discovered in ImageMagick 6.9.7. A specially crafted xcf file could lead to a NULL pointer dereference.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6501",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "next",
          "ReadXCFImage",
          "image",
          "paths",
          "read",
          "sizeof",
          "3",
          "image_info",
          "num_colours",
          "layer_info",
          "exception",
          "p",
          "of"
        ],
        "arrays": [
          "unit_string",
          "magick",
          "cmap",
          "layer_info",
          "buf"
        ],
        "size_variables": [
          "number_scenes",
          "ssize_t",
          "length",
          "file_size",
          "prop_size",
          "ReadBlobStringWithLongSize",
          "count",
          "size_t",
          "num_successful_elements",
          "blending",
          "gssize_t",
          "sizeof",
          "filename",
          "LocaleNCompare",
          "GetBlobSize",
          "num_colours",
          "number_layers",
          "num_cols"
        ],
        "all_variables": [
          "size_t",
          "unit_string",
          "blending",
          "read",
          "3",
          "image_info",
          "next",
          "ssize_t",
          "file_size",
          "ReadXCFImage",
          "num_successful_elements",
          "paths",
          "cmap",
          "num_colours",
          "exception",
          "num_cols",
          "length",
          "ReadBlobStringWithLongSize",
          "count",
          "gssize_t",
          "filename",
          "LocaleNCompare",
          "layer_info",
          "GetBlobSize",
          "number_layers",
          "of",
          "number_scenes",
          "prop_size",
          "image",
          "sizeof",
          "magick",
          "buf",
          "p"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*) NULL);\n  assert(image_info->signature == MagickSignature)"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ckSignature);\n  if (image_info->debug != MagickFalse)"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "odule(),\"%s\",\n      image_info->filename);\n  assert(exceptio"
            },
            {
              "variable": "exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*) NULL);\n  assert(exception->signature == MagickSignature)"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "attributes.\n  */\n  image->columns=doc_info.width;\n  i"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s=doc_info.width;\n  image->rows=doc_info.height;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tBlobSize(image);\n  image->compression=NoCompression;\n  im"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "on=NoCompression;\n  image->depth=8;\n  status=SetImag"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "etImageExtent(image,image->columns,image->rows);\n  if"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage,image->columns,image->rows);\n  if (status == M"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xception(exception,&image->exception);\n      return(Dest"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "== GIMP_GRAY)\n      image->colorspace=GRAYColorspace;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ThrowFileException(&image->exception,CorruptImageError,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nexpectedEndOfFile\",image->filename);\n    /*\n      if ("
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n    /*\n      if (info->file_version == 0)\n      {"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "le map.\"));\n        info->cp +=\n          xcf_re"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xcf_read_int32 (info->fp, (guint32*) &gimage"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fo->fp, (guint32*) &gimage->num_cols, 1);\n        gimage"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_cols, 1);\n        gimage->cmap = g_new (guchar, gi"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ap = g_new (guchar, gimage->num_cols*3);\n        xcf_see"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xcf_seek_pos (info, info->cp + gimage->num_cols)"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s (info, info->cp + gimage->num_cols);\n        for (i ="
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for (i = 0; i<gimage->num_cols; i++)\n          {"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n            gimage->cmap[i*3+0] = i;"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0] = i;\n            gimage->cmap[i*3+1] = i;"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1] = i;\n            gimage->cmap[i*3+2] = i;"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lse\n      {\n        info->cp +=\n          xcf_re"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xcf_read_int32 (info->fp, (guint32*) &gimage"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fo->fp, (guint32*) &gimage->num_cols, 1);\n        gimage"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_cols, 1);\n        gimage->cmap = g_new (guchar, gi"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ap = g_new (guchar, gimage->num_cols*3);\n        info->c"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "um_cols*3);\n        info->cp +=\n          xcf_re"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xcf_read_int8 (info->fp,"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(guint8*) gimage->cmap, gimage->num_cols*3"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ThrowFileException(&image->exception,CorruptImageError,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nexpectedEndOfFile\",image->filename);\n      }\n      bre"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e\");\n        xres = gimage->gimp->config->default_xr"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "res = gimage->gimp->config->default_xresolution;\n        yres = gim"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ion;\n        yres = gimage->gimp->config->default_yr"
            },
            {
              "variable": "config",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "res = gimage->gimp->config->default_yresolution;\n        }"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "et :(\n              image->x_resolution = xres;"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xres;\n              image->y_resolution = yres;\n        */"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ThrowFileException(&image->exception,CorruptImageError,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nexpectedEndOfFile\",image->filename);\n        /*"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ze_t         base = info->cp;\n      GimpParasite"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e *p;\n\n      while (info->cp - base < prop_size)"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n      if (info->cp - base != prop_size"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ThrowFileException(&image->exception,CorruptImageError,"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nexpectedEndOfFile\",image->filename);\n\n        /*"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "geHeader\");\n\n  if ((image_info->ping != MagickFalse) &&"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= MagickFalse) && (image_info->number_scenes != 0))\n    {"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nexpectedEndOfFile\",image->filename);\n            break"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xt channel */\n      info->cp += xcf_read_int32 ("
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+= xcf_read_int32 (info->fp, &offset, 1);"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/\n      saved_pos = info->cp;\n\n      /* seek to"
            },
            {
              "variable": "gimage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (channel != gimage->selection_mask)\n        gimp_image"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "== GIMP_GRAY)\n     image->type=GrayscaleType;\n   r"
            },
            {
              "variable": "ReadXCFImage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "static Image *ReadXCFImage(const ImageInfo *im"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age(const ImageInfo *image_info,ExceptionInfo *exce"
            },
            {
              "variable": "exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_info,ExceptionInfo *exception)\n{\n  char\n    magic"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k[14];\n\n  Image\n    *image;\n\n  int\n    foundPr"
            },
            {
              "variable": "Open",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o\n    doc_info;\n\n  /*\n    Open image file.\n  */"
            },
            {
              "variable": "Initialize",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "bMSBLong(image);\n  /*\n    Initialize image attributes."
            },
            {
              "variable": "Read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "undColor(image);\n  /*\n    Read properties.\n  */"
            },
            {
              "variable": "Cannot",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "P:\n      {\n        /* Cannot rely on prop_size h"
            },
            {
              "variable": "num_colours",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ardBlobBytes(image,3*num_colours) == MagickFalse)"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ar, gimage->num_cols*3);\n        xcf_seek_"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gimage->cmap[i*3+0] = i;"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gimage->cmap[i*3+1] = i;"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gimage->cmap[i*3+2] = i;\n          }"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ar, gimage->num_cols*3);\n        info->cp"
            },
            {
              "variable": "3",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ap, gimage->num_cols*3);\n      }\n     */"
            },
            {
              "variable": "just",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ":\n      {\n         /* just skip it - we don't"
            },
            {
              "variable": "float",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "N:\n      {\n        /* float xres = (float) */ ("
            },
            {
              "variable": "float",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng(image);\n        /* float yres = (float) */ ("
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*/\n\n\n        /* BOGUS: we don't write the"
            },
            {
              "variable": "we",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "O:\n      {\n        /* we need to read it, ev"
            },
            {
              "variable": "size_t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nore it */\n        /*size_t  tattoo_state = */"
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "S:\n      {\n        /* BOGUS: we may need these"
            },
            {
              "variable": "gssize_t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "filename);\n        /*\n      gssize_t         base = info"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "GimpParasite *p;\n\n      while (info"
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "T:\n      {\n        /* BOGUS: ignore for now..."
            },
            {
              "variable": "size_t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "or now... */\n      /*size_t unit =  */ (void) R"
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "THS:\n      {\n      /* BOGUS: just skip it for n"
            },
            {
              "variable": "PathList",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ilename);\n\n        /*\n      PathList *paths = xcf_load_b"
            },
            {
              "variable": "paths",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "/*\n      PathList *paths = xcf_load_bzpaths"
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ing[1000];\n        /*BOGUS: ignored for now */"
            },
            {
              "variable": "float",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "for now */\n        /*float  factor = (float) *"
            },
            {
              "variable": "size_t",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ng(image);\n        /* size_t digits =  */ (void)"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e_t amount;\n\n      /* read over it... */"
            },
            {
              "variable": "do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0))\n    {\n      ; /* do nothing, were just"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CFLayerInfo\n        *layer_info;\n\n      /*"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "layer_info;\n\n      /*\n        The read pointer."
            },
            {
              "variable": "restore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",oldPos,SEEK_SET); /* restore the position! */"
            },
            {
              "variable": "allocate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ImageHeader\");\n    /* allocate our array of layer"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ength,\n      sizeof(*layer_info));\n    if (layer_in"
            },
            {
              "variable": "sizeof",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info,0,number_layers*sizeof(XCFLayerInfo));"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "saved_pos;\n\n      /* read in the offset of th"
            },
            {
              "variable": "of",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "re at the end\n      *  of the layer list."
            },
            {
              "variable": "save",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n      /* save the current positio"
            },
            {
              "variable": "next",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "is where the\n      *  next layer offset is sto"
            },
            {
              "variable": "seek",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Blob(image);\n      /* seek to the layer offset"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PixelData\");\n      /* read in the layer */"
            },
            {
              "variable": "restore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ");\n        }\n      /* restore the saved position"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "l be ready to\n      *  read the next offset."
            },
            {
              "variable": "NOTE",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n        /* NOTE: XCF layers are REV"
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "; j--) {\n          /* BOGUS: need to consider l"
            },
            {
              "variable": "only",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo[j].visible ) { /* only visible ones, pleas"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ge );\n\n            /* If we do this, we'll g"
            },
            {
              "variable": "NOTE",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "se\n      {\n        /* NOTE: XCF layers are REV"
            },
            {
              "variable": "now",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ize_t  j;\n\n        /* now reverse the order o"
            },
            {
              "variable": "BOGUS",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "yer_info);\n\n#if 0  /* BOGUS: do we need the cha"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kTrue)\n    {\n      /* read in the offset of th"
            },
            {
              "variable": "of",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "re at the end\n      *  of the channel list."
            },
            {
              "variable": "save",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n\n      /* save the current positio"
            },
            {
              "variable": "next",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "is where the\n      *  next channel offset is s"
            },
            {
              "variable": "seek",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= info->cp;\n\n      /* seek to the channel offs"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "o, offset);\n\n      /* read in the layer */"
            },
            {
              "variable": "add",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "elements++;\n\n      /* add the channel to the"
            },
            {
              "variable": "restore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "annel, -1);\n\n      /* restore the saved position"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "l be ready to\n      *  read the next offset."
            },
            {
              "variable": "magick",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ption)\n{\n  char\n    magick[14];\n\n  Image\n    *imag"
            },
            {
              "variable": "unit_string",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n        char  unit_string[1000];\n        /*BOGUS: i"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "{\n        int buf[16];\n        ssize_t am"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&doc_info,\n        &layer_info[current_layer],current_layer);"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "r; j++)\n            layer_info[j].image=DestroyImage("
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ".image=DestroyImage(layer_info[j].image);\n          l"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "*/\n\n          if ( layer_info[j].visible ) { /* only"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "e, OverCompositeOp, layer_info[j].image,"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "layer_info[j].offset_x, layer_inf"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "r_info[j].offset_x, layer_info[j].offset_y );"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t_y );\n             layer_info[j].image =DestroyImage"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "mage =DestroyImage( layer_info[j].image );"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "QuantizeImage( &qi, layer_info[j].image );"
            },
            {
              "variable": "layer_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "dImageToList(&image,layer_info[j].image);\n      }\n#en"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 33,
        "pointer_count": 13,
        "array_count": 5,
        "size_variable_count": 18
      }
    },
    "predict": "{\"vulnerable_variables\":[]}",
    "vulnerable_variables": [],
    "variable_definitions": {},
    "variable_types": {},
    "type_mapping": {}
  },
  {
    "idx": 160327,
    "project": "ImageMagick",
    "commit_id": "7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94",
    "project_url": "https://github.com/ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94",
    "commit_message": "None",
    "label": 0,
    "func": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          mask->matte=MagickFalse;\n          channel_image=mask;\n        }\n     }\n \n   offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n",
    "func_hash": 125483886699136157546867296341617927954,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-6497",
    "cve_desc": "An issue was discovered in ImageMagick 6.9.7. A specially crafted psd file could lead to a NULL pointer dereference (thus, a DoS).",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6497",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "image",
          "sizes",
          "option",
          "channel_image",
          "layer_info",
          "image_info",
          "psd_info",
          "exception"
        ],
        "arrays": [
          "channel_info"
        ],
        "size_variables": [
          "size_t",
          "ReadPSDRLESizes",
          "filename",
          "sizes",
          "size"
        ],
        "all_variables": [
          "image",
          "size_t",
          "ReadPSDRLESizes",
          "sizes",
          "option",
          "filename",
          "channel_image",
          "layer_info",
          "image_info",
          "psd_info",
          "channel_info",
          "exception",
          "size"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mage *) NULL;\n  if (layer_info->channel_info[channel].type < -1)"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "-mask\");\n      if ((layer_info->channel_info[channel].type != -2"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= -2) ||\n          (layer_info->mask.flags > 2) || ((lay"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ask.flags > 2) || ((layer_info->mask.flags & 0x02) &&"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "SeekBlob(image,layer_info->channel_info[channel].size-2,SEE"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sk=CloneImage(image,layer_info->mask.page.width,"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "age.width,\n         layer_info->mask.page.height,MagickF"
            },
            {
              "variable": "mask",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n          mask->matte=MagickFalse;"
            },
            {
              "variable": "psd_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "elRaw(channel_image,psd_info->channels,\n        layer_info"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->channels,\n        layer_info->channel_info[channel].type,excep"
            },
            {
              "variable": "channel_image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nnel_image,psd_info,channel_image->rows);\n        if (sizes"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ailed\",\n            image->filename);\n        status=Re"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "psd_info,\n          layer_info->channel_info[channel].type,sizes"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "elZip(channel_image,layer_info->channels,\n        layer_info"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->channels,\n        layer_info->channel_info[channel].type,compr"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ompression,\n        layer_info->channel_info[channel].size-2,exc"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"'%s' (ZLIB)\",image->filename);\n#endif\n      brea"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ekBlob(image,offset+layer_info->channel_info[channel].size-2,SEE"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ressImage\",\n        image->filename);\n    }\n  layer_inf"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">filename);\n    }\n  layer_info->mask.image=mask;\n  retur"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eadPSDChannel(Image *image,\n  const ImageInfo"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n  const ImageInfo *image_info,const PSDInfo *psd_"
            },
            {
              "variable": "psd_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_info,const PSDInfo *psd_info,LayerInfo* layer_in"
            },
            {
              "variable": "layer_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*psd_info,LayerInfo* layer_info,\n  const size_t cha"
            },
            {
              "variable": "exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "on,\n  ExceptionInfo *exception)\n{\n  Image\n    *cha"
            },
            {
              "variable": "channel_image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tion)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  Magi"
            },
            {
              "variable": "mask",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*channel_image,\n    *mask;\n\n  MagickOffsetTyp"
            },
            {
              "variable": "option",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char\n        *option;\n      /*\n        I"
            },
            {
              "variable": "Ignore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*option;\n      /*\n        Ignore mask that is not a"
            },
            {
              "variable": "sizes",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ffsetType\n          *sizes;\n\n        sizes=Rea"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ";\n  if (layer_info->channel_info[channel].type < -1)\n    {"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if ((layer_info->channel_info[channel].type != -2) ||"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "b(image,layer_info->channel_info[channel].size-2,SEEK_CUR);"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "layer_info->channel_info[channel].type,exception);"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "layer_info->channel_info[channel].type,sizes,exceptio"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "layer_info->channel_info[channel].type,compression,"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "layer_info->channel_info[channel].size-2,exception);"
            },
            {
              "variable": "channel_info",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ",offset+layer_info->channel_info[channel].size-2,SEEK_SET);"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 13,
        "pointer_count": 8,
        "array_count": 1,
        "size_variable_count": 5
      }
    },
    "predict": "{\"vulnerable_variables\": [\"option\"]}",
    "vulnerable_variables": [
      "option"
    ],
    "vulnerable_variable": "option",
    "variable_definitions": {
      "option": "const char *option;"
    },
    "variable_types": {
      "option": "char pointer"
    },
    "type_mapping": {
      "option": "char pointer"
    }
  },
  {
    "idx": 160359,
    "project": "bitlbee",
    "commit_id": "30d598ce7cd3f136ee9d7097f39fa9818a272441",
    "project_url": "https://github.com/bitlbee/bitlbee",
    "commit_url": "https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441",
    "commit_message": "purple: Fix crash on ft requests from unknown contacts\n\nFollowup to 701ab81 (included in 3.5) which was a partial fix which only\nimproved things for non-libpurple file transfers (that is, just jabber)",
    "label": 0,
    "func": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n",
    "func_hash": 154082361588877421742416951807362844001,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-5668",
    "cve_desc": "bitlbee-libpurple before 3.5.1 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-10189.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5668",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "who",
          "px",
          "buddy",
          "ic",
          "xfer"
        ],
        "arrays": [],
        "size_variables": [
          "size",
          "account",
          "filename"
        ],
        "all_variables": [
          "who",
          "px",
          "account",
          "buddy",
          "ic",
          "filename",
          "xfer",
          "size"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "c = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer"
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *budd"
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= purple_find_buddy(xfer->account, xfer->who);\n\twho ="
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uddy(xfer->account, xfer->who);\n\twho = buddy ? pu"
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer)"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "il cast below. */\n \tpx->ft = imcb_file_send_st"
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif"
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ho, xfer->filename, xfer->size);\n\n\tif (!px->ft) {"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return FALSE;\n\t}\n \tpx->ft->data = px;\n \n \tpx-"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">ft->data = px;\n \n \tpx->ft->accept = prpl_xfer"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xf"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_f"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= prpl_xfer_free;\n\tpx->ft->write_request = pr"
            },
            {
              "variable": "xfer",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_"
            },
            {
              "variable": "ic",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct im_connection *ic = purple_ic_by_pa(x"
            },
            {
              "variable": "px",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ruct prpl_xfer_data *px = xfer->ui_data;\n\tP"
            },
            {
              "variable": "buddy",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;"
            },
            {
              "variable": "who",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*buddy;\n\tconst char *who;\n\n\tbuddy = purple_f"
            },
            {
              "variable": "TODO",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y) : xfer->who;\n\n \t/* TODO(wilmer): After spre"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 8,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 3
      }
    },
    "predict": "{\"vulnerable_variables\": [\"px\"]}",
    "vulnerable_variables": [
      "px"
    ],
    "vulnerable_variable": "px",
    "variable_definitions": {
      "px": "struct prpl_xfer_data *px = xfer->ui_data;"
    },
    "variable_types": {
      "px": "struct pointer"
    },
    "type_mapping": {
      "px": "struct pointer"
    }
  },
  {
    "idx": 160424,
    "project": "jasper",
    "commit_id": "bdfe95a6e81ffb4b2fad31a76b57943695beed20",
    "project_url": "https://github.com/mdadams/jasper",
    "commit_url": "https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20",
    "commit_message": "Fixed another problem with incorrect cleanup of JP2 box data upon error.",
    "label": 0,
    "func": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n \tbox->ops = &jp2_boxinfo_unk.ops;\n\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "func_hash": 197303767499977507565859552304656461905,
    "file_name": "jp2_cod.c",
    "file_hash": 233396642819954459006611521767831373161,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-10250",
    "cve_desc": "The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10250",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "tmpstream",
          "in",
          "box",
          "jp2_box_get",
          "boxinfo"
        ],
        "arrays": [],
        "size_variables": [
          "extlen",
          "length",
          "datalen",
          "sizeof",
          "len",
          "JP2_BOX_HDRLEN"
        ],
        "all_variables": [
          "extlen",
          "length",
          "datalen",
          "tmpstream",
          "JP2_BOX_HDRLEN",
          "in",
          "box",
          "sizeof",
          "jp2_box_get",
          "len",
          "boxinfo"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "destroy it later.\n \tbox->ops = &jp2_boxinfo_unk."
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "jp2_getuint32(in, &box->type)) {\n \t\tgoto error;"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= jp2_boxinfolookup(box->type);\n \tbox->info = box"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ookup(box->type);\n \tbox->info = boxinfo;\n \tbox->l"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG"
            },
            {
              "variable": "boxinfo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ngth=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, bo"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "boxinfo->name, '\"', box->type, box->len\n\t  ));\n\ti"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "me, '\"', box->type, box->len\n\t  ));\n\tif (box->le"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ox->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_g"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->da"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BO"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(fa"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LEN(false);\n\t}\n\tif (box->len != 0 && box->len <"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f (box->len != 0 && box->len < 8) {\n\t\tgoto error"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_S"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e box operations.\n\t\tbox->ops = &boxinfo->ops;"
            },
            {
              "variable": "boxinfo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ions.\n\t\tbox->ops = &boxinfo->ops;\n\n \t\tif (box->ops->"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xinfo->ops;\n\n \t\tif (box->ops->getdata) {\n \t\t\tif"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "etdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmps"
            },
            {
              "variable": "jp2_box_get",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{"
            },
            {
              "variable": "in",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ox_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *bo"
            },
            {
              "variable": "boxinfo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmp"
            },
            {
              "variable": "tmpstream",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "getdata) {\n \t\t\tif ((*box->ops->getdata)(box,"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 11,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 6
      }
    },
    "predict": "{\"vulnerable_variables\": [\"extlen\", \"len\", \"datalen\", \"tmpstream\"]}",
    "vulnerable_variables": [
      "extlen",
      "len",
      "datalen",
      "tmpstream"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "extlen": "uint_fast64_t extlen;",
      "len": "uint_fast32_t len;",
      "datalen": "Definition not found",
      "tmpstream": "jas_stream_t *tmpstream;"
    },
    "variable_types": {
      "extlen": "integer",
      "len": "integer",
      "datalen": "integer",
      "tmpstream": "struct pointer"
    },
    "type_mapping": {
      "extlen": "Integer",
      "len": "Integer",
      "datalen": "Integer",
      "tmpstream": "struct pointer"
    }
  },
  {
    "idx": 160428,
    "project": "jasper",
    "commit_id": "2e82fa00466ae525339754bb3ab0a0474a31d4bd",
    "project_url": "https://github.com/mdadams/jasper",
    "commit_url": "https://github.com/mdadams/jasper/commit/2e82fa00466ae525339754bb3ab0a0474a31d4bd",
    "commit_message": "Fixed an integral type promotion problem by adding a JAS_CAST.\nModified the jpc_tsfb_synthesize function so that it will be a noop for\nan empty sequence (in order to avoid dereferencing a null pointer).",
    "label": 0,
    "func": " int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n\t  jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n",
    "func_hash": 167624567335881304499016138255108404614,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-10248",
    "cve_desc": "The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10248",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "tsfb",
          "a"
        ],
        "arrays": [],
        "size_variables": [
          "numlvls",
          "jpc_tsfb_synthesize2",
          "jpc_tsfb_synthesize",
          "jas_seq2d_size"
        ],
        "all_variables": [
          "tsfb",
          "jas_seq2d_size",
          "jpc_tsfb_synthesize2",
          "jpc_tsfb_synthesize",
          "numlvls",
          "a"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "tsfb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d_t *a)\n {\n\treturn (tsfb->numlvls > 0 && jas_seq2d_si"
            },
            {
              "variable": "tsfb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}"
            },
            {
              "variable": "tsfb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {"
            },
            {
              "variable": "a",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*tsfb, jas_seq2d_t *a)\n {\n\treturn (tsfb->"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 2,
        "array_count": 0,
        "size_variable_count": 4
      }
    },
    "predict": "{\"vulnerable_variables\": [\"numlvls\", \"a\"]}",
    "vulnerable_variables": [
      "numlvls",
      "a"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "numlvls": "Definition not found",
      "a": "jas_seq2d_t *a"
    },
    "variable_types": {
      "numlvls": "struct pointer_integer",
      "a": "struct pointer"
    },
    "type_mapping": {
      "numlvls": "sp_integer",
      "a": "struct pointer"
    }
  },
  {
    "idx": 160432,
    "project": "yara",
    "commit_id": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
    "project_url": "https://github.com/VirusTotal/yara",
    "commit_url": "https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
    "commit_message": "re_lexer: Make reading escape sequences more robust (#586)\n\n* Add test for issue #503\n\n* re_lexer: Make reading escape sequences more robust\n\nThis commit fixes parsing incomplete escape sequences at the end of a\nregular expression and parsing things like \\xxy (invalid hex digits)\nwhich before were silently turned into (char)255.\n\nClose #503\n\n* Update re_lexer.c",
    "label": 0,
    "func": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n    if (!isxdigit(text[3]))\n       return 0;\n   }\n \n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}\n",
    "func_hash": 150218527312276800646595174666455869605,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2017-8294",
    "cve_desc": "libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-8294",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "escaped_char"
        ],
        "arrays": [
          "text"
        ],
        "size_variables": [],
        "all_variables": [
          "escaped_char",
          "text"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "escaped_char",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "scanner,\n    uint8_t* escaped_char)\n{\n  char text[4] ="
            },
            {
              "variable": "escaped_char",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return 0;\n   }\n \n  *escaped_char = escaped_char_valu"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "aped_char)\n{\n  char text[4] = {0, 0, 0, 0};"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "= {0, 0, 0, 0};\n\n   text[0] = '\\\\';\n   text[1]"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yysca"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "yyscanner);\n \n  if (text[1] == EOF || text[1] ="
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(text[1] == EOF || text[1] == 0)\n     return 0"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "return 0;\n \n   if (text[1] == 'x')\n   {\n     t"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yysca"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (!isxdigit(text[2]))\n       return 0;"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "return 0;\n \n     text[3] = RE_YY_INPUT(yysca"
            },
            {
              "variable": "text",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (!isxdigit(text[3]))\n       return 0;"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 2,
        "pointer_count": 1,
        "array_count": 1,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\": []}",
    "vulnerable_variables": [],
    "variable_definitions": {},
    "variable_types": {},
    "type_mapping": {}
  },
  {
    "idx": 160448,
    "project": "bitlbee",
    "commit_id": "701ab8129ba9ea64f569daedca9a8603abad740f",
    "project_url": "https://github.com/bitlbee/bitlbee",
    "commit_url": "https://github.com/bitlbee/bitlbee/commit/701ab8129ba9ea64f569daedca9a8603abad740f",
    "commit_message": "imcb_file_send_start: handle ft attempts from non-existing users",
    "label": 0,
    "func": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n \n\tif (bee->ui->ft_in_start && bu) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;\n\t}\n}\n",
    "func_hash": 96363477977669399126369583556654961651,
    "file_name": "bee_ft.c",
    "file_hash": 79543836780597754761817896918875173502,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-10189",
    "cve_desc": "BitlBee before 3.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10189",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "bu",
          "bee",
          "ic",
          "file_name",
          "imcb_file_send_start",
          "handle"
        ],
        "arrays": [],
        "size_variables": [
          "size_t",
          "file_size"
        ],
        "all_variables": [
          "bu",
          "file_size",
          "size_t",
          "bee",
          "ic",
          "file_name",
          "imcb_file_send_start",
          "handle"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "ic",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e)\n{\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu ="
            },
            {
              "variable": "bee",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ic, handle);\n \n\tif (bee->ui->ft_in_start && bu)"
            },
            {
              "variable": "bee",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& bu) {\n \t\treturn bee->ui->ft_in_start(bee, b"
            },
            {
              "variable": "imcb_file_send_start",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "file_transfer_t *imcb_file_send_start(struct im_connectio"
            },
            {
              "variable": "ic",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct im_connection *ic, char *handle, char"
            },
            {
              "variable": "handle",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "onnection *ic, char *handle, char *file_name, s"
            },
            {
              "variable": "file_name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "char *handle, char *file_name, size_t file_size)"
            },
            {
              "variable": "bee",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ile_size)\n{\n \tbee_t *bee = ic->bee;\n \tbee_us"
            },
            {
              "variable": "bu",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->bee;\n \tbee_user_t *bu = bee_user_by_handl"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 8,
        "pointer_count": 6,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\":[\"bu\"]}",
    "vulnerable_variables": [
      "bu"
    ],
    "vulnerable_variable": "bu",
    "variable_definitions": {
      "bu": "bee_user_t *bu = bee_user_by_handle(bee, ic, handle);"
    },
    "variable_types": {
      "bu": "struct pointer"
    },
    "type_mapping": {
      "bu": "struct pointer"
    }
  },
  {
    "idx": 160632,
    "project": "jasper",
    "commit_id": "e24bdc716c3327b067c551bc6cfb97fd2370358d",
    "project_url": "https://github.com/mdadams/jasper",
    "commit_url": "https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d",
    "commit_message": "Fixed a bug that resulted in the destruction of JP2 box data that had never\nbeen constructed in the first place.",
    "label": 0,
    "func": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "func_hash": 247824527682006594654232944011084931481,
    "file_name": "jp2_cod.c",
    "file_hash": 250067815251904752657708944442782132588,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-8887",
    "cve_desc": "The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-8887",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "tmpstream",
          "in",
          "box",
          "jp2_box_get",
          "boxinfo"
        ],
        "arrays": [],
        "size_variables": [
          "extlen",
          "length",
          "datalen",
          "sizeof",
          "len",
          "JP2_BOX_HDRLEN"
        ],
        "all_variables": [
          "extlen",
          "length",
          "datalen",
          "tmpstream",
          "JP2_BOX_HDRLEN",
          "in",
          "box",
          "sizeof",
          "jp2_box_get",
          "len",
          "boxinfo"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk."
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "jp2_getuint32(in, &box->type)) {\n\t\tgoto error;"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= jp2_boxinfolookup(box->type);\n \tbox->info = box"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ookup(box->type);\n \tbox->info = boxinfo;\n \tbox->o"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->info = boxinfo;\n \tbox->ops = &boxinfo->ops;"
            },
            {
              "variable": "boxinfo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= &boxinfo->ops;\n \tbox->len = len;\n\tJAS_DBGLOG("
            },
            {
              "variable": "boxinfo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ngth=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, bo"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "boxinfo->name, '\"', box->type, box->len\n\t  ));"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "me, '\"', box->type, box->len\n\t  ));\n \tif (box->l"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "x->len\n\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->da"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BO"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(fa"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LEN(false);\n\t}\n\tif (box->len != 0 && box->len <"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f (box->len != 0 && box->len < 8) {\n\t\tgoto error"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_S"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "estroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk."
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ("
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmps"
            },
            {
              "variable": "jp2_box_get",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{"
            },
            {
              "variable": "in",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ox_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *bo"
            },
            {
              "variable": "boxinfo",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmp"
            },
            {
              "variable": "tmpstream",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len"
            },
            {
              "variable": "box",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">getdata) {\n\t\t\tif ((*box->ops->getdata)(box,"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 11,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 6
      }
    },
    "predict": "{\"vulnerable_variables\": []}",
    "vulnerable_variables": [],
    "variable_definitions": {},
    "variable_types": {},
    "type_mapping": {}
  },
  {
    "idx": 160633,
    "project": "jasper",
    "commit_id": "5d66894d2313e3f3469f19066e149e08ff076698",
    "project_url": "https://github.com/mdadams/jasper",
    "commit_url": "https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698",
    "commit_message": "Fixed a problem with a null pointer dereference in the BMP decoder.",
    "label": 0,
    "func": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n\timage = 0;\n\tinfo = 0;\n\n \tif (optstr) {\n \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t\t//return 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t\t//return 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n\t\t\t//bmp_info_destroy(info);\n\t\t\t//return 0;\n\t\t\tgoto error;\n \t\t}\n \t}\n \n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \n \tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n\t\t//bmp_info_destroy(info);\n\t\t//jas_image_destroy(image);\n\t\t//return 0;\n\t\tgoto error;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n }\n",
    "func_hash": 276728953916609429523941895221486262458,
    "file_name": "bmp_dec.c",
    "file_hash": 118114575294326840274362992352901727596,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2016-8690",
    "cve_desc": "The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-8690",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "bmp_decode",
          "image",
          "in",
          "optstr",
          "cmptparm",
          "info"
        ],
        "arrays": [
          "cmptparms"
        ],
        "size_variables": [
          "BMP_INFOLEN",
          "numplanes",
          "BMP_PALLEN",
          "BMP_HDRLEN",
          "numcmpts",
          "number",
          "numcolors",
          "len",
          "bmp_numcmpts"
        ],
        "all_variables": [
          "bmp_decode",
          "BMP_INFOLEN",
          "numplanes",
          "BMP_PALLEN",
          "image",
          "len",
          "BMP_HDRLEN",
          "numcmpts",
          "in",
          "optstr",
          "number",
          "cmptparms",
          "cmptparm",
          "numcolors",
          "info",
          "bmp_numcmpts"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t  JAS_CAST(long, info->width), JAS_CAST(long, in"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "th), JAS_CAST(long, info->height),\n\t  JAS_CAST(long,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, in"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, in"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pe), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, in"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ",\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, in"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rs), JAS_CAST(long, info->mincolors)));\n\n\tif (info->wid"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mincolors)));\n\n\tif (info->width < 0 || info->height"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(info->width < 0 || info->height < 0 || info->numpla"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info->height < 0 || info->numplanes < 0 ||\n\t  info->dep"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "numplanes < 0 ||\n\t  info->depth < 0 || info->siz <"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "info->depth < 0 || info->siz < 0 || info->hres <"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|| info->siz < 0 || info->hres < 0 || info->vres <"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "| info->hres < 0 || info->vres < 0) {\n\t\tjas_eprint"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tl"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hs"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vs"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->wi"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcm"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cmptparm->width = info->width;\n\t\tcmptparm->height"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "th = info->width;\n\t\tcmptparm->height = info->height;\n\t\tc"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cmptparm->height = info->height;\n\t\tcmptparm->prec ="
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sg"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* C"
            },
            {
              "variable": "bmp_decode",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "jas_image_t *bmp_decode(jas_stream_t *in, c"
            },
            {
              "variable": "in",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "decode(jas_stream_t *in, char *optstr)\n{\n\tj"
            },
            {
              "variable": "optstr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_stream_t *in, char *optstr)\n{\n\tjas_image_t *im"
            },
            {
              "variable": "image",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "str)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tb"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmp"
            },
            {
              "variable": "cmptparm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "as_image_cmptparm_t *cmptparm;\n \tuint_fast16_t nu"
            },
            {
              "variable": "Read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "STEAD.\\n\"\n\t  );\n\n \t/* Read the bitmap header."
            },
            {
              "variable": "Read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hdr.off\n\t  ));\n\n \t/* Read the bitmap informat"
            },
            {
              "variable": "Ensure",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "goto error;\n\t}\n \n \t/* Ensure that we support thi"
            },
            {
              "variable": "Skip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "oto error;\n \t}\n \n \t/* Skip over any useless da"
            },
            {
              "variable": "Get",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "error;\n \t\t}\n \t}\n \n\t/* Get the number of compo"
            },
            {
              "variable": "Create",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gnd = false;\n\t}\n\n \t/* Create image object. */"
            },
            {
              "variable": "Read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "D_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */"
            },
            {
              "variable": "cmptparms",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "as_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptpar"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 16,
        "pointer_count": 6,
        "array_count": 1,
        "size_variable_count": 9
      }
    },
    "predict": "{\"vulnerable_variables\": [\"in\", \"info\", \"image\"]}",
    "vulnerable_variables": [
      "in",
      "info",
      "image"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "in": "Definition not found",
      "info": "bmp_info_t *info;",
      "image": "jas_image_t *image;"
    },
    "variable_types": {
      "in": "struct pointer",
      "info": "struct pointer",
      "image": "struct pointer"
    },
    "type_mapping": {
      "in": "struct pointer",
      "info": "struct pointer",
      "image": "struct pointer"
    }
  },
  {
    "idx": 160699,
    "project": "ImageMagick",
    "commit_id": "5b4bebaa91849c592a8448bc353ab25a54ff8c44",
    "project_url": "https://github.com/ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/5b4bebaa91849c592a8448bc353ab25a54ff8c44",
    "commit_message": "https://github.com/ImageMagick/ImageMagick/pull/34",
    "label": 0,
    "func": "MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n   p=images;\n   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    register Image\n      *next;\n    \n    next=GetNextImageInList(p);\n    if (next == (Image *) NULL)\n      break;\n    if (p->scene >= next->scene)\n       {\n         register ssize_t\n           i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n           p->scene=(size_t) i++;\n         break;\n       }\n  }\n   /*\n     Write images.\n   */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n",
    "func_hash": 321109016875635859590448570298569851410,
    "file_name": "constitute.c",
    "file_hash": 199859930407694204395135052459848195511,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2015-8898",
    "cve_desc": "The WriteImages function in magick/constitute.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8898",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "next",
          "write_info",
          "p",
          "images",
          "filename",
          "image_info",
          "exception",
          "sans_exception"
        ],
        "arrays": [],
        "size_variables": [
          "ssize_t",
          "number_images",
          "size_t",
          "filename",
          "GetImageListLength",
          "numbers",
          "MagickSizeType"
        ],
        "all_variables": [
          "next",
          "ssize_t",
          "number_images",
          "write_info",
          "size_t",
          "p",
          "images",
          "GetImageListLength",
          "filename",
          "image_info",
          "MagickSizeType",
          "exception",
          "numbers",
          "sans_exception"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*) NULL);\n  assert(image_info->signature == MagickCoreSignat"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*) NULL);\n  assert(images->signature == MagickCoreSignat"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reSignature);\n  if (images->debug != MagickFalse)"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MagickModule(),\"%s\",images->filename);\n  assert(exceptio"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nfo(image_info);\n  *write_info->magick='\\0';\n  images=GetF"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d) CopyMagickString(p->filename,filename,MagickPath"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d) CopyMagickString(write_info->filename,images->filename,Ma"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rite_info->filename,images->filename,MagickPathExtent);"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_exception);\n  if (*write_info->magick == '\\0')\n     (void"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d) CopyMagickString(write_info->magick,images->magick,Magi"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(write_info->magick,images->magick,MagickPathExtent);"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "break;\n    if (p->scene >= next->scene)"
            },
            {
              "variable": "next",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (p->scene >= next->scene)\n       {"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "i=(ssize_t) images->scene;\n        for (p=ima"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "List(p))\n           p->scene=(size_t) i++;"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "itor) NULL,\n        p->client_data);\n    status&=Write"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(p,progress_monitor,p->client_data);\n    if (write_inf"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ient_data);\n    if (write_info->adjoin != MagickFalse)"
            },
            {
              "variable": "image_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ges(const ImageInfo *image_info,\n  Image *images,co"
            },
            {
              "variable": "images",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "image_info,\n  Image *images,const char *filenam"
            },
            {
              "variable": "filename",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*images,const char *filename,ExceptionInfo *exce"
            },
            {
              "variable": "exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ename,ExceptionInfo *exception)\n{\n#define WriteIma"
            },
            {
              "variable": "sans_exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanTy"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "register Image\n    *p;\n\n  assert(image_in"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Info(image_info);\n  *write_info->magick='\\0';\n  ima"
            },
            {
              "variable": "write_info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s_exception);\n  if (*write_info->magick == '\\0')"
            },
            {
              "variable": "next",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "egister Image\n      *next;\n    \n    next=GetN"
            },
            {
              "variable": "Generate",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "i;\n\n        /*\n          Generate consistent scene nu"
            },
            {
              "variable": "Write",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k;\n       }\n  }\n   /*\n     Write images.\n   */\n  sta"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 14,
        "pointer_count": 8,
        "array_count": 0,
        "size_variable_count": 7
      }
    },
    "predict": "{\"vulnerable_variables\": [\"images\", \"write_info\"]}",
    "vulnerable_variables": [
      "images",
      "write_info"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "images": "Definition not found",
      "write_info": "ImageInfo *write_info;"
    },
    "variable_types": {
      "images": "struct pointer",
      "write_info": "struct pointer"
    },
    "type_mapping": {
      "images": "struct pointer",
      "write_info": "struct pointer"
    }
  },
  {
    "idx": 160719,
    "project": "pgbouncer",
    "commit_id": "74d6e5f7de5ec736f71204b7b422af7380c19ac5",
    "project_url": "https://github.com/pgbouncer/pgbouncer",
    "commit_url": "https://github.com/pgbouncer/pgbouncer/commit/74d6e5f7de5ec736f71204b7b422af7380c19ac5",
    "commit_message": "Check if auth_user is set.\n\nFixes a crash if password packet appears before startup packet (#42).",
    "label": 0,
    "func": "static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n{\n\tconst char *passwd;\n\tconst uint8_t *key;\n\tbool ok;\n\n\tSBuf *sbuf = &client->sbuf;\n\n\t/* don't tolerate partial packets */\n\tif (incomplete_pkt(pkt)) {\n\t\tdisconnect_client(client, true, \"client sent partial pkt in startup phase\");\n\t\treturn false;\n\t}\n\n\tif (client->wait_for_welcome) {\n\t\tif  (finish_client_login(client)) {\n\t\t\t/* the packet was already parsed */\n\t\t\tsbuf_prepare_skip(sbuf, pkt->len);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tswitch (pkt->type) {\n\tcase PKT_SSLREQ:\n\t\tslog_noise(client, \"C: req SSL\");\n\t\tslog_noise(client, \"P: nak\");\n\n\t\t/* reject SSL attempt */\n\t\tif (!sbuf_answer(&client->sbuf, \"N\", 1)) {\n\t\t\tdisconnect_client(client, false, \"failed to nak SSL\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_STARTUP_V2:\n\t\tdisconnect_client(client, true, \"Old V2 protocol not supported\");\n\t\treturn false;\n\tcase PKT_STARTUP:\n\t\tif (client->pool) {\n\t\t\tdisconnect_client(client, true, \"client re-sent startup pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!decide_startup_pool(client, pkt))\n\t\t\treturn false;\n\n\t\tif (client->pool->db->admin) {\n\t\t\tif (!admin_pre_login(client))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (cf_auth_type <= AUTH_TRUST || client->own_user) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!send_client_authreq(client)) {\n\t\t\t\tdisconnect_client(client, false, \"failed to send auth req\");\n\t\t\t\treturn false;\n\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase 'p':\t\t/* PasswordMessage */\n\t\t/* too early */\n\t\tif (!client->auth_user) {\n\t\t\tdisconnect_client(client, true, \"client password pkt before startup packet\");\n\t\t\treturn false;\n\t\t}\n\n \t\t/* haven't requested it */\n \t\tif (cf_auth_type <= AUTH_TRUST) {\n \t\t\tdisconnect_client(client, true, \"unrequested passwd pkt\");\n\t\t\treturn false;\n\t\t}\n\n\t\tok = mbuf_get_string(&pkt->data, &passwd);\n\t\tif (ok && check_client_passwd(client, passwd)) {\n\t\t\tif (!finish_client_login(client))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tdisconnect_client(client, true, \"Auth failed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PKT_CANCEL:\n\t\tif (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN\n\t\t    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))\n\t\t{\n\t\t\tmemcpy(client->cancel_key, key, BACKENDKEY_LEN);\n\t\t\taccept_cancel_request(client);\n\t\t} else\n\t\t\tdisconnect_client(client, false, \"bad cancel request\");\n\t\treturn false;\n\tdefault:\n\t\tdisconnect_client(client, false, \"bad packet\");\n\t\treturn false;\n\t}\n\tsbuf_prepare_skip(sbuf, pkt->len);\n\tclient->request_time = get_cached_time();\n\treturn true;\n}\n",
    "func_hash": 114851079844768048216139139598678878211,
    "file_name": "client.c",
    "file_hash": 231648386052178416320464168125402333010,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2015-4054",
    "cve_desc": "PgBouncer before 1.5.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by sending a password packet before a startup packet.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4054",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "sbuf",
          "key",
          "client",
          "passwd",
          "pkt"
        ],
        "arrays": [],
        "size_variables": [
          "BACKENDKEY_LEN",
          "len"
        ],
        "all_variables": [
          "sbuf",
          "BACKENDKEY_LEN",
          "key",
          "client",
          "passwd",
          "pkt",
          "len"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ok;\n\n\tSBuf *sbuf = &client->sbuf;\n\n\t/* don't tolerat"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "urn false;\n\t}\n\n\tif (client->wait_for_welcome) {\n\t\tif  (finish_cl"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_prepare_skip(sbuf, pkt->len);\n\t\t\treturn true;"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "false;\n\t}\n\n\tswitch (pkt->type) {\n\tcase PKT_SSLREQ"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (!sbuf_answer(&client->sbuf, \"N\", 1)) {\n\t\t\tdisc"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "PKT_STARTUP:\n\t\tif (client->pool) {\n\t\t\tdisconnect_cl"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eturn false;\n\n\t\tif (client->pool->db->admin) {\n\t\t\tif"
            },
            {
              "variable": "db",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (client->pool->db->admin) {\n\t\t\tif (!admin_pr"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pe <= AUTH_TRUST || client->own_user) {\n\t\t\tif (!finish_c"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "too early */\n\t\tif (!client->auth_user) {\n\t\t\tdisconnect_cl"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= mbuf_get_string(&pkt->data, &passwd);\n\t\tif (ok"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "buf_avail_for_read(&pkt->data) == BACKENDKEY_LEN"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&& mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &k"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "key))\n\t\t{\n\t\t\tmemcpy(client->cancel_key, key, BACKENDKEY_LE"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_prepare_skip(sbuf, pkt->len);\n\tclient->request_"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p(sbuf, pkt->len);\n\tclient->request_time = get_cached_time()"
            },
            {
              "variable": "client",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt_startup(PgSocket *client, PktHdr *pkt)\n{\n\tco"
            },
            {
              "variable": "pkt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ket *client, PktHdr *pkt)\n{\n\tconst char *pas"
            },
            {
              "variable": "passwd",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*pkt)\n{\n\tconst char *passwd;\n\tconst uint8_t *ke"
            },
            {
              "variable": "key",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "swd;\n\tconst uint8_t *key;\n\tbool ok;\n\n\tSBuf *"
            },
            {
              "variable": "sbuf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y;\n\tbool ok;\n\n\tSBuf *sbuf = &client->sbuf;"
            },
            {
              "variable": "don",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= &client->sbuf;\n\n\t/* don't tolerate partial"
            },
            {
              "variable": "the",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ogin(client)) {\n\t\t\t/* the packet was already"
            },
            {
              "variable": "reject",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ent, \"P: nak\");\n\n\t\t/* reject SSL attempt */\n\t\tif"
            },
            {
              "variable": "PasswordMessage",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reak;\n \tcase 'p':\t\t/* PasswordMessage */\n\t\t/* too early *"
            },
            {
              "variable": "too",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sswordMessage */\n\t\t/* too early */\n\t\tif (!cli"
            },
            {
              "variable": "haven",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "urn false;\n\t\t}\n\n \t\t/* haven't requested it */"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 7,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\": [\"client\", \"pkt\"]}",
    "vulnerable_variables": [
      "client",
      "pkt"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "client": "PgSocket *client",
      "pkt": "PktHdr *pkt"
    },
    "variable_types": {
      "client": "struct pointer",
      "pkt": "struct pointer"
    },
    "type_mapping": {
      "client": "struct pointer",
      "pkt": "struct pointer"
    }
  },
  {
    "idx": 160743,
    "project": "libarchive",
    "commit_id": "15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175",
    "project_url": "https://github.com/libarchive/libarchive",
    "commit_url": "https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175",
    "commit_message": "Skip 0-length ACL fields\n\nCurrently, it is possible to create an archive that crashes bsdtar\nwith a malformed ACL:\n\nProgram received signal SIGSEGV, Segmentation fault.\narchive_acl_from_text_l (acl=<optimised out>, text=0x7e2e92 \"\", want_type=<optimised out>, sc=<optimised out>) at libarchive/archive_acl.c:1726\n1726\t\t\t\tswitch (*s) {\n(gdb) p n\n$1 = 1\n(gdb) p field[n]\n$2 = {start = 0x0, end = 0x0}\n\nStop this by checking that the length is not zero before beginning\nthe switch statement.\n\nI am pretty sure this is the bug mentioned in the qsym paper [1],\nand I was able to replicate it with a qsym + AFL + afl-rb setup.\n\n[1] https://www.usenix.org/conference/usenixsecurity18/presentation/yun",
    "label": 0,
    "func": "archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n \t\t\tst = field[n].start + 1;\n \t\t\tlen = field[n].end - field[n].start;\n \n\t\t\tif (len == 0) {\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n \t\t\tswitch (*s) {\n \t\t\tcase 'u':\n \t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}\n",
    "func_hash": 280170834845320563619229397978989170046,
    "file_name": "archive_acl.c",
    "file_hash": 129044179870758678483544350212295552452,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-1000879",
    "cve_desc": "libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted archive file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-1000879",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "sc",
          "s",
          "text",
          "acl",
          "Exception",
          "end",
          "to",
          "start"
        ],
        "arrays": [
          "field"
        ],
        "size_variables": [
          "numeric",
          "size_t",
          "numfields",
          "archive_acl_add_entry_len_l",
          "len"
        ],
        "all_variables": [
          "sc",
          "numeric",
          "s",
          "size_t",
          "text",
          "numfields",
          "archive_acl_add_entry_len_l",
          "field",
          "acl",
          "Exception",
          "end",
          "to",
          "len",
          "start"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "acl",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(struct archive_acl *acl, const char *text,"
            },
            {
              "variable": "text",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "cl *acl, const char *text,\n    int want_type,"
            },
            {
              "variable": "sc",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "archive_string_conv *sc)\n{\n\tstruct {\n\t\tcons"
            },
            {
              "variable": "start",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ruct {\n\t\tconst char *start;\n\t\tconst char *end;"
            },
            {
              "variable": "end",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "start;\n\t\tconst char *end;\n\t} field[6], name;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "name;\n\n\tconst char *s, *st;\n\tint numfield"
            },
            {
              "variable": "st",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e;\n\n\tconst char *s, *st;\n\tint numfields, fi"
            },
            {
              "variable": "text",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e (text != NULL &&  *text != '\\0') {\n\t\t/*"
            },
            {
              "variable": "Parse",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= '\\0') {\n\t\t/*\n\t\t * Parse the fields out of t"
            },
            {
              "variable": "advance",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "the next entry,\n\t\t * advance 'text' to start of"
            },
            {
              "variable": "start",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "do {\n\t\t\tconst char *start, *end;\n\t\t\tnext_fiel"
            },
            {
              "variable": "end",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char *start, *end;\n\t\t\tnext_field(&tex"
            },
            {
              "variable": "Set",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e (sep == ':');\n\n\t\t/* Set remaining fields to"
            },
            {
              "variable": "Comment",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tart) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tc"
            },
            {
              "variable": "POSIX",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*"
            },
            {
              "variable": "Default",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:us"
            },
            {
              "variable": "We",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ore field\n\t\t\t *\n\t\t\t * We also support old So"
            },
            {
              "variable": "to",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "L corresponding\n\t\t\t * to \"user::rwx\", etc. v"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ld[0].start;\n\t\t\tif (*s == 'd' && (len == 1"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e = want_type;\n\n\t\t\t/* Check for a numeric ID in"
            },
            {
              "variable": "Field",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+ 1].end, &id);\n\t\t\t/* Field n+3 is optional. */"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\t\t}\n\n \t\t\tswitch (*s) {\n \t\t\tcase 'u':"
            },
            {
              "variable": "This",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&permset)) {\n\t\t\t\t\t/* This is Solaris-style \"o"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */"
            },
            {
              "variable": "Without",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expec"
            },
            {
              "variable": "Exception",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mode in field 3\n\t\t\t * Exception: Solaris other and"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */"
            },
            {
              "variable": "NFS4",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = fiel"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip e"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip e"
            },
            {
              "variable": "Invalid",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(type == 0) {\n\t\t\t\t/* Invalid entry type, skip en"
            },
            {
              "variable": "Add",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&id);\n\t\t}\n\n\t\t/* Add entry to the intern"
            },
            {
              "variable": "Reset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "const char *end;\n\t} field[6], name;\n\n\tconst char"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "< numfields) {\n\t\t\t\tfield[fields].start = start;"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ".start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "numfields; ++n)\n\t\t\tfield[n].start = field[n].en"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "field[n].start = field[n].end = NULL;\n\n\t\tif ("
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ".end = NULL;\n\n\t\tif (field[0].start != NULL && *("
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ".start != NULL && *(field[0].start) == '#') {"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = fie"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[0].start;\n\t\t\tlen = field[0].end - field[0].star"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "en = field[0].end - field[0].start;\n\t\t\tif (*s =="
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\tels"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tag = 0;\n\t\t\ts = field[n].start;\n \t\t\tst = fie"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[n].start;\n \t\t\tst = field[n].start + 1;\n \t\t\tlen"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "tart + 1;\n \t\t\tlen = field[n].end - field[n].star"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "en = field[n].end - field[n].start;\n \n\t\t\tif (len"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = fie"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "[0].start;\n\t\t\tlen = field[0].end - field[0].star"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "en = field[0].end - field[0].start;\n\t\t\ttag = 0;"
            },
            {
              "variable": "field",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "n = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.sta"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 14,
        "pointer_count": 8,
        "array_count": 1,
        "size_variable_count": 5
      }
    },
    "predict": "{\"vulnerable_variables\":[\"field\",\"s\"]}",
    "vulnerable_variables": [
      "field",
      "s"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "field": "struct { const char *start; const char *end; } field[6], name;",
      "s": "const char *s, *st;"
    },
    "variable_types": {
      "field": "struct array",
      "s": "char pointer"
    },
    "type_mapping": {
      "field": "struct array",
      "s": "char pointer"
    }
  },
  {
    "idx": 160808,
    "project": "libmspack",
    "commit_id": "8759da8db6ec9e866cb8eb143313f397f925bb4f",
    "project_url": "https://github.com/kyz/libmspack",
    "commit_url": "https://github.com/kyz/libmspack/commit/8759da8db6ec9e866cb8eb143313f397f925bb4f",
    "commit_message": "Avoid returning CHM file entries that are \"blank\" because they have embedded null bytes",
    "label": 0,
    "func": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n     while (num_entries--) {\n       READ_ENCINT(name_len);\n       if (name_len > (unsigned int) (end - p)) goto chunk_end;\n       name = p; p += name_len;\n       READ_ENCINT(section);\n       READ_ENCINT(offset);\n       READ_ENCINT(length);\n \n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n       /* empty files and directory names are stored as a file entry at\n        * offset 0 with length 0. We want to keep empty files, but not\n        * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}\n",
    "func_hash": 112914575198027149916774137571455496957,
    "file_name": "chmd.c",
    "file_hash": 147705968754428363600309429539747778541,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-18585",
    "cve_desc": "chmd_read_headers in mspack/chmd.c in libmspack before 0.8alpha accepts a filename that has '\\0' as its first or second character (such as the \"/\\0\" name).",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-18585",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "cache",
          "sys",
          "chm",
          "fi",
          "directory",
          "reading",
          "or",
          "chunk_size",
          "fh",
          "large",
          "offset"
        ],
        "arrays": [
          "name",
          "fi",
          "guids",
          "content_name",
          "filename",
          "chunk",
          "control_name",
          "spaninfo_name",
          "buf",
          "rtable_name"
        ],
        "size_variables": [
          "chmhead_SIZEOF",
          "size_t",
          "chmhs0_SIZEOF",
          "chmhs1_SIZEOF",
          "number",
          "num_chunks",
          "num_entries",
          "pmgl_QuickRefSize",
          "filenames",
          "length",
          "chmhs0_FileLen",
          "chmhs1_NumChunks",
          "filename",
          "chmhst3_SIZEOF",
          "chmhs1_ChunkSize",
          "size",
          "name_len",
          "chunk_size",
          "sizeof"
        ],
        "all_variables": [
          "sys",
          "fi",
          "chmhead_SIZEOF",
          "size_t",
          "chmhs0_SIZEOF",
          "chmhs1_SIZEOF",
          "offset",
          "number",
          "num_chunks",
          "num_entries",
          "pmgl_QuickRefSize",
          "directory",
          "filenames",
          "fh",
          "spaninfo_name",
          "length",
          "chmhs0_FileLen",
          "chmhs1_NumChunks",
          "large",
          "chunk",
          "filename",
          "control_name",
          "chmhst3_SIZEOF",
          "chmhs1_ChunkSize",
          "rtable_name",
          "size",
          "cache",
          "chm",
          "reading",
          "name",
          "guids",
          "content_name",
          "name_len",
          "or",
          "chunk_size",
          "sizeof",
          "buf"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "alise pointers */\n  chm->files         = NULL;\n  c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s         = NULL;\n  chm->sysfiles      = NULL;\n  chm-"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "iles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->se"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ec1.base.id  = 1;\n  chm->sec1.content  = NULL;"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".content  = NULL;\n  chm->sec1.control  = NULL;"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".control  = NULL;\n  chm->sec1.spaninfo = NULL;"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".spaninfo = NULL;\n  chm->sec1.rtable   = NULL;"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rst header */\n  if (sys->read(fh, &buf[0], chmhea"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "R_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf["
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[ch"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "head_Timestamp]);\n  chm->language  = EndGetI32(&buf[c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LanguageID]);\n  if (chm->version > 3) {\n    sys->mes"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">version > 3) {\n    sys->message(fh, \"WARNING; CHM v"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tion table */\n  if (sys->read(fh, &buf[0], chmhst"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|\n      read_off64(&chm->dir_offset,  &buf[chmhst_Offse"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "|\n      read_off64(&chm->sec0.offset, &buf[chmhst"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "section 0 */\n  if (sys->seek(fh, offset, MSPACK_"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "section 0 */\n  if (sys->read(fh, &buf[0], chmhs0"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n  if (read_off64(&chm->length, &buf[chmhs0_FileLe"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "section 1 */\n  if (sys->seek(fh, chm->dir_offset"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_ST"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "section 1 */\n  if (sys->read(fh, &buf[0], chmhs1"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chm->dir_offset = sys->tell(fh);\n  chm->chunk_s"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[ch"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chmhs1_Density]);\n  chm->depth      = EndGetI32(&b"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "f[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[ch"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[ch"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[ch"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versi"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_o"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chm->sec0.offset = chm->dir_offset + (chm->chunk_size"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chm->dir_offset + (chm->chunk_size * chm->num_chunks);"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check i"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e is wrong */\n  if (chm->sec0.offset > chm->lengt"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(chm->sec0.offset > chm->length) {\n    D((\"content"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "um_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "k size.\n   */\n  if (chm->num_chunks > 100000) {\n    D(("
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk_size * (off_t)chm->num_chunks > chm->length) {"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t)chm->num_chunks > chm->length) {\n    D((\"chunks l"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "1 fields */\n  if ((chm->chunk_size & (chm->chunk_size"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    s"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "e - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->me"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "st_pmgl != 0) {\n    sys->message(fh, \"WARNING; first"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pm"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && ch"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ot != 0xFFFFFFFF && chm->index_root >= chm->num_chunks)"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chm->index_root >= chm->num_chunks) {\n    D((\"index_ro"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sy"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "gl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_C"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(c"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= (unsigned char *) sys->alloc(sys, (size_t)chm->c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">alloc(sys, (size_t)chm->chunk_size))) {\n    return MSP"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xt chunk */\n    if (sys->read(fh, chunk, (int)chm"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ead(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk_size) != (int)chm->chunk_size) {\n      sys->free("
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "chunk_size) {\n      sys->free(chunk);\n      retur"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "Size]) < 2) {\n      sys->message(fh, \"WARNING; PMGL"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "RefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tries))\n    {\n      sys->message(fh, \"WARNING; PMGL"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "];\n    end = &chunk[chm->chunk_size - 2];\n    num_entri"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (section > 1) {\n\tsys->message(fh, \"invalid sectio"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ruct mschmd_file *) sys->alloc(sys, sizeof(struct"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSP"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ORY;\n      }\n\n      fi->next     = NULL;\n      f"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t     = NULL;\n      fi->filename = (char *) &fi[1];"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ar *) &fi[1];\n      fi->section  = ((section == 0)"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mschmd_section *) (&chm->sec0)"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mschmd_section *) (&chm->sec1));\n      fi->offset"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&chm->sec1));\n      fi->offset   = offset;\n      f"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t   = offset;\n      fi->length   = length;\n      s"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "h   = length;\n      sys->copy(name, fi->filename,"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sys->copy(name, fi->filename, (size_t) name_len)"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t) name_len);\n      fi->filename[name_len] = '\\0';"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "able = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tc"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = f"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }"
            },
            {
              "variable": "link",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "file */\n\tif (link) link->next = fi; else chm->fil"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nk->next = fi; else chm->files = fi;\n\tlink = fi;"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (e"
            },
            {
              "variable": "sys",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct mspack_system *sys, struct mspack_file"
            },
            {
              "variable": "fh",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct mspack_file *fh,\n\t\t\t     struct msc"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct mschmd_header *chm, int entire)\n{\n  un"
            },
            {
              "variable": "chunk",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ned char buf[0x54], *chunk = NULL, *name, *p,"
            },
            {
              "variable": "name",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "54], *chunk = NULL, *name, *p, *end;\n  struct"
            },
            {
              "variable": "p",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "hunk = NULL, *name, *p, *end;\n  struct msc"
            },
            {
              "variable": "end",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "= NULL, *name, *p, *end;\n  struct mschmd_fi"
            },
            {
              "variable": "fi",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct mschmd_file *fi, *link = NULL;\n  of"
            },
            {
              "variable": "link",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ct mschmd_file *fi, *link = NULL;\n  off_t off"
            },
            {
              "variable": "initialise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "nt num_entries;\n\n  /* initialise pointers */\n  chm->"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "table   = NULL;\n\n  /* read the first header */"
            },
            {
              "variable": "check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "K_ERR_READ;\n  }\n\n  /* check ITSF signature */"
            },
            {
              "variable": "check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_SIGNATURE;\n  }\n\n  /* check both header GUIDs *"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "sion > 3\");\n  }\n\n  /* read the header section"
            },
            {
              "variable": "chmhst3_OffsetCS0",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "K_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in v"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "or 2 CHM files.\n   * The offset will be corr"
            },
            {
              "variable": "seek",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DATAFORMAT;\n  }\n\n  /* seek to header section 0"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "K_ERR_SEEK;\n  }\n\n  /* read header section 0 */"
            },
            {
              "variable": "seek",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DATAFORMAT;\n  }\n\n  /* seek to header section 1"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "K_ERR_SEEK;\n  }\n\n  /* read header section 1 */"
            },
            {
              "variable": "versions",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "version < 3) {\n    /* versions before 3 don't have"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "+ (chm->chunk_size * chm->num_chunks);\n  }"
            },
            {
              "variable": "check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "um_chunks);\n  }\n\n  /* check if content offset o"
            },
            {
              "variable": "ensure",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "TAFORMAT;\n  }\n  \n  /* ensure there are chunks an"
            },
            {
              "variable": "large",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "at chunk size is\n   * large enough for signatur"
            },
            {
              "variable": "The",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DATAFORMAT;\n  }\n\n  /* The chunk_cache data st"
            },
            {
              "variable": "or",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s for num_chunks\n   * or num_chunks*chunk_si"
            },
            {
              "variable": "chunk_size",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s\n   * or num_chunks*chunk_size can exhaust all mem"
            },
            {
              "variable": "cache",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "l a better chunk\n   * cache is implemented, put"
            },
            {
              "variable": "common",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DATAFORMAT;\n  }\n\n  /* common sense checks on hea"
            },
            {
              "variable": "seek",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL c"
            },
            {
              "variable": "chm",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ">seek(fh,(off_t) (x * chm->chunk_size), MSPAC"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "R_NOMEMORY;\n  }\n\n  /* read and process all chu"
            },
            {
              "variable": "read",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "um_chunks--) {\n    /* read next chunk */\n    i"
            },
            {
              "variable": "process",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "R_READ;\n    }\n\n    /* process only directory (PMG"
            },
            {
              "variable": "ignore",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "T(length);\n \n      /* ignore blank or one-char ("
            },
            {
              "variable": "empty",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "continue;\n\n       /* empty files and directory"
            },
            {
              "variable": "offset",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "le entry at\n        * offset 0 with length 0. We"
            },
            {
              "variable": "directory",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "es, but not\n        * directory names, which end wi"
            },
            {
              "variable": "system",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "name[1] == ':') {\n\t/* system file */\n\tif (mspack"
            },
            {
              "variable": "normal",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n      else {\n\t/* normal file */\n\tif (link)"
            },
            {
              "variable": "this",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n    }\n\n    /* this is reached either w"
            },
            {
              "variable": "reading",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "uns out, or if\n     * reading data from the chunk"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ks;\n  unsigned char buf[0x54], *chunk = NULL, *na"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (sys->read(fh, &buf[0], chmhead_SIZEOF) !="
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "*/\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) !="
            },
            {
              "variable": "guids",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "uf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "sion   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "estamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "guage  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->versio"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (sys->read(fh, &buf[0], chmhst3_SIZEOF) !="
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (sys->read(fh, &buf[0], chmhs0_SIZEOF) !="
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ff64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    re"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (sys->read(fh, &buf[0], chmhs1_SIZEOF) !="
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "k_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ity    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "h      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "x_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "t_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl"
            },
            {
              "variable": "buf",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->versi"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) con"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chu"
            },
            {
              "variable": "chunk",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[c"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "f (name_len < 2 || !name[0] || !name[1]) contin"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "< 2 || !name[0] || !name[1]) continue;"
            },
            {
              "variable": "fi",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ilename = (char *) &fi[1];\n      fi->section"
            },
            {
              "variable": "filename",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ame_len);\n      fi->filename[name_len] = '\\0';\n\n      if ("
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "= '\\0';\n\n      if (name[0] == ':' && name[1] ="
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "(name[0] == ':' && name[1] == ':') {\n\t/* syste"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (mspack_memcmp(&name[2], &content_name[2],"
            },
            {
              "variable": "content_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "k_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (mspack_memcmp(&name[33], &content_name[33],"
            },
            {
              "variable": "content_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    c"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (mspack_memcmp(&name[33], &control_name[33],"
            },
            {
              "variable": "control_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_memcmp(&name[33], &control_name[33], 11L) == 0) {"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (mspack_memcmp(&name[33], &spaninfo_name[33]"
            },
            {
              "variable": "spaninfo_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    c"
            },
            {
              "variable": "name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "if (mspack_memcmp(&name[33], &rtable_name[33],"
            },
            {
              "variable": "rtable_name",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "_memcmp(&name[33], &rtable_name[33], 72L) == 0) {"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 37,
        "pointer_count": 11,
        "array_count": 10,
        "size_variable_count": 19
      }
    },
    "predict": "{\"vulnerable_variables\": [\"name\"]}",
    "vulnerable_variables": [
      "name"
    ],
    "vulnerable_variable": "name",
    "variable_definitions": {
      "name": "unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;"
    },
    "variable_types": {
      "name": "char pointer"
    },
    "type_mapping": {
      "name": "char pointer"
    }
  },
  {
    "idx": 160872,
    "project": "libxkbcommon",
    "commit_id": "96df3106d49438e442510c59acad306e94f3db4d",
    "project_url": "https://github.com/xkbcommon/libxkbcommon",
    "commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d",
    "commit_message": "xkbcomp: Don't crash on no-op modmask expressions\n\nIf we have an expression of the form 'l1' in an interp section, we\nunconditionally try to dereference its args, even if it has none.\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>",
    "label": 0,
    "func": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n             log_err(info->ctx,\n                     \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n             return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}\n",
    "func_hash": 72505359917534657184248207646389279372,
    "file_name": "compat.c",
    "file_hash": 283034088681410377734077208342226721410,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-15863",
    "cve_desc": "Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-15863",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "mods_rtrn",
          "expr",
          "pred_txt",
          "pred_rtrn",
          "info"
        ],
        "arrays": [],
        "size_variables": [
          "enum"
        ],
        "all_variables": [
          "mods_rtrn",
          "enum",
          "expr",
          "pred_txt",
          "pred_rtrn",
          "info"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "txt = xkb_atom_text(info->ctx, expr->action.name)"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "log_err(info->ctx,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "txt = xkb_atom_text(info->ctx, expr->ident.ident)"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ExprResolveModMask(info->ctx, expr, MOD_REAL, &i"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "x, expr, MOD_REAL, &info->mods,"
            },
            {
              "variable": "pred_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_match_operation *pred_rtrn,"
            },
            {
              "variable": "mods_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_mod_mask_t *mods_rtrn, CompatInfo *info)"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ds_rtrn, CompatInfo *info)\n{\n    if (expr =="
            },
            {
              "variable": "pred_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "== NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE"
            },
            {
              "variable": "mods_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL"
            },
            {
              "variable": "pred_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "n true;\n    }\n\n     *pred_rtrn = MATCH_EXACTLY;"
            },
            {
              "variable": "pred_txt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char *pred_txt = xkb_atom_text(inf"
            },
            {
              "variable": "pred_txt",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char *pred_txt = xkb_atom_text(inf"
            },
            {
              "variable": "pred_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ny\")) {\n            *pred_rtrn = MATCH_ANY;"
            },
            {
              "variable": "mods_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "CH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 5,
        "array_count": 0,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\":[\"pred_rtrn\",\"mods_rtrn\",\"info\"]}",
    "vulnerable_variables": [
      "pred_rtrn",
      "mods_rtrn",
      "info"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "pred_rtrn": "enum xkb_match_operation *pred_rtrn,",
      "mods_rtrn": "xkb_mod_mask_t *mods_rtrn,",
      "info": "CompatInfo *info"
    },
    "variable_types": {
      "pred_rtrn": "struct pointer",
      "mods_rtrn": "struct pointer",
      "info": "struct pointer"
    },
    "type_mapping": {
      "pred_rtrn": "struct pointer",
      "mods_rtrn": "struct pointer",
      "info": "struct pointer"
    }
  },
  {
    "idx": 160873,
    "project": "libxkbcommon",
    "commit_id": "bb4909d2d8fa6b08155e449986a478101e2b2634",
    "project_url": "https://github.com/xkbcommon/libxkbcommon",
    "commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/bb4909d2d8fa6b08155e449986a478101e2b2634",
    "commit_message": "Fail expression lookup on invalid atoms\n\nIf we fail atom lookup, then we should not claim that we successfully\nlooked up the expression.\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>",
    "label": 0,
    "func": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n",
    "func_hash": 77460604937986879787696942754050088030,
    "file_name": "expr.c",
    "file_hash": 155589504409794333474968021976527415003,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-15859",
    "cve_desc": "Unchecked NULL pointer usage when parsing invalid atoms in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because lookup failures are mishandled.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-15859",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "ctx",
          "field_rtrn",
          "expr",
          "elem_rtrn"
        ],
        "arrays": [],
        "size_variables": [],
        "all_variables": [
          "ctx",
          "field_rtrn",
          "expr",
          "elem_rtrn"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_atom_text(ctx, expr->ident.ident);\n        *in"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_atom_text(ctx, expr->field_ref.element);"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_atom_text(ctx, expr->field_ref.field);\n         *i"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_atom_text(ctx, expr->array_ref.element);"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_atom_text(ctx, expr->array_ref.field);\n         *i"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*index_rtrn = expr->array_ref.entry;\n\tif (expr->a"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ray_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "d in ResolveLhs\\n\", expr->expr.op);\n    return fal"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(struct xkb_context *ctx, const ExprDef *exp"
            },
            {
              "variable": "expr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*ctx, const ExprDef *expr,\n               con"
            },
            {
              "variable": "elem_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "const char **elem_rtrn, const char **field"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "m_rtrn, const char **field_rtrn,\n               Exp"
            },
            {
              "variable": "index_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ExprDef **index_rtrn)\n{\n    switch (expr"
            },
            {
              "variable": "elem_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *fi"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "trn = NULL;\n        *field_rtrn = xkb_atom_text(ctx"
            },
            {
              "variable": "index_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ent.ident);\n        *index_rtrn = NULL;\n        ret"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LL;\n        return (*field_rtrn != NULL);\n    case"
            },
            {
              "variable": "elem_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".element);\n         *field_rtrn = xkb_atom_text(ctx"
            },
            {
              "variable": "index_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ef.field);\n         *index_rtrn = NULL;\n        ret"
            },
            {
              "variable": "elem_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "LL;\n        return (*elem_rtrn != NULL && *field_r"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lem_rtrn != NULL && *field_rtrn != NULL);\n     case"
            },
            {
              "variable": "elem_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ".element);\n         *field_rtrn = xkb_atom_text(ctx"
            },
            {
              "variable": "index_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ef.field);\n         *index_rtrn = expr->array_ref.e"
            },
            {
              "variable": "elem_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "!= XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn f"
            },
            {
              "variable": "field_rtrn",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return false;\n\tif (*field_rtrn == NULL)\n\t\treturn f"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 4,
        "pointer_count": 4,
        "array_count": 0,
        "size_variable_count": 0
      }
    },
    "predict": "{\"vulnerable_variables\": [\"elem_rtrn\"]}",
    "vulnerable_variables": [
      "elem_rtrn"
    ],
    "vulnerable_variable": "elem_rtrn",
    "variable_definitions": {
      "elem_rtrn": "Definition not found"
    },
    "variable_types": {
      "elem_rtrn": "char pointer"
    },
    "type_mapping": {
      "elem_rtrn": "char pointer"
    }
  },
  {
    "idx": 160874,
    "project": "libxkbcommon",
    "commit_id": "badb428e63387140720f22486b3acbd3d738859f",
    "project_url": "https://github.com/xkbcommon/libxkbcommon",
    "commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f",
    "commit_message": "keycodes: don't try to copy zero key aliases\n\nMove the aliases copy to within the (num_key_aliases > 0) block.\n\nPassing info->aliases into this fuction with invalid aliases will\ncause log messages but num_key_aliases stays on 0. The key_aliases array\nis never allocated and remains NULL. We then loop through the aliases, causing\na null-pointer dereference.\n\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>",
    "label": 0,
    "func": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n \n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
    "func_hash": 222688645802915657784991239609009619780,
    "file_name": "keycodes.c",
    "file_hash": 4630575712486582694713951267535919926,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-15858",
    "cve_desc": "Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-15858",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "alias",
          "because",
          "key_aliases",
          "keymap",
          "info"
        ],
        "arrays": [
          "key_aliases"
        ],
        "size_variables": [
          "sizeof",
          "num_key_aliases"
        ],
        "all_variables": [
          "alias",
          "num_key_aliases",
          "because",
          "sizeof",
          "key_aliases",
          "keymap",
          "info"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rray_foreach(alias, info->aliases) {\n        /* Check"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n        /* Check that ->real is a key. */"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kbKeyByName(keymap, alias->real, false)) {"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "log_vrb(info->ctx, 5,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "KeyNameText(info->ctx, alias->alias),"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NameText(info->ctx, alias->alias),"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "KeyNameText(info->ctx, alias->real));"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NameText(info->ctx, alias->real));\n            alia"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "real));\n            alias->real = XKB_ATOM_NONE;"
            },
            {
              "variable": "that",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        /* Check that ->alias is not a key. */"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "kbKeyByName(keymap, alias->alias, false)) {"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "log_vrb(info->ctx, 5,"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "KeyNameText(info->ctx, alias->alias),"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NameText(info->ctx, alias->alias),"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "KeyNameText(info->ctx, alias->real));"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "NameText(info->ctx, alias->real));\n            alia"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "real));\n            alias->real = XKB_ATOM_NONE;"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rray_foreach(alias, info->aliases) {\n            if ("
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") {\n            if (alias->real != XKB_ATOM_NONE) {"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_aliases[i].alias = alias->alias;\n                ke"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "y_aliases[i].real = alias->real;\n                i+"
            },
            {
              "variable": "keymap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n     }\n \n    keymap->num_key_aliases = num_key_aliases;"
            },
            {
              "variable": "keymap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "um_key_aliases;\n    keymap->key_aliases = key_aliases;"
            },
            {
              "variable": "keymap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "p(struct xkb_keymap *keymap, KeyNamesInfo *info"
            },
            {
              "variable": "info",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eymap, KeyNamesInfo *info)\n{\n    AliasInfo *a"
            },
            {
              "variable": "alias",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fo)\n{\n    AliasInfo *alias;\n    unsigned i, nu"
            },
            {
              "variable": "key_aliases",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "truct xkb_key_alias *key_aliases;\n\n    /*\n     * Do"
            },
            {
              "variable": "Do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "iases;\n\n    /*\n     * Do some sanity checkin"
            },
            {
              "variable": "because",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t do it before\n     * because keys and their alia"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "aliases) {\n        /* Check that ->real is a ke"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        /* Check that ->alias is not"
            },
            {
              "variable": "Copy",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ases++;\n    }\n\n    /* Copy key aliases. */"
            },
            {
              "variable": "key_aliases",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "key_aliases, sizeof(*key_aliases));\n         if (!ke"
            },
            {
              "variable": "key_aliases",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": ") {\n                key_aliases[i].alias = alias->alia"
            },
            {
              "variable": "key_aliases",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "as;\n                key_aliases[i].real = alias->real;"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 7,
        "pointer_count": 5,
        "array_count": 1,
        "size_variable_count": 2
      }
    },
    "predict": "{\n    \"vulnerable_variables\": [\"alias\"]\n}",
    "vulnerable_variables": [
      "alias"
    ],
    "vulnerable_variable": "alias",
    "variable_definitions": {
      "alias": "AliasInfo *alias;"
    },
    "variable_types": {
      "alias": "struct pointer"
    },
    "type_mapping": {
      "alias": "struct pointer"
    }
  },
  {
    "idx": 160877,
    "project": "libxkbcommon",
    "commit_id": "917636b1d0d70205a13f89062b95e3a0fc31d4ff",
    "project_url": "https://github.com/xkbcommon/libxkbcommon",
    "commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff",
    "commit_message": "xkbcomp: fix crash when parsing an xkb_geometry section\n\nxkb_geometry sections are ignored; previously the had done so by\nreturning NULL for the section's XkbFile, however some sections of the\ncode do not expect this. Instead, create an XkbFile for it, it will\nnever be processes and discarded later.\n\nCaught with the afl fuzzer.\n\nSigned-off-by: Ran Benita <ran234@gmail.com>",
    "label": 0,
    "func": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n             continue;\n         }\n \n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n",
    "func_hash": 162450249631361234817494786251457080921,
    "file_name": "keymap.c",
    "file_hash": 16064074085906367585603031047495071273,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-15855",
    "cve_desc": "Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-15855",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "file",
          "keymap",
          "files",
          "ctx"
        ],
        "arrays": [
          "compile_file_fns",
          "files"
        ],
        "size_variables": [
          "enum"
        ],
        "all_variables": [
          "enum",
          "keymap",
          "ctx",
          "file",
          "compile_file_fns",
          "files"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "keymap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xkb_context *ctx = keymap->ctx;\n\n    /* Collect se"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "(file = (XkbFile *) file->defs; file;\n          fi"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "file = (XkbFile *) file->common.next) {\n         if"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ext) {\n         if (file->file_type < FIRST_KEYMAP_FILE"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "YPE ||\n             file->file_type > LAST_KEYMAP_FILE_"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") {\n            if (file->file_type == FILE_TYPE_GEOMET"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "file_type_to_string(file->file_type));\n            }"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (files[file->file_type]) {\n            log"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "file_type_to_string(file->file_type));\n            cont"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        files[file->file_type] = file;\n    }"
            },
            {
              "variable": "file",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mpileKeymap(XkbFile *file, struct xkb_keymap"
            },
            {
              "variable": "keymap",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ", struct xkb_keymap *keymap, enum merge_mode me"
            },
            {
              "variable": "files",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TY"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct xkb_context *ctx = keymap->ctx;"
            },
            {
              "variable": "Collect",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "keymap->ctx;\n\n    /* Collect section files and c"
            },
            {
              "variable": "Check",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n    /*\n     * Check that all required s"
            },
            {
              "variable": "Report",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "were provided.\n     * Report everything before f"
            },
            {
              "variable": "Compile",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "return false;\n\n    /* Compile sections. */\n    fo"
            },
            {
              "variable": "files",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pe++) {\n        if (files[type] == NULL) {"
            },
            {
              "variable": "files",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pe_to_string(type), files[type]->name);\n\n        ok"
            },
            {
              "variable": "compile_file_fns",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "ame);\n\n        ok = compile_file_fns[type](files[type], keymap"
            },
            {
              "variable": "files",
              "pattern": "array/pointer access (possibly without null check)",
              "line_context": "pile_file_fns[type](files[type], keymap, merge);"
            }
          ],
          "patterns_found": [
            "array/pointer access",
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 4,
        "array_count": 2,
        "size_variable_count": 1
      }
    },
    "predict": "{\"vulnerable_variables\": [\"files\", \"compile_file_fns\"]}",
    "vulnerable_variables": [
      "files",
      "compile_file_fns"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "files": "XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };",
      "compile_file_fns": "Definition not found"
    },
    "variable_types": {
      "files": "struct pointer array",
      "compile_file_fns": "unknown"
    },
    "type_mapping": {
      "files": "struct pointer array",
      "compile_file_fns": "unknown"
    }
  },
  {
    "idx": 160915,
    "project": "FFmpeg",
    "commit_id": "00e8181bd97c834fe60751b0c511d4bb97875f78",
    "project_url": "https://github.com/FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/00e8181bd97c834fe60751b0c511d4bb97875f78",
    "commit_message": "avcodec/ac3_parser: Check init_get_bits8() for failure\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_6.avi\n\nFound-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "label": 0,
    "func": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n \n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}\n",
    "func_hash": 69022085928273561828120058073996778140,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-13303",
    "cve_desc": "In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13303",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "buf",
          "hdr"
        ],
        "arrays": [],
        "size_variables": [
          "size_t",
          "sizeof",
          "get_bits_count",
          "size"
        ],
        "all_variables": [
          "size_t",
          "sizeof",
          "get_bits_count",
          "buf",
          "size",
          "hdr"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "phdr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ader(AC3HeaderInfo **phdr, const uint8_t *buf"
            },
            {
              "variable": "buf",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "phdr, const uint8_t *buf,"
            },
            {
              "variable": "hdr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n    AC3HeaderInfo *hdr;\n    int err;"
            },
            {
              "variable": "phdr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int err;\n\n    if (!*phdr)\n        *phdr = av"
            },
            {
              "variable": "phdr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (!*phdr)\n        *phdr = av_mallocz(sizeof"
            },
            {
              "variable": "phdr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "derInfo));\n    if (!*phdr)\n         return AV"
            },
            {
              "variable": "phdr",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ENOMEM);\n     hdr = *phdr;\n \n    err = init_g"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 6,
        "pointer_count": 2,
        "array_count": 0,
        "size_variable_count": 4
      }
    },
    "predict": "{\"vulnerable_variables\": [\"buf\", \"size\"]}",
    "vulnerable_variables": [
      "buf",
      "size"
    ],
    "vulnerable_variable": null,
    "variable_definitions": {
      "buf": "const uint8_t *buf,",
      "size": "size_t size"
    },
    "variable_types": {
      "buf": "integer pointer",
      "size": "integer"
    },
    "type_mapping": {
      "buf": "integer pointer",
      "size": "Integer"
    }
  },
  {
    "idx": 160917,
    "project": "FFmpeg",
    "commit_id": "2aa9047486dbff12d9e040f917e5f799ed2fd78b",
    "project_url": "https://github.com/FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b",
    "commit_message": "avcodec/mpeg4videodec: Check read profile before setting it\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_7.avi\n\nFound-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "label": 0,
    "func": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n         } else if (startcode == GOP_STARTCODE) {\n             mpeg4_decode_gop_header(s, gb);\n         } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                 s->studio_profile = 1;\n                 next_start_code_studio(gb);\n                 extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n             }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n         } else if (startcode == VISUAL_OBJ_STARTCODE) {\n             if (s->studio_profile) {\n                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n             return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n",
    "func_hash": 330188945297559948044988140730479926100,
    "file_name": "None",
    "file_hash": null,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-13301",
    "cve_desc": "In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13301",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "ctx",
          "s",
          "gb"
        ],
        "arrays": [],
        "size_variables": [
          "get_bits_count",
          "size_in_bits"
        ],
        "all_variables": [
          "s",
          "ctx",
          "get_bits_count",
          "size_in_bits",
          "gb"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "pegEncContext *s = &ctx->m;\n    unsigned start"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "bits(gb);\n\n    if (!s->studio_profile && s->avctx->bits_p"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "->studio_profile && s->avctx->bits_per_raw_sampl"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ample != 8)\n        s->avctx->bits_per_raw_sampl"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\")"
            },
            {
              "variable": "gb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "t_bits_count(gb) >= gb->size_in_bits) {\n            if ("
            },
            {
              "variable": "gb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ") {\n            if (gb->size_in_bits == 8 &&"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&&\n                (ctx->divx_version >= 0 || ctx->xvid_b"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ivx_version >= 0 || ctx->xvid_build >= 0) || s->codec_t"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\"))"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_VERBOSE, \"f"
            },
            {
              "variable": "gb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "\"frame skip %d\\n\", gb->size_in_bits);\n                r"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rtcode\n\n        if (s->avctx->debug & FF_DEBUG_S"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"sta"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vid"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vid"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Res"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"FGS"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Res"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vis"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vis"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Use"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Gro"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vid"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vis"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Vid"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"sli"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"ext"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"fgs"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"FBA"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"FBA"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Mes"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Mes"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Sti"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Tex"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Tex"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Tex"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Tex"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"stu"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"res"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \"Sys"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_DEBUG, \" at"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_WARNING, \"I"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n                 s->studio_profile = 1;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "} else if (s->studio_profile) {"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "priv_request_sample(s->avctx, \"Mixes studio and"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n            s->avctx->profile = profile;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rofile;\n            s->avctx->level   = level;"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "{\n             if (s->studio_profile) {"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\nend:\n    if (s->avctx->flags & AV_CODEC_F"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_LOW_DELAY)\n        s->low_delay = 1;\n     s->avctx-"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "low_delay = 1;\n     s->avctx->has_b_frames = !s-"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "tx->has_b_frames = !s->low_delay;\n \n     if (s->stud"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "w_delay;\n \n     if (s->studio_profile) {\n        av_asser"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_assert0(s->avctx->profile == FF_PROF"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "DIO);\n         if (!s->avctx->bits_per_raw_sampl"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "av_log(s->avctx, AV_LOG_ERROR, \"Mis"
            },
            {
              "variable": "ctx",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "der(Mpeg4DecContext *ctx, GetBitContext *gb)"
            },
            {
              "variable": "gb",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "*ctx, GetBitContext *gb)\n{\n    MpegEncConte"
            },
            {
              "variable": "s",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "MpegEncContext *s = &ctx->m;\n    unsi"
            },
            {
              "variable": "search",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "int vol = 0;\n\n    /* search next start code */"
            },
            {
              "variable": "use",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "}\n\n        /* use the bits after the"
            }
          ],
          "patterns_found": [
            "pointer dereference"
          ]
        }
      },
      "summary": {
        "total_variables": 5,
        "pointer_count": 3,
        "array_count": 0,
        "size_variable_count": 2
      }
    },
    "predict": "{\"vulnerable_variables\":[]}",
    "vulnerable_variables": [],
    "variable_definitions": {},
    "variable_types": {},
    "type_mapping": {}
  },
  {
    "idx": 160920,
    "project": "linux",
    "commit_id": "23fcb3340d033d9f081e21e6c12c2db7eaa541d3",
    "project_url": "https://github.com/torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3",
    "commit_message": "xfs: More robust inode extent count validation\n\nWhen the inode is in extent format, it can't have more extents that\nfit in the inode fork. We don't currenty check this, and so this\ncorruption goes unnoticed by the inode verifiers. This can lead to\ncrashes operating on invalid in-memory structures.\n\nAttempts to access such a inode will now error out in the verifier\nrather than allowing modification operations to proceed.\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Darrick J. Wong <darrick.wong@oracle.com>\n[darrick: fix a typedef, add some braces and breaks to shut up compiler warnings]\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>",
    "label": 0,
    "func": " xfs_dinode_verify(\n \tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_failaddr_t\t\tfa;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tflags;\n\tuint64_t\t\tflags2;\n\tuint64_t\t\tdi_size;\n\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn __this_address;\n\n\t/* Verify v3 integrity information first */\n\tif (dip->di_version >= 3) {\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn __this_address;\n\t\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t\t      XFS_DINODE_CRC_OFF))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(dip->di_ino) != ino)\n\t\t\treturn __this_address;\n\t\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t}\n\n\t/* don't allow invalid i_size */\n\tdi_size = be64_to_cpu(dip->di_size);\n\tif (di_size & (1ULL << 63))\n\t\treturn __this_address;\n\n\tmode = be16_to_cpu(dip->di_mode);\n\tif (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)\n\t\treturn __this_address;\n\n\t/* No zero-length symlinks/dirs. */\n\tif ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)\n\t\treturn __this_address;\n\n\t/* Fork checks carried over from xfs_iformat_fork */\n\tif (mode &&\n\t    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >\n\t\t\tbe64_to_cpu(dip->di_nblocks))\n\t\treturn __this_address;\n\n\tif (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)\n\t\treturn __this_address;\n\n\tflags = be16_to_cpu(dip->di_flags);\n\n\tif (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\treturn __this_address;\n\n\t/* Do we have appropriate data fork formats for the mode? */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (dip->di_format != XFS_DINODE_FMT_DEV)\n\t\t\treturn __this_address;\n\t\tbreak;\n \tcase S_IFREG:\n \tcase S_IFLNK:\n \tcase S_IFDIR:\n\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);\n\t\tif (fa)\n\t\t\treturn fa;\n \t\tbreak;\n \tcase 0:\n \t\t/* Uninitialized inode ok. */\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n \t}\n \n \tif (XFS_DFORK_Q(dip)) {\n\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);\n\t\tif (fa)\n\t\t\treturn fa;\n \t} else {\n \t\t/*\n \t\t * If there is no fork offset, this may be a freshly-made inode\n\t\t * in a new disk cluster, in which case di_aformat is zeroed.\n\t\t * Otherwise, such an inode must be in EXTENTS format; this goes\n\t\t * for freed inodes as well.\n\t\t */\n\t\tswitch (dip->di_aformat) {\n\t\tcase 0:\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t\tif (dip->di_anextents)\n\t\t\treturn __this_address;\n\t}\n\n\t/* extent size hint validation */\n\tfa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),\n\t\t\tmode, flags);\n\tif (fa)\n\t\treturn fa;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn NULL;\n\n\tflags2 = be64_to_cpu(dip->di_flags2);\n\n\t/* don't allow reflink/cowextsize if we don't have reflink */\n\tif ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&\n\t     !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\t/* only regular files get reflink */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)\n\t\treturn __this_address;\n\n\t/* don't let reflink and realtime mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))\n\t\treturn __this_address;\n\n\t/* don't let reflink and dax mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))\n\t\treturn __this_address;\n\n\t/* COW extent size hint validation */\n\tfa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),\n\t\t\tmode, flags, flags2);\n\tif (fa)\n\t\treturn fa;\n\n\treturn NULL;\n}\n",
    "func_hash": 337413762145059151966900295036121966544,
    "file_name": "xfs_inode_buf.c",
    "file_hash": 28431729147325602105540977225374642285,
    "cwe": [
      "CWE-476"
    ],
    "cve_id":"CVE-2018-13095",
    "cve_desc": "An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork.",
    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-13095",
    "vulnerability_analysis": {
      "extracted_variables": {
        "pointers": [
          "for",
          "dip",
          "in",
          "mp"
        ],
        "arrays": [],
        "size_variables": [
          "length",
          "i_size",
          "xfs_inode_validate_extsize",
          "cowextsize",
          "sb_inodesize",
          "xfs_inode_validate_cowextsize",
          "di_cowextsize",
          "di_extsize",
          "di_size",
          "XFS_DIFLAG2_COWEXTSIZE",
          "size"
        ],
        "all_variables": [
          "length",
          "dip",
          "i_size",
          "for",
          "xfs_inode_validate_extsize",
          "cowextsize",
          "sb_inodesize",
          "in",
          "xfs_inode_validate_cowextsize",
          "di_cowextsize",
          "mp",
          "di_size",
          "di_extsize",
          "XFS_DIFLAG2_COWEXTSIZE",
          "size"
        ]
      },
      "cwe_specific_analysis": {
        "CWE-476": {
          "cwe": "CWE-476",
          "vulnerable_variables": [
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "4_t\t\tdi_size;\n\n\tif (dip->di_magic != cpu_to_be16(XFS_"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ation first */\n\tif (dip->di_version >= 3) {\n\t\tif (!xfs_"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn __this_"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_cksum((char *)dip, mp->m_sb.sb_inodesize,"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": ";\n\t\tif (be64_to_cpu(dip->di_ino) != ino)\n\t\t\treturn"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ual(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\tr"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_size = be64_to_cpu(dip->di_size);\n\tif (di_size & (1"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "mode = be16_to_cpu(dip->di_mode);\n\tif (mode && xfs_"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "&&\n\t    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip-"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ents) + be16_to_cpu(dip->di_anextents) >\n\t\t\tbe64_to_cpu(d"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "s) >\n\t\t\tbe64_to_cpu(dip->di_nblocks))\n\t\treturn __this_a"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "S_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)\n\t\tret"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "flags = be16_to_cpu(dip->di_flags);\n\n\tif (mode && (fl"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "IFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\treturn __this_ad"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ase S_IFSOCK:\n\t\tif (dip->di_format != XFS_DINODE_FMT_D"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ll.\n\t\t */\n\t\tswitch (dip->di_aformat) {\n\t\tcase 0:\n\t\tcase"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "_address;\n\t\t}\n\t\tif (dip->di_anextents)\n\t\t\treturn __this_a"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ize(mp, be32_to_cpu(dip->di_extsize),\n\t\t\tmode, flags);"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "rified here */\n\tif (dip->di_version < 3)\n\t\treturn NULL;"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "lags2 = be64_to_cpu(dip->di_flags2);\n\n\t/* don't allow"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "version_hasreflink(&mp->m_sb))\n\t\treturn __this_a"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ize(mp, be32_to_cpu(dip->di_cowextsize),\n\t\t\tmode, flags, f"
            },
            {
              "variable": "mp",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,"
            },
            {
              "variable": "dip",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "struct xfs_dinode\t*dip)\n{\n\txfs_failaddr_t"
            },
            {
              "variable": "Verify",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* Verify v3 integrity inform"
            },
            {
              "variable": "don",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "this_address;\n\t}\n\n\t/* don't allow invalid i_s"
            },
            {
              "variable": "No",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* No zero-length symlink"
            },
            {
              "variable": "Fork",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* Fork checks carried over"
            },
            {
              "variable": "Do",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* Do we have appropriate"
            },
            {
              "variable": "Uninitialized",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "reak;\n \tcase 0:\n \t\t/* Uninitialized inode ok. */\n\t\tbrea"
            },
            {
              "variable": "If",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "} else {\n \t\t/*\n \t\t * If there is no fork of"
            },
            {
              "variable": "in",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "eshly-made inode\n\t\t * in a new disk cluster,"
            },
            {
              "variable": "Otherwise",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "ormat is zeroed.\n\t\t * Otherwise, such an inode must"
            },
            {
              "variable": "extent",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "this_address;\n\t}\n\n\t/* extent size hint validatio"
            },
            {
              "variable": "only",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "fa)\n\t\treturn fa;\n\n\t/* only version 3 or greate"
            },
            {
              "variable": "don",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "dip->di_flags2);\n\n\t/* don't allow reflink/cow"
            },
            {
              "variable": "only",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* only regular files get r"
            },
            {
              "variable": "don",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* don't let reflink and r"
            },
            {
              "variable": "don",
              "pattern": "pointer dereference (possibly without null check)",
              "line_context": "__this_address;\n\n\t/* don't let reflink and d"
            },
            {
              "variable": "COW",
              "pattern": "pointer dereference (possibly without null check)",
              "line