{"idx": 157857, "project": "savannah", "commit_id": "190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "commit_message": "None", "target": 0, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n  *session_data_size = psession.size;\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 217937088037221829579003352102231694649, "file_name": "gnutls_session.c", "file_hash": 172090285683835050051624343283961906986, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 157858, "project": "savannah", "commit_id": "e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "commit_message": "None", "target": 0, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n \n   if (psession.size > *session_data_size)\n     {\n      *session_data_size = psession.size;\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 282098968981021847575763555214602715866, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 157899, "project": "pengutronix", "commit_id": "574ce994016107ad8ab0f845a785f28d7eaa5208", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_message": "None", "target": 0, "func": "static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,\n\t\t\t    char **target)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tuint32_t len;\n\tstruct packet *nfs_packet;\n\n\t/*\n\t * struct READLINK3args {\n\t * \tnfs_fh3 symlink;\n\t * };\n\t *\n\t * struct READLINK3resok {\n\t * \tpost_op_attr symlink_attributes;\n\t * \tnfspath3 data;\n\t * };\n\t *\n\t * struct READLINK3resfail {\n\t * \tpost_op_attr symlink_attributes;\n\t * }\n\t *\n\t * union READLINK3res switch (nfsstat3 status) {\n\t * case NFS3_OK:\n\t * \tREADLINK3resok resok;\n\t * default:\n\t * \tREADLINK3resfail resfail;\n\t * };\n\t */\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tp = nfs_add_fh3(p, fh);\n\n\tlen = p - &(data[0]);\n\n\tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);\n\tif (IS_ERR(nfs_packet))\n\t\treturn PTR_ERR(nfs_packet);\n\n\tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;\n\n \tp = nfs_read_post_op_attr(p, NULL);\n \n \tlen = ntoh32(net_read_uint32(p)); /* new path length */\n\n\tlen = max_t(unsigned int, len,\n\t\t    nfs_packet->len - sizeof(struct rpc_reply) - sizeof(uint32_t));\n\n \tp++;\n \n \t*target = xzalloc(len + 1);\n\treturn 0;\n}\n", "func_hash": 52376305515786293225734978443916270796, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15938", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_req in fs/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15938"}
{"idx": 157900, "project": "pengutronix", "commit_id": "84986ca024462058574432b5483f4bf9136c538d", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/net/nfs.c?h=next&id=84986ca024462058574432b5483f4bf9136c538d", "commit_message": "None", "target": 0, "func": "static int nfs_readlink_reply(unsigned char *pkt, unsigned len)\n {\n \tuint32_t *data;\n \tchar *path;\n\tunsigned int rlen;\n \tint ret;\n \n \tret = rpc_check_reply(pkt, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));\n\n\tdata++;\n \n \trlen = ntohl(net_read_uint32(data)); /* new path length */\n \n\trlen = max_t(unsigned int, rlen,\n\t\t     len - sizeof(struct rpc_reply) - sizeof(uint32_t));\n\n \tdata++;\n \tpath = (char *)data;\n\t} else {\n\t\tmemcpy(nfs_path, path, rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n", "func_hash": 206056256559243150120680816426898705118, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15937", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_reply in net/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15937"}
{"idx": 157919, "project": "libxfont", "commit_id": "d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_message": "None", "target": 0, "func": "BufCompressedFill (BufFilePtr f)\n{\n    CompressedFile  *file;\n    register char_type *stackp, *de_stack;\n    register char_type finchar;\n    register code_int code, oldcode, incode;\n    BufChar\t    *buf, *bufend;\n\n    file = (CompressedFile *) f->private;\n\n    buf = f->buffer;\n    bufend = buf + BUFFILESIZE;\n    stackp = file->stackp;\n    de_stack = file->de_stack;\n    finchar = file->finchar;\n    oldcode = file->oldcode;\n    while (buf < bufend) {\n\twhile (stackp > de_stack && buf < bufend)\n\t    *buf++ = *--stackp;\n\n\tif (buf == bufend)\n\t    break;\n\n\tif (oldcode == -1)\n\t    break;\n\n\tcode = getcode (file);\n\tif (code == -1)\n\t    break;\n    \n    \tif ( (code == CLEAR) && file->block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t    \tfile->tab_prefix[code] = 0;\n\t    file->clear_flg = 1;\n\t    file->free_ent = FIRST - 1;\n\t    if ( (code = getcode (file)) == -1 )\t/* O, untimely death! */\n\t    \tbreak;\n    \t}\n    \tincode = code;\n    \t/*\n     \t * Special case for KwKwK string.\n     \t */\n    \tif ( code >= file->free_ent ) {\n\t    *stackp++ = finchar;\n\t    code = oldcode;\n    \t}\n    \n    \t/*\n     \t * Generate output characters in reverse order\n      \t */\n     \twhile ( code >= 256 )\n     \t{\n\t    if (stackp - de_stack >= STACK_SIZE - 1)\n\t\treturn BUFFILEEOF;\n \t    *stackp++ = file->tab_suffix[code];\n \t    code = file->tab_prefix[code];\n     \t}\n    \n    \t/*\n     \t * Generate the new entry.\n     \t */\n    \tif ( (code=file->free_ent) < file->maxmaxcode ) {\n\t    file->tab_prefix[code] = (unsigned short)oldcode;\n\t    file->tab_suffix[code] = finchar;\n\t    file->free_ent = code+1;\n    \t} \n\t/*\n\t * Remember previous code.\n\t */\n\toldcode = incode;\n    }\n    file->oldcode = oldcode;\n    file->stackp = stackp;\n    file->finchar = finchar;\n    if (buf == f->buffer) {\n\tf->left = 0;\n\treturn BUFFILEEOF;\n    }\n    f->bufp = f->buffer + 1;\n    f->left = (buf - f->buffer) - 1;\n    return f->buffer[0];\n}\n", "func_hash": 176288859918527814344787198280161772156, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-2895", "cve_desc": "The LZW decompressor in (1) the BufCompressedFill function in fontfile/decompress.c in X.Org libXfont before 1.4.4 and (2) compress/compress.c in 4.3BSD, as used in zopen.c in OpenBSD before 3.8, FreeBSD, NetBSD 4.0.x and 5.0.x before 5.0.3 and 5.1.x before 5.1.1, FreeType 2.1.9, and other products, does not properly handle code words that are absent from the decompression table when encountered, which allows context-dependent attackers to trigger an infinite loop or a heap-based buffer overflow, and possibly execute arbitrary code, via a crafted compressed stream, a related issue to CVE-2006-1168 and CVE-2011-2896.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2895"}
{"idx": 157920, "project": "musl", "commit_id": "45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "project_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_message": "None", "target": 0, "func": "static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)\n {\n \tchar tmp[256];\n \tstruct dpc_ctx *ctx = c;\n\tif (ctx->cnt >= MAXADDRS) return -1;\n \tswitch (rr) {\n \tcase RR_A:\n \t\tif (len != 4) return -1;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);\n\t\tbreak;\n\tcase RR_AAAA:\n\t\tif (len != 16) return -1;\n\t\tctx->addrs[ctx->cnt].family = AF_INET6;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);\n\t\tbreak;\n\tcase RR_CNAME:\n\t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,\n\t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))\n\t\t\tstrcpy(ctx->canon, tmp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "func_hash": 60029525500602919860744776503907800398, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-15650", "cve_desc": "musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15650"}
{"idx": 157922, "project": "poppler", "commit_id": "b8682d868ddf7f741e93b791588af0932893f95c", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/utils/pdfseparate.cc?id=b8682d868ddf7f741e93b", "commit_message": "pdfseparate: improve the path building\n\nMake use of snprintf to limit the output to the pathName buffer;\nwhile I'm there, expand its size to 4096 (might help longer paths),\nalthough a better fix would be dynamically allocate its length\n(and/or using GooString, maybe).", "target": 0, "func": " bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n   GooString *gfileName = new GooString (srcFileName);\n   PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n \n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n    firstPage = 1;\n  if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n    snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n     int errCode = doc->savePageAs(gpageName, pageNo);\n     if ( errCode != errNone) {\n      delete gpageName;\n      delete gfileName;\n      return false;\n    }\n    delete gpageName;\n  }\n  delete gfileName;\n  return true;\n}\n", "func_hash": 151037751520527895735005785354898270248, "file_name": "pdfseparate.cc", "file_hash": 242088384603448305863907034385681213666, "cwe": ["CWE-119"], "cve": "CVE-2013-4473", "cve_desc": "Stack-based buffer overflow in the extractPages function in utils/pdfseparate.cc in poppler before 0.24.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a source filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4473"}
{"idx": 157954, "project": "savannah", "commit_id": "ba6b44f6745b14dce414761a8e4b35d31b176bba", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/wget.git/commit/?id=ba6b44f6745b14dce414761a8e4b35d31b176bba", "commit_message": "None", "target": 0, "func": "fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread, wgint startpos,\n\n              wgint *qtyread, wgint *qtywritten, double *elapsed, int flags,\n              FILE *out2)\n{\n  int ret = 0;\n#undef max\n#define max(a,b) ((a) > (b) ? (a) : (b))\n  int dlbufsize = max (BUFSIZ, 8 * 1024);\n  char *dlbuf = xmalloc (dlbufsize);\n\n  struct ptimer *timer = NULL;\n  double last_successful_read_tm = 0;\n\n  /* The progress gauge, set according to the user preferences. */\n  void *progress = NULL;\n\n  /* Non-zero if the progress gauge is interactive, i.e. if it can\n     continually update the display.  When true, smaller timeout\n     values are used so that the gauge can update the display when\n     data arrives slowly. */\n  bool progress_interactive = false;\n\n  bool exact = !!(flags & rb_read_exactly);\n\n  /* Used only by HTTP/HTTPS chunked transfer encoding.  */\n  bool chunked = flags & rb_chunked_transfer_encoding;\n  wgint skip = 0;\n\n  /* How much data we've read/written.  */\n  wgint sum_read = 0;\n  wgint sum_written = 0;\n  wgint remaining_chunk_size = 0;\n\n#ifdef HAVE_LIBZ\n  /* try to minimize the number of calls to inflate() and write_data() per\n     call to fd_read() */\n  unsigned int gzbufsize = dlbufsize * 4;\n  char *gzbuf = NULL;\n  z_stream gzstream;\n\n  if (flags & rb_compressed_gzip)\n    {\n      gzbuf = xmalloc (gzbufsize);\n      if (gzbuf != NULL)\n        {\n          gzstream.zalloc = zalloc;\n          gzstream.zfree = zfree;\n          gzstream.opaque = Z_NULL;\n          gzstream.next_in = Z_NULL;\n          gzstream.avail_in = 0;\n\n          #define GZIP_DETECT 32 /* gzip format detection */\n          #define GZIP_WINDOW 15 /* logarithmic window size (default: 15) */\n          ret = inflateInit2 (&gzstream, GZIP_DETECT | GZIP_WINDOW);\n          if (ret != Z_OK)\n            {\n              xfree (gzbuf);\n              errno = (ret == Z_MEM_ERROR) ? ENOMEM : EINVAL;\n              ret = -1;\n              goto out;\n            }\n        }\n      else\n        {\n          errno = ENOMEM;\n          ret = -1;\n          goto out;\n        }\n    }\n#endif\n\n  if (flags & rb_skip_startpos)\n    skip = startpos;\n\n  if (opt.show_progress)\n    {\n      const char *filename_progress;\n      /* If we're skipping STARTPOS bytes, pass 0 as the INITIAL\n         argument to progress_create because the indicator doesn't\n         (yet) know about \"skipping\" data.  */\n      wgint start = skip ? 0 : startpos;\n      if (opt.dir_prefix)\n        filename_progress = downloaded_filename + strlen (opt.dir_prefix) + 1;\n      else\n        filename_progress = downloaded_filename;\n      progress = progress_create (filename_progress, start, start + toread);\n      progress_interactive = progress_interactive_p (progress);\n    }\n\n  if (opt.limit_rate)\n    limit_bandwidth_reset ();\n\n  /* A timer is needed for tracking progress, for throttling, and for\n     tracking elapsed time.  If either of these are requested, start\n     the timer.  */\n  if (progress || opt.limit_rate || elapsed)\n    {\n      timer = ptimer_new ();\n      last_successful_read_tm = 0;\n    }\n\n  /* Use a smaller buffer for low requested bandwidths.  For example,\n     with --limit-rate=2k, it doesn't make sense to slurp in 16K of\n     data and then sleep for 8s.  With buffer size equal to the limit,\n     we never have to sleep for more than one second.  */\n  if (opt.limit_rate && opt.limit_rate < dlbufsize)\n    dlbufsize = opt.limit_rate;\n\n  /* Read from FD while there is data to read.  Normally toread==0\n     means that it is unknown how much data is to arrive.  However, if\n     EXACT is set, then toread==0 means what it says: that no data\n     should be read.  */\n  while (!exact || (sum_read < toread))\n    {\n      int rdsize;\n      double tmout = opt.read_timeout;\n\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                {\n                  ret = -1;\n                  break;\n                }\n              else if (out2 != NULL)\n                fwrite (line, 1, strlen (line), out2);\n\n               remaining_chunk_size = strtol (line, &endl, 16);\n               xfree (line);\n \n              if (remaining_chunk_size < 0)\n                {\n                  ret = -1;\n                  break;\n                }\n\n               if (remaining_chunk_size == 0)\n                 {\n                   ret = 0;\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                  break;\n                }\n            }\n\n          rdsize = MIN (remaining_chunk_size, dlbufsize);\n        }\n      else\n        rdsize = exact ? MIN (toread - sum_read, dlbufsize) : dlbufsize;\n\n      if (progress_interactive)\n        {\n          /* For interactive progress gauges, always specify a ~1s\n             timeout, so that the gauge can be updated regularly even\n             when the data arrives very slowly or stalls.  */\n          tmout = 0.95;\n          if (opt.read_timeout)\n            {\n              double waittm;\n              waittm = ptimer_read (timer) - last_successful_read_tm;\n              if (waittm + tmout > opt.read_timeout)\n                {\n                  /* Don't let total idle time exceed read timeout. */\n                  tmout = opt.read_timeout - waittm;\n                  if (tmout < 0)\n                    {\n                      /* We've already exceeded the timeout. */\n                      ret = -1, errno = ETIMEDOUT;\n                      break;\n                    }\n                }\n            }\n        }\n      ret = fd_read (fd, dlbuf, rdsize, tmout);\n\n      if (progress_interactive && ret < 0 && errno == ETIMEDOUT)\n        ret = 0;                /* interactive timeout, handled above */\n      else if (ret <= 0)\n        break;                  /* EOF or read error */\n\n      if (progress || opt.limit_rate || elapsed)\n        {\n          ptimer_measure (timer);\n          if (ret > 0)\n            last_successful_read_tm = ptimer_read (timer);\n        }\n\n      if (ret > 0)\n        {\n          int write_res;\n\n          sum_read += ret;\n\n#ifdef HAVE_LIBZ\n          if (gzbuf != NULL)\n            {\n              int err;\n              int towrite;\n              gzstream.avail_in = ret;\n              gzstream.next_in = (unsigned char *) dlbuf;\n\n              do\n                {\n                  gzstream.avail_out = gzbufsize;\n                  gzstream.next_out = (unsigned char *) gzbuf;\n\n                  err = inflate (&gzstream, Z_NO_FLUSH);\n\n                  switch (err)\n                    {\n                    case Z_MEM_ERROR:\n                      errno = ENOMEM;\n                      ret = -1;\n                      goto out;\n                    case Z_NEED_DICT:\n                    case Z_DATA_ERROR:\n                      errno = EINVAL;\n                      ret = -1;\n                      goto out;\n                    case Z_STREAM_END:\n                      if (exact && sum_read != toread)\n                        {\n                          DEBUGP((\"zlib stream ended unexpectedly after \"\n                                  \"%ld/%ld bytes\\n\", sum_read, toread));\n                        }\n                    }\n\n                  towrite = gzbufsize - gzstream.avail_out;\n                  write_res = write_data (out, out2, gzbuf, towrite, &skip,\n                                          &sum_written);\n                  if (write_res < 0)\n                    {\n                      ret = (write_res == -3) ? -3 : -2;\n                      goto out;\n                    }\n                }\n              while (gzstream.avail_out == 0);\n            }\n          else\n#endif\n            {\n              write_res = write_data (out, out2, dlbuf, ret, &skip,\n                                      &sum_written);\n              if (write_res < 0)\n                {\n                  ret = (write_res == -3) ? -3 : -2;\n                  goto out;\n                }\n            }\n\n          if (chunked)\n            {\n              remaining_chunk_size -= ret;\n              if (remaining_chunk_size == 0)\n                {\n                  char *line = fd_read_line (fd);\n                  if (line == NULL)\n                    {\n                      ret = -1;\n                      break;\n                    }\n                  else\n                    {\n                      if (out2 != NULL)\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                }\n            }\n        }\n\n      if (opt.limit_rate)\n        limit_bandwidth (ret, timer);\n\n      if (progress)\n        progress_update (progress, ret, ptimer_read (timer));\n#ifdef WINDOWS\n      if (toread > 0 && opt.show_progress)\n        ws_percenttitle (100.0 *\n                         (startpos + sum_read) / (startpos + toread));\n#endif\n    }\n", "func_hash": 220093956480677323605982437392462496483, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-13090", "cve_desc": "The retr.c:fd_read_body() function is called when processing OK responses. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to read the chunk in pieces of 8192 bytes by using the MIN() macro, but ends up passing the negative chunk length to retr.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument. The attacker can corrupt malloc metadata after the allocated buffer.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-13090"}
{"idx": 157964, "project": "haproxy", "commit_id": "7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commit;h=7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "commit_message": "None", "target": 0, "func": " void buffer_slow_realign(struct buffer *buf)\n {\n       int block1 = buf->o;\n       int block2 = 0;\n\n       /* process output data in two steps to cover wrapping */\n       if (block1 > buf->p - buf->data) {\n               block2 = buf->p - buf->data;\n               block1 -= block2;\n       }\n       memcpy(swap_buffer + buf->size - buf->o, bo_ptr(buf), block1);\n       memcpy(swap_buffer + buf->size - block2, buf->data, block2);\n\n       /* process input data in two steps to cover wrapping */\n       block1 = buf->i;\n       block2 = 0;\n\n       if (block1 > buf->data + buf->size - buf->p) {\n               block1 = buf->data + buf->size - buf->p;\n               block2 = buf->i - block1;\n        }\n       memcpy(swap_buffer, bi_ptr(buf), block1);\n       memcpy(swap_buffer + block1, buf->data, block2);\n\n       /* reinject changes into the buffer */\n       memcpy(buf->data, swap_buffer, buf->i);\n       memcpy(buf->data + buf->size - buf->o, swap_buffer + buf->size - buf->o, buf->o);\n \n        buf->p = buf->data;\n }\n", "func_hash": 93118898612400237957558909236733687601, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-3281", "cve_desc": "The buffer_slow_realign function in HAProxy 1.5.x before 1.5.14 and 1.6-dev does not properly realign a buffer that is used for pending outgoing data, which allows remote attackers to obtain sensitive information (uninitialized memory contents of previous requests) via a crafted request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3281"}
{"idx": 157965, "project": "savannah", "commit_id": "3f872fe60463a931c5c766dbf8c36870c0023e88", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=3f872fe60463a931c5c766dbf8c36870c0023e88", "commit_message": "None", "target": 0, "func": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_register_event *emsg;\n  int len;\n\n  emsg = (struct msg_register_event *) buf;\n  len = sizeof (struct msg_register_event) +\n    filter->num_areas * sizeof (struct in_addr);\n   emsg->filter.typemask = htons (filter->typemask);\n   emsg->filter.origin = filter->origin;\n   emsg->filter.num_areas = filter->num_areas;\n  if (len > sizeof (buf))\n    len = sizeof(buf);\n  /* API broken - missing memcpy to fill data */\n   return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);\n }\n", "func_hash": 145214918048062551547513527429211682293, "file_name": "ospf_api.c", "file_hash": 14936573712231031653620730937465117872, "cwe": ["CWE-119"], "cve": "CVE-2013-2236", "cve_desc": "Stack-based buffer overflow in the new_msg_lsa_change_notify function in the OSPFD API (ospf_api.c) in Quagga before 0.99.22.2, when --enable-opaque-lsa and the -a command line option are used, allows remote attackers to cause a denial of service (crash) via a large LSA.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2236"}
{"idx": 157985, "project": "netfilter", "commit_id": "2ae1099a42e6a0f06de305ca13a842ac83d4683e", "project_url": "https://git.netfilter.org/conntrack-tools", "commit_url": "https://git.netfilter.org/iptables/commit/iptables/xshared.c?id=2ae1099a42e6a0f06de305ca13a842ac83d4683e", "commit_message": "None", "target": 0, "func": " void add_param_to_argv(char *parsestart, int line)\n {\n\tint quote_open = 0, escaped = 0;\n\tstruct xt_param_buf param = {};\n\tchar *curchar;\n \n \t/* After fighting with strtok enough, here's now\n \t * a 'real' parser. According to Rusty I'm now no\n\t\t\t} else {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \tfor (curchar = parsestart; *curchar; curchar++) {\n \t\tif (quote_open) {\n \t\t\tif (escaped) {\n\t\t\t\tadd_param(&param, curchar);\n \t\t\t\tescaped = 0;\n \t\t\t\tcontinue;\n \t\t\t} else if (*curchar == '\\\\') {\n\t\t}\n\n\t\tswitch (*curchar) {\n \t\t\t\tquote_open = 0;\n \t\t\t\t*curchar = '\"';\n \t\t\t} else {\n\t\t\t\tadd_param(&param, curchar);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* regular character, copy to buffer */\n\t\t\tparam_buffer[param_len++] = *curchar;\n\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n \t\tcase ' ':\n \t\tcase '\\t':\n \t\tcase '\\n':\n\t\t\tif (!param.len) {\n \t\t\t\t/* two spaces? */\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n \t\t\t/* regular character, copy to buffer */\n\t\t\tadd_param(&param, curchar);\n \t\t\tcontinue;\n \t\t}\n \n\t\tparam.buffer[param.len] = '\\0';\n \n \t\t/* check if table name specified */\n\t\tif ((param.buffer[0] == '-' &&\n\t\t     param.buffer[1] != '-' &&\n\t\t     strchr(param.buffer, 't')) ||\n\t\t    (!strncmp(param.buffer, \"--t\", 3) &&\n\t\t     !strncmp(param.buffer, \"--table\", strlen(param.buffer)))) {\n \t\t\txtables_error(PARAMETER_PROBLEM,\n \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",\n \t\t\t\t      line, xt_params->program_name);\n \t\t}\n \n\t\tadd_argv(param.buffer, 0);\n\t\tparam.len = 0;\n \t}\n", "func_hash": 82639535107168519393189431221613615364, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-11360", "cve_desc": "A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-11360"}
{"idx": 157990, "project": "xserver", "commit_id": "215f894965df5fb0bb45b107d84524e700d2073c", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=215f894965df5fb0bb45b107d84524e700d2073c", "commit_message": "dix: Disallow GenericEvent in SendEvent request.\n\nThe SendEvent request holds xEvent which is exactly 32 bytes long, no more,\nno less. Both ProcSendEvent and SProcSendEvent verify that the received data\nexactly match the request size. However nothing stops the client from passing\nin event with xEvent::type = GenericEvent and any value of\nxGenericEvent::length.\n\nIn the case of ProcSendEvent, the event will be eventually passed to\nWriteEventsToClient which will see that it is Generic event and copy the\narbitrary length from the receive buffer (and possibly past it) and send it to\nthe other client. This allows clients to copy unitialized heap memory out of X\nserver or to crash it.\n\nIn case of SProcSendEvent, it will attempt to swap the incoming event by\ncalling a swapping function from the EventSwapVector array. The swapped event\nis written to target buffer, which in this case is local xEvent variable. The\nxEvent variable is 32 bytes long, but the swapping functions for GenericEvents\nexpect that the target buffer has size matching the size of the source\nGenericEvent. This allows clients to cause stack buffer overflows.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 0, "func": "ProcSendEvent(ClientPtr client)\n{\n    WindowPtr pWin;\n    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */\n    DeviceIntPtr dev = PickPointer(client);\n    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);\n    SpritePtr pSprite = dev->spriteInfo->sprite;\n\n    REQUEST(xSendEventReq);\n\n    REQUEST_SIZE_MATCH(xSendEventReq);\n\n    /* libXext and other extension libraries may set the bit indicating\n     * that this event came from a SendEvent request so remove it\n     * since otherwise the event type may fail the range checks\n     * and cause an invalid BadValue error to be returned.\n     *\n     * This is safe to do since we later add the SendEvent bit (0x80)\n     * back in once we send the event to the client */\n\n    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);\n\n    /* The client's event type must be a core event type or one defined by an\n       extension. */\n\n    if (!((stuff->event.u.u.type > X_Reply &&\n           stuff->event.u.u.type < LASTEvent) ||\n          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&\n           stuff->event.u.u.type < (unsigned) lastEvent))) {\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n    /* Generic events can have variable size, but SendEvent request holds\n       exactly 32B of event data. */\n    if (stuff->event.u.u.type == GenericEvent) {\n        client->errorValue = stuff->event.u.u.type;\n        return BadValue;\n    }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {\n    }\n\n    if (stuff->destination == PointerWindow)\n        pWin = pSprite->win;\n    else if (stuff->destination == InputFocus) {\n        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;\n\n        if (inputFocus == NoneWin)\n            return Success;\n\n        /* If the input focus is PointerRootWin, send the event to where\n           the pointer is if possible, then perhaps propogate up to root. */\n        if (inputFocus == PointerRootWin)\n            inputFocus = GetCurrentRootWindow(dev);\n\n        if (IsParent(inputFocus, pSprite->win)) {\n            effectiveFocus = inputFocus;\n            pWin = pSprite->win;\n        }\n        else\n            effectiveFocus = pWin = inputFocus;\n    }\n    else\n        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);\n\n    if (!pWin)\n        return BadWindow;\n    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {\n        client->errorValue = stuff->propagate;\n        return BadValue;\n    }\n    stuff->event.u.u.type |= SEND_EVENT_BIT;\n    if (stuff->propagate) {\n        for (; pWin; pWin = pWin->parent) {\n            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,\n                         &stuff->event, 1))\n                return Success;\n            if (DeliverEventsToWindow(dev, pWin,\n                                      &stuff->event, 1, stuff->eventMask,\n                                      NullGrab))\n                return Success;\n            if (pWin == effectiveFocus)\n                return Success;\n            stuff->eventMask &= ~wDontPropagateMask(pWin);\n            if (!stuff->eventMask)\n                break;\n        }\n    }\n    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))\n        DeliverEventsToWindow(dev, pWin, &stuff->event,\n                              1, stuff->eventMask, NullGrab);\n    return Success;\n}\n", "func_hash": 107904058737663543656332226040399053348, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 157991, "project": "xserver", "commit_id": "8caed4df36b1f802b4992edcfd282cbeeec35d9d", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=8caed4df36b1f802b4992edcfd282cbeeec35d9d", "commit_message": "Xi: Verify all events in ProcXSendExtensionEvent.\n\nThe requirement is that events have type in range\nEXTENSION_EVENT_BASE..lastEvent, but it was tested\nonly for first event of all.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 0, "func": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret, i;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n\n    if (stuff->num_events == 0)\n        return ret;\n\n     /* The client's event type must be one defined by an extension. */\n \n     first = ((xEvent *) &stuff[1]);\n    for (i = 0; i < stuff->num_events; i++) {\n        if (!((EXTENSION_EVENT_BASE <= first[i].u.u.type) &&\n            (first[i].u.u.type < lastEvent))) {\n            client->errorValue = first[i].u.u.type;\n            return BadValue;\n        }\n     }\n \n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n\n    return ret;\n}\n", "func_hash": 7864871216394926527164481647583599943, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 158000, "project": "ghostscript", "commit_id": "c53183d4e7103e87368b7cfa15367a47d559e323", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c53183d4e7103e87368b7cfa15367a47d559e323", "commit_message": "None", "target": 0, "func": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    /* This function is copied verbatim from plfont.c */\n\n    int table_length;\n     int table_offset;\n \n     ulong format;\n    int numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; /* post table pointer */\n \n    if (glyph >= GS_MIN_GLYPH_INDEX) {\n        glyph -= GS_MIN_GLYPH_INDEX;\n    }\n\n     /* guess if the font type is not truetype */\n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }\n", "func_hash": 61931341795887404678779836705866374570, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9619", "cve_desc": "The xps_true_callback_glyph_name function in xps/xpsttf.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (Segmentation Violation and application crash) via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9619"}
{"idx": 158001, "project": "ghostscript", "commit_id": "3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "commit_message": "None", "target": 0, "func": "xps_load_sfnt_name(xps_font_t *font, char *namep)\nxps_load_sfnt_name(xps_font_t *font, char *namep, const int buflen)\n {\n     byte *namedata;\n     int offset, length;\n    /*int format;*/\n    int count, stringoffset;\n    int found;\n    int i, k;\n\n    found = 0;\n    strcpy(namep, \"Unknown\");\n\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n        return;\n    }\n\n    /* validate the offset, and the data for the two\n     * values we're about to read\n     */\n    if (offset + 6 > font->length)\n    {\n        gs_warn(\"name table byte offset invalid\");\n        return;\n    }\n    namedata = font->data + offset;\n\n    /*format = u16(namedata + 0);*/\n    count = u16(namedata + 2);\n    stringoffset = u16(namedata + 4);\n\n    if (stringoffset + offset > font->length\n        || offset + 6 + count * 12 > font->length)\n    {\n        gs_warn(\"name table invalid\");\n        return;\n    }\n\n    if (length < 6 + (count * 12))\n    {\n        gs_warn(\"name table too short\");\n        return;\n    }\n\n    for (i = 0; i < count; i++)\n    {\n        byte *record = namedata + 6 + i * 12;\n        int pid = u16(record + 0);\n        int eid = u16(record + 2);\n        int langid = u16(record + 4);\n        int nameid = u16(record + 6);\n         length = u16(record + 8);\n         offset = u16(record + 10);\n \n        length = length > buflen - 1 ? buflen - 1: length;\n\n         /* Full font name or postscript name */\n         if (nameid == 4 || nameid == 6)\n         {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n\n            if (pid == 3 && eid == 1 && langid == 0x409) /* windows unicode ucs-2, US */\n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n\n            if (pid == 3 && eid == 10 && langid == 0x409) /* windows unicode ucs-4, US */\n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n", "func_hash": 35053491490394057768170760061098710155, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9618", "cve_desc": "The xps_load_sfnt_name function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9618"}
{"idx": 158011, "project": "openssl", "commit_id": "d0666f289ac013094bbbf547bfbcd616199b7d2d", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d0666f289ac013094bbbf547bfbcd616199b7d2d", "commit_message": "evp: prevent underflow in base64 decoding\n\nThis patch resolves RT ticket #2608.\n\nThanks to Robert Dugal for originally spotting this, and to David\nRamos for noticing that the ball had been dropped.\n\nSigned-off-by: Geoff Thorpe <geoff@openssl.org>", "target": 0, "func": "int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint seof= -1,eof=0,rv= -1,ret=0,i,v,tmp,n,ln,exp_nl;\n\tunsigned char *d;\n\n\tn=ctx->num;\n\td=ctx->enc_data;\n\tln=ctx->line_num;\n\texp_nl=ctx->expect_nl;\n\n\t/* last line of input. */\n\tif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF)))\n\t\t{ rv=0; goto end; }\n\t\t\n\t/* We parse the input data */\n\tfor (i=0; i<inl; i++)\n\t\t{\n\t\t/* If the current line is > 80 characters, scream alot */\n\t\tif (ln >= 80) { rv= -1; goto end; }\n\n\t\t/* Get char and put it into the buffer */\n\t\ttmp= *(in++);\n\t\tv=conv_ascii2bin(tmp);\n\t\t/* only save the good data :-) */\n\t\tif (!B64_NOT_BASE64(v))\n\t\t\t{\n\t\t\tOPENSSL_assert(n < (int)sizeof(ctx->enc_data));\n\t\t\td[n++]=tmp;\n\t\t\tln++;\n\t\t\t}\n\t\telse if (v == B64_ERROR)\n\t\t\t{\n\t\t\trv= -1;\n\t\t\tgoto end;\n\t\t\t}\n\n\t\t/* have we seen a '=' which is 'definitly' the last\n\t\t * input line.  seof will point to the character that\n\t\t * holds it. and eof will hold how many characters to\n\t\t * chop off. */\n\t\tif (tmp == '=')\n\t\t\t{\n\t\t\tif (seof == -1) seof=n;\n\t\t\teof++;\n\t\t\t}\n\n\t\tif (v == B64_CR)\n\t\t\t{\n\t\t\tln = 0;\n\t\t\tif (exp_nl)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t/* eoln */\n\t\tif (v == B64_EOLN)\n\t\t\t{\n\t\t\tln=0;\n\t\t\tif (exp_nl)\n\t\t\t\t{\n\t\t\t\texp_nl=0;\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\texp_nl=0;\n\n\t\t/* If we are at the end of input and it looks like a\n\t\t * line, process it. */\n\t\tif (((i+1) == inl) && (((n&3) == 0) || eof))\n\t\t\t{\n\t\t\tv=B64_EOF;\n\t\t\t/* In case things were given us in really small\n\t\t\t   records (so two '=' were given in separate\n\t\t\t   updates), eof may contain the incorrect number\n\t\t\t   of ending bytes to skip, so let's redo the count */\n\t\t\teof = 0;\n\t\t\tif (d[n-1] == '=') eof++;\n\t\t\tif (d[n-2] == '=') eof++;\n\t\t\t/* There will never be more than two '=' */\n\t\t\t}\n\n\t\tif ((v == B64_EOF && (n&3) == 0) || (n >= 64))\n\t\t\t{\n\t\t\t/* This is needed to work correctly on 64 byte input\n\t\t\t * lines.  We process the line and then need to\n\t\t\t * accept the '\\n' */\n\t\t\tif ((v != B64_EOF) && (n >= 64)) exp_nl=1;\n\t\t\tif (n > 0)\n\t\t\t\t{\n                                v=EVP_DecodeBlock(out,d,n);\n                                n=0;\n                                if (v < 0) { rv=0; goto end; }\n                               if (eof > v) { rv=-1; goto end; }\n                                ret+=(v-eof);\n                                }\n                        else\n\t\t\t\teof=1;\n\t\t\t\tv=0;\n\t\t\t\t}\n\n\t\t\t/* This is the case where we have had a short\n\t\t\t * but valid input line */\n\t\t\tif ((v < ctx->length) && eof)\n\t\t\t\t{\n\t\t\t\trv=0;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tctx->length=v;\n\n\t\t\tif (seof >= 0) { rv=0; goto end; }\n\t\t\tout+=v;\n\t\t\t}\n\t\t}\n", "func_hash": 290784375241955931137206791690548785053, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-0292", "cve_desc": "Integer underflow in the EVP_DecodeUpdate function in crypto/evp/encode.c in the base64-decoding implementation in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted base64 data that triggers a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-0292"}
{"idx": 158025, "project": "savannah", "commit_id": "7f2e4f4f553f6836be7683f66226afac3fa979b8", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7f2e4f4f553f6836be7683f66226afac3fa979b8", "commit_message": "None", "target": 0, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n       if ( p->glyph_enc == -1 && p->list.used > 2 )\n         p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n \n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n       FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n                                   sizeof ( unsigned long ) * 32 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 284263663179865322266403542444429355517, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5670", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) via vectors related to BDF fonts and an ENCODING field with a negative value.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5670"}
{"idx": 158026, "project": "savannah", "commit_id": "07bdb6e289c7954e2a533039dc93c1c136099d2d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=07bdb6e289c7954e2a533039dc93c1c136099d2d", "commit_message": "None", "target": 0, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n      if ( p->glyph_enc == -1 && p->list.used > 2 )\n        p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n\n      FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n       /* otherwise p->have (a bitmap with static size) overflows. */\n      if ( p->glyph_enc > 0                                      &&\n           (size_t)p->glyph_enc >= sizeof ( p->have ) /\n                                   sizeof ( unsigned long ) * 32 )\n       {\n         FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n         error = BDF_Err_Invalid_File_Format;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 112133374329751410214358441913282019949, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5669", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to BDF fonts and an incorrect calculation that triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5669"}
{"idx": 158039, "project": "savannah", "commit_id": "18a8f0d9943369449bc4de92d411c78fb08d616c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=18a8f0d9943369449bc4de92d411c78fb08d616c", "commit_message": "None", "target": 0, "func": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n      string_count = FT_MIN( 64, string_count );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= string_count )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n", "func_hash": 183885571031352663780341239821456219872, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9672", "cve_desc": "Array index error in the parse_fond function in base/ftmac.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (out-of-bounds read) or obtain sensitive information from process memory via a crafted FOND resource in a Mac font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9672"}
{"idx": 158060, "project": "savannah", "commit_id": "f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "commit_message": "None", "target": 0, "func": "  tt_sbit_decoder_load_image( TT_SBitDecoder  decoder,\n                              FT_UInt         glyph_index,\n                              FT_Int          x_pos,\n                              FT_Int          y_pos )\n  {\n    /*\n     *  First, we find the correct strike range that applies to this\n     *  glyph index.\n     */\n\n    FT_Byte*  p          = decoder->eblc_base + decoder->strike_index_array;\n    FT_Byte*  p_limit    = decoder->eblc_limit;\n    FT_ULong  num_ranges = decoder->strike_index_count;\n    FT_UInt   start, end, index_format, image_format;\n    FT_ULong  image_start = 0, image_end = 0, image_offset;\n\n\n    for ( ; num_ranges > 0; num_ranges-- )\n    {\n      start = FT_NEXT_USHORT( p );\n      end   = FT_NEXT_USHORT( p );\n\n      if ( glyph_index >= start && glyph_index <= end )\n        goto FoundRange;\n\n      p += 4;  /* ignore index offset */\n    }\n    goto NoBitmap;\n\n  FoundRange:\n    image_offset = FT_NEXT_ULONG( p );\n\n    /* overflow check */\n    p = decoder->eblc_base + decoder->strike_index_array;\n    if ( image_offset > (FT_ULong)( p_limit - p ) )\n      goto Failure;\n\n    p += image_offset;\n    if ( p + 8 > p_limit )\n      goto NoBitmap;\n\n    /* now find the glyph's location and extend within the ebdt table */\n    index_format = FT_NEXT_USHORT( p );\n    image_format = FT_NEXT_USHORT( p );\n    image_offset = FT_NEXT_ULONG ( p );\n\n    switch ( index_format )\n    {\n    case 1: /* 4-byte offsets relative to `image_offset' */\n      p += 4 * ( glyph_index - start );\n      if ( p + 8 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_ULONG( p );\n      image_end   = FT_NEXT_ULONG( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 2: /* big metrics, constant image size */\n      {\n        FT_ULong  image_size;\n\n\n        if ( p + 12 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        image_start = image_size * ( glyph_index - start );\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    case 3: /* 2-byte offsets relative to 'image_offset' */\n      p += 2 * ( glyph_index - start );\n      if ( p + 4 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_USHORT( p );\n      image_end   = FT_NEXT_USHORT( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 4: /* sparse glyph array with (glyph,offset) pairs */\n      {\n        FT_ULong  mm, num_glyphs;\n\n\n        if ( p + 4 > p_limit )\n          goto NoBitmap;\n\n         num_glyphs = FT_NEXT_ULONG( p );\n \n         /* overflow check for p + ( num_glyphs + 1 ) * 4 */\n        if ( p + 4 > p_limit                                         ||\n             num_glyphs > (FT_ULong)( ( ( p_limit - p ) >> 2 ) - 1 ) )\n           goto NoBitmap;\n \n         for ( mm = 0; mm < num_glyphs; mm++ )\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n          {\n            image_start = FT_NEXT_USHORT( p );\n            p          += 2;\n            image_end   = FT_PEEK_USHORT( p );\n            break;\n          }\n          p += 2;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n      }\n      break;\n\n    case 5: /* constant metrics with sparse glyph codes */\n    case 19:\n      {\n        FT_ULong  image_size, mm, num_glyphs;\n\n\n        if ( p + 16 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        num_glyphs = FT_NEXT_ULONG( p );\n\n        /* overflow check for p + 2 * num_glyphs */\n        if ( num_glyphs > (FT_ULong)( ( p_limit - p ) >> 1 ) )\n          goto NoBitmap;\n\n        for ( mm = 0; mm < num_glyphs; mm++ )\n        {\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n            break;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n\n        image_start = image_size * mm;\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    default:\n      goto NoBitmap;\n    }\n", "func_hash": 174846873576513811633114180196953003240, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9656", "cve_desc": "The tt_sbit_decoder_load_image function in sfnt/ttsbit.c in FreeType before 2.5.4 does not properly check for an integer overflow, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted OpenType font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9656"}
{"idx": 158064, "project": "savannah", "commit_id": "3774fc08b502c3e685afca098b6e8a195aded6a0", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3774fc08b502c3e685afca098b6e8a195aded6a0", "commit_message": "None", "target": 0, "func": "  ps_parser_to_token( PS_Parser  parser,\n                      T1_Token   token )\n  {\n    FT_Byte*  cur;\n    FT_Byte*  limit;\n    FT_Int    embed;\n\n\n    token->type  = T1_TOKEN_TYPE_NONE;\n    token->start = NULL;\n    token->limit = NULL;\n\n    /* first of all, skip leading whitespace */\n    ps_parser_skip_spaces( parser );\n\n    cur   = parser->cursor;\n    limit = parser->limit;\n\n    if ( cur >= limit )\n      return;\n\n    switch ( *cur )\n    {\n      /************* check for literal string *****************/\n    case '(':\n      token->type  = T1_TOKEN_TYPE_STRING;\n      token->start = cur;\n\n      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for programs/array *****************/\n    case '{':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      token->start = cur;\n\n      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for table/array ********************/\n      /* XXX: in theory we should also look for \"<<\"          */\n      /*      since this is semantically equivalent to \"[\";   */\n      /*      in practice it doesn't matter (?)               */\n    case '[':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      embed        = 1;\n      token->start = cur++;\n\n      /* we need this to catch `[ ]' */\n      parser->cursor = cur;\n      ps_parser_skip_spaces( parser );\n      cur = parser->cursor;\n\n      while ( cur < limit && !parser->error )\n      {\n        /* XXX: this is wrong because it does not      */\n        /*      skip comments, procedures, and strings */\n        if ( *cur == '[' )\n          embed++;\n        else if ( *cur == ']' )\n        {\n          embed--;\n          if ( embed <= 0 )\n          {\n            token->limit = ++cur;\n            break;\n          }\n        }\n\n        parser->cursor = cur;\n        ps_parser_skip_PS_token( parser );\n        /* we need this to catch `[XXX ]' */\n        ps_parser_skip_spaces  ( parser );\n        cur = parser->cursor;\n      }\n      break;\n\n      /* ************ otherwise, it is any token **************/\n    default:\n      token->start = cur;\n      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;\n      ps_parser_skip_PS_token( parser );\n      cur = parser->cursor;\n      if ( !parser->error )\n        token->limit = cur;\n    }\n\n    if ( !token->limit )\n    {\n      token->start = NULL;\n      token->type  = T1_TOKEN_TYPE_NONE;\n    }\n\n    parser->cursor = cur;\n  }\n\n\n  /* NB: `tokens' can be NULL if we only want to count */\n  /* the number of array elements                      */\n\n  FT_LOCAL_DEF( void )\n  ps_parser_to_token_array( PS_Parser  parser,\n                            T1_Token   tokens,\n                            FT_UInt    max_tokens,\n                            FT_Int*    pnum_tokens )\n  {\n    T1_TokenRec  master;\n\n\n    *pnum_tokens = -1;\n\n    /* this also handles leading whitespace */\n    ps_parser_to_token( parser, &master );\n\n    if ( master.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      FT_Byte*  old_cursor = parser->cursor;\n      FT_Byte*  old_limit  = parser->limit;\n      T1_Token  cur        = tokens;\n      T1_Token  limit      = cur + max_tokens;\n\n\n      /* don't include outermost delimiters */\n      parser->cursor = master.start + 1;\n      parser->limit  = master.limit - 1;\n\n      while ( parser->cursor < parser->limit )\n      {\n        T1_TokenRec  token;\n\n\n        ps_parser_to_token( parser, &token );\n        if ( !token.type )\n          break;\n\n        if ( tokens && cur < limit )\n          *cur = token;\n\n        cur++;\n      }\n\n      *pnum_tokens = (FT_Int)( cur - tokens );\n\n      parser->cursor = old_cursor;\n      parser->limit  = old_limit;\n    }\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `coords' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_coords'            */\n\n  static FT_Int\n  ps_tocoordarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_coords,\n                   FT_Short*  coords )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* check for the beginning of an array; otherwise, only one number */\n    /* will be read                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the coordinates */\n    while ( cur < limit )\n    {\n      FT_Short  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( coords && count >= max_coords )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( coords ? &coords[count] : &dummy ) =\n        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `values' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_values'            */\n  /*                                                           */\n  /* return number of successfully parsed values               */\n\n  static FT_Int\n  ps_tofixedarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_values,\n                   FT_Fixed*  values,\n                   FT_Int     power_ten )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* Check for the beginning of an array.  Otherwise, only one number */\n    /* will be read.                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the values */\n    while ( cur < limit )\n    {\n      FT_Fixed  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( values && count >= max_values )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( values ? &values[count] : &dummy ) =\n        PS_Conv_ToFixed( &cur, limit, power_ten );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n#if 0\n\n  static FT_String*\n  ps_tostring( FT_Byte**  cursor,\n               FT_Byte*   limit,\n               FT_Memory  memory )\n  {\n    FT_Byte*    cur = *cursor;\n    FT_UInt     len = 0;\n    FT_Int      count;\n    FT_String*  result;\n    FT_Error    error;\n\n\n    /* XXX: some stupid fonts have a `Notice' or `Copyright' string     */\n    /*      that simply doesn't begin with an opening parenthesis, even */\n    /*      though they have a closing one!  E.g. \"amuncial.pfb\"        */\n    /*                                                                  */\n    /*      We must deal with these ill-fated cases there.  Note that   */\n    /*      these fonts didn't work with the old Type 1 driver as the   */\n    /*      notice/copyright was not recognized as a valid string token */\n    /*      and made the old token parser commit errors.                */\n\n    while ( cur < limit && ( *cur == ' ' || *cur == '\\t' ) )\n      cur++;\n    if ( cur + 1 >= limit )\n      return 0;\n\n    if ( *cur == '(' )\n      cur++;  /* skip the opening parenthesis, if there is one */\n\n    *cursor = cur;\n    count   = 0;\n\n    /* then, count its length */\n    for ( ; cur < limit; cur++ )\n    {\n      if ( *cur == '(' )\n        count++;\n\n      else if ( *cur == ')' )\n      {\n        count--;\n        if ( count < 0 )\n          break;\n      }\n    }\n\n    len = (FT_UInt)( cur - *cursor );\n    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )\n      return 0;\n\n    /* now copy the string */\n    FT_MEM_COPY( result, *cursor, len );\n    result[len] = '\\0';\n    *cursor = cur;\n    return result;\n  }\n\n#endif /* 0 */\n\n\n  static int\n  ps_tobool( FT_Byte*  *acur,\n             FT_Byte*   limit )\n  {\n    FT_Byte*  cur    = *acur;\n    FT_Bool   result = 0;\n\n\n    /* return 1 if we find `true', 0 otherwise */\n    if ( cur + 3 < limit &&\n         cur[0] == 't'   &&\n         cur[1] == 'r'   &&\n         cur[2] == 'u'   &&\n         cur[3] == 'e'   )\n    {\n      result = 1;\n      cur   += 5;\n    }\n    else if ( cur + 4 < limit &&\n              cur[0] == 'f'   &&\n              cur[1] == 'a'   &&\n              cur[2] == 'l'   &&\n              cur[3] == 's'   &&\n              cur[4] == 'e'   )\n    {\n      result = 0;\n      cur   += 6;\n    }\n\n    *acur = cur;\n    return result;\n  }\n\n\n  /* load a simple field (i.e. non-table) into the current list of objects */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field( PS_Parser       parser,\n                        const T1_Field  field,\n                        void**          objects,\n                        FT_UInt         max_objects,\n                        FT_ULong*       pflags )\n  {\n    T1_TokenRec   token;\n    FT_Byte*      cur;\n    FT_Byte*      limit;\n    FT_UInt       count;\n    FT_UInt       idx;\n    FT_Error      error;\n    T1_FieldType  type;\n\n\n    /* this also skips leading whitespace */\n    ps_parser_to_token( parser, &token );\n    if ( !token.type )\n      goto Fail;\n\n    count = 1;\n    idx   = 0;\n    cur   = token.start;\n    limit = token.limit;\n\n    type = field->type;\n\n    /* we must detect arrays in /FontBBox */\n    if ( type == T1_FIELD_TYPE_BBOX )\n    {\n      T1_TokenRec  token2;\n      FT_Byte*     old_cur   = parser->cursor;\n      FT_Byte*     old_limit = parser->limit;\n\n\n      /* don't include delimiters */\n      parser->cursor = token.start + 1;\n      parser->limit  = token.limit - 1;\n\n      ps_parser_to_token( parser, &token2 );\n      parser->cursor = old_cur;\n      parser->limit  = old_limit;\n\n      if ( token2.type == T1_TOKEN_TYPE_ARRAY )\n      {\n        type = T1_FIELD_TYPE_MM_BBOX;\n        goto FieldArray;\n      }\n    }\n    else if ( token.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      count = max_objects;\n\n    FieldArray:\n      /* if this is an array and we have no blend, an error occurs */\n      if ( max_objects == 0 )\n        goto Fail;\n\n      idx = 1;\n\n      /* don't include delimiters */\n      cur++;\n      limit--;\n    }\n\n    for ( ; count > 0; count--, idx++ )\n    {\n      FT_Byte*    q      = (FT_Byte*)objects[idx] + field->offset;\n      FT_Long     val;\n      FT_String*  string = NULL;\n\n\n      skip_spaces( &cur, limit );\n\n      switch ( type )\n      {\n      case T1_FIELD_TYPE_BOOL:\n        val = ps_tobool( &cur, limit );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED:\n        val = PS_Conv_ToFixed( &cur, limit, 0 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED_1000:\n        val = PS_Conv_ToFixed( &cur, limit, 3 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_INTEGER:\n        val = PS_Conv_ToInt( &cur, limit );\n        /* fall through */\n\n      Store_Integer:\n        switch ( field->size )\n        {\n        case (8 / FT_CHAR_BIT):\n          *(FT_Byte*)q = (FT_Byte)val;\n          break;\n\n        case (16 / FT_CHAR_BIT):\n          *(FT_UShort*)q = (FT_UShort)val;\n          break;\n\n        case (32 / FT_CHAR_BIT):\n          *(FT_UInt32*)q = (FT_UInt32)val;\n          break;\n\n        default:                /* for 64-bit systems */\n          *(FT_Long*)q = val;\n        }\n        break;\n\n      case T1_FIELD_TYPE_STRING:\n      case T1_FIELD_TYPE_KEY:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_UInt    len    = (FT_UInt)( limit - cur );\n\n\n          if ( cur >= limit )\n            break;\n\n          /* we allow both a string or a name   */\n          /* for cases like /FontName (foo) def */\n          if ( token.type == T1_TOKEN_TYPE_KEY )\n          {\n            /* don't include leading `/' */\n            len--;\n            cur++;\n          }\n          else if ( token.type == T1_TOKEN_TYPE_STRING )\n          {\n            /* don't include delimiting parentheses    */\n            /* XXX we don't handle <<...>> here        */\n            /* XXX should we convert octal escapes?    */\n            /*     if so, what encoding should we use? */\n            cur++;\n            len -= 2;\n          }\n          else\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected a name or string\\n\"\n                       \"                     \"\n                       \" but found token of type %d instead\\n\",\n                       token.type ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          /* for this to work (FT_String**)q must have been */\n          /* initialized to NULL                            */\n          if ( *(FT_String**)q )\n          {\n            FT_TRACE0(( \"ps_parser_load_field: overwriting field %s\\n\",\n                        field->ident ));\n            FT_FREE( *(FT_String**)q );\n            *(FT_String**)q = NULL;\n          }\n\n          if ( FT_ALLOC( string, len + 1 ) )\n            goto Exit;\n\n          FT_MEM_COPY( string, cur, len );\n          string[len] = 0;\n\n          *(FT_String**)q = string;\n        }\n        break;\n\n      case T1_FIELD_TYPE_BBOX:\n        {\n          FT_Fixed  temp[4];\n          FT_BBox*  bbox = (FT_BBox*)q;\n          FT_Int    result;\n\n\n          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );\n\n          if ( result < 4 )\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected four integers in bounding box\\n\" ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          bbox->xMin = FT_RoundFix( temp[0] );\n          bbox->yMin = FT_RoundFix( temp[1] );\n          bbox->xMax = FT_RoundFix( temp[2] );\n          bbox->yMax = FT_RoundFix( temp[3] );\n        }\n        break;\n\n      case T1_FIELD_TYPE_MM_BBOX:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_Fixed*  temp   = NULL;\n          FT_Int     result;\n          FT_UInt    i;\n\n\n          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )\n            goto Exit;\n\n          for ( i = 0; i < 4; i++ )\n          {\n            result = ps_tofixedarray( &cur, limit, (FT_Int)max_objects,\n                                      temp + i * max_objects, 0 );\n            if ( result < 0 || (FT_UInt)result < max_objects )\n            {\n              FT_ERROR(( \"ps_parser_load_field:\"\n                         \" expected %d integer%s in the %s subarray\\n\"\n                         \"                     \"\n                         \" of /FontBBox in the /Blend dictionary\\n\",\n                         max_objects, max_objects > 1 ? \"s\" : \"\",\n                         i == 0 ? \"first\"\n                                : ( i == 1 ? \"second\"\n                                           : ( i == 2 ? \"third\"\n                                                      : \"fourth\" ) ) ));\n              error = FT_THROW( Invalid_File_Format );\n\n              FT_FREE( temp );\n              goto Exit;\n            }\n\n            skip_spaces( &cur, limit );\n          }\n\n          for ( i = 0; i < max_objects; i++ )\n          {\n            FT_BBox*  bbox = (FT_BBox*)objects[i];\n\n\n            bbox->xMin = FT_RoundFix( temp[i                  ] );\n            bbox->yMin = FT_RoundFix( temp[i +     max_objects] );\n            bbox->xMax = FT_RoundFix( temp[i + 2 * max_objects] );\n            bbox->yMax = FT_RoundFix( temp[i + 3 * max_objects] );\n          }\n\n          FT_FREE( temp );\n        }\n        break;\n\n      default:\n        /* an error occurred */\n        goto Fail;\n      }\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    error = FT_Err_Ok;\n\n  Exit:\n    return error;\n\n  Fail:\n    error = FT_THROW( Invalid_File_Format );\n    goto Exit;\n  }\n\n\n#define T1_MAX_TABLE_ELEMENTS  32\n\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field_table( PS_Parser       parser,\n                              const T1_Field  field,\n                              void**          objects,\n                              FT_UInt         max_objects,\n                              FT_ULong*       pflags )\n  {\n    T1_TokenRec  elements[T1_MAX_TABLE_ELEMENTS];\n    T1_Token     token;\n    FT_Int       num_elements;\n    FT_Error     error = FT_Err_Ok;\n    FT_Byte*     old_cursor;\n    FT_Byte*     old_limit;\n    T1_FieldRec  fieldrec = *(T1_Field)field;\n\n\n    fieldrec.type = T1_FIELD_TYPE_INTEGER;\n    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||\n         field->type == T1_FIELD_TYPE_BBOX        )\n      fieldrec.type = T1_FIELD_TYPE_FIXED;\n\n    ps_parser_to_token_array( parser, elements,\n                              T1_MAX_TABLE_ELEMENTS, &num_elements );\n    if ( num_elements < 0 )\n    {\n      error = FT_ERR( Ignore );\n      goto Exit;\n    }\n    if ( (FT_UInt)num_elements > field->array_max )\n      num_elements = (FT_Int)field->array_max;\n\n    old_cursor = parser->cursor;\n    old_limit  = parser->limit;\n\n    /* we store the elements count if necessary;           */\n    /* we further assume that `count_offset' can't be zero */\n    if ( field->type != T1_FIELD_TYPE_BBOX && field->count_offset != 0 )\n      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =\n        (FT_Byte)num_elements;\n\n    /* we now load each element, adjusting the field.offset on each one */\n    token = elements;\n    for ( ; num_elements > 0; num_elements--, token++ )\n    {\n      parser->cursor = token->start;\n      parser->limit  = token->limit;\n\n      error = ps_parser_load_field( parser,\n                                    &fieldrec,\n                                    objects,\n                                    max_objects,\n                                    0 );\n      if ( error )\n        break;\n\n      fieldrec.offset += fieldrec.size;\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    parser->cursor = old_cursor;\n    parser->limit  = old_limit;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Long )\n  ps_parser_to_int( PS_Parser  parser )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToInt( &parser->cursor, parser->limit );\n  }\n\n\n  /* first character must be `<' if `delimiters' is non-zero */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_to_bytes( PS_Parser  parser,\n                      FT_Byte*   bytes,\n                      FT_Offset  max_bytes,\n                      FT_ULong*  pnum_bytes,\n                      FT_Bool    delimiters )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_Byte*  cur;\n\n\n    ps_parser_skip_spaces( parser );\n    cur = parser->cursor;\n\n    if ( cur >= parser->limit )\n      goto Exit;\n\n    if ( delimiters )\n    {\n      if ( *cur != '<' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing starting delimiter `<'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,\n                                          parser->limit,\n                                          bytes,\n                                          max_bytes );\n\n    if ( delimiters )\n    {\n      if ( cur < parser->limit && *cur != '>' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    parser->cursor = cur;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Fixed )\n  ps_parser_to_fixed( PS_Parser  parser,\n                      FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_coord_array( PS_Parser  parser,\n                            FT_Int     max_coords,\n                            FT_Short*  coords )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tocoordarray( &parser->cursor, parser->limit,\n                            max_coords, coords );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_fixed_array( PS_Parser  parser,\n                            FT_Int     max_values,\n                            FT_Fixed*  values,\n                            FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tofixedarray( &parser->cursor, parser->limit,\n                            max_values, values, power_ten );\n  }\n\n\n#if 0\n\n  FT_LOCAL_DEF( FT_String* )\n  T1_ToString( PS_Parser  parser )\n  {\n    return ps_tostring( &parser->cursor, parser->limit, parser->memory );\n  }\n\n\n  FT_LOCAL_DEF( FT_Bool )\n  T1_ToBool( PS_Parser  parser )\n  {\n    return ps_tobool( &parser->cursor, parser->limit );\n  }\n\n#endif /* 0 */\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_init( PS_Parser  parser,\n                  FT_Byte*   base,\n                  FT_Byte*   limit,\n                  FT_Memory  memory )\n  {\n    parser->error  = FT_Err_Ok;\n    parser->base   = base;\n    parser->limit  = limit;\n    parser->cursor = base;\n    parser->memory = memory;\n    parser->funcs  = ps_parser_funcs;\n  }\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_done( PS_Parser  parser )\n  {\n    FT_UNUSED( parser );\n  }\n\n\n  /*************************************************************************/\n  /*************************************************************************/\n  /*****                                                               *****/\n  /*****                            T1 BUILDER                         *****/\n  /*****                                                               *****/\n  /*************************************************************************/\n  /*************************************************************************/\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_init                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Initializes a given glyph builder.                                 */\n  /*                                                                       */\n  /* <InOut>                                                               */\n  /*    builder :: A pointer to the glyph builder to initialize.           */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    face    :: The current face object.                                */\n  /*                                                                       */\n  /*    size    :: The current size object.                                */\n  /*                                                                       */\n  /*    glyph   :: The current glyph object.                               */\n  /*                                                                       */\n  /*    hinting :: Whether hinting should be applied.                      */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_init( T1_Builder    builder,\n                   FT_Face       face,\n                   FT_Size       size,\n                   FT_GlyphSlot  glyph,\n                   FT_Bool       hinting )\n  {\n    builder->parse_state = T1_Parse_Start;\n    builder->load_points = 1;\n\n    builder->face   = face;\n    builder->glyph  = glyph;\n    builder->memory = face->memory;\n\n    if ( glyph )\n    {\n      FT_GlyphLoader  loader = glyph->internal->loader;\n\n\n      builder->loader  = loader;\n      builder->base    = &loader->base.outline;\n      builder->current = &loader->current.outline;\n      FT_GlyphLoader_Rewind( loader );\n\n      builder->hints_globals = size->internal;\n      builder->hints_funcs   = NULL;\n\n      if ( hinting )\n        builder->hints_funcs = glyph->internal->glyph_hints;\n    }\n\n    builder->pos_x = 0;\n    builder->pos_y = 0;\n\n    builder->left_bearing.x = 0;\n    builder->left_bearing.y = 0;\n    builder->advance.x      = 0;\n    builder->advance.y      = 0;\n\n    builder->funcs = t1_builder_funcs;\n  }\n\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_done                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Finalizes a given glyph builder.  Its contents can still be used   */\n  /*    after the call, but the function saves important information       */\n  /*    within the corresponding glyph slot.                               */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    builder :: A pointer to the glyph builder to finalize.             */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_done( T1_Builder  builder )\n  {\n    FT_GlyphSlot  glyph = builder->glyph;\n\n\n    if ( glyph )\n      glyph->outline = *builder->base;\n  }\n\n\n  /* check that there is enough space for `count' more points */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_check_points( T1_Builder  builder,\n                           FT_Int      count )\n  {\n    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );\n  }\n\n\n  /* add a new point, do not check space */\n  FT_LOCAL_DEF( void )\n  t1_builder_add_point( T1_Builder  builder,\n                        FT_Pos      x,\n                        FT_Pos      y,\n                        FT_Byte     flag )\n  {\n    FT_Outline*  outline = builder->current;\n\n\n    if ( builder->load_points )\n    {\n      FT_Vector*  point   = outline->points + outline->n_points;\n      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n\n\n      point->x = FIXED_TO_INT( x );\n      point->y = FIXED_TO_INT( y );\n      *control = (FT_Byte)( flag ? FT_CURVE_TAG_ON : FT_CURVE_TAG_CUBIC );\n    }\n    outline->n_points++;\n  }\n\n\n  /* check space for a new on-curve point, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_point1( T1_Builder  builder,\n                         FT_Pos      x,\n                         FT_Pos      y )\n  {\n    FT_Error  error;\n\n\n    error = t1_builder_check_points( builder, 1 );\n    if ( !error )\n      t1_builder_add_point( builder, x, y, 1 );\n\n    return error;\n  }\n\n\n  /* check space for a new contour, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Error     error;\n\n\n    /* this might happen in invalid fonts */\n    if ( !outline )\n    {\n      FT_ERROR(( \"t1_builder_add_contour: no outline to add points to\\n\" ));\n      return FT_THROW( Invalid_File_Format );\n    }\n\n    if ( !builder->load_points )\n    {\n      outline->n_contours++;\n      return FT_Err_Ok;\n    }\n\n    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );\n    if ( !error )\n    {\n      if ( outline->n_contours > 0 )\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n\n      outline->n_contours++;\n    }\n\n    return error;\n  }\n\n\n  /* if a path was begun, add its first on-curve point */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_start_point( T1_Builder  builder,\n                          FT_Pos      x,\n                          FT_Pos      y )\n  {\n    FT_Error  error = FT_ERR( Invalid_File_Format );\n\n\n    /* test whether we are building a new contour */\n\n    if ( builder->parse_state == T1_Parse_Have_Path )\n      error = FT_Err_Ok;\n    else\n    {\n      builder->parse_state = T1_Parse_Have_Path;\n      error = t1_builder_add_contour( builder );\n      if ( !error )\n        error = t1_builder_add_point1( builder, x, y );\n    }\n\n    return error;\n  }\n\n\n  /* close the current contour */\n  FT_LOCAL_DEF( void )\n  t1_builder_close_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Int       first;\n\n\n    if ( !outline )\n      return;\n\n     first = outline->n_contours <= 1\n             ? 0 : outline->contours[outline->n_contours - 2] + 1;\n \n    /* in malformed fonts it can happen that a contour was started */\n    /* but no points were added                                    */\n    if ( outline->n_contours && first == outline->n_points )\n    {\n      outline->n_contours--;\n      return;\n    }\n\n     /* We must not include the last point in the path if it */\n     /* is located on the first point.                       */\n     if ( outline->n_points > 1 )\n      if ( p1->x == p2->x && p1->y == p2->y )\n        if ( *control == FT_CURVE_TAG_ON )\n          outline->n_points--;\n    }\n\n    if ( outline->n_contours > 0 )\n    {\n      /* Don't add contours only consisting of one point, i.e.,  */\n      /* check whether the first and the last point is the same. */\n      if ( first == outline->n_points - 1 )\n      {\n        outline->n_contours--;\n        outline->n_points--;\n      }\n      else\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n    }\n  }\n", "func_hash": 271086143539799141627769963035955134012, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-8287", "cve_desc": "FreeType 2 before 2017-03-26 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_builder_close_contour function in psaux/psobjs.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-8287"}
{"idx": 158076, "project": "savannah", "commit_id": "94e01571507835ff59dd8ce2a0b56a4b566965a4", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commit;h=94e01571507835ff59dd8ce2a0b56a4b566965a4", "commit_message": "None", "target": 0, "func": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n  /* Outlandishly-long time zone abbreviations should not cause problems.  */\n  {\n    static char const bufprefix[] = \"TZ=\\\"\";\n    enum { tzname_len = 2000 };\n    static char const bufsuffix[] = \"0\\\" 1970-01-01 01:02:03.123456789\";\n    enum { bufsize = sizeof bufprefix - 1 + tzname_len + sizeof bufsuffix };\n    char buf[bufsize];\n    memcpy (buf, bufprefix, sizeof bufprefix - 1);\n    memset (buf + sizeof bufprefix - 1, 'X', tzname_len);\n    strcpy (buf + bufsize - sizeof bufsuffix, bufsuffix);\n    ASSERT (parse_datetime (&result, buf, &now));\n    LOG (buf, now, result);\n    ASSERT (result.tv_sec == 1 * 60 * 60 + 2 * 60 + 3\n            && result.tv_nsec == 123456789);\n  }\n\n   return 0;\n }\n", "func_hash": 254772284669524418106772745534242359013, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-7476", "cve_desc": "Gnulib before 2017-04-26 has a heap-based buffer overflow with the TZ environment variable. The error is in the save_abbr function in time_rz.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-7476"}
{"idx": 158077, "project": "savannah", "commit_id": "59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "commit_message": "None", "target": 0, "func": "  ft_var_readpackedpoints( FT_Stream  stream,\n                           FT_UInt   *point_cnt )\n  {\n    FT_UShort *points;\n    FT_Int     n;\n    FT_Int     runcnt;\n    FT_Int     i;\n     FT_Int     j;\n     FT_Int     first;\n     FT_Memory  memory = stream->memory;\n    FT_Error   error  = TT_Err_Ok;\n \n     FT_UNUSED( error );\n \n\n    *point_cnt = n = FT_GET_BYTE();\n    if ( n == 0 )\n      return ALL_POINTS;\n\n    if ( n & GX_PT_POINTS_ARE_WORDS )\n      n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );\n\n    if ( FT_NEW_ARRAY( points, n ) )\n      return NULL;\n\n    i = 0;\n    while ( i < n )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_PT_POINTS_ARE_WORDS )\n      {\n         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n         first  = points[i++] = FT_GET_USHORT();\n \n        if ( runcnt < 1 || i + runcnt >= n )\n           goto Exit;\n \n         /* first point not included in runcount */\n        for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_USHORT() );\n      }\n      else\n       {\n         first = points[i++] = FT_GET_BYTE();\n \n        if ( runcnt < 1 || i + runcnt >= n )\n           goto Exit;\n \n         for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_BYTE() );\n      }\n    }\n\n  Exit:\n    return points;\n  }\n", "func_hash": 179208058990458728256307235003655306316, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-3855", "cve_desc": "Buffer overflow in the ft_var_readpackedpoints function in truetype/ttgxvar.c in FreeType 2.4.3 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted TrueType GX font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-3855"}
{"idx": 158078, "project": "ghostscript", "commit_id": "39b1e54b2968620723bf32e96764c88797714879", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=39b1e54b2968620723bf32e96764c88797714879", "commit_message": "None", "target": 0, "func": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code;\n     double rounded;\n \n    if (dx > 1e38 || dy > 1e38)\n        code = gs_error_undefinedresult;\n    else\n        code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n\n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n", "func_hash": 59940488774012010522720030779464241139, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10194", "cve_desc": "The set_text_distance function in devices/vector/gdevpdts.c in the pdfwrite component in Artifex Ghostscript through 9.22 does not prevent overflows in text-positioning calculation, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PDF document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10194"}
{"idx": 158079, "project": "haproxy", "commit_id": "3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "http://git.haproxy.org/?p=haproxy.git;a=commitdiff;h=3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "commit_message": "BUG/CRITICAL: h2: fix incorrect frame length check\n\nThe incoming H2 frame length was checked against the max_frame_size\nsetting instead of being checked against the bufsize. The max_frame_size\nonly applies to outgoing traffic and not to incoming one, so if a large\nenough frame size is advertised in the SETTINGS frame, a wrapped frame\nwill be defragmented into a temporary allocated buffer where the second\nfragment my overflow the heap by up to 16 kB.\n\nIt is very unlikely that this can be exploited for code execution given\nthat buffers are very short lived and their address not realistically\npredictable in production, but the likeliness of an immediate crash is\nabsolutely certain.\n\nThis fix must be backported to 1.8.\n\nMany thanks to Jordan Zebor from F5 Networks for reporting this issue\nin a responsible way.", "target": 0, "func": "static void h2_process_demux(struct h2c *h2c)\n{\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn;\n\n\tif (unlikely(h2c->st0 < H2_CS_FRAME_H)) {\n\t\tif (h2c->st0 == H2_CS_PREFACE) {\n\t\t\tif (unlikely(h2c_frt_recv_preface(h2c) <= 0)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\th2c->max_id = 0;\n\t\t\th2c->st0 = H2_CS_SETTINGS1;\n\t\t}\n\n\t\tif (h2c->st0 == H2_CS_SETTINGS1) {\n\t\t\tstruct h2_fh hdr;\n\n\t\t\t/* ensure that what is pending is a valid SETTINGS frame\n\t\t\t * without an ACK.\n\t\t\t */\n\t\t\tif (!h2_get_frame_hdr(h2c->dbuf, &hdr)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (hdr.sid || hdr.ft != H2_FT_SETTINGS || hdr.ff & H2_F_SETTINGS_ACK) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_ERROR2;\n                                goto fail;\n                        }\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > global.tune.bufsize) {\n                                /* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* that's OK, switch to FRAME_P to process it */\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t}\n\t}\n\n\t/* process as many incoming frames as possible below */\n\twhile (h2c->dbuf->i) {\n\t\tint ret = 0;\n\n\t\tif (h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_H) {\n\t\t\tstruct h2_fh hdr;\n\n                        if (!h2_peek_frame_hdr(h2c->dbuf, &hdr))\n                                break;\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > global.tune.bufsize) {\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR;\n                                break;\n\t\t\t}\n\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t\th2_skip_frame_hdr(h2c->dbuf);\n\t\t}\n\n\t\t/* Only H2_CS_FRAME_P and H2_CS_FRAME_A here */\n\t\th2s = h2c_st_by_id(h2c, h2c->dsi);\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tgoto strm_err;\n\n\t\tif (h2s->st == H2_SS_IDLE &&\n\t\t    h2c->dft != H2_FT_HEADERS && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than HEADERS or PRIORITY in\n\t\t\t * this state MUST be treated as a connection error\n\t\t\t */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\th2c->st0 = H2_CS_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h2s->st == H2_SS_HREM && h2c->dft != H2_FT_WINDOW_UPDATE &&\n\t\t    h2c->dft != H2_FT_RST_STREAM && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than WU/PRIO/RST in\n\t\t\t * this state MUST be treated as a stream error\n\t\t\t */\n\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\t/* Below the management of frames received in closed state is a\n\t\t * bit hackish because the spec makes strong differences between\n\t\t * streams closed by receiving RST, sending RST, and seeing ES\n\t\t * in both directions. In addition to this, the creation of a\n\t\t * new stream reusing the identifier of a closed one will be\n\t\t * detected here. Given that we cannot keep track of all closed\n\t\t * streams forever, we consider that unknown closed streams were\n\t\t * closed on RST received, which allows us to respond with an\n\t\t * RST without breaking the connection (eg: to abort a transfer).\n\t\t * Some frames have to be silently ignored as well.\n\t\t */\n\t\tif (h2s->st == H2_SS_CLOSED && h2c->dsi) {\n\t\t\tif (h2c->dft == H2_FT_HEADERS || h2c->dft == H2_FT_PUSH_PROMISE) {\n\t\t\t\t/* #5.1.1: The identifier of a newly\n\t\t\t\t * established stream MUST be numerically\n\t\t\t\t * greater than all streams that the initiating\n\t\t\t\t * endpoint has opened or reserved. This\n\t\t\t\t * governs streams that are opened using a\n\t\t\t\t * HEADERS frame and streams that are reserved\n\t\t\t\t * using PUSH_PROMISE. An endpoint that\n\t\t\t\t * receives an unexpected stream identifier\n\t\t\t\t * MUST respond with a connection error.\n\t\t\t\t */\n\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\tif (h2s->flags & H2_SF_RST_RCVD) {\n\t\t\t\t/* RFC7540#5.1:closed: an endpoint that\n\t\t\t\t * receives any frame other than PRIORITY after\n\t\t\t\t * receiving a RST_STREAM MUST treat that as a\n\t\t\t\t * stream error of type STREAM_CLOSED.\n\t\t\t\t *\n\t\t\t\t * Note that old streams fall into this category\n\t\t\t\t * and will lead to an RST being sent.\n\t\t\t\t */\n\t\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\t/* RFC7540#5.1:closed: if this state is reached as a\n\t\t\t * result of sending a RST_STREAM frame, the peer that\n\t\t\t * receives the RST_STREAM might have already sent\n\t\t\t * frames on the stream that cannot be withdrawn. An\n\t\t\t * endpoint MUST ignore frames that it receives on\n\t\t\t * closed streams after it has sent a RST_STREAM\n\t\t\t * frame. An endpoint MAY choose to limit the period\n\t\t\t * over which it ignores frames and treat frames that\n\t\t\t * arrive after this time as being in error.\n\t\t\t */\n\t\t\tif (!(h2s->flags & H2_SF_RST_SENT)) {\n\t\t\t\t/* RFC7540#5.1:closed: any frame other than\n\t\t\t\t * PRIO/WU/RST in this state MUST be treated as\n\t\t\t\t * a connection error\n\t\t\t\t */\n\t\t\t\tif (h2c->dft != H2_FT_RST_STREAM &&\n\t\t\t\t    h2c->dft != H2_FT_PRIORITY &&\n\t\t\t\t    h2c->dft != H2_FT_WINDOW_UPDATE) {\n\t\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\t\tgoto strm_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if 0\n\n\t\t/* graceful shutdown, ignore streams whose ID is higher than\n\t\t * the one advertised in GOAWAY. RFC7540#6.8.\n\t\t */\n\t\tif (unlikely(h2c->last_sid >= 0) && h2c->dsi > h2c->last_sid) {\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t\tgoto strm_err;\n\t\t}\n#endif\n\n\t\tswitch (h2c->dft) {\n\t\tcase H2_FT_SETTINGS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_settings(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_settings(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PING:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_ping(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_ping(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_WINDOW_UPDATE:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_window_update(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_CONTINUATION:\n\t\t\t/* we currently don't support CONTINUATION frames since\n\t\t\t * we have nowhere to store the partial HEADERS frame.\n\t\t\t * Let's abort the stream on an INTERNAL_ERROR here.\n\t\t\t */\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P) {\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase H2_FT_HEADERS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_headers(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_DATA:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_data(h2c, h2s);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_send_strm_wu(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PRIORITY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_priority(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_RST_STREAM:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_rst_stream(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_GOAWAY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_goaway(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PUSH_PROMISE:\n\t\t\t/* not permitted here, RFC7540#5.1 */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\tbreak;\n\n\t\t\t/* implement all extra frame types here */\n\t\tdefault:\n\t\t\t/* drop frames that we ignore. They may be larger than\n\t\t\t * the buffer so we drain all of their contents until\n\t\t\t * we reach the end.\n\t\t\t */\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t}\n\n\tstrm_err:\n\t\t/* We may have to send an RST if not done yet */\n\t\tif (h2s->st == H2_SS_ERROR)\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tret = h2c_send_rst_stream(h2c, h2s);\n\n\t\t/* error or missing data condition met above ? */\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 != H2_CS_FRAME_H) {\n\t\t\tbi_del(h2c->dbuf, h2c->dfl);\n\t\t\th2c->st0 = H2_CS_FRAME_H;\n\t\t}\n\t}\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM)))\n\t\th2c_send_conn_wu(h2c);\n\n fail:\n\t/* we can go here on missing data, blocked response or error */\n\treturn;\n}\n", "func_hash": 78211051505197321979153553871570809611, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10184", "cve_desc": "An issue was discovered in HAProxy before 1.8.8. The incoming H2 frame length was checked against the max_frame_size setting instead of being checked against the bufsize. The max_frame_size only applies to outgoing traffic and not to incoming, so if a large enough frame size is advertised in the SETTINGS frame, a wrapped frame will be defragmented into a temporary allocated buffer where the second fragment may overflow the heap by up to 16 kB. It is very unlikely that this can be exploited for code execution given that buffers are very short lived and their addresses not realistically predictable in production, but the likelihood of an immediate crash is absolutely certain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10184"}
{"idx": 158083, "project": "libXvMC", "commit_id": "2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_message": "None", "target": 0, "func": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n", "func_hash": 134961230573839871155626004817245283432, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-7953", "cve_desc": "Buffer underflow in X.org libXvMC before 1.0.10 allows remote X servers to have unspecified impact via an empty string.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7953"}
{"idx": 158093, "project": "tartarus", "commit_id": "4ff22863d895cb7ebfced4cf923a012a614adaa8", "project_url": "https://git.tartarus.org/?p=simon/putty", "commit_url": "https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=4ff22863d895cb7ebfced4cf923a012a614adaa8", "commit_message": "None", "target": 0, "func": "static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)\n{\n    int i;\n    struct ssh_channel *c;\n\n    if (enable == ssh->throttled_all)\n\treturn;\n    ssh->throttled_all = enable;\n    ssh->overall_bufsize = bufsize;\n    if (!ssh->channels)\n\treturn;\n    for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {\n\tswitch (c->type) {\n\t  case CHAN_MAINSESSION:\n\t    /*\n\t     * This is treated separately, outside the switch.\n\t     */\n\t    break;\n            x11_override_throttle(c->u.x11.xconn, enable);\n            break;\n          case CHAN_AGENT:\n           /* Agent forwarding channels are buffer-managed by\n             * checking ssh->throttled_all in ssh_agentf_try_forward.\n             * So at the moment we _un_throttle again, we must make an\n             * attempt to do something. */\n            if (!enable)\n                ssh_agentf_try_forward(c);\n            break;\n          case CHAN_SOCKDATA:\n            pfd_override_throttle(c->u.pfd.pf, enable);\n\nstatic void ssh_agent_callback(void *sshv, void *reply, int replylen)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->auth_agent_query = NULL;\n\n    ssh->agent_response = reply;\n    ssh->agent_response_len = replylen;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_authconn(ssh, NULL, -1, NULL);\n}\n\nstatic void ssh_dialog_callback(void *sshv, int ret)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->user_response = ret;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    /*\n     * This may have unfrozen the SSH connection, so do a\n     * queued-data run.\n     */\n    ssh_process_queued_incoming_data(ssh);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n     ssh_process_queued_incoming_data(ssh);\n }\n \nstatic void ssh_agentf_got_response(struct ssh_channel *c,\n                                    void *reply, int replylen)\n {\n     c->u.a.pending = NULL;\n\n    if (!reply) {\n       /* The real agent didn't send any kind of reply at all for\n         * some reason, so fake an SSH_AGENT_FAILURE. */\n       reply = \"\\0\\0\\0\\1\\5\";\n        replylen = 5;\n     }\n\n    ssh_send_channel_data(c, reply, replylen);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen);\n\nstatic void ssh_agentf_try_forward(struct ssh_channel *c)\n{\n    unsigned datalen, lengthfield, messagelen;\n    unsigned char *message;\n    unsigned char msglen[4];\n    void *reply;\n    int replylen;\n\n     /*\n     * Don't try to parallelise agent requests. Wait for each one to\n     * return before attempting the next.\n      */\n    if (c->u.a.pending)\n        return;\n\n    /*\n     * If the outgoing side of the channel connection is currently\n     * throttled (for any reason, either that channel's window size or\n     * the entire SSH connection being throttled), don't submit any\n     * new forwarded requests to the real agent. This causes the input\n     * side of the agent forwarding not to be emptied, exerting the\n     * required back-pressure on the remote client, and encouraging it\n     * to read our responses before sending too many more requests.\n     */\n    if (c->ssh->throttled_all ||\n        (c->ssh->version == 2 && c->v.v2.remwindow == 0))\n        return;\n\n    while (1) {\n        /*\n         * Try to extract a complete message from the input buffer.\n         */\n        datalen = bufchain_size(&c->u.a.inbuffer);\n        if (datalen < 4)\n            break;         /* not even a length field available yet */\n\n        bufchain_fetch(&c->u.a.inbuffer, msglen, 4);\n        lengthfield = GET_32BIT(msglen);\n        if (lengthfield > datalen - 4)\n            break;          /* a whole message is not yet available */\n\n        messagelen = lengthfield + 4;\n\n        message = snewn(messagelen, unsigned char);\n        bufchain_fetch(&c->u.a.inbuffer, message, messagelen);\n        bufchain_consume(&c->u.a.inbuffer, messagelen);\n        c->u.a.pending = agent_query(\n            message, messagelen, &reply, &replylen, ssh_agentf_callback, c);\n        sfree(message);\n\n        if (c->u.a.pending)\n            return;   /* agent_query promised to reply in due course */\n\n        /*\n         * If the agent gave us an answer immediately, pass it\n         * straight on and go round this loop again.\n         */\n        ssh_agentf_got_response(c, reply, replylen);\n    }\n\n    /*\n     * If we get here (i.e. we left the above while loop via 'break'\n     * rather than 'return'), that means we've determined that the\n     * input buffer for the agent forwarding connection doesn't\n     * contain a complete request.\n     *\n     * So if there's potentially more data to come, we can return now,\n     * and wait for the remote client to send it. But if the remote\n     * has sent EOF, it would be a mistake to do that, because we'd be\n     * waiting a long time. So this is the moment to check for EOF,\n     * and respond appropriately.\n     */\n    if (c->closes & CLOSES_RCVD_EOF)\n         sshfwd_write_eof(c);\n }\n \nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n{\n    struct ssh_channel *c = (struct ssh_channel *)cv;\n\n    ssh_agentf_got_response(c, reply, replylen);\n    sfree(reply);\n\n    /*\n     * Now try to extract and send further messages from the channel's\n     * input-side buffer.\n     */\n    ssh_agentf_try_forward(c);\n}\n\n /*\n  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'\n  * non-NULL, otherwise just close the connection. `client_reason' == NULL\n\t\t\t struct Packet *pktin)\n{\n    int i, j, ret;\n    unsigned char cookie[8], *ptr;\n    struct MD5Context md5c;\n    struct do_ssh1_login_state {\n\tint crLine;\n\tint len;\n\tunsigned char *rsabuf;\n        const unsigned char *keystr1, *keystr2;\n\tunsigned long supported_ciphers_mask, supported_auths_mask;\n\tint tried_publickey, tried_agent;\n\tint tis_auth_refused, ccard_auth_refused;\n\tunsigned char session_id[16];\n\tint cipher_type;\n\tvoid *publickey_blob;\n\tint publickey_bloblen;\n\tchar *publickey_comment;\n\tint privatekey_available, privatekey_encrypted;\n\tprompts_t *cur_prompt;\n\tchar c;\n\tint pwpkt_type;\n\tunsigned char request[5], *response, *p;\n\tint responselen;\n\tint keyi, nkeys;\n\tint authed;\n\tstruct RSAKey key;\n\tBignum challenge;\n\tchar *commentp;\n\tint commentlen;\n        int dlgret;\n\tFilename *keyfile;\n        struct RSAKey servkey, hostkey;\n    };\n    crState(do_ssh1_login_state);\n\n    crBeginState;\n\n    if (!pktin)\n\tcrWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_PUBLIC_KEY) {\n\tbombout((\"Public key packet not received\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Received public keys\");\n\n    ptr = ssh_pkt_getdata(pktin, 8);\n    if (!ptr) {\n\tbombout((\"SSH-1 public key packet stopped before random cookie\"));\n\tcrStop(0);\n    }\n    memcpy(cookie, ptr, 8);\n\n    if (!ssh1_pkt_getrsakey(pktin, &s->servkey, &s->keystr1) ||\n\t!ssh1_pkt_getrsakey(pktin, &s->hostkey, &s->keystr2)) {\t\n\tbombout((\"Failed to read SSH-1 public keys from public key packet\"));\n\tcrStop(0);\n    }\n\n    /*\n     * Log the host key fingerprint.\n     */\n    {\n\tchar logmsg[80];\n\tlogevent(\"Host key fingerprint is:\");\n\tstrcpy(logmsg, \"      \");\n\ts->hostkey.comment = NULL;\n\trsa_fingerprint(logmsg + strlen(logmsg),\n\t\t\tsizeof(logmsg) - strlen(logmsg), &s->hostkey);\n\tlogevent(logmsg);\n    }\n\n    ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);\n    s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);\n    s->supported_auths_mask = ssh_pkt_getuint32(pktin);\n    if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))\n\ts->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);\n\n    ssh->v1_local_protoflags =\n\tssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;\n    ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;\n\n    MD5Init(&md5c);\n    MD5Update(&md5c, s->keystr2, s->hostkey.bytes);\n    MD5Update(&md5c, s->keystr1, s->servkey.bytes);\n    MD5Update(&md5c, cookie, 8);\n    MD5Final(s->session_id, &md5c);\n\n    for (i = 0; i < 32; i++)\n\tssh->session_key[i] = random_byte();\n\n    /*\n     * Verify that the `bits' and `bytes' parameters match.\n     */\n    if (s->hostkey.bits > s->hostkey.bytes * 8 ||\n\ts->servkey.bits > s->servkey.bytes * 8) {\n\tbombout((\"SSH-1 public keys were badly formatted\"));\n\tcrStop(0);\n    }\n\n    s->len = (s->hostkey.bytes > s->servkey.bytes ?\n              s->hostkey.bytes : s->servkey.bytes);\n\n    s->rsabuf = snewn(s->len, unsigned char);\n\n    /*\n     * Verify the host key.\n     */\n    {\n\t/*\n\t * First format the key into a string.\n\t */\n\tint len = rsastr_len(&s->hostkey);\n\tchar fingerprint[100];\n\tchar *keystr = snewn(len, char);\n\trsastr_fmt(keystr, &s->hostkey);\n\trsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);\n\n        /* First check against manually configured host keys. */\n        s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);\n        if (s->dlgret == 0) {          /* did not match */\n            bombout((\"Host key did not appear in manually configured list\"));\n            sfree(keystr);\n            crStop(0);\n        } else if (s->dlgret < 0) { /* none configured; use standard handling */\n            ssh_set_frozen(ssh, 1);\n            s->dlgret = verify_ssh_host_key(ssh->frontend,\n                                            ssh->savedhost, ssh->savedport,\n                                            \"rsa\", keystr, fingerprint,\n                                            ssh_dialog_callback, ssh);\n            sfree(keystr);\n#ifdef FUZZING\n\t    s->dlgret = 1;\n#endif\n            if (s->dlgret < 0) {\n                do {\n                    crReturn(0);\n                    if (pktin) {\n                        bombout((\"Unexpected data from server while waiting\"\n                                 \" for user host key response\"));\n                        crStop(0);\n                    }\n                } while (pktin || inlen > 0);\n                s->dlgret = ssh->user_response;\n            }\n            ssh_set_frozen(ssh, 0);\n\n            if (s->dlgret == 0) {\n                ssh_disconnect(ssh, \"User aborted at host key verification\",\n                               NULL, 0, TRUE);\n                crStop(0);\n            }\n        } else {\n            sfree(keystr);\n        }\n    }\n\n    for (i = 0; i < 32; i++) {\n\ts->rsabuf[i] = ssh->session_key[i];\n\tif (i < 16)\n\t    s->rsabuf[i] ^= s->session_id[i];\n    }\n\n    if (s->hostkey.bytes > s->servkey.bytes) {\n\tret = rsaencrypt(s->rsabuf, 32, &s->servkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);\n    } else {\n\tret = rsaencrypt(s->rsabuf, 32, &s->hostkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);\n    }\n    if (!ret) {\n\tbombout((\"SSH-1 public key encryptions failed due to bad formatting\"));\n\tcrStop(0);\t\n    }\n\n    logevent(\"Encrypted session key\");\n\n    {\n\tint cipher_chosen = 0, warn = 0;\n\tconst char *cipher_string = NULL;\n\tint i;\n\tfor (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {\n\t    int next_cipher = conf_get_int_int(ssh->conf,\n\t\t\t\t\t       CONF_ssh_cipherlist, i);\n\t    if (next_cipher == CIPHER_WARN) {\n\t\t/* If/when we choose a cipher, warn about it */\n\t\twarn = 1;\n\t    } else if (next_cipher == CIPHER_AES) {\n\t\t/* XXX Probably don't need to mention this. */\n\t\tlogevent(\"AES not supported in SSH-1, skipping\");\n\t    } else {\n\t\tswitch (next_cipher) {\n\t\t  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;\n\t\t\t\t\tcipher_string = \"3DES\"; break;\n\t\t  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;\n\t\t\t\t\tcipher_string = \"Blowfish\"; break;\n\t\t  case CIPHER_DES:\ts->cipher_type = SSH_CIPHER_DES;\n\t\t\t\t\tcipher_string = \"single-DES\"; break;\n\t\t}\n\t\tif (s->supported_ciphers_mask & (1 << s->cipher_type))\n\t\t    cipher_chosen = 1;\n\t    }\n\t}\n\tif (!cipher_chosen) {\n\t    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)\n\t\tbombout((\"Server violates SSH-1 protocol by not \"\n\t\t\t \"supporting 3DES encryption\"));\n\t    else\n\t\t/* shouldn't happen */\n\t\tbombout((\"No supported ciphers found\"));\n\t    crStop(0);\n\t}\n\n\t/* Warn about chosen cipher if necessary. */\n\tif (warn) {\n            ssh_set_frozen(ssh, 1);\n\t    s->dlgret = askalg(ssh->frontend, \"cipher\", cipher_string,\n\t\t\t       ssh_dialog_callback, ssh);\n\t    if (s->dlgret < 0) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for user response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\ts->dlgret = ssh->user_response;\n\t    }\n            ssh_set_frozen(ssh, 0);\n\t    if (s->dlgret == 0) {\n\t\tssh_disconnect(ssh, \"User aborted at cipher warning\", NULL,\n\t\t\t       0, TRUE);\n\t\tcrStop(0);\n\t    }\n        }\n    }\n\n    switch (s->cipher_type) {\n      case SSH_CIPHER_3DES:\n\tlogevent(\"Using 3DES encryption\");\n\tbreak;\n      case SSH_CIPHER_DES:\n\tlogevent(\"Using single-DES encryption\");\n\tbreak;\n      case SSH_CIPHER_BLOWFISH:\n\tlogevent(\"Using Blowfish encryption\");\n\tbreak;\n    }\n\n    send_packet(ssh, SSH1_CMSG_SESSION_KEY,\n\t\tPKT_CHAR, s->cipher_type,\n\t\tPKT_DATA, cookie, 8,\n\t\tPKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,\n\t\tPKT_DATA, s->rsabuf, s->len,\n\t\tPKT_INT, ssh->v1_local_protoflags, PKT_END);\n\n    logevent(\"Trying to enable encryption...\");\n\n    sfree(s->rsabuf);\n\n    ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :\n\t\t   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :\n\t\t   &ssh_3des);\n    ssh->v1_cipher_ctx = ssh->cipher->make_context();\n    ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);\n    logeventf(ssh, \"Initialised %s encryption\", ssh->cipher->text_name);\n\n    ssh->crcda_ctx = crcda_make_context();\n    logevent(\"Installing CRC compensation attack detector\");\n\n    if (s->servkey.modulus) {\n\tsfree(s->servkey.modulus);\n\ts->servkey.modulus = NULL;\n    }\n    if (s->servkey.exponent) {\n\tsfree(s->servkey.exponent);\n\ts->servkey.exponent = NULL;\n    }\n    if (s->hostkey.modulus) {\n\tsfree(s->hostkey.modulus);\n\ts->hostkey.modulus = NULL;\n    }\n    if (s->hostkey.exponent) {\n\tsfree(s->hostkey.exponent);\n\ts->hostkey.exponent = NULL;\n    }\n    crWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_SUCCESS) {\n\tbombout((\"Encryption not successfully enabled\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Successfully started encryption\");\n\n    fflush(stdout); /* FIXME eh? */\n    {\n\tif ((ssh->username = get_remote_username(ssh->conf)) == NULL) {\n\t    int ret; /* need not be kept over crReturn */\n\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH login name\");\n\t    add_prompt(s->cur_prompt, dupstr(\"login as: \"), TRUE);\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a username. Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, \"No username provided\", NULL, 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);\n\t    free_prompts(s->cur_prompt);\n\t}\n\n\tsend_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);\n\t{\n\t    char *userlog = dupprintf(\"Sent username \\\"%s\\\"\", ssh->username);\n\t    logevent(userlog);\n\t    if (flags & FLAG_INTERACTIVE &&\n\t\t(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {\n\t\tc_write_str(ssh, userlog);\n\t\tc_write_str(ssh, \"\\r\\n\");\n\t    }\n\t    sfree(userlog);\n\t}\n    }\n\n    crWaitUntil(pktin);\n\n    if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {\n\t/* We must not attempt PK auth. Pretend we've already tried it. */\n\ts->tried_publickey = s->tried_agent = 1;\n    } else {\n\ts->tried_publickey = s->tried_agent = 0;\n    }\n    s->tis_auth_refused = s->ccard_auth_refused = 0;\n    /*\n     * Load the public half of any configured keyfile for later use.\n     */\n    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n    if (!filename_is_null(s->keyfile)) {\n\tint keytype;\n\tlogeventf(ssh, \"Reading key file \\\"%.150s\\\"\",\n\t\t  filename_to_str(s->keyfile));\n\tkeytype = key_type(s->keyfile);\n\tif (keytype == SSH_KEYTYPE_SSH1 ||\n            keytype == SSH_KEYTYPE_SSH1_PUBLIC) {\n\t    const char *error;\n\t    if (rsakey_pubblob(s->keyfile,\n\t\t\t       &s->publickey_blob, &s->publickey_bloblen,\n\t\t\t       &s->publickey_comment, &error)) {\n                s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);\n                if (!s->privatekey_available)\n                    logeventf(ssh, \"Key file contains public key only\");\n\t\ts->privatekey_encrypted = rsakey_encrypted(s->keyfile,\n                                                           NULL);\n\t    } else {\n\t\tchar *msgbuf;\n\t\tlogeventf(ssh, \"Unable to load key (%s)\", error);\n\t\tmsgbuf = dupprintf(\"Unable to load key file \"\n\t\t\t\t   \"\\\"%.150s\\\" (%s)\\r\\n\",\n\t\t\t\t   filename_to_str(s->keyfile),\n\t\t\t\t   error);\n\t\tc_write_str(ssh, msgbuf);\n\t\tsfree(msgbuf);\n\t\ts->publickey_blob = NULL;\n\t    }\n\t} else {\n\t    char *msgbuf;\n\t    logeventf(ssh, \"Unable to use this key file (%s)\",\n\t\t      key_type_to_str(keytype));\n\t    msgbuf = dupprintf(\"Unable to use key file \\\"%.150s\\\"\"\n\t\t\t       \" (%s)\\r\\n\",\n\t\t\t       filename_to_str(s->keyfile),\n\t\t\t       key_type_to_str(keytype));\n\t    c_write_str(ssh, msgbuf);\n\t    sfree(msgbuf);\n\t    s->publickey_blob = NULL;\n\t}\n    } else\n\ts->publickey_blob = NULL;\n\n    while (pktin->type == SSH1_SMSG_FAILURE) {\n\ts->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;\n\n\tif (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {\n\t    /*\n\t     * Attempt RSA authentication using Pageant.\n\t     */\n\t    void *r;\n\n\t    s->authed = FALSE;\n\t    s->tried_agent = 1;\n\t    logevent(\"Pageant is running. Requesting keys.\");\n\n\t    /* Request the keys held by the agent. */\n\t    PUT_32BIT(s->request, 1);\n\t    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;\n            ssh->auth_agent_query = agent_query(\n                s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);\n\t    if (ssh->auth_agent_query) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for agent response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\tr = ssh->agent_response;\n\t\ts->responselen = ssh->agent_response_len;\n\t    }\n\t    s->response = (unsigned char *) r;\n\t    if (s->response && s->responselen >= 5 &&\n\t\ts->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {\n\t\ts->p = s->response + 5;\n\t\ts->nkeys = toint(GET_32BIT(s->p));\n                if (s->nkeys < 0) {\n                    logeventf(ssh, \"Pageant reported negative key count %d\",\n                              s->nkeys);\n                    s->nkeys = 0;\n                }\n\t\ts->p += 4;\n\t\tlogeventf(ssh, \"Pageant has %d SSH-1 keys\", s->nkeys);\n\t\tfor (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {\n\t\t    unsigned char *pkblob = s->p;\n\t\t    s->p += 4;\n\t\t    {\n\t\t\tint n, ok = FALSE;\n\t\t\tdo {\t       /* do while (0) to make breaking easy */\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.exponent);\n\t\t\t    if (n < 0)\n\t\t\t\tbreak;\n\t\t\t    s->p += n;\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.modulus);\n\t\t\t    if (n < 0)\n                                break;\n\t\t\t    s->p += n;\n\t\t\t    if (s->responselen - (s->p-s->response) < 4)\n\t\t\t\tbreak;\n\t\t\t    s->commentlen = toint(GET_32BIT(s->p));\n\t\t\t    s->p += 4;\n\t\t\t    if (s->commentlen < 0 ||\n                                toint(s->responselen - (s->p-s->response)) <\n\t\t\t\ts->commentlen)\n\t\t\t\tbreak;\n\t\t\t    s->commentp = (char *)s->p;\n\t\t\t    s->p += s->commentlen;\n\t\t\t    ok = TRUE;\n\t\t\t} while (0);\n\t\t\tif (!ok) {\n\t\t\t    logevent(\"Pageant key list packet was truncated\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (s->publickey_blob) {\n\t\t\tif (!memcmp(pkblob, s->publickey_blob,\n\t\t\t\t    s->publickey_bloblen)) {\n\t\t\t    logeventf(ssh, \"Pageant key #%d matches \"\n\t\t\t\t      \"configured key file\", s->keyi);\n\t\t\t    s->tried_publickey = 1;\n\t\t\t} else\n\t\t\t    /* Skip non-configured key */\n\t\t\t    continue;\n\t\t    }\n\t\t    logeventf(ssh, \"Trying Pageant key #%d\", s->keyi);\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t\tPKT_BIGNUM, s->key.modulus, PKT_END);\n\t\t    crWaitUntil(pktin);\n\t\t    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t\tlogevent(\"Key refused\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    logevent(\"Received RSA challenge\");\n\t\t    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\n\t\t    {\n\t\t\tchar *agentreq, *q, *ret;\n\t\t\tvoid *vret;\n\t\t\tint len, retlen;\n\t\t\tlen = 1 + 4;   /* message type, bit count */\n\t\t\tlen += ssh1_bignum_length(s->key.exponent);\n\t\t\tlen += ssh1_bignum_length(s->key.modulus);\n\t\t\tlen += ssh1_bignum_length(s->challenge);\n\t\t\tlen += 16;     /* session id */\n\t\t\tlen += 4;      /* response format */\n\t\t\tagentreq = snewn(4 + len, char);\n\t\t\tPUT_32BIT(agentreq, len);\n\t\t\tq = agentreq + 4;\n\t\t\t*q++ = SSH1_AGENTC_RSA_CHALLENGE;\n\t\t\tPUT_32BIT(q, bignum_bitcount(s->key.modulus));\n\t\t\tq += 4;\n\t\t\tq += ssh1_write_bignum(q, s->key.exponent);\n\t\t\tq += ssh1_write_bignum(q, s->key.modulus);\n\t\t\tq += ssh1_write_bignum(q, s->challenge);\n\t\t\tmemcpy(q, s->session_id, 16);\n\t\t\tq += 16;\n\t\t\tPUT_32BIT(q, 1);\t/* response format */\n                        ssh->auth_agent_query = agent_query(\n                            agentreq, len + 4, &vret, &retlen,\n                            ssh_agent_callback, ssh);\n\t\t\tif (ssh->auth_agent_query) {\n\t\t\t    sfree(agentreq);\n\t\t\t    do {\n\t\t\t\tcrReturn(0);\n\t\t\t\tif (pktin) {\n\t\t\t\t    bombout((\"Unexpected data from server\"\n\t\t\t\t\t     \" while waiting for agent\"\n\t\t\t\t\t     \" response\"));\n\t\t\t\t    crStop(0);\n\t\t\t\t}\n\t\t\t    } while (pktin || inlen > 0);\n\t\t\t    vret = ssh->agent_response;\n\t\t\t    retlen = ssh->agent_response_len;\n\t\t\t} else\n\t\t\t    sfree(agentreq);\n\t\t\tret = vret;\n\t\t\tif (ret) {\n\t\t\t    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {\n\t\t\t\tlogevent(\"Sending Pageant's response\");\n\t\t\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\t\t    PKT_DATA, ret + 5, 16,\n\t\t\t\t\t    PKT_END);\n\t\t\t\tsfree(ret);\n\t\t\t\tcrWaitUntil(pktin);\n\t\t\t\tif (pktin->type == SSH1_SMSG_SUCCESS) {\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response accepted\");\n\t\t\t\t    if (flags & FLAG_VERBOSE) {\n\t\t\t\t\tc_write_str(ssh, \"Authenticated using\"\n\t\t\t\t\t\t    \" RSA key \\\"\");\n\t\t\t\t\tc_write(ssh, s->commentp,\n\t\t\t\t\t\ts->commentlen);\n\t\t\t\t\tc_write_str(ssh, \"\\\" from agent\\r\\n\");\n\t\t\t\t    }\n\t\t\t\t    s->authed = TRUE;\n\t\t\t\t} else\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response not accepted\");\n\t\t\t    } else {\n\t\t\t\tlogevent\n\t\t\t\t    (\"Pageant failed to answer challenge\");\n\t\t\t\tsfree(ret);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    logevent(\"No reply received from Pageant\");\n\t\t\t}\n\t\t    }\n\t\t    freebn(s->key.exponent);\n\t\t    freebn(s->key.modulus);\n\t\t    freebn(s->challenge);\n\t\t    if (s->authed)\n\t\t\tbreak;\n\t\t}\n\t\tsfree(s->response);\n\t\tif (s->publickey_blob && !s->tried_publickey)\n\t\t    logevent(\"Configured key file not in Pageant\");\n\t    } else {\n                logevent(\"Failed to get reply from Pageant\");\n            }\n\t    if (s->authed)\n\t\tbreak;\n\t}\n\tif (s->publickey_blob && s->privatekey_available &&\n            !s->tried_publickey) {\n\t    /*\n\t     * Try public key authentication with the specified\n\t     * key file.\n\t     */\n\t    int got_passphrase; /* need not be kept over crReturn */\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Trying public key authentication.\\r\\n\");\n\t    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t    logeventf(ssh, \"Trying public key \\\"%s\\\"\",\n\t\t      filename_to_str(s->keyfile));\n\t    s->tried_publickey = 1;\n\t    got_passphrase = FALSE;\n\t    while (!got_passphrase) {\n\t\t/*\n\t\t * Get a passphrase, if necessary.\n\t\t */\n\t\tchar *passphrase = NULL;    /* only written after crReturn */\n\t\tconst char *error;\n\t\tif (!s->privatekey_encrypted) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"No passphrase required.\\r\\n\");\n\t\t    passphrase = NULL;\n\t\t} else {\n\t\t    int ret; /* need not be kept over crReturn */\n\t\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t\t    s->cur_prompt->to_server = FALSE;\n\t\t    s->cur_prompt->name = dupstr(\"SSH key passphrase\");\n\t\t    add_prompt(s->cur_prompt,\n\t\t\t       dupprintf(\"Passphrase for key \\\"%.100s\\\": \",\n\t\t\t\t\t s->publickey_comment), FALSE);\n\t\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t\t    while (ret < 0) {\n\t\t\tssh->send_ok = 1;\n\t\t\tcrWaitUntil(!pktin);\n\t\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\t\tssh->send_ok = 0;\n\t\t    }\n\t\t    if (!ret) {\n\t\t\t/* Failed to get a passphrase. Terminate. */\n\t\t\tfree_prompts(s->cur_prompt);\n\t\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\",\n\t\t\t\t       0, TRUE);\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    passphrase = dupstr(s->cur_prompt->prompts[0]->result);\n\t\t    free_prompts(s->cur_prompt);\n\t\t}\n\t\t/*\n\t\t * Try decrypting key with passphrase.\n\t\t */\n\t\ts->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t\tret = loadrsakey(s->keyfile, &s->key, passphrase,\n\t\t\t\t &error);\n\t\tif (passphrase) {\n\t\t    smemclr(passphrase, strlen(passphrase));\n\t\t    sfree(passphrase);\n\t\t}\n\t\tif (ret == 1) {\n\t\t    /* Correct passphrase. */\n\t\t    got_passphrase = TRUE;\n\t\t} else if (ret == 0) {\n\t\t    c_write_str(ssh, \"Couldn't load private key from \");\n\t\t    c_write_str(ssh, filename_to_str(s->keyfile));\n\t\t    c_write_str(ssh, \" (\");\n\t\t    c_write_str(ssh, error);\n\t\t    c_write_str(ssh, \").\\r\\n\");\n\t\t    got_passphrase = FALSE;\n\t\t    break;\t       /* go and try something else */\n\t\t} else if (ret == -1) {\n\t\t    c_write_str(ssh, \"Wrong passphrase.\\r\\n\"); /* FIXME */\n\t\t    got_passphrase = FALSE;\n\t\t    /* and try again */\n\t\t} else {\n\t\t    assert(0 && \"unexpected return from loadrsakey()\");\n\t\t    got_passphrase = FALSE;   /* placate optimisers */\n\t\t}\n\t    }\n\n\t    if (got_passphrase) {\n\n\t\t/*\n\t\t * Send a public key attempt.\n\t\t */\n\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t    PKT_BIGNUM, s->key.modulus, PKT_END);\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    c_write_str(ssh, \"Server refused our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t}\n\t\tif (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t    bombout((\"Bizarre response to offer of public key\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\t{\n\t\t    int i;\n\t\t    unsigned char buffer[32];\n\t\t    Bignum challenge, response;\n\n\t\t    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    response = rsadecrypt(challenge, &s->key);\n\t\t    freebn(s->key.private_exponent);/* burn the evidence */\n\n\t\t    for (i = 0; i < 32; i++) {\n\t\t\tbuffer[i] = bignum_byte(response, 31 - i);\n\t\t    }\n\n\t\t    MD5Init(&md5c);\n\t\t    MD5Update(&md5c, buffer, 32);\n\t\t    MD5Update(&md5c, s->session_id, 16);\n\t\t    MD5Final(buffer, &md5c);\n\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\tPKT_DATA, buffer, 16, PKT_END);\n\n\t\t    freebn(challenge);\n\t\t    freebn(response);\n\t\t}\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"Failed to authenticate with\"\n\t\t\t\t    \" our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t\t    bombout((\"Bizarre response to RSA authentication response\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\tbreak;\t\t       /* we're through! */\n\t    }\n\n\t}\n\n\t/*\n\t * Otherwise, try various forms of password-like authentication.\n\t */\n\ts->cur_prompt = new_prompts(ssh->frontend);\n\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&\n\t    !s->tis_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;\n\t    logevent(\"Requested TIS authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {\n\t\tlogevent(\"TIS authentication declined\");\n\t\tif (flags & FLAG_INTERACTIVE)\n\t\t    c_write_str(ssh, \"TIS authentication refused.\\r\\n\");\n\t\ts->tis_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"TIS challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received TIS challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH TIS authentication\");\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using TIS authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&\n\t    !s->ccard_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;\n\t    logevent(\"Requested CryptoCard authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {\n\t\tlogevent(\"CryptoCard authentication declined\");\n\t\tc_write_str(ssh, \"CryptoCard authentication refused.\\r\\n\");\n\t\ts->ccard_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"CryptoCard challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received CryptoCard challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH CryptoCard authentication\");\n\t\ts->cur_prompt->name_reqd = FALSE;\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using CryptoCard authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {\n\t\tbombout((\"No supported authentication methods available\"));\n\t\tcrStop(0);\n\t    }\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH password\");\n\t    add_prompt(s->cur_prompt, dupprintf(\"%s@%s's password: \",\n\t\t\t\t\t\tssh->username, ssh->savedhost),\n\t\t       FALSE);\n\t}\n\n\t/*\n\t * Show password prompt, having first obtained it via a TIS\n\t * or CryptoCard exchange if we're doing TIS or CryptoCard\n\t * authentication.\n\t */\n\t{\n\t    int ret; /* need not be kept over crReturn */\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a password (for example\n\t\t * because one was supplied on the command line\n\t\t * which has already failed to work). Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\", 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t}\n\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    /*\n\t     * Defence against traffic analysis: we send a\n\t     * whole bunch of packets containing strings of\n\t     * different lengths. One of these strings is the\n\t     * password, in a SSH1_CMSG_AUTH_PASSWORD packet.\n\t     * The others are all random data in\n\t     * SSH1_MSG_IGNORE packets. This way a passive\n\t     * listener can't tell which is the password, and\n\t     * hence can't deduce the password length.\n\t     * \n\t     * Anybody with a password length greater than 16\n\t     * bytes is going to have enough entropy in their\n\t     * password that a listener won't find it _that_\n\t     * much help to know how long it is. So what we'll\n\t     * do is:\n\t     * \n\t     *  - if password length < 16, we send 15 packets\n\t     *    containing string lengths 1 through 15\n\t     * \n\t     *  - otherwise, we let N be the nearest multiple\n\t     *    of 8 below the password length, and send 8\n\t     *    packets containing string lengths N through\n\t     *    N+7. This won't obscure the order of\n\t     *    magnitude of the password length, but it will\n\t     *    introduce a bit of extra uncertainty.\n\t     * \n\t     * A few servers can't deal with SSH1_MSG_IGNORE, at\n\t     * least in this context. For these servers, we need\n\t     * an alternative defence. We make use of the fact\n\t     * that the password is interpreted as a C string:\n\t     * so we can append a NUL, then some random data.\n\t     * \n\t     * A few servers can deal with neither SSH1_MSG_IGNORE\n\t     * here _nor_ a padded password string.\n\t     * For these servers we are left with no defences\n\t     * against password length sniffing.\n\t     */\n\t    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&\n\t        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can deal with SSH1_MSG_IGNORE, so\n\t\t * we can use the primary defence.\n\t\t */\n\t\tint bottom, top, pwlen, i;\n\t\tchar *randomstr;\n\n\t\tpwlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (pwlen < 16) {\n\t\t    bottom = 0;    /* zero length passwords are OK! :-) */\n\t\t    top = 15;\n\t\t} else {\n\t\t    bottom = pwlen & ~7;\n\t\t    top = bottom + 7;\n\t\t}\n\n\t\tassert(pwlen >= bottom && pwlen <= top);\n\n\t\trandomstr = snewn(top + 1, char);\n\n\t\tfor (i = bottom; i <= top; i++) {\n\t\t    if (i == pwlen) {\n\t\t\tdefer_packet(ssh, s->pwpkt_type,\n                                     PKT_STR,s->cur_prompt->prompts[0]->result,\n\t\t\t\t     PKT_END);\n\t\t    } else {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    do {\n\t\t\t\trandomstr[j] = random_byte();\n\t\t\t    } while (randomstr[j] == '\\0');\n\t\t\t}\n\t\t\trandomstr[i] = '\\0';\n\t\t\tdefer_packet(ssh, SSH1_MSG_IGNORE,\n\t\t\t\t     PKT_STR, randomstr, PKT_END);\n\t\t    }\n\t\t}\n\t\tlogevent(\"Sending password with camouflage packets\");\n\t\tssh_pkt_defersend(ssh);\n\t\tsfree(randomstr);\n\t    } \n\t    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can't deal with SSH1_MSG_IGNORE\n\t\t * but can deal with padded passwords, so we\n\t\t * can use the secondary defence.\n\t\t */\n\t\tchar string[64];\n\t\tchar *ss;\n\t\tint len;\n\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (len < sizeof(string)) {\n\t\t    ss = string;\n\t\t    strcpy(string, s->cur_prompt->prompts[0]->result);\n\t\t    len++;\t       /* cover the zero byte */\n\t\t    while (len < sizeof(string)) {\n\t\t\tstring[len++] = (char) random_byte();\n\t\t    }\n\t\t} else {\n\t\t    ss = s->cur_prompt->prompts[0]->result;\n\t\t}\n\t\tlogevent(\"Sending length-padded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n\t\t\t    PKT_INT, len, PKT_DATA, ss, len,\n\t\t\t    PKT_END);\n\t    } else {\n\t\t/*\n\t\t * The server is believed unable to cope with\n\t\t * any of our password camouflage methods.\n\t\t */\n\t\tint len;\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tlogevent(\"Sending unpadded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n                            PKT_INT, len,\n\t\t\t    PKT_DATA, s->cur_prompt->prompts[0]->result, len,\n\t\t\t    PKT_END);\n\t    }\n\t} else {\n\t    send_packet(ssh, s->pwpkt_type,\n\t\t\tPKT_STR, s->cur_prompt->prompts[0]->result,\n\t\t\tPKT_END);\n\t}\n\tlogevent(\"Sent password\");\n\tfree_prompts(s->cur_prompt);\n\tcrWaitUntil(pktin);\n\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Access denied\\r\\n\");\n\t    logevent(\"Authentication refused\");\n\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t    bombout((\"Strange packet received, type %d\", pktin->type));\n\t    crStop(0);\n\t}\n    }\n\n    /* Clear up */\n    if (s->publickey_blob) {\n\tsfree(s->publickey_blob);\n\tsfree(s->publickey_comment);\n    }\n\n    logevent(\"Authentication successful\");\n\n    crFinish(1);\n}\n\nstatic void ssh_channel_try_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    assert(c->pending_eof);          /* precondition for calling us */\n    if (c->halfopen)\n        return;                 /* can't close: not even opened yet */\n    if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)\n        return;              /* can't send EOF: pending outgoing data */\n\n    c->pending_eof = FALSE;            /* we're about to send it */\n    if (ssh->version == 1) {\n        send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,\n                    PKT_END);\n        c->closes |= CLOSES_SENT_EOF;\n    } else {\n        struct Packet *pktout;\n        pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);\n        ssh2_pkt_adduint32(pktout, c->remoteid);\n        ssh2_pkt_send(ssh, pktout);\n        c->closes |= CLOSES_SENT_EOF;\n\tssh2_channel_check_close(c);\n    }\n}\n\nConf *sshfwd_get_conf(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    return ssh->conf;\n}\n\nvoid sshfwd_write_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    if (c->closes & CLOSES_SENT_EOF)\n        return;\n\n    c->pending_eof = TRUE;\n    ssh_channel_try_eof(c);\n}\n\nvoid sshfwd_unclean_close(struct ssh_channel *c, const char *err)\n{\n    Ssh ssh = c->ssh;\n    char *reason;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    reason = dupprintf(\"due to local error: %s\", err);\n    ssh_channel_close_local(c, reason);\n    sfree(reason);\n    c->pending_eof = FALSE;   /* this will confuse a zombie channel */\n\n    ssh2_channel_check_close(c);\n}\n\nint sshfwd_write(struct ssh_channel *c, char *buf, int len)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn 0;\n\n    return ssh_send_channel_data(c, buf, len);\n}\n\nvoid sshfwd_unthrottle(struct ssh_channel *c, int bufsize)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    ssh_channel_unthrottle(c, bufsize);\n}\n\nstatic void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)\n{\n    struct queued_handler *qh = ssh->qhead;\n\n    assert(qh != NULL);\n\n    assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);\n\n    if (qh->msg1 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;\n    }\n    if (qh->msg2 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;\n    }\n\n    if (qh->next) {\n\tssh->qhead = qh->next;\n\n\tif (ssh->qhead->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;\n\t}\n\tif (ssh->qhead->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qhead = ssh->qtail = NULL;\n    }\n\n    qh->handler(ssh, pktin, qh->ctx);\n\n    sfree(qh);\n}\n\nstatic void ssh_queue_handler(Ssh ssh, int msg1, int msg2,\n\t\t\t      chandler_fn_t handler, void *ctx)\n{\n    struct queued_handler *qh;\n\n    qh = snew(struct queued_handler);\n    qh->msg1 = msg1;\n    qh->msg2 = msg2;\n    qh->handler = handler;\n    qh->ctx = ctx;\n    qh->next = NULL;\n\n    if (ssh->qtail == NULL) {\n\tssh->qhead = qh;\n\n\tif (qh->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;\n\t}\n\tif (qh->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qtail->next = qh;\n    }\n    ssh->qtail = qh;\n}\n\nstatic void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)\n{\n    struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;\n\n    if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :\n\t\t\tSSH2_MSG_REQUEST_SUCCESS)) {\n\tlogeventf(ssh, \"Remote port forwarding from %s enabled\",\n\t\t  pf->sportdesc);\n    } else {\n\tlogeventf(ssh, \"Remote port forwarding from %s refused\",\n\t\t  pf->sportdesc);\n\n\trpf = del234(ssh->rportfwds, pf);\n\tassert(rpf == pf);\n\tpf->pfrec->remote = NULL;\n\tfree_rportfwd(pf);\n    }\n}\n\nint ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,\n                               void *share_ctx)\n{\n    struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);\n    pf->dhost = NULL;\n    pf->dport = 0;\n    pf->share_ctx = share_ctx;\n    pf->shost = dupstr(shost);\n    pf->sport = sport;\n    pf->sportdesc = NULL;\n    if (!ssh->rportfwds) {\n        assert(ssh->version == 2);\n        ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n    }\n    if (add234(ssh->rportfwds, pf) != pf) {\n        sfree(pf->shost);\n        sfree(pf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nstatic void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,\n                                                void *ctx)\n{\n    share_got_pkt_from_server(ctx, pktin->type,\n                              pktin->body, pktin->length);\n}\n\nvoid ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)\n{\n    ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,\n                      ssh_sharing_global_request_response, share_ctx);\n}\n\nstatic void ssh_setup_portfwd(Ssh ssh, Conf *conf)\n{\n    struct ssh_portfwd *epf;\n    int i;\n    char *key, *val;\n\n    if (!ssh->portfwds) {\n\tssh->portfwds = newtree234(ssh_portcmp);\n    } else {\n\t/*\n\t * Go through the existing port forwardings and tag them\n\t * with status==DESTROY. Any that we want to keep will be\n\t * re-enabled (status==KEEP) as we go through the\n\t * configuration and find out which bits are the same as\n\t * they were before.\n\t */\n\tstruct ssh_portfwd *epf;\n\tint i;\n\tfor (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\t    epf->status = DESTROY;\n    }\n\n    for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\tchar *kp, *kp2, *vp, *vp2;\n\tchar address_family, type;\n\tint sport,dport,sserv,dserv;\n\tchar *sports, *dports, *saddr, *host;\n\n\tkp = key;\n\n\taddress_family = 'A';\n\ttype = 'L';\n\tif (*kp == 'A' || *kp == '4' || *kp == '6')\n\t    address_family = *kp++;\n\tif (*kp == 'L' || *kp == 'R')\n\t    type = *kp++;\n\n\tif ((kp2 = host_strchr(kp, ':')) != NULL) {\n\t    /*\n\t     * There's a colon in the middle of the source port\n\t     * string, which means that the part before it is\n\t     * actually a source address.\n\t     */\n\t    char *saddr_tmp = dupprintf(\"%.*s\", (int)(kp2 - kp), kp);\n            saddr = host_strduptrim(saddr_tmp);\n            sfree(saddr_tmp);\n\t    sports = kp2+1;\n\t} else {\n\t    saddr = NULL;\n\t    sports = kp;\n\t}\n\tsport = atoi(sports);\n\tsserv = 0;\n\tif (sport == 0) {\n\t    sserv = 1;\n\t    sport = net_service_lookup(sports);\n\t    if (!sport) {\n\t\tlogeventf(ssh, \"Service lookup failed for source\"\n\t\t\t  \" port \\\"%s\\\"\", sports);\n\t    }\n\t}\n\n\tif (type == 'L' && !strcmp(val, \"D\")) {\n            /* dynamic forwarding */\n\t    host = NULL;\n\t    dports = NULL;\n\t    dport = -1;\n\t    dserv = 0;\n            type = 'D';\n        } else {\n            /* ordinary forwarding */\n\t    vp = val;\n\t    vp2 = vp + host_strcspn(vp, \":\");\n\t    host = dupprintf(\"%.*s\", (int)(vp2 - vp), vp);\n\t    if (*vp2)\n\t\tvp2++;\n\t    dports = vp2;\n\t    dport = atoi(dports);\n\t    dserv = 0;\n\t    if (dport == 0) {\n\t\tdserv = 1;\n\t\tdport = net_service_lookup(dports);\n\t\tif (!dport) {\n\t\t    logeventf(ssh, \"Service lookup failed for destination\"\n\t\t\t      \" port \\\"%s\\\"\", dports);\n\t\t}\n\t    }\n\t}\n\n\tif (sport && dport) {\n\t    /* Set up a description of the source port. */\n\t    struct ssh_portfwd *pfrec, *epfrec;\n\n\t    pfrec = snew(struct ssh_portfwd);\n\t    pfrec->type = type;\n\t    pfrec->saddr = saddr;\n\t    pfrec->sserv = sserv ? dupstr(sports) : NULL;\n\t    pfrec->sport = sport;\n\t    pfrec->daddr = host;\n\t    pfrec->dserv = dserv ? dupstr(dports) : NULL;\n\t    pfrec->dport = dport;\n\t    pfrec->local = NULL;\n\t    pfrec->remote = NULL;\n\t    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :\n\t\t\t\t    address_family == '6' ? ADDRTYPE_IPV6 :\n\t\t\t\t    ADDRTYPE_UNSPEC);\n\n\t    epfrec = add234(ssh->portfwds, pfrec);\n\t    if (epfrec != pfrec) {\n\t\tif (epfrec->status == DESTROY) {\n\t\t    /*\n\t\t     * We already have a port forwarding up and running\n\t\t     * with precisely these parameters. Hence, no need\n\t\t     * to do anything; simply re-tag the existing one\n\t\t     * as KEEP.\n\t\t     */\n\t\t    epfrec->status = KEEP;\n\t\t}\n\t\t/*\n\t\t * Anything else indicates that there was a duplicate\n\t\t * in our input, which we'll silently ignore.\n\t\t */\n\t\tfree_portfwd(pfrec);\n\t    } else {\n\t\tpfrec->status = CREATE;\n\t    }\n\t} else {\n\t    sfree(saddr);\n\t    sfree(host);\n\t}\n    }\n\n    /*\n     * Now go through and destroy any port forwardings which were\n     * not re-enabled.\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == DESTROY) {\n\t    char *message;\n\n\t    message = dupprintf(\"%s port forwarding from %s%s%d\",\n\t\t\t\tepf->type == 'L' ? \"local\" :\n\t\t\t\tepf->type == 'R' ? \"remote\" : \"dynamic\",\n\t\t\t\tepf->saddr ? epf->saddr : \"\",\n\t\t\t\tepf->saddr ? \":\" : \"\",\n\t\t\t\tepf->sport);\n\n\t    if (epf->type != 'D') {\n\t\tchar *msg2 = dupprintf(\"%s to %s:%d\", message,\n\t\t\t\t       epf->daddr, epf->dport);\n\t\tsfree(message);\n\t\tmessage = msg2;\n\t    }\n\n\t    logeventf(ssh, \"Cancelling %s\", message);\n\t    sfree(message);\n\n\t    /* epf->remote or epf->local may be NULL if setting up a\n\t     * forwarding failed. */\n\t    if (epf->remote) {\n\t\tstruct ssh_rportfwd *rpf = epf->remote;\n\t\tstruct Packet *pktout;\n\n\t\t/*\n\t\t * Cancel the port forwarding at the server\n\t\t * end.\n\t\t */\n\t\tif (ssh->version == 1) {\n\t\t    /*\n\t\t     * We cannot cancel listening ports on the\n\t\t     * server side in SSH-1! There's no message\n\t\t     * to support it. Instead, we simply remove\n\t\t     * the rportfwd record from the local end\n\t\t     * so that any connections the server tries\n\t\t     * to make on it are rejected.\n\t\t     */\n\t\t} else {\n\t\t    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t    ssh2_pkt_addstring(pktout, \"cancel-tcpip-forward\");\n\t\t    ssh2_pkt_addbool(pktout, 0);/* _don't_ want reply */\n\t\t    if (epf->saddr) {\n\t\t\tssh2_pkt_addstring(pktout, epf->saddr);\n\t\t    } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n\t\t\t/* XXX: rport_acceptall may not represent\n\t\t\t * what was used to open the original connection,\n\t\t\t * since it's reconfigurable. */\n\t\t\tssh2_pkt_addstring(pktout, \"\");\n\t\t    } else {\n\t\t\tssh2_pkt_addstring(pktout, \"localhost\");\n\t\t    }\n\t\t    ssh2_pkt_adduint32(pktout, epf->sport);\n\t\t    ssh2_pkt_send(ssh, pktout);\n\t\t}\n\n\t\tdel234(ssh->rportfwds, rpf);\n\t\tfree_rportfwd(rpf);\n\t    } else if (epf->local) {\n\t\tpfl_terminate(epf->local);\n\t    }\n\n\t    delpos234(ssh->portfwds, i);\n\t    free_portfwd(epf);\n\t    i--;\t\t       /* so we don't skip one in the list */\n\t}\n\n    /*\n     * And finally, set up any new port forwardings (status==CREATE).\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == CREATE) {\n\t    char *sportdesc, *dportdesc;\n\t    sportdesc = dupprintf(\"%s%s%s%s%d%s\",\n\t\t\t\t  epf->saddr ? epf->saddr : \"\",\n\t\t\t\t  epf->saddr ? \":\" : \"\",\n\t\t\t\t  epf->sserv ? epf->sserv : \"\",\n\t\t\t\t  epf->sserv ? \"(\" : \"\",\n\t\t\t\t  epf->sport,\n\t\t\t\t  epf->sserv ? \")\" : \"\");\n\t    if (epf->type == 'D') {\n\t\tdportdesc = NULL;\n\t    } else {\n\t\tdportdesc = dupprintf(\"%s:%s%s%d%s\",\n\t\t\t\t      epf->daddr,\n\t\t\t\t      epf->dserv ? epf->dserv : \"\",\n\t\t\t\t      epf->dserv ? \"(\" : \"\",\n\t\t\t\t      epf->dport,\n\t\t\t\t      epf->dserv ? \")\" : \"\");\n\t    }\n\n\t    if (epf->type == 'L') {\n                char *err = pfl_listen(epf->daddr, epf->dport,\n                                       epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s forwarding to %s%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc, dportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n                if (err)\n                    sfree(err);\n\t    } else if (epf->type == 'D') {\n\t\tchar *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s SOCKS dynamic forwarding%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n\n                if (err)\n                    sfree(err);\n\t    } else {\n\t\tstruct ssh_rportfwd *pf;\n\n\t\t/*\n\t\t * Ensure the remote port forwardings tree exists.\n\t\t */\n\t\tif (!ssh->rportfwds) {\n\t\t    if (ssh->version == 1)\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh1);\n\t\t    else\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n\t\t}\n\n\t\tpf = snew(struct ssh_rportfwd);\n                pf->share_ctx = NULL;\n                pf->dhost = dupstr(epf->daddr);\n\t\tpf->dport = epf->dport;\n                if (epf->saddr) {\n                    pf->shost = dupstr(epf->saddr);\n                } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n                    pf->shost = dupstr(\"\");\n                } else {\n                    pf->shost = dupstr(\"localhost\");\n                }\n\t\tpf->sport = epf->sport;\n\t\tif (add234(ssh->rportfwds, pf) != pf) {\n\t\t    logeventf(ssh, \"Duplicate remote port forwarding to %s:%d\",\n\t\t\t      epf->daddr, epf->dport);\n\t\t    sfree(pf);\n\t\t} else {\n\t\t    logeventf(ssh, \"Requesting remote port %s\"\n\t\t\t      \" forward to %s\", sportdesc, dportdesc);\n\n\t\t    pf->sportdesc = sportdesc;\n\t\t    sportdesc = NULL;\n\t\t    epf->remote = pf;\n\t\t    pf->pfrec = epf;\n\n\t\t    if (ssh->version == 1) {\n\t\t\tsend_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,\n\t\t\t\t    PKT_INT, epf->sport,\n\t\t\t\t    PKT_STR, epf->daddr,\n\t\t\t\t    PKT_INT, epf->dport,\n\t\t\t\t    PKT_END);\n\t\t\tssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,\n\t\t\t\t\t  SSH1_SMSG_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    } else {\n\t\t\tstruct Packet *pktout;\n\t\t\tpktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tssh2_pkt_addstring(pktout, \"tcpip-forward\");\n\t\t\tssh2_pkt_addbool(pktout, 1);/* want reply */\n\t\t\tssh2_pkt_addstring(pktout, pf->shost);\n\t\t\tssh2_pkt_adduint32(pktout, pf->sport);\n\t\t\tssh2_pkt_send(ssh, pktout);\n\n\t\t\tssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,\n\t\t\t\t\t  SSH2_MSG_REQUEST_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    }\n\t\t}\n\t    }\n\t    sfree(sportdesc);\n\t    sfree(dportdesc);\n\t}\n}\n\nstatic void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)\n{\n    char *string;\n    int stringlen, bufsize;\n\n    ssh_pkt_getstring(pktin, &string, &stringlen);\n    if (string == NULL) {\n\tbombout((\"Incoming terminal data packet was badly formed\"));\n\treturn;\n    }\n\n    bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,\n\t\t\t   string, stringlen);\n    if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {\n\tssh->v1_stdout_throttling = 1;\n\tssh_throttle_conn(ssh, +1);\n    }\n}\n\nstatic void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * X-Server. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    logevent(\"Received X11 connect request\");\n    /* Refuse if X11 forwarding is disabled. */\n    if (!ssh->X11_fwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n\tlogevent(\"Rejected X11 connect request\");\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\n\tssh_channel_init(c);\n\tc->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_X11;\t/* identify channel type */\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT,\n                    c->localid, PKT_END);\n        logevent(\"Opened X11 forward channel\");\n    }\n}\n\nstatic void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * agent. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    /* Refuse if agent forwarding is disabled. */\n    if (!ssh->agentfwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\tssh_channel_init(c);\n\tc->remoteid = remoteid;\n\tc->halfopen = FALSE;\n\tc->type = CHAN_AGENT;\t/* identify channel type */\n\tc->u.a.lensofar = 0;\n\tc->u.a.message = NULL;\n\tc->u.a.pending = NULL;\n\tc->u.a.outstanding_requests = 0;\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t    PKT_INT, c->remoteid, PKT_INT, c->localid,\n\t\t    PKT_END);\n    }\n}\n\nstatic void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to a\n     * forwarded port. Give them back a local channel number. */\n    struct ssh_rportfwd pf, *pfp;\n    int remoteid;\n    int hostsize, port;\n    char *host;\n    char *err;\n\n    remoteid = ssh_pkt_getuint32(pktin);\n    ssh_pkt_getstring(pktin, &host, &hostsize);\n    port = ssh_pkt_getuint32(pktin);\n\n    pf.dhost = dupprintf(\"%.*s\", hostsize, NULLTOEMPTY(host));\n    pf.dport = port;\n    pfp = find234(ssh->rportfwds, &pf, NULL);\n\n    if (pfp == NULL) {\n\tlogeventf(ssh, \"Rejected remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n        struct ssh_channel *c = snew(struct ssh_channel);\n        c->ssh = ssh;\n\n\tlogeventf(ssh, \"Received remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\terr = pfd_connect(&c->u.pfd.pf, pf.dhost, port,\n                          c, ssh->conf, pfp->pfrec->addressfamily);\n\tif (err != NULL) {\n\t    logeventf(ssh, \"Port open failed: %s\", err);\n            sfree(err);\n\t    sfree(c);\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t\tPKT_INT, remoteid, PKT_END);\n\t} else {\n\t    ssh_channel_init(c);\n\t    c->remoteid = remoteid;\n\t    c->halfopen = FALSE;\n\t    c->type = CHAN_SOCKDATA;\t/* identify channel type */\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t\tPKT_INT, c->remoteid, PKT_INT,\n\t\t\tc->localid, PKT_END);\n\t    logevent(\"Forwarded port opened successfully\");\n\t}\n    }\n\n    sfree(pf.dhost);\n}\n\nstatic void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)\n{\n    struct ssh_channel *c;\n\n    c = ssh_channel_msg(ssh, pktin);\n    if (c && c->type == CHAN_SOCKDATA) {\n\tc->remoteid = ssh_pkt_getuint32(pktin);\n\tc->halfopen = FALSE;\n\tc->throttling_conn = 0;\n\tpfd_confirm(c->u.pfd.pf);\n    }\n\n    if (c && c->pending_eof) {\n\t/*\n\t * We have a pending close on this channel,\n\t * which we decided on before the server acked\n\t * the channel open. So now we know the\n\t * remoteid, we can close it again.\n\t */\n        ssh_channel_try_eof(c);\n    }\n}\n\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_AGENT;   /* identify channel type */\n        c->u.a.pending = NULL;\n        bufchain_init(&c->u.a.inbuffer);\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT, c->localid,\n                    PKT_END);\n\tdel234(ssh->channels, c);\n\tsfree(c);\n    }\n}\n", "func_hash": 245301482448712873104203214442039471825, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6542", "cve_desc": "The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6542"}
{"idx": 158101, "project": "virglrenderer", "commit_id": "e534b51ca3c3cd25f3990589932a9ed711c59b27", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=e534b51ca3c3cd25f3990589932a9ed711c59b27", "commit_message": "gallium/tgsi: fix overflow in parse property\n\nIn parse_identifier, it doesn't stop copying '*pcur'\nuntill encounter the NULL. As the 'ret' has a\nfixed-size buffer, if the '*pcur' has a long string,\nthere will be a buffer overflow. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "static boolean parse_identifier( const char **pcur, char *ret )\nstatic boolean parse_identifier( const char **pcur, char *ret, size_t len )\n {\n    const char *cur = *pcur;\n    int i = 0;\n    if (is_alpha_underscore( cur )) {\n       ret[i++] = *cur++;\n      while (is_alpha_underscore( cur ) || is_digit( cur )) {\n         if (i == len - 1)\n            return FALSE;\n          ret[i++] = *cur++;\n      }\n       ret[i++] = '\\0';\n       *pcur = cur;\n       return TRUE;\n\n/* Parse floating point.\n */\nstatic boolean parse_float( const char **pcur, float *val )\n{\n   const char *cur = *pcur;\n   boolean integral_part = FALSE;\n   boolean fractional_part = FALSE;\n\n   if (*cur == '0' && *(cur + 1) == 'x') {\n      union fi fi;\n      fi.ui = strtoul(cur, NULL, 16);\n      *val = fi.f;\n      cur += 10;\n      goto out;\n   }\n\n   *val = (float) atof( cur );\n   if (*cur == '-' || *cur == '+')\n      cur++;\n   if (is_digit( cur )) {\n      cur++;\n      integral_part = TRUE;\n      while (is_digit( cur ))\n         cur++;\n   }\n   if (*cur == '.') {\n      cur++;\n      if (is_digit( cur )) {\n         cur++;\n         fractional_part = TRUE;\n         while (is_digit( cur ))\n            cur++;\n      }\n   }\n   if (!integral_part && !fractional_part)\n      return FALSE;\n   if (uprcase( *cur ) == 'E') {\n      cur++;\n      if (*cur == '-' || *cur == '+')\n         cur++;\n      if (is_digit( cur )) {\n         cur++;\n         while (is_digit( cur ))\n            cur++;\n      }\n      else\n         return FALSE;\n   }\n\nout:\n   *pcur = cur;\n   return TRUE;\n}\n\nstatic boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)\n{\n   const char *cur = *pcur;\n   union {\n      double dval;\n      uint32_t uval[2];\n   } v;\n\n   v.dval = strtod(cur, (char**)pcur);\n   if (*pcur == cur)\n      return FALSE;\n\n   *val0 = v.uval[0];\n   *val1 = v.uval[1];\n\n   return TRUE;\n}\n\nstruct translate_ctx\n{\n   const char *text;\n   const char *cur;\n   struct tgsi_token *tokens;\n   struct tgsi_token *tokens_cur;\n   struct tgsi_token *tokens_end;\n   struct tgsi_header *header;\n   unsigned processor : 4;\n   unsigned implied_array_size : 6;\n   unsigned num_immediates;\n};\n\nstatic void report_error(struct translate_ctx *ctx, const char *format, ...)\n{\n   va_list args;\n   int line = 1;\n   int column = 1;\n   const char *itr = ctx->text;\n\n   debug_printf(\"\\nTGSI asm error: \");\n\n   va_start(args, format);\n   _debug_vprintf(format, args);\n   va_end(args);\n\n   while (itr != ctx->cur) {\n      if (*itr == '\\n') {\n         column = 1;\n         ++line;\n      }\n      ++column;\n      ++itr;\n   }\n\n   debug_printf(\" [%d : %d] \\n\", line, column);\n}\n\n/* Parse shader header.\n * Return TRUE for one of the following headers.\n *    FRAG\n *    GEOM\n *    VERT\n */\nstatic boolean parse_header( struct translate_ctx *ctx )\n{\n   uint processor;\n\n   if (str_match_nocase_whole( &ctx->cur, \"FRAG\" ))\n      processor = TGSI_PROCESSOR_FRAGMENT;\n   else if (str_match_nocase_whole( &ctx->cur, \"VERT\" ))\n      processor = TGSI_PROCESSOR_VERTEX;\n   else if (str_match_nocase_whole( &ctx->cur, \"GEOM\" ))\n      processor = TGSI_PROCESSOR_GEOMETRY;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_CTRL\" ))\n      processor = TGSI_PROCESSOR_TESS_CTRL;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_EVAL\" ))\n      processor = TGSI_PROCESSOR_TESS_EVAL;\n   else if (str_match_nocase_whole( &ctx->cur, \"COMP\" ))\n      processor = TGSI_PROCESSOR_COMPUTE;\n   else {\n      report_error( ctx, \"Unknown header\" );\n      return FALSE;\n   }\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   ctx->header = (struct tgsi_header *) ctx->tokens_cur++;\n   *ctx->header = tgsi_build_header();\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );\n   ctx->processor = processor;\n\n   return TRUE;\n}\n\nstatic boolean parse_label( struct translate_ctx *ctx, uint *val )\n{\n   const char *cur = ctx->cur;\n\n   if (parse_uint( &cur, val )) {\n      eat_opt_white( &cur );\n      if (*cur == ':') {\n         cur++;\n         ctx->cur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_file( const char **pcur, uint *file )\n{\n   uint i;\n\n   for (i = 0; i < TGSI_FILE_COUNT; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {\n         *pcur = cur;\n         *file = i;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_opt_writemask(\n   struct translate_ctx *ctx,\n   uint *writemask )\n{\n   const char *cur;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      cur++;\n      *writemask = TGSI_WRITEMASK_NONE;\n      eat_opt_white( &cur );\n      if (uprcase( *cur ) == 'X') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_X;\n      }\n      if (uprcase( *cur ) == 'Y') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Y;\n      }\n      if (uprcase( *cur ) == 'Z') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Z;\n      }\n      if (uprcase( *cur ) == 'W') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_W;\n      }\n\n      if (*writemask == TGSI_WRITEMASK_NONE) {\n         report_error( ctx, \"Writemask expected\" );\n         return FALSE;\n      }\n\n      ctx->cur = cur;\n   }\n   else {\n      *writemask = TGSI_WRITEMASK_XYZW;\n   }\n   return TRUE;\n}\n\n\n/* <register_file_bracket> ::= <file> `['\n */\nstatic boolean\nparse_register_file_bracket(\n   struct translate_ctx *ctx,\n   uint *file )\n{\n   if (!parse_file( &ctx->cur, file )) {\n      report_error( ctx, \"Unknown register file\" );\n      return FALSE;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '[') {\n      report_error( ctx, \"Expected `['\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* <register_file_bracket_index> ::= <register_file_bracket> <uint>\n */\nstatic boolean\nparse_register_file_bracket_index(\n   struct translate_ctx *ctx,\n   uint *file,\n   int *index )\n{\n   uint uindex;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   *index = (int) uindex;\n   return TRUE;\n}\n\n/* Parse simple 1d register operand.\n *    <register_dst> ::= <register_file_bracket_index> `]'\n */\nstatic boolean\nparse_register_1d(struct translate_ctx *ctx,\n                  uint *file,\n                  int *index )\n{\n   if (!parse_register_file_bracket_index( ctx, file, index ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\nstruct parsed_bracket {\n   int index;\n\n   uint ind_file;\n   int ind_index;\n   uint ind_comp;\n   uint ind_array;\n};\n\n\nstatic boolean\nparse_register_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets)\n{\n   const char *cur;\n   uint uindex;\n\n   memset(brackets, 0, sizeof(struct parsed_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   cur = ctx->cur;\n   if (parse_file( &cur, &brackets->ind_file )) {\n      if (!parse_register_1d( ctx, &brackets->ind_file,\n                              &brackets->ind_index ))\n         return FALSE;\n      eat_opt_white( &ctx->cur );\n\n      if (*ctx->cur == '.') {\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n\n         switch (uprcase(*ctx->cur)) {\n         case 'X':\n            brackets->ind_comp = TGSI_SWIZZLE_X;\n            break;\n         case 'Y':\n            brackets->ind_comp = TGSI_SWIZZLE_Y;\n            break;\n         case 'Z':\n            brackets->ind_comp = TGSI_SWIZZLE_Z;\n            break;\n         case 'W':\n            brackets->ind_comp = TGSI_SWIZZLE_W;\n            break;\n         default:\n            report_error(ctx, \"Expected indirect register swizzle component `x', `y', `z' or `w'\");\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n      }\n\n      if (*ctx->cur == '+' || *ctx->cur == '-')\n         parse_int( &ctx->cur, &brackets->index );\n      else\n         brackets->index = 0;\n   }\n   else {\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      brackets->index = (int) uindex;\n      brackets->ind_file = TGSI_FILE_NULL;\n      brackets->ind_index = 0;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   if (*ctx->cur == '(') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &brackets->ind_array )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_opt_register_src_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets,\n   int *parsed_brackets)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_brackets = 0;\n\n   eat_opt_white( &cur );\n   if (cur[0] == '[') {\n      ++cur;\n      ctx->cur = cur;\n\n      if (!parse_register_bracket(ctx, brackets))\n         return FALSE;\n\n      *parsed_brackets = 1;\n   }\n\n   return TRUE;\n}\n\n\n/* Parse source register operand.\n *    <register_src> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `+' <uint> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `-' <uint> `]'\n */\nstatic boolean\nparse_register_src(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstruct parsed_dcl_bracket {\n   uint first;\n   uint last;\n};\n\nstatic boolean\nparse_register_dcl_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_dcl_bracket *bracket)\n{\n   uint uindex;\n   memset(bracket, 0, sizeof(struct parsed_dcl_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      /* it can be an empty bracket [] which means its range\n       * is from 0 to some implied size */\n      if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {\n         bracket->first = 0;\n         bracket->last = ctx->implied_array_size - 1;\n         goto cleanup;\n      }\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   bracket->first = uindex;\n\n   eat_opt_white( &ctx->cur );\n\n   if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {\n      uint uindex;\n\n      ctx->cur += 2;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal integer\" );\n         return FALSE;\n      }\n      bracket->last = (int) uindex;\n      eat_opt_white( &ctx->cur );\n   }\n   else {\n      bracket->last = bracket->first;\n   }\n\ncleanup:\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]' or `..'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* Parse register declaration.\n *    <register_dcl> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket_index> `..' <index> `]'\n */\nstatic boolean\nparse_register_dcl(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_dcl_bracket *brackets,\n   int *num_brackets)\n{\n   const char *cur;\n\n   *num_brackets = 0;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_dcl_bracket( ctx, &brackets[0] ))\n      return FALSE;\n\n   *num_brackets = 1;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (cur[0] == '[') {\n      bool is_in = *file == TGSI_FILE_INPUT;\n      bool is_out = *file == TGSI_FILE_OUTPUT;\n\n      ++cur;\n      ctx->cur = cur;\n      if (!parse_register_dcl_bracket( ctx, &brackets[1] ))\n         return FALSE;\n      /* for geometry shader we don't really care about\n       * the first brackets it's always the size of the\n       * input primitive. so we want to declare just\n       * the index relevant to the semantics which is in\n       * the second bracket */\n\n      /* tessellation has similar constraints to geometry shader */\n      if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {\n         brackets[0] = brackets[1];\n         *num_brackets = 1;\n      } else {\n         *num_brackets = 2;\n      }\n   }\n\n   return TRUE;\n}\n\n\n/* Parse destination register operand.*/\nstatic boolean\nparse_register_dst(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_dst_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_dst_register *dst )\n{\n   uint file;\n   uint writemask;\n   const char *cur;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (!parse_register_dst( ctx, &file, &bracket[0] ))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   dst->Register.File = file;\n   if (parsed_opt_brackets) {\n      dst->Register.Dimension = 1;\n      dst->Dimension.Indirect = 0;\n      dst->Dimension.Dimension = 0;\n      dst->Dimension.Index = bracket[0].index;\n\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         dst->Dimension.Indirect = 1;\n         dst->DimIndirect.File = bracket[0].ind_file;\n         dst->DimIndirect.Index = bracket[0].ind_index;\n         dst->DimIndirect.Swizzle = bracket[0].ind_comp;\n         dst->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   dst->Register.Index = bracket[0].index;\n   dst->Register.WriteMask = writemask;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      dst->Register.Indirect = 1;\n      dst->Indirect.File = bracket[0].ind_file;\n      dst->Indirect.Index = bracket[0].ind_index;\n      dst->Indirect.Swizzle = bracket[0].ind_comp;\n      dst->Indirect.ArrayID = bracket[0].ind_array;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_optional_swizzle(\n   struct translate_ctx *ctx,\n   uint *swizzle,\n   boolean *parsed_swizzle,\n   int components)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_swizzle = FALSE;\n\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < components; i++) {\n         if (uprcase( *cur ) == 'X')\n            swizzle[i] = TGSI_SWIZZLE_X;\n         else if (uprcase( *cur ) == 'Y')\n            swizzle[i] = TGSI_SWIZZLE_Y;\n         else if (uprcase( *cur ) == 'Z')\n            swizzle[i] = TGSI_SWIZZLE_Z;\n         else if (uprcase( *cur ) == 'W')\n            swizzle[i] = TGSI_SWIZZLE_W;\n         else {\n\t    report_error( ctx, \"Expected register swizzle component `x', `y', `z' or `w'\" );\n\t    return FALSE;\n         }\n         cur++;\n      }\n      *parsed_swizzle = TRUE;\n      ctx->cur = cur;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_src_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_src_register *src )\n{\n   uint file;\n   uint swizzle[4];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (*ctx->cur == '-') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Negate = 1;\n   }\n\n   if (*ctx->cur == '|') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Absolute = 1;\n   }\n\n   if (!parse_register_src(ctx, &file, &bracket[0]))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   src->Register.File = file;\n   if (parsed_opt_brackets) {\n      src->Register.Dimension = 1;\n      src->Dimension.Indirect = 0;\n      src->Dimension.Dimension = 0;\n      src->Dimension.Index = bracket[0].index;\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         src->Dimension.Indirect = 1;\n         src->DimIndirect.File = bracket[0].ind_file;\n         src->DimIndirect.Index = bracket[0].ind_index;\n         src->DimIndirect.Swizzle = bracket[0].ind_comp;\n         src->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   src->Register.Index = bracket[0].index;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      src->Register.Indirect = 1;\n      src->Indirect.File = bracket[0].ind_file;\n      src->Indirect.Index = bracket[0].ind_index;\n      src->Indirect.Swizzle = bracket[0].ind_comp;\n      src->Indirect.ArrayID = bracket[0].ind_array;\n   }\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n      if (parsed_swizzle) {\n         src->Register.SwizzleX = swizzle[0];\n         src->Register.SwizzleY = swizzle[1];\n         src->Register.SwizzleZ = swizzle[2];\n         src->Register.SwizzleW = swizzle[3];\n      }\n   }\n\n   if (src->Register.Absolute) {\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != '|') {\n         report_error( ctx, \"Expected `|'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n\n\n   return TRUE;\n}\n\nstatic boolean\nparse_texoffset_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_texture_offset *src )\n{\n   uint file;\n   uint swizzle[3];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket;\n\n   if (!parse_register_src(ctx, &file, &bracket))\n      return FALSE;\n\n   src->File = file;\n   src->Index = bracket.index;\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {\n      if (parsed_swizzle) {\n         src->SwizzleX = swizzle[0];\n         src->SwizzleY = swizzle[1];\n         src->SwizzleZ = swizzle[2];\n      }\n   }\n\n   return TRUE;\n}\n\nstatic boolean\nmatch_inst(const char **pcur,\n           unsigned *saturate,\n           const struct tgsi_opcode_info *info)\n{\n   const char *cur = *pcur;\n\n   /* simple case: the whole string matches the instruction name */\n   if (str_match_nocase_whole(&cur, info->mnemonic)) {\n      *pcur = cur;\n      *saturate = 0;\n      return TRUE;\n   }\n\n   if (str_match_no_case(&cur, info->mnemonic)) {\n      /* the instruction has a suffix, figure it out */\n      if (str_match_nocase_whole(&cur, \"_SAT\")) {\n         *pcur = cur;\n         *saturate = 1;\n         return TRUE;\n      }\n   }\n\n   return FALSE;\n}\n\nstatic boolean\nparse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n         cur++;\n         eat_opt_white( &cur );\n         ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\n/* parses a 4-touple of the form {x, y, z, w}\n * where x, y, z, w are numbers */\nstatic boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,\n                                    union tgsi_immediate_data *values)\n{\n   unsigned i;\n   int ret;\n\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '{') {\n      report_error( ctx, \"Expected `{'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   for (i = 0; i < 4; i++) {\n      eat_opt_white( &ctx->cur );\n      if (i > 0) {\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      switch (type) {\n      case TGSI_IMM_FLOAT64:\n         ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);\n         i++;\n         break;\n      case TGSI_IMM_FLOAT32:\n         ret = parse_float(&ctx->cur, &values[i].Float);\n         break;\n      case TGSI_IMM_UINT32:\n         ret = parse_uint(&ctx->cur, &values[i].Uint);\n         break;\n      case TGSI_IMM_INT32:\n         ret = parse_int(&ctx->cur, &values[i].Int);\n         break;\n      default:\n         assert(0);\n         ret = FALSE;\n         break;\n      }\n\n      if (!ret) {\n         report_error( ctx, \"Expected immediate constant\" );\n         return FALSE;\n      }\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '}') {\n      report_error( ctx, \"Expected `}'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n\n   return TRUE;\n}\n\nstatic boolean parse_declaration( struct translate_ctx *ctx )\n{\n   struct tgsi_full_declaration decl;\n   uint file;\n   struct parsed_dcl_bracket brackets[2];\n   int num_brackets;\n   uint writemask;\n   const char *cur, *cur2;\n   uint advance;\n   boolean is_vs_input;\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))\n      return FALSE;\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   decl = tgsi_default_full_declaration();\n   decl.Declaration.File = file;\n   decl.Declaration.UsageMask = writemask;\n\n   if (num_brackets == 1) {\n      decl.Range.First = brackets[0].first;\n      decl.Range.Last = brackets[0].last;\n   } else {\n      decl.Range.First = brackets[1].first;\n      decl.Range.Last = brackets[1].last;\n\n      decl.Declaration.Dimension = 1;\n      decl.Dim.Index2D = brackets[0].first;\n   }\n\n   is_vs_input = (file == TGSI_FILE_INPUT &&\n                  ctx->processor == TGSI_PROCESSOR_VERTEX);\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',') {\n      cur2 = cur;\n      cur2++;\n      eat_opt_white( &cur2 );\n      if (str_match_nocase_whole( &cur2, \"ARRAY\" )) {\n         int arrayid;\n         if (*cur2 != '(') {\n            report_error( ctx, \"Expected `('\" );\n            return FALSE;\n         }\n         cur2++;\n         eat_opt_white( &cur2 );\n         if (!parse_int( &cur2, &arrayid )) {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         eat_opt_white( &cur2 );\n         if (*cur2 != ')') {\n            report_error( ctx, \"Expected `)'\" );\n            return FALSE;\n         }\n         cur2++;\n         decl.Declaration.Array = 1;\n         decl.Array.ArrayID = arrayid;\n         ctx->cur = cur = cur2;\n      }\n   }\n\n   if (*cur == ',' && !is_vs_input) {\n      uint i, j;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (file == TGSI_FILE_RESOURCE) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.Resource.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n\n         cur2 = cur;\n         eat_opt_white(&cur2);\n         while (*cur2 == ',') {\n            cur2++;\n            eat_opt_white(&cur2);\n            if (str_match_nocase_whole(&cur2, \"RAW\")) {\n               decl.Resource.Raw = 1;\n\n            } else if (str_match_nocase_whole(&cur2, \"WR\")) {\n               decl.Resource.Writable = 1;\n\n            } else {\n               break;\n            }\n            cur = cur2;\n            eat_opt_white(&cur2);\n         }\n\n         ctx->cur = cur;\n\n      } else if (file == TGSI_FILE_SAMPLER_VIEW) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.SamplerView.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n         eat_opt_white( &cur );\n         if (*cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ++cur;\n         eat_opt_white( &cur );\n         for (j = 0; j < 4; ++j) {\n            for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {\n               if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {\n                  switch (j) {\n                  case 0:\n                     decl.SamplerView.ReturnTypeX = i;\n                     break;\n                  case 1:\n                     decl.SamplerView.ReturnTypeY = i;\n                     break;\n                  case 2:\n                     decl.SamplerView.ReturnTypeZ = i;\n                     break;\n                  case 3:\n                     decl.SamplerView.ReturnTypeW = i;\n                     break;\n                  default:\n                     assert(0);\n                  }\n                  break;\n               }\n            }\n            if (i == TGSI_RETURN_TYPE_COUNT) {\n               if (j == 0 || j >  2) {\n                  report_error(ctx, \"Expected type name\");\n                  return FALSE;\n               }\n               break;\n            } else {\n               cur2 = cur;\n               eat_opt_white( &cur2 );\n               if (*cur2 == ',') {\n                  cur2++;\n                  eat_opt_white( &cur2 );\n                  cur = cur2;\n                  continue;\n               } else\n                  break;\n            }\n         }\n         if (j < 4) {\n            decl.SamplerView.ReturnTypeY =\n               decl.SamplerView.ReturnTypeZ =\n               decl.SamplerView.ReturnTypeW =\n               decl.SamplerView.ReturnTypeX;\n         }\n         ctx->cur = cur;\n      } else {\n         if (str_match_nocase_whole(&cur, \"LOCAL\")) {\n            decl.Declaration.Local = 1;\n            ctx->cur = cur;\n         }\n\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n         if (*cur == ',') {\n            cur++;\n            eat_opt_white( &cur );\n\n            for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {\n               if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {\n                  uint index;\n\n                  cur2 = cur;\n                  eat_opt_white( &cur2 );\n                  if (*cur2 == '[') {\n                     cur2++;\n                     eat_opt_white( &cur2 );\n                     if (!parse_uint( &cur2, &index )) {\n                        report_error( ctx, \"Expected literal integer\" );\n                        return FALSE;\n                     }\n                     eat_opt_white( &cur2 );\n                     if (*cur2 != ']') {\n                        report_error( ctx, \"Expected `]'\" );\n                        return FALSE;\n                     }\n                     cur2++;\n\n                     decl.Semantic.Index = index;\n\n                     cur = cur2;\n                  }\n\n                  decl.Declaration.Semantic = 1;\n                  decl.Semantic.Name = i;\n\n                  ctx->cur = cur;\n                  break;\n               }\n            }\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {\n            decl.Declaration.Interpolate = 1;\n            decl.Interp.Interpolate = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n      if (i == TGSI_INTERPOLATE_COUNT) {\n         report_error( ctx, \"Expected semantic or interpolate attribute\" );\n         return FALSE;\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {\n            decl.Interp.Location = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n\n   advance = tgsi_build_full_declaration(\n      &decl,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\nstatic boolean parse_immediate( struct translate_ctx *ctx )\n{\n   struct tgsi_full_immediate imm;\n   uint advance;\n   int type;\n\n   if (*ctx->cur == '[') {\n      uint uindex;\n\n      ++ctx->cur;\n\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n\n      if (uindex != ctx->num_immediates) {\n         report_error( ctx, \"Immediates must be sorted\" );\n         return FALSE;\n      }\n\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ']') {\n         report_error( ctx, \"Expected `]'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {\n      if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))\n         break;\n   }\n   if (type == Elements(tgsi_immediate_type_names)) {\n      report_error( ctx, \"Expected immediate type\" );\n      return FALSE;\n   }\n\n   imm = tgsi_default_full_immediate();\n   imm.Immediate.NrTokens += 4;\n   imm.Immediate.DataType = type;\n   parse_immediate_data(ctx, type, imm.u);\n\n   advance = tgsi_build_full_immediate(\n      &imm,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   ctx->num_immediates++;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_primitive( const char **pcur, uint *primitive )\n{\n   uint i;\n\n   for (i = 0; i < PIPE_PRIM_MAX; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {\n         *primitive = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {\n         *fs_coord_origin = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {\n         *fs_coord_pixel_center = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\n\nstatic boolean parse_property( struct translate_ctx *ctx )\n{\n   struct tgsi_full_property prop;\n   uint property_name;\n   uint values[8];\n   uint advance;\n   char id[64];\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n   if (!parse_identifier( &ctx->cur, id, sizeof(id) )) {\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n         break;\n      }\n   }\n", "func_hash": 72378232091169844659239787043415407980, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6209", "cve_desc": "Stack-based buffer overflow in the parse_identifier function in tgsi_text.c in the TGSI auxiliary module in the Gallium driver in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to parsing properties.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6209"}
{"idx": 158102, "project": "virglrenderer", "commit_id": "114688c526fe45f341d75ccd1d85473c3b08f7a7", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=114688c526fe45f341d75ccd1d85473c3b08f7a7", "commit_message": "renderer: fix heap overflow in vertex elements state create\n\nThe 'num_elements' can be controlled by the guest but the\n'vrend_vertex_element_array' has a fixed 'elements' field.\nThis can cause a heap overflow. Add sanity check of 'num_elements'.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n    if (!v)\n       return ENOMEM;\n \n   if (num_elements > PIPE_MAX_ATTRIBS)\n      return EINVAL;\n\n    v->count = num_elements;\n    for (i = 0; i < num_elements; i++) {\n       memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n", "func_hash": 226301324475184087438442572611658189614, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-5994", "cve_desc": "Heap-based buffer overflow in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and crash) via the num_elements parameter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5994"}
{"idx": 158105, "project": "infradead", "commit_id": "14cae65318d3ef1f7d449e463b72b6934e82f1c2", "project_url": "http://git.infradead.org/?p=mtd-2.6", "commit_url": "http://git.infradead.org/users/dwmw2/openconnect.git/commitdiff/14cae65318d3ef1f7d449e463b72b6934e82f1c2", "commit_message": "None", "target": 0, "func": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n \n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)+1))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\t\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\n\tfree(banner);\n}\t\n", "func_hash": 279834395077552091770358368547534380658, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-3291", "cve_desc": "Heap-based buffer overflow in OpenConnect 3.18 allows remote servers to cause a denial of service via a crafted greeting banner.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3291"}
{"idx": 158113, "project": "virglrenderer", "commit_id": "28894a30a17a84529be102b21118e55d6c9f23fa", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/src/gallium/auxiliary/tgsi/tgsi_text.c?id=28894a30a17a84529be102b21118e55d6c9f23fa", "commit_message": "gallium/tgsi: fix oob access in parse instruction\n\nWhen parsing texture instruction, it doesn't stop if the\n'cur' is ',', the loop variable 'i' will also be increased\nand be used to index the 'inst.TexOffsets' array. This can lead\nan oob access issue. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 0, "func": "parse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ',' && i < TGSI_FULL_MAX_TEX_OFFSETS; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n", "func_hash": 321254582650752893308442793791247099756, "file_name": "tgsi_text.c", "file_hash": 244335851684317795143634576379783630430, "cwe": ["CWE-119"], "cve": "CVE-2017-5580", "cve_desc": "The parse_instruction function in gallium/auxiliary/tgsi/tgsi_text.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and process crash) via a crafted texture instruction.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5580"}
{"idx": 158122, "project": "savannah", "commit_id": "888cd1843e935fe675cf2ac303116d4ed5b9d54b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=888cd1843e935fe675cf2ac303116d4ed5b9d54b", "commit_message": "None", "target": 0, "func": "  Ins_IUP( INS_ARG )\n  {\n    IUP_WorkerRec  V;\n    FT_Byte        mask;\n\n    FT_UInt   first_point;   /* first point of contour        */\n    FT_UInt   end_point;     /* end point (last+1) of contour */\n\n    FT_UInt   first_touched; /* first touched point in contour   */\n    FT_UInt   cur_touched;   /* current touched point in contour */\n\n    FT_UInt   point;         /* current point   */\n    FT_Short  contour;       /* current contour */\n\n    FT_UNUSED_ARG;\n\n\n    /* ignore empty outlines */\n    if ( CUR.pts.n_contours == 0 )\n      return;\n\n    if ( CUR.opcode & 1 )\n    {\n      mask   = FT_CURVE_TAG_TOUCH_X;\n      V.orgs = CUR.pts.org;\n      V.curs = CUR.pts.cur;\n      V.orus = CUR.pts.orus;\n    }\n    else\n    {\n      mask   = FT_CURVE_TAG_TOUCH_Y;\n      V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );\n      V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );\n      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );\n    }\n    V.max_points = CUR.pts.n_points;\n\n    contour = 0;\n    point   = 0;\n\n    do\n    {\n       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;\n       first_point = point;\n \n      if ( BOUNDS ( end_point, CUR.pts.n_points ) )\n        end_point = CUR.pts.n_points - 1;\n \n       while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )\n         point++;\n\n      if ( point <= end_point )\n      {\n        first_touched = point;\n        cur_touched   = point;\n\n        point++;\n\n        while ( point <= end_point )\n        {\n          if ( ( CUR.pts.tags[point] & mask ) != 0 )\n          {\n            if ( point > 0 )\n              _iup_worker_interpolate( &V,\n                                       cur_touched + 1,\n                                       point - 1,\n                                       cur_touched,\n                                       point );\n            cur_touched = point;\n          }\n\n          point++;\n        }\n\n        if ( cur_touched == first_touched )\n          _iup_worker_shift( &V, first_point, end_point, cur_touched );\n        else\n        {\n          _iup_worker_interpolate( &V,\n                                   (FT_UShort)( cur_touched + 1 ),\n                                   end_point,\n                                   cur_touched,\n                                   first_touched );\n\n          if ( first_touched > 0 )\n            _iup_worker_interpolate( &V,\n                                     first_point,\n                                     first_touched - 1,\n                                     cur_touched,\n                                     first_touched );\n        }\n      }\n      contour++;\n    } while ( contour < CUR.pts.n_contours );\n  }\n", "func_hash": 12490107828131494076459414255246754337, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2520", "cve_desc": "Heap-based buffer overflow in the Ins_IUP function in truetype/ttinterp.c in FreeType before 2.4.0, when TrueType bytecode support is enabled, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2520"}
{"idx": 158123, "project": "savannah", "commit_id": "b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "commit_message": "None", "target": 0, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n       FT_TRACE3(( \"POST fragment[%d]: offsets=0x%08x, rlen=0x%08x, flags=0x%04x\\n\",\n                    i, offsets[i], rlen, flags ));\n \n      if ( ( flags >> 8 ) == 0 )        /* Comment, should not be loaded */\n        continue;\n\n       /* the flags are part of the resource, so rlen >= 2.  */\n       /* but some fonts declare rlen = 0 for empty fragment */\n       if ( rlen > 2 )\n\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        if ( pfb_lenpos + 3 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        if ( pfb_pos + 6 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n      }\n\n      error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n      if ( error )\n        goto Exit2;\n      pfb_pos += rlen;\n    }\n\n    if ( pfb_pos + 2 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_pos++] = 0x80;\n    pfb_data[pfb_pos++] = 3;\n\n    if ( pfb_lenpos + 3 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 138045724524241880239158930414068620502, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2519", "cve_desc": "Heap-based buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted length value in a POST fragment header in a font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2519"}
{"idx": 158126, "project": "savannah", "commit_id": "c69891a1345640096fbf396e8dd567fe879ce233", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c69891a1345640096fbf396e8dd567fe879ce233", "commit_message": "None", "target": 0, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n      rlen -= 2;                    /* the flags are part of the resource */\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n       }\n \n       error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n      if ( error )\n        goto Exit2;\n       pfb_pos += rlen;\n     }\n\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 104194448279931618216830643509594183948, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2499", "cve_desc": "Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted LaserWriter PS font file with an embedded PFB fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2499"}
{"idx": 158146, "project": "samba", "commit_id": "9280051bfba337458722fb157f3082f93cbd9f2b", "project_url": "https://github.com/samba-team/samba", "commit_url": "https://git.samba.org/?p=samba.git;a=commit;h=9280051bfba337458722fb157f3082f93cbd9f2b", "commit_message": "s3: Fix an uninitialized variable read\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>\n\nThanks for that,\n\nVolker\n\nFix bug #7254 (An uninitialized variable read could cause an smbd crash).", "target": 0, "func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n        file_save(\"negotiate.dat\", blob1.data, blob1.length);\n #endif\n \n       p2 = (char *)req->buf + blob1.length;\n \n        p2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n                                     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}\n", "func_hash": 264029160300950657613398871836569816502, "file_name": "sesssetup.c", "file_hash": 54377162305834695452010991557158062329, "cwe": ["CWE-119"], "cve": "CVE-2010-1642", "cve_desc": "The reply_sesssetup_and_X_spnego function in sesssetup.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to trigger an out-of-bounds read, and cause a denial of service (process crash), via a \\xff\\xff security blob length in a Session Setup AndX request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1642"}
{"idx": 158149, "project": "enlightment", "commit_id": "37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "commit_message": "None", "target": 0, "func": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = calloc(w, sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   if (!rows)\n     {\n        goto quit2;\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n \n    if (im->loader || immediate_load || progress)\n      {\n        DATA32 colormap[256];\n\n         bg = gif->SBackGroundColor;\n         cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n        memset (colormap, 0, sizeof(colormap));\n        if (cmap != NULL)\n           {\n              for (i = cmap->ColorCount > 256 ? 256 : cmap->ColorCount; i-- > 0;)\n                 {\n                    r = cmap->Colors[i].Red;\n                    g = cmap->Colors[i].Green;\n                    b = cmap->Colors[i].Blue;\n                    colormap[i] = (0xff << 24) | (r << 16) | (g << 8) | b;\n                 }\n              /* if bg > cmap->ColorCount, it is transparent black already */\n              if (transp >= 0 && transp < 256)\n                 colormap[transp] = bg >= 0 && bg < 256 ? colormap[bg] & 0x00ffffff : 0x00000000;\n           }\n         im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n           {\n              for (j = 0; j < w; j++)\n                {\n                  *ptr++ = colormap[rows[i][j]];\n                   per += per_inc;\n                   if (progress && (((int)per) != last_per)\n                       && (((int)per) % progress_granularity == 0))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n", "func_hash": 327794120807518814236575440422420435138, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3994", "cve_desc": "The GIF loader in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (application crash) or obtain sensitive information via a crafted image, which triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3994"}
{"idx": 158150, "project": "enlightment", "commit_id": "ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "commit_message": "None", "target": 0, "func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (xx < tw) && (T(xx, y).used & T_USED); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n", "func_hash": 35689730528572601890660899349736969741, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3993", "cve_desc": "Off-by-one error in the __imlib_MergeUpdate function in lib/updates.c in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via crafted coordinates.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3993"}
{"idx": 158219, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 0, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_gpgsm_t gpgsm = (engine_gpgsm_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (gpgsm->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (gpgsm->status.fnc)\n\t    err = gpgsm->status.fnc (gpgsm->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && gpgsm->colon.fnc && gpgsm->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              gpgsm->colon.any = 0;\n              err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (gpgsm->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &gpgsm->colon.attic.line;\n\t  int *alinelen = &gpgsm->colon.attic.linelen;\n\n\t  if (gpgsm->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 gpgsm->colon.attic.linesize = *alinelen + linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      gpgsm->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (gpgsm->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (gpgsm->status.fnc)\n\t\terr = gpgsm->status.fnc (gpgsm->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (gpgsm, keyword);\n          assuan_write_line (gpgsm->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (gpgsm->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 193381261896924450850721776242232796740, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 158220, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 0, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_uiserver_t uiserver = (engine_uiserver_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (uiserver->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (uiserver->status.fnc)\n\t    err = uiserver->status.fnc (uiserver->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && uiserver->colon.fnc && uiserver->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              uiserver->colon.any = 0;\n              err = uiserver->colon.fnc (uiserver->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (uiserver->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &uiserver->colon.attic.line;\n\t  int *alinelen = &uiserver->colon.attic.linelen;\n\n\t  if (uiserver->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 uiserver->colon.attic.linesize = *alinelen + linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      uiserver->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = uiserver->colon.fnc (uiserver->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (uiserver->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (uiserver->status.fnc)\n\t\terr = uiserver->status.fnc (uiserver->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (uiserver, keyword);\n          assuan_write_line (uiserver->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (uiserver->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 8839794853672060345166196416059519004, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 158231, "project": "openssl", "commit_id": "578b956fe741bf8e84055547b1e83c28dd902c73", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=578b956fe741bf8e84055547b1e83c28dd902c73", "commit_message": "Fix memory issues in BIO_*printf functions\n\nThe internal |fmtstr| function used in processing a \"%s\" format string\nin the BIO_*printf functions could overflow while calculating the length\nof a string and cause an OOB read when printing very long strings.\n\nAdditionally the internal |doapr_outch| function can attempt to write to\nan OOB memory location (at an offset from the NULL pointer) in the event of\na memory allocation failure. In 1.0.2 and below this could be caused where\nthe size of a buffer to be allocated is greater than INT_MAX. E.g. this\ncould be in processing a very long \"%s\" format string. Memory leaks can also\noccur.\n\nThese issues will only occur on certain platforms where sizeof(size_t) >\nsizeof(int). E.g. many 64 bit systems. The first issue may mask the second\nissue dependent on compiler behaviour.\n\nThese problems could enable attacks where large amounts of untrusted data\nis passed to the BIO_*printf functions. If applications use these functions\nin this way then they could be vulnerable. OpenSSL itself uses these\nfunctions when printing out human-readable dumps of ASN.1 data. Therefore\napplications that print this data could be vulnerable if the data is from\nuntrusted sources. OpenSSL command line applications could also be\nvulnerable where they print out ASN.1 data, or if untrusted data is passed\nas command line arguments.\n\nLibssl is not considered directly vulnerable. Additionally certificates etc\nreceived via remote connections via libssl are also unlikely to be able to\ntrigger these issues because of message size limits enforced within libssl.\n\nCVE-2016-0799\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 0, "func": " _dopr(char **sbuffer,\n       char **buffer,\n       size_t *maxlen,\n      size_t *retlen, int *truncated, const char *format, va_list args)\n{\n    char ch;\n    LLONG value;\n    LDOUBLE fvalue;\n    char *strvalue;\n    int min;\n    int max;\n    int state;\n    int flags;\n    int cflags;\n    size_t currlen;\n\n    state = DP_S_DEFAULT;\n    flags = currlen = cflags = min = 0;\n    max = -1;\n    ch = *format++;\n\n    while (state != DP_S_DONE) {\n        if (ch == '\\0' || (buffer == NULL && currlen >= *maxlen))\n            state = DP_S_DONE;\n\n        switch (state) {\n        case DP_S_DEFAULT:\n             if (ch == '%')\n                 state = DP_S_FLAGS;\n             else\n                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen, ch))\n                    return 0;\n             ch = *format++;\n             break;\n         case DP_S_FLAGS:\n            case '-':\n                flags |= DP_F_MINUS;\n                ch = *format++;\n                break;\n            case '+':\n                flags |= DP_F_PLUS;\n                ch = *format++;\n                break;\n            case ' ':\n                flags |= DP_F_SPACE;\n                ch = *format++;\n                break;\n            case '#':\n                flags |= DP_F_NUM;\n                ch = *format++;\n                break;\n            case '0':\n                flags |= DP_F_ZERO;\n                ch = *format++;\n                break;\n            default:\n                state = DP_S_MIN;\n                break;\n            }\n            break;\n        case DP_S_MIN:\n            if (isdigit((unsigned char)ch)) {\n                min = 10 * min + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                min = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_DOT;\n            } else\n                state = DP_S_DOT;\n            break;\n        case DP_S_DOT:\n            if (ch == '.') {\n                state = DP_S_MAX;\n                ch = *format++;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MAX:\n            if (isdigit((unsigned char)ch)) {\n                if (max < 0)\n                    max = 0;\n                max = 10 * max + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                max = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_MOD;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MOD:\n            switch (ch) {\n            case 'h':\n                cflags = DP_C_SHORT;\n                ch = *format++;\n                break;\n            case 'l':\n                if (*format == 'l') {\n                    cflags = DP_C_LLONG;\n                    format++;\n                } else\n                    cflags = DP_C_LONG;\n                ch = *format++;\n                break;\n            case 'q':\n                cflags = DP_C_LLONG;\n                ch = *format++;\n                break;\n            case 'L':\n                cflags = DP_C_LDOUBLE;\n                ch = *format++;\n                break;\n            default:\n                break;\n            }\n            state = DP_S_CONV;\n            break;\n        case DP_S_CONV:\n            switch (ch) {\n            case 'd':\n            case 'i':\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (short int)va_arg(args, int);\n                    break;\n                case DP_C_LONG:\n                    value = va_arg(args, long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, LLONG);\n                    break;\n                default:\n                    value = va_arg(args, int);\n                     value = va_arg(args, int);\n                     break;\n                 }\n                if (!fmtint(sbuffer, buffer, &currlen, maxlen, value, 10, min,\n                            max, flags))\n                    return 0;\n                 break;\n             case 'X':\n                 flags |= DP_F_UP;\n            case 'o':\n            case 'u':\n                flags |= DP_F_UNSIGNED;\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (unsigned short int)va_arg(args, unsigned int);\n                    break;\n                case DP_C_LONG:\n                    value = (LLONG) va_arg(args, unsigned long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, unsigned LLONG);\n                    break;\n                default:\n                    value = (LLONG) va_arg(args, unsigned int);\n                    break;\n                     value = (LLONG) va_arg(args, unsigned int);\n                     break;\n                 }\n                if (!fmtint(sbuffer, buffer, &currlen, maxlen, value,\n                            ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\n                            min, max, flags))\n                    return 0;\n                 break;\n             case 'f':\n                 if (cflags == DP_C_LDOUBLE)\n                     fvalue = va_arg(args, LDOUBLE);\n                 else\n                     fvalue = va_arg(args, double);\n                if (!fmtfp(sbuffer, buffer, &currlen, maxlen, fvalue, min, max,\n                           flags))\n                    return 0;\n                 break;\n             case 'E':\n                 flags |= DP_F_UP;\n                    fvalue = va_arg(args, double);\n                break;\n            case 'G':\n                flags |= DP_F_UP;\n            case 'g':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                break;\n            case 'c':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                     fvalue = va_arg(args, double);\n                 break;\n             case 'c':\n                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                            va_arg(args, int)))\n                    return 0;\n                 break;\n             case 's':\n                 strvalue = va_arg(args, char *);\n                }\n                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                       flags, min, max);\n                     else\n                         max = *maxlen;\n                 }\n                if (!fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                            flags, min, max))\n                    return 0;\n                 break;\n             case 'p':\n                 value = (long)va_arg(args, void *);\n                if (!fmtint(sbuffer, buffer, &currlen, maxlen,\n                            value, 16, min, max, flags | DP_F_NUM))\n                    return 0;\n                 break;\n             case 'n':          /* XXX */\n                 if (cflags == DP_C_SHORT) {\n                } else if (cflags == DP_C_LLONG) { /* XXX */\n                    LLONG *num;\n                    num = va_arg(args, LLONG *);\n                    *num = (LLONG) currlen;\n                } else {\n                    int *num;\n                    num = va_arg(args, int *);\n                    *num = currlen;\n                }\n                break;\n            case '%':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\n                break;\n            case 'w':\n                /* not supported yet, treat as next char */\n                 }\n", "func_hash": 195613941504483693700403529577879018231, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2842", "cve_desc": "The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2842"}
{"idx": 158232, "project": "savannah", "commit_id": "a3bc7e9400b214a0f078fdb19596ba54214a1442", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/quagga.git/commit/?id=a3bc7e9400b214a0f078fdb19596ba54214a1442", "commit_message": "None", "target": 0, "func": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n#define VPN_PREFIXLEN_MIN_BYTES (3 + 8) /* label + RD */\n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = afi2family (packet->afi);\n       psize = PSIZE (prefixlen);\n      \n      /* sanity check against packet data */\n      if (prefixlen < VPN_PREFIXLEN_MIN_BYTES*8 || (pnt + psize) > lim)\n        {\n          zlog_err (\"prefix length (%d) is less than 88\"\n                    \" or larger than received (%u)\",\n                    prefixlen, (uint)(lim-pnt));\n          return -1;\n        }\n      \n      /* sanity check against storage for the IP address portion */\n      if ((psize - VPN_PREFIXLEN_MIN_BYTES) > (ssize_t) sizeof(p.u))\n        {\n          zlog_err (\"prefix length (%d) exceeds prefix storage (%zu)\",\n                    prefixlen - VPN_PREFIXLEN_MIN_BYTES*8, sizeof(p.u));\n          return -1;\n        }\n      \n      /* Sanity check against max bitlen of the address family */\n      if ((psize - VPN_PREFIXLEN_MIN_BYTES) > prefix_blen (&p))\n        {\n          zlog_err (\"prefix length (%d) exceeds family (%u) max byte length (%u)\",\n                    prefixlen - VPN_PREFIXLEN_MIN_BYTES*8, \n                    p.family, prefix_blen (&p));\n          return -1;\n                  \n        }\n      \n       /* Copyr label to prefix. */\n      tagpnt = pnt;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - VPN_PREFIXLEN_MIN_BYTES*8;\n      memcpy (&p.u.prefix, pnt + VPN_PREFIXLEN_MIN_BYTES, \n              psize - VPN_PREFIXLEN_MIN_BYTES);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}\n", "func_hash": 117907470428073272654099801965911501253, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2342", "cve_desc": "The bgp_nlri_parse_vpnv4 function in bgp_mplsvpn.c in the VPNv4 NLRI parser in bgpd in Quagga before 1.0.20160309, when a certain VPNv4 configuration is used, relies on a Labeled-VPN SAFI routes-data length field during a data copy, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2342"}
{"idx": 158246, "project": "openssl", "commit_id": "2919516136a4227d9e6d8f2fe66ef976aaf8c561", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=2919516136a4227d9e6d8f2fe66ef976aaf8c561", "commit_message": "Prevent EBCDIC overread for very long strings\n\nASN1 Strings that are over 1024 bytes can cause an overread in\napplications using the X509_NAME_oneline() function on EBCDIC systems.\nThis could result in arbitrary stack data being returned in the buffer.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2176\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 0, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            if (num > (int)sizeof(ebcdic_buf))\n                num = sizeof(ebcdic_buf);\n            ascii2ebcdic(ebcdic_buf, q, num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n", "func_hash": 102161235674682768354989675007761833395, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2176", "cve_desc": "The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2176"}
{"idx": 158260, "project": "ghostscript", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=60dabde18d7fe12b19da8b509bdfee9cc886aafc", "commit_message": "None", "target": 0, "func": " xps_parse_color(xps_document *doc, char *base_uri, char *string,\n                fz_colorspace **csp, float *samples)\n {\n       fz_context *ctx = doc->ctx;\n        char *p;\n        int i, n;\n        char buf[1024];\n        char *profile;\n \n       *csp = fz_device_rgb(ctx);\n \n        samples[0] = 1;\n        samples[1] = 0;\n\tsamples[3] = 0;\n\n\tif (string[0] == '#')\n\t{\n\t\tif (strlen(string) == 9)\n\t\t{\n\t\t\tsamples[0] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[1] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[2] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t\tsamples[3] = unhex(string[7]) * 16 + unhex(string[8]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsamples[0] = 255;\n\t\t\tsamples[1] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[2] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[3] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t}\n\n\t\tsamples[0] /= 255;\n\t\tsamples[1] /= 255;\n\t\tsamples[2] /= 255;\n\t\tsamples[3] /= 255;\n\t}\n\n\telse if (string[0] == 's' && string[1] == 'c' && string[2] == '#')\n\t{\n\t\tif (count_commas(string) == 2)\n\t\t\tsscanf(string, \"sc#%g,%g,%g\", samples + 1, samples + 2, samples + 3);\n\t\tif (count_commas(string) == 3)\n\t\t\tsscanf(string, \"sc#%g,%g,%g,%g\", samples, samples + 1, samples + 2, samples + 3);\n\t}\n\n\telse if (strstr(string, \"ContextColor \") == string)\n\t{\n\t\t/* Crack the string for profile name and sample values */\n\t\tfz_strlcpy(buf, string, sizeof buf);\n\n\t\tprofile = strchr(buf, ' ');\n                profile = strchr(buf, ' ');\n                if (!profile)\n                {\n                       fz_warn(ctx, \"cannot find icc profile uri in '%s'\", string);\n                        return;\n                }\n \n\t\tp = strchr(profile, ' ');\n                p = strchr(profile, ' ');\n                if (!p)\n                {\n                       fz_warn(ctx, \"cannot find component values in '%s'\", profile);\n                        return;\n                }\n \n                *p++ = 0;\n                n = count_commas(p) + 1;\n               if (n > FZ_MAX_COLORS)\n               {\n                       fz_warn(ctx, \"ignoring %d color components (max %d allowed)\", n - FZ_MAX_COLORS, FZ_MAX_COLORS);\n                       n = FZ_MAX_COLORS;\n               }\n                i = 0;\n                while (i < n)\n                {\n\t\t\t\tp ++;\n\t\t}\n\t\twhile (i < n)\n\t\t{\n\t\t\tsamples[i++] = 0;\n\t\t}\n\n\t\t/* TODO: load ICC profile */\n\t\tswitch (n)\n\t\t{\n\t\tcase 2: *csp = fz_device_gray(doc->ctx); break;\n\t\tcase 4: *csp = fz_device_rgb(doc->ctx); break;\n\t\tcase 5: *csp = fz_device_cmyk(doc->ctx); break;\n                /* TODO: load ICC profile */\n                switch (n)\n                {\n               case 2: *csp = fz_device_gray(ctx); break;\n               case 4: *csp = fz_device_rgb(ctx); break;\n               case 5: *csp = fz_device_cmyk(ctx); break;\n               default: *csp = fz_device_gray(ctx); break;\n                }\n        }\n }\n\tfor (i = 0; i < colorspace->n; i++)\n\t\tdoc->color[i] = samples[i + 1];\n\tdoc->alpha = samples[0] * doc->opacity[doc->opacity_top];\n}\n", "func_hash": 104133691355236952097313818918215819307, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-2013", "cve_desc": "Stack-based buffer overflow in the xps_parse_color function in xps/xps-common.c in MuPDF 1.3 and earlier allows remote attackers to execute arbitrary code via a large number of entries in the ContextColor value of the Fill attribute in a Path element.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2013"}
{"idx": 158271, "project": "libav", "commit_id": "5a396bb3a66a61a68b80f2369d0249729bf85e04", "project_url": "https://github.com/libav/libav", "commit_url": "https://git.libav.org/?p=libav.git;a=commitdiff;h=5a396bb3a66a61a68b80f2369d0249729bf85e04", "commit_message": "dv: Fix null pointer dereference due to ach=0\n\ndv: Fix null pointer dereference due to ach=0\n\nFixes part2 of CVE-2011-3929\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nReviewed-by: Roman Shaposhnik <roman@shaposhnik.org>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Alex Converse <alex.converse@gmail.com>", "target": 0, "func": "int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = avpriv_dv_frame_profile(c->sys, buf, buf_size)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   /* Broken frame, or not enough data */\n    }\n\n    /* Queueing audio packet */\n    /* FIXME: in case of no audio/bad audio we have to do something */\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n        ppcm[i] = c->audio_buf[i];\n     }\n    if (c->ach)\n        dv_extract_audio(buf, ppcm, c->sys);\n \n     /* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. */\n        if (buf[1] & 0x0C) {\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        } else {\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n            c->abytes += size;\n        }\n    } else {\n        c->abytes += size;\n    }\n", "func_hash": 230194429546358495875504885626884790759, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3929", "cve_desc": "The avpriv_dv_produce_packet function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) and possibly execute arbitrary code via a crafted DV file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3929"}
{"idx": 158272, "project": "harfbuzz", "commit_id": "81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "project_url": "https://github.com/behdad/harfbuzz", "commit_url": "https://cgit.freedesktop.org/harfbuzz.old/commit/?id=81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "commit_message": "None", "target": 0, "func": "static HB_Error  Lookup_MarkMarkPos( GPOS_Instance*    gpi,\n\t\t\t\t     HB_GPOS_SubTable* st,\n\t\t\t\t     HB_Buffer        buffer,\n\t\t\t\t     HB_UShort         flags,\n\t\t\t\t     HB_UShort         context_length,\n\t\t\t\t     int               nesting_level )\n{\n  HB_UShort        i, j, mark1_index, mark2_index, property, class;\n  HB_Fixed           x_mark1_value, y_mark1_value,\n\t\t   x_mark2_value, y_mark2_value;\n  HB_Error         error;\n  HB_GPOSHeader*  gpos = gpi->gpos;\n  HB_MarkMarkPos* mmp = &st->markmark;\n\n  HB_MarkArray*    ma1;\n  HB_Mark2Array*   ma2;\n  HB_Mark2Record*  m2r;\n  HB_Anchor*       mark1_anchor;\n  HB_Anchor*       mark2_anchor;\n\n  HB_Position    o;\n\n  HB_UNUSED(nesting_level);\n\n  if ( context_length != 0xFFFF && context_length < 1 )\n    return HB_Err_Not_Covered;\n\n  if ( flags & HB_LOOKUP_FLAG_IGNORE_MARKS )\n    return HB_Err_Not_Covered;\n\n  if ( CHECK_Property( gpos->gdef, IN_CURITEM(),\n\t\t       flags, &property ) )\n    return error;\n\n  error = _HB_OPEN_Coverage_Index( &mmp->Mark1Coverage, IN_CURGLYPH(),\n\t\t\t  &mark1_index );\n  if ( error )\n    return error;\n\n  /* now we search backwards for a suitable mark glyph until a non-mark\n     glyph                                                */\n\n  if ( buffer->in_pos == 0 )\n    return HB_Err_Not_Covered;\n\n  i = 1;\n  j = buffer->in_pos - 1;\n  while ( i <= buffer->in_pos )\n  {\n    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),\n\t\t\t\t\t&property );\n    if ( error )\n      return error;\n\n    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )\n      return HB_Err_Not_Covered;\n\n    if ( flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )\n    {\n      if ( property == (flags & 0xFF00) )\n        break;\n    }\n    else\n      break;\n\n    i++;\n     j--;\n   }\n \n  if ( i > buffer->in_pos )\n    return HB_Err_Not_Covered;\n\n   error = _HB_OPEN_Coverage_Index( &mmp->Mark2Coverage, IN_GLYPH( j ),\n \t\t\t  &mark2_index );\n   if ( error )\n\n  if ( mark1_index >= ma1->MarkCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  class        = ma1->MarkRecord[mark1_index].Class;\n  mark1_anchor = &ma1->MarkRecord[mark1_index].MarkAnchor;\n\n  if ( class >= mmp->ClassCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  ma2 = &mmp->Mark2Array;\n\n  if ( mark2_index >= ma2->Mark2Count )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  m2r          = &ma2->Mark2Record[mark2_index];\n  mark2_anchor = &m2r->Mark2Anchor[class];\n\n  error = Get_Anchor( gpi, mark1_anchor, IN_CURGLYPH(),\n\t\t      &x_mark1_value, &y_mark1_value );\n  if ( error )\n    return error;\n  error = Get_Anchor( gpi, mark2_anchor, IN_GLYPH( j ),\n\t\t      &x_mark2_value, &y_mark2_value );\n  if ( error )\n    return error;\n\n  /* anchor points are not cumulative */\n\n  o = POSITION( buffer->in_pos );\n\n  o->x_pos     = x_mark2_value - x_mark1_value;\n  o->y_pos     = y_mark2_value - y_mark1_value;\n  o->x_advance = 0;\n  o->y_advance = 0;\n  o->back      = 1;\n\n  (buffer->in_pos)++;\n\n  return HB_Err_Ok;\n}\n", "func_hash": 178106868639481976497145253828664788353, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3193", "cve_desc": "Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3193"}
{"idx": 158295, "project": "openssl", "commit_id": "1632ef744872edc2aa2a53d487d3e79c965a4ad3", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=1632ef744872edc2aa2a53d487d3e79c965a4ad3", "commit_message": "Fix for CVE-2014-0195\n\nA buffer overrun attack can be triggered by sending invalid DTLS fragments\nto an OpenSSL DTLS client or server. This is potentially exploitable to\nrun arbitrary code on a vulnerable client or server.\n\nFixed by adding consistency check for DTLS fragments.\n\nThanks to Jri Aedla for reporting this issue.", "target": 0, "func": "dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Determine maximum allowed message size. Depends on (user set)\n\t * maximum certificate length, but 16k is minimum.\n\t */\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n                frag->msg_header.frag_off = 0;\n                }\n        else\n               {\n                frag = (hm_fragment*) item->data;\n               if (frag->msg_header.msg_len != msg_hdr->msg_len)\n                       {\n                       item = NULL;\n                       frag = NULL;\n                       goto err;\n                       }\n               }\n\n \n        /* If message is already reassembled, this must be a\n         * retransmit and can be dropped.\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n", "func_hash": 74745124692429710262121995963451957444, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-0195", "cve_desc": "The dtls1_reassemble_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly validate fragment lengths in DTLS ClientHello messages, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) via a long non-initial fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0195"}
{"idx": 158311, "project": "libxfont", "commit_id": "4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "commit_message": "None", "target": 0, "func": "bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState,\n\t\t  int bit, int byte, int glyph, int scan)\n{\n    unsigned char *line;\n    register CharInfoPtr ci;\n    int         i,\n                ndx,\n                nchars,\n                nignored;\n    unsigned int char_row, char_col;\n    int         numEncodedGlyphs = 0;\n    CharInfoPtr *bdfEncoding[256];\n    BitmapFontPtr  bitmapFont;\n    BitmapExtraPtr bitmapExtra;\n    CARD32     *bitmapsSizes;\n    unsigned char        lineBuf[BDFLINELEN];\n    int         nencoding;\n\n    bitmapFont = (BitmapFontPtr) pFont->fontPrivate;\n    bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;\n\n    if (bitmapExtra) {\n\tbitmapsSizes = bitmapExtra->bitmapsSizes;\n\tfor (i = 0; i < GLYPHPADOPTIONS; i++)\n\t    bitmapsSizes[i] = 0;\n    } else\n\tbitmapsSizes = NULL;\n\n    bzero(bdfEncoding, sizeof(bdfEncoding));\n    bitmapFont->metrics = NULL;\n    ndx = 0;\n\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\n    if ((!line) || (sscanf((char *) line, \"CHARS %d\", &nchars) != 1)) {\n\tbdfError(\"bad 'CHARS' in bdf file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars < 1) {\n\tbdfError(\"invalid number of CHARS in BDF file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars > INT32_MAX / sizeof(CharInfoRec)) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    ci = calloc(nchars, sizeof(CharInfoRec));\n    if (!ci) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    bitmapFont->metrics = ci;\n\n    if (bitmapExtra) {\n\tbitmapExtra->glyphNames = malloc(nchars * sizeof(Atom));\n\tif (!bitmapExtra->glyphNames) {\n\t    bdfError(\"Couldn't allocate glyphNames (%d*%d)\\n\",\n\t\t     nchars, (int) sizeof(Atom));\n\t    goto BAILOUT;\n\t}\n    }\n    if (bitmapExtra) {\n\tbitmapExtra->sWidths = malloc(nchars * sizeof(int));\n\tif (!bitmapExtra->sWidths) {\n\t    bdfError(\"Couldn't allocate sWidth (%d *%d)\\n\",\n\t\t     nchars, (int) sizeof(int));\n\t    return FALSE;\n\t}\n    }\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n    pFont->info.firstRow = 256;\n    pFont->info.lastRow = 0;\n    pFont->info.firstCol = 256;\n    pFont->info.lastCol = 0;\n    nignored = 0;\n    for (ndx = 0; (ndx < nchars) && (line) && (bdfIsPrefix(line, \"STARTCHAR\"));) {\n\tint         t;\n\tint         wx;\t\t/* x component of width */\n\tint         wy;\t\t/* y component of width */\n\tint         bw;\t\t/* bounding-box width */\n\tint         bh;\t\t/* bounding-box height */\n\tint         bl;\t\t/* bounding-box left */\n\tint         bb;\t\t/* bounding-box bottom */\n\tint         enc,\n\t            enc2;\t/* encoding */\n\tunsigned char *p;\t/* temp pointer into line */\n \tchar        charName[100];\n \tint         ignore;\n \n\tif (sscanf((char *) line, \"STARTCHAR %99s\", charName) != 1) {\n \t    bdfError(\"bad character name in BDF file\\n\");\n \t    goto BAILOUT;\t/* bottom of function, free and return error */\n \t}\n\tif (bitmapExtra)\n\t    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif (!line || (t = sscanf((char *) line, \"ENCODING %d %d\", &enc, &enc2)) < 1) {\n\t    bdfError(\"bad 'ENCODING' in BDF file\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (enc < -1 || (t == 2 && enc2 < -1)) {\n\t    bdfError(\"bad ENCODING value\");\n\t    goto BAILOUT;\n\t}\n\tif (t == 2 && enc == -1)\n\t    enc = enc2;\n\tignore = 0;\n\tif (enc == -1) {\n\t    if (!bitmapExtra) {\n\t\tnignored++;\n\t\tignore = 1;\n\t    }\n\t} else if (enc > MAXENCODING) {\n\t    bdfError(\"char '%s' has encoding too large (%d)\\n\",\n\t\t     charName, enc);\n\t} else {\n\t    char_row = (enc >> 8) & 0xFF;\n\t    char_col = enc & 0xFF;\n\t    if (char_row < pFont->info.firstRow)\n\t\tpFont->info.firstRow = char_row;\n\t    if (char_row > pFont->info.lastRow)\n\t\tpFont->info.lastRow = char_row;\n\t    if (char_col < pFont->info.firstCol)\n\t\tpFont->info.firstCol = char_col;\n\t    if (char_col > pFont->info.lastCol)\n\t\tpFont->info.lastCol = char_col;\n\t    if (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t\tbdfEncoding[char_row] = malloc(256 * sizeof(CharInfoPtr));\n\t\tif (!bdfEncoding[char_row]) {\n\t\t    bdfError(\"Couldn't allocate row %d of encoding (%d*%d)\\n\",\n\t\t\t     char_row, INDICES, (int) sizeof(CharInfoPtr));\n\t\t    goto BAILOUT;\n\t\t}\n\t\tfor (i = 0; i < 256; i++)\n\t\t    bdfEncoding[char_row][i] = (CharInfoPtr) NULL;\n\t    }\n\t    if (bdfEncoding[char_row] != NULL) {\n\t\tbdfEncoding[char_row][char_col] = ci;\n\t\tnumEncodedGlyphs++;\n\t    }\n\t}\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"SWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'SWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"SWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (bitmapExtra)\n\t    bitmapExtra->sWidths[ndx] = wx;\n\n/* 5/31/89 (ef) -- we should be able to ditch the character and recover */\n/*\t\tfrom all of these.\t\t\t\t\t*/\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"DWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'DWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"DWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"BBX %d %d %d %d\", &bw, &bh, &bl, &bb) != 4)) {\n\t    bdfError(\"bad 'BBX'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif ((bh < 0) || (bw < 0)) {\n\t    bdfError(\"character '%s' has a negative sized bitmap, %dx%d\\n\",\n\t\t     charName, bw, bh);\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((line) && (bdfIsPrefix(line, \"ATTRIBUTES\"))) {\n\t    for (p = line + strlen(\"ATTRIBUTES \");\n\t\t    (*p == ' ') || (*p == '\\t');\n\t\t    p++)\n\t\t /* empty for loop */ ;\n\t    ci->metrics.attributes = (bdfHexByte(p) << 8) + bdfHexByte(p + 2);\n\t    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\t} else\n\t    ci->metrics.attributes = 0;\n\n\tif (!line || !bdfIsPrefix(line, \"BITMAP\")) {\n\t    bdfError(\"missing 'BITMAP'\\n\");\n\t    goto BAILOUT;\n\t}\n\t/* collect data for generated properties */\n\tif ((strlen(charName) == 1)) {\n\t    if ((charName[0] >= '0') && (charName[0] <= '9')) {\n\t\tpState->digitWidths += wx;\n\t\tpState->digitCount++;\n\t    } else if (charName[0] == 'x') {\n\t\tpState->exHeight = (bh + bb) <= 0 ? bh : bh + bb;\n\t    }\n\t}\n\tif (!ignore) {\n\t    ci->metrics.leftSideBearing = bl;\n\t    ci->metrics.rightSideBearing = bl + bw;\n\t    ci->metrics.ascent = bh + bb;\n\t    ci->metrics.descent = -bb;\n\t    ci->metrics.characterWidth = wx;\n\t    ci->bits = NULL;\n\t    bdfReadBitmap(ci, file, bit, byte, glyph, scan, bitmapsSizes);\n\t    ci++;\n\t    ndx++;\n\t} else\n\t    bdfSkipBitmap(file, bh);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\t/* get STARTCHAR or\n\t\t\t\t\t\t\t * ENDFONT */\n    }\n\n    if (ndx + nignored != nchars) {\n\tbdfError(\"%d too few characters\\n\", nchars - (ndx + nignored));\n\tgoto BAILOUT;\n    }\n    nchars = ndx;\n    bitmapFont->num_chars = nchars;\n    if ((line) && (bdfIsPrefix(line, \"STARTCHAR\"))) {\n\tbdfError(\"more characters than specified\\n\");\n\tgoto BAILOUT;\n    }\n    if ((!line) || (!bdfIsPrefix(line, \"ENDFONT\"))) {\n\tbdfError(\"missing 'ENDFONT'\\n\");\n\tgoto BAILOUT;\n    }\n    if (numEncodedGlyphs == 0)\n\tbdfWarning(\"No characters with valid encodings\\n\");\n\n    nencoding = (pFont->info.lastRow - pFont->info.firstRow + 1) *\n\t(pFont->info.lastCol - pFont->info.firstCol + 1);\n    bitmapFont->encoding = calloc(NUM_SEGMENTS(nencoding),sizeof(CharInfoPtr*));\n    if (!bitmapFont->encoding) {\n\tbdfError(\"Couldn't allocate ppCI (%d,%d)\\n\",\n                 NUM_SEGMENTS(nencoding),\n                 (int) sizeof(CharInfoPtr*));\n\tgoto BAILOUT;\n    }\n    pFont->info.allExist = TRUE;\n    i = 0;\n    for (char_row = pFont->info.firstRow;\n\t    char_row <= pFont->info.lastRow;\n\t    char_row++) {\n\tif (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t    pFont->info.allExist = FALSE;\n            i += pFont->info.lastCol - pFont->info.firstCol + 1;\n\t} else {\n\t    for (char_col = pFont->info.firstCol;\n\t\t    char_col <= pFont->info.lastCol;\n\t\t    char_col++) {\n\t\tif (!bdfEncoding[char_row][char_col])\n\t\t    pFont->info.allExist = FALSE;\n                else {\n                    if (!bitmapFont->encoding[SEGMENT_MAJOR(i)]) {\n                        bitmapFont->encoding[SEGMENT_MAJOR(i)]=\n                            calloc(BITMAP_FONT_SEGMENT_SIZE,\n                                   sizeof(CharInfoPtr));\n                        if (!bitmapFont->encoding[SEGMENT_MAJOR(i)])\n                            goto BAILOUT;\n                    }\n                    ACCESSENCODINGL(bitmapFont->encoding,i) =\n                        bdfEncoding[char_row][char_col];\n                }\n                i++;\n            }\n\t}\n    }\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    return (TRUE);\nBAILOUT:\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    /* bdfFreeFontBits will clean up the rest */\n    return (FALSE);\n}\n", "func_hash": 233543311274131421373611476427752557785, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-6462", "cve_desc": "Stack-based buffer overflow in the bdfReadCharacters function in bitmap/bdfread.c in X.Org libXfont 1.1 through 1.4.6 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a long string in a character name in a BDF font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6462"}
{"idx": 158324, "project": "libbsd", "commit_id": "c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "project_url": "https://gitlab.freedesktop.org/libbsd/libbsd", "commit_url": "https://cgit.freedesktop.org/libbsd/commit/?id=c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "commit_message": "Fix heap buffer overflow in fgetwln()\n\nIn the function fgetwln() there's a 4 byte heap overflow.\n\nThere is a while loop that has this check to see whether there's still\nenough space in the buffer:\n\n\t\tif (!fb->len || wused > fb->len) {\n\nIf this is true more memory gets allocated. However this test won't be\ntrue if wused == fb->len, but at that point wused already points out\nof the buffer. Some lines later there's a write to the buffer:\n\n\t\tfb->wbuf[wused++] = wc;\n\nThis bug was found with the help of address sanitizer.\n\nWarned-by: ASAN\nFixes: https://bugs.freedesktop.org/show_bug.cgi?id=93881\nSigned-off-by: Guillem Jover <guillem@hadrons.org>", "target": 0, "func": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused >= fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n", "func_hash": 270452454086101436166140658237240500443, "file_name": "fgetwln.c", "file_hash": 74899023810301719481895724574229840429, "cwe": ["CWE-119"], "cve": "CVE-2016-2090", "cve_desc": "Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2090"}
{"idx": 158371, "project": "libxfont", "commit_id": "5bf703700ee4a5d6eae20da07cb7a29369667aef", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=5bf703700ee4a5d6eae20da07cb7a29369667aef", "commit_message": "None", "target": 0, "func": "CatalogueRescan (FontPathElementPtr fpe)\n{\n    CataloguePtr\tcat = fpe->private;\n    char\t\tlink[MAXFONTFILENAMELEN];\n    char\t\tdest[MAXFONTFILENAMELEN];\n    char\t\t*attrib;\n    FontPathElementPtr\tsubfpe;\n    struct stat\t\tstatbuf;\n    const char\t\t*path;\n    DIR\t\t\t*dir;\n    struct dirent\t*entry;\n    int\t\t\tlen;\n    int\t\t\tpathlen;\n\n    path = fpe->name + strlen(CataloguePrefix);\n    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))\n\treturn BadFontPath;\n\n    if (statbuf.st_mtime <= cat->mtime)\n\treturn Successful;\n\n    dir = opendir(path);\n    if (dir == NULL)\n    {\n\txfree(cat);\n\treturn BadFontPath;\n    }\n\n    CatalogueUnrefFPEs (fpe);\n     while (entry = readdir(dir), entry != NULL)\n     {\n \tsnprintf(link, sizeof link, \"%s/%s\", path, entry->d_name);\n\tlen = readlink(link, dest, sizeof dest - 1);\n \tif (len < 0)\n \t    continue;\n\tdest[len] = '\\0';\n\n\tif (dest[0] != '/')\n\t{\n\t   pathlen = strlen(path);\n\t   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);\n\t   memcpy(dest, path, pathlen);\n\t   memcpy(dest + pathlen, \"/\", 1);\n\t   len += pathlen + 1;\n\t}\n\n\tattrib = strchr(link, ':');\n\tif (attrib && len + strlen(attrib) < sizeof dest)\n\t{\n\t    memcpy(dest + len, attrib, strlen(attrib));\n\t    len += strlen(attrib);\n\t}\n\n\tsubfpe = xalloc(sizeof *subfpe);\n\tif (subfpe == NULL)\n\t    continue;\n\n\t/* The fonts returned by OpenFont will point back to the\n\t * subfpe they come from.  So set the type of the subfpe to\n\t * what the catalogue fpe was assigned, so calls to CloseFont\n\t * (which uses font->fpe->type) goes to CatalogueCloseFont. */\n\tsubfpe->type = fpe->type;\n\tsubfpe->name_length = len;\n\tsubfpe->name = xalloc (len + 1);\n\tif (subfpe == NULL)\n\t{\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tmemcpy(subfpe->name, dest, len);\n\tsubfpe->name[len] = '\\0';\n\n\t/* The X server will manipulate the subfpe ref counts\n\t * associated with the font in OpenFont and CloseFont, so we\n\t * have to make sure it's valid. */\n\tsubfpe->refcount = 1;\n\n\tif (FontFileInitFPE (subfpe) != Successful)\n\t{\n\t    xfree(subfpe->name);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tif (CatalogueAddFPE(cat, subfpe) != Successful)\n\t{\n\t    FontFileFreeFPE (subfpe);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n    }\n\n    closedir(dir);\n\n    qsort(cat->fpeList,\n\t  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);\n\n    cat->mtime = statbuf.st_mtime;\n\n    return Successful;\n}\n", "func_hash": 228542085319408063625872411309938296359, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2007-5199", "cve_desc": "A single byte overflow in catalogue.c in X.Org libXfont 1.3.1 allows remote attackers to have unspecified impact.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2007-5199"}
{"idx": 158394, "project": "savannah", "commit_id": "a0d7fe4589651c64bd16ddaaa634030bb0455866", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/patch.git/commit/src/pch.c?id=a0d7fe4589651c64bd16ddaaa634030bb0455866", "commit_message": "None", "target": 0, "func": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = (p_len[line] > 0) && (p_line[line][p_len[line] - 1] == '\\n');\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}\n", "func_hash": 217144092183050078310306191340626200681, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-10713", "cve_desc": "An issue was discovered in GNU patch before 2.7.6. Out-of-bounds access within pch_write_line() in pch.c can possibly lead to DoS via a crafted input file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10713"}
{"idx": 158399, "project": "ghostscript", "commit_id": "e698d5c11d27212aa1098bc5b1673a3378563092", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=jbig2dec.git;a=commit;h=e698d5c11d27212aa1098bc5b1673a3378563092", "commit_message": "None", "target": 0, "func": "jbig2_decode_gray_scale_image(Jbig2Ctx *ctx, Jbig2Segment *segment,\n                              const byte *data, const size_t size,\n                              bool GSMMR, uint32_t GSW, uint32_t GSH,\n                              uint32_t GSBPP, bool GSUSESKIP, Jbig2Image *GSKIP, int GSTEMPLATE, Jbig2ArithCx *GB_stats)\n {\n     uint8_t **GSVALS = NULL;\n     size_t consumed_bytes = 0;\n    uint32_t i, j, stride, x, y;\n    int code;\n     Jbig2Image **GSPLANES;\n     Jbig2GenericRegionParams rparams;\n     Jbig2WordStream *ws = NULL;\n    Jbig2ArithState *as = NULL;\n\n    /* allocate GSPLANES */\n    GSPLANES = jbig2_new(ctx, Jbig2Image *, GSBPP);\n    if (GSPLANES == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %d bytes for GSPLANES\", GSBPP);\n        return NULL;\n    }\n\n    for (i = 0; i < GSBPP; ++i) {\n        GSPLANES[i] = jbig2_image_new(ctx, GSW, GSH);\n         if (GSPLANES[i] == NULL) {\n             jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %dx%d image for GSPLANES\", GSW, GSH);\n             /* free already allocated */\n            for (j = i; j > 0;)\n                jbig2_image_release(ctx, GSPLANES[--j]);\n             jbig2_free(ctx->allocator, GSPLANES);\n             return NULL;\n         }\n        }\n    }\n", "func_hash": 264680539555902462578789547952215319677, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-9601", "cve_desc": "ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9601"}
{"idx": 158429, "project": "nbd", "commit_id": "3ef52043861ab16352d49af89e048ba6339d6df8", "project_url": "https://github.com/yoe/nbd", "commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8", "commit_message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.", "target": 0, "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE - sizeof(struct nbd_reply))\n \t\t\terr(\"Request too big!\");\n #ifdef DODBG\n \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n", "func_hash": 208511006621789243604207821580929935528, "file_name": "nbd-server.c", "file_hash": 215605186871532710415959471360452243779, "cwe": ["CWE-119"], "cve": "CVE-2011-0530", "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-0530"}
{"idx": 158479, "project": "linux", "commit_id": "79549c6dfda0603dba9a70a53467ce62d9335c33", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33", "commit_message": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \n\tp->replacement_session_keyring = NULL;\n\n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n", "func_hash": 193438030228150908602383473129084673303, "file_name": "cred.c", "file_hash": 192217264892189979249448018287327016675, "cwe": ["CWE-119"], "cve": "CVE-2012-2745", "cve_desc": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2745"}
{"idx": 158515, "project": "suhosin", "commit_id": "73b1968ee30f6d9d2dae497544b910e68e114bfa", "project_url": "https://github.com/stefanesser/suhosin", "commit_url": "https://github.com/stefanesser/suhosin/commit/73b1968ee30f6d9d2dae497544b910e68e114bfa", "commit_message": "Fixed stack based buffer overflow in transparent cookie encryption (see separate advisory)", "target": 0, "func": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar *buf, *buf2, *d, *d_url;\n\tint l;\n\n\tbuf = estrndup(name, name_len);\n\t\n \t\n \tname_len = php_url_decode(buf, name_len);\n\tnormalize_varname(buf);\n\tname_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tefree(buf);\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n \t\n\tbuf2 = estrndup(value, value_len);\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n\tefree(buf);\n\tefree(buf2);\n \treturn d_url;\n }\n", "func_hash": 131347476304509844742823814818049939285, "file_name": "header.c", "file_hash": 86130229650536993826447685238882031430, "cwe": ["CWE-119"], "cve": "CVE-2012-0807", "cve_desc": "Stack-based buffer overflow in the suhosin_encrypt_single_cookie function in the transparent cookie-encryption feature in the Suhosin extension before 0.9.33 for PHP, when suhosin.cookie.encrypt and suhosin.multiheader are enabled, might allow remote attackers to execute arbitrary code via a long string that is used in a Set-Cookie HTTP header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0807"}
{"idx": 158586, "project": "linux", "commit_id": "15291164b22a357cb211b618adfef4fa82fc0de3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/15291164b22a357cb211b618adfef4fa82fc0de3", "commit_message": "jbd2: clear BH_Delay & BH_Unwritten in journal_unmap_buffer\n\njournal_unmap_buffer()'s zap_buffer: code clears a lot of buffer head\nstate ala discard_buffer(), but does not touch _Delay or _Unwritten as\ndiscard_buffer() does.\n\nThis can be problematic in some areas of the ext4 code which assume\nthat if they have found a buffer marked unwritten or delay, then it's\na live one.  Perhaps those spots should check whether it is mapped\nas well, but if jbd2 is going to tear down a buffer, let's really\ntear it down completely.\n\nWithout this I get some fsx failures on sub-page-block filesystems\nup until v3.2, at which point 4e96b2dbbf1d7e81f22047a50f862555a6cb87cb\nand 189e868fa8fdca702eb9db9d8afc46b5cb9144c9 make the failures go\naway, because buried within that large change is some more flag\nclearing.  I still think it's worth doing in jbd2, since\n->invalidatepage leads here directly, and it's the right place\nto clear away these flags.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 0, "func": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\tint ret;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * buffer can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. So we just set j_next_transaction to the\n\t\t * running transaction (if there is one) and mark\n\t\t * buffer as freed so that commit code knows it should\n\t\t * clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\twrite_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n \tclear_buffer_mapped(bh);\n \tclear_buffer_req(bh);\n \tclear_buffer_new(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n \tbh->b_bdev = NULL;\n \treturn may_free;\n }\n", "func_hash": 239508390190332514870287981493186722846, "file_name": "transaction.c", "file_hash": 312279320265495413761314436998558776188, "cwe": ["CWE-119"], "cve": "CVE-2011-4086", "cve_desc": "The journal_unmap_buffer function in fs/jbd2/transaction.c in the Linux kernel before 3.3.1 does not properly handle the _Delay and _Unwritten buffer head states, which allows local users to cause a denial of service (system crash) by leveraging the presence of an ext4 filesystem that was mounted with a journal.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4086"}
{"idx": 158588, "project": "linux", "commit_id": "c85ce65ecac078ab1a1835c87c4a6319cf74660a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a", "commit_message": "b43: allocate receive buffers big enough for max frame len + offset\n\nOtherwise, skb_put inside of dma_rx can fail...\n\n\thttps://bugzilla.kernel.org/show_bug.cgi?id=32042\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nAcked-by: Larry Finger <Larry.Finger@lwfinger.net>\nCc: stable@kernel.org", "target": 0, "func": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n \t\tdmaaddr = meta->dmaaddr;\n \t\tgoto drop_recycle_buffer;\n \t}\n\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n \t\t/* The data did not fit into one descriptor buffer\n \t\t * and is split over multiple buffers.\n \t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}\n", "func_hash": 57346809163291589501075433785130252914, "file_name": "dma.c", "file_hash": 261830879301148322247416076881739498561, "cwe": ["CWE-119"], "cve": "CVE-2011-3359", "cve_desc": "The dma_rx function in drivers/net/wireless/b43/dma.c in the Linux kernel before 2.6.39 does not properly allocate receive buffers, which allows remote attackers to cause a denial of service (system crash) via a crafted frame.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3359"}
{"idx": 158589, "project": "linux", "commit_id": "c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "commit_message": "fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message\n\nFUSE_NOTIFY_INVAL_ENTRY didn't check the length of the write so the\nmessage processing could overrun and result in a \"kernel BUG at\nfs/fuse/dev.c:629!\"\n\nReported-by: Han-Wen Nienhuys <hanwenn@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org", "target": 0, "func": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}\n", "func_hash": 278035628439275691104113509523122686714, "file_name": "dev.c", "file_hash": 218502694604823484599405881283163566522, "cwe": ["CWE-119"], "cve": "CVE-2011-3353", "cve_desc": "Buffer overflow in the fuse_notify_inval_entry function in fs/fuse/dev.c in the Linux kernel before 3.1 allows local users to cause a denial of service (BUG_ON and system crash) by leveraging the ability to mount a FUSE filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3353"}
{"idx": 158695, "project": "linux", "commit_id": "cae13fe4cc3f24820ffb990c09110626837e85d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4", "commit_message": "Fix for buffer overflow in ldm_frag_add not sufficient\n\nAs Ben Hutchings discovered [1], the patch for CVE-2011-1017 (buffer\noverflow in ldm_frag_add) is not sufficient.  The original patch in\ncommit c340b1d64000 (\"fs/partitions/ldm.c: fix oops caused by corrupted\npartition table\") does not consider that, for subsequent fragments,\npreviously allocated memory is used.\n\n[1] http://lkml.org/lkml/2011/5/6/407\n\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n", "func_hash": 312950127537623365577828777607943036574, "file_name": "ldm.c", "file_hash": 193102196756441336769179572683907987665, "cwe": ["CWE-119"], "cve": "CVE-2011-2182", "cve_desc": "The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2182"}
{"idx": 158721, "project": "linux", "commit_id": "7572777eef78ebdee1ecb7c258c0ef94d35bad16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16", "commit_message": "fuse: verify ioctl retries\n\nVerify that the total length of the iovec returned in FUSE_IOCTL_RETRY\ndoesn't overflow iov_length().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: Tejun Heo <tj@kernel.org>\nCC: <stable@kernel.org>         [2.6.31+]", "target": 0, "func": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n \t\tin_iov = page_address(iov_page);\n \t\tout_iov = in_iov + in_iovs;\n \n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n \t\tgoto retry;\n \t}\n \n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\n", "func_hash": 73869176651699469631819965635667453404, "file_name": "file.c", "file_hash": 316485230383673723348757172334976611504, "cwe": ["CWE-119"], "cve": "CVE-2010-4650", "cve_desc": "Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-4650"}
{"idx": 158723, "project": "linux", "commit_id": "f5563318ff1bde15b10e736e97ffce13be08bc1a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f5563318ff1bde15b10e736e97ffce13be08bc1a", "commit_message": "wireless: radiotap: fix parsing buffer overrun\n\nWhen parsing an invalid radiotap header, the parser can overrun\nthe buffer that is passed in because it doesn't correctly check\n 1) the minimum radiotap header size\n 2) the space for extended bitmaps\n\nThe first issue doesn't affect any in-kernel user as they all\ncheck the minimum size before calling the radiotap function.\nThe second issue could potentially affect the kernel if an skb\nis passed in that consists only of the radiotap header with a\nlot of extended bitmaps that extend past the SKB. In that case\na read-only buffer overrun by at most 4 bytes is possible.\n\nFix this by adding the appropriate checks to the parser.\n\nCc: stable@vger.kernel.org\nReported-by: Evan Huus <eapache@gmail.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "target": 0, "func": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n\t/* check the radiotap header can actually be present */\n\tif (max_length < sizeof(struct ieee80211_radiotap_header))\n\t\treturn -EINVAL;\n\n \t/* Linux only supports version 0 radiotap format */\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n \t\t\t */\n \n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader +\n\t\t\t    sizeof(uint32_t) >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}\n", "func_hash": 293055781004458751821814114070443238337, "file_name": "radiotap.c", "file_hash": 23121824623036651781491045808747671484, "cwe": ["CWE-119"], "cve": "CVE-2013-7027", "cve_desc": "The ieee80211_radiotap_iterator_init function in net/wireless/radiotap.c in the Linux kernel before 3.11.7 does not check whether a frame contains any data outside of the header, which might allow attackers to cause a denial of service (buffer over-read) via a crafted header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7027"}
{"idx": 158727, "project": "FFmpeg", "commit_id": "f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "commit_message": "avcodec/parser: reset indexes on realloc failure\n\nFixes Ticket2982\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n\n    /* Copy overread bytes from last frame into buffer. */\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n\n    /* flush remaining if EOF */\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n\n    pc->last_index= pc->index;\n\n    /* copy into buffer end return */\n     if(next == END_NOT_FOUND){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n \n        if(!new_buffer) {\n            pc->index = 0;\n             return AVERROR(ENOMEM);\n        }\n         pc->buffer = new_buffer;\n         memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n         pc->index += *buf_size;\n        return -1;\n    }\n\n    *buf_size=\n    pc->overread_index= pc->index + next;\n\n     /* append to buffer */\n     if(pc->index){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer) {\n            pc->overread_index =\n            pc->index = 0;\n             return AVERROR(ENOMEM);\n        }\n         pc->buffer = new_buffer;\n         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n             memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n\n    /* store overread bytes */\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n\n    return 0;\n}\n", "func_hash": 140651272046924709040495532214522141021, "file_name": "parser.c", "file_hash": 105227933394977883394091717119289145022, "cwe": ["CWE-119"], "cve": "CVE-2013-7023", "cve_desc": "The ff_combine_frame function in libavcodec/parser.c in FFmpeg before 2.1 does not properly handle certain memory-allocation errors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7023"}
{"idx": 158728, "project": "FFmpeg", "commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e07ac727c1cc9eed39e7f9117c97006f719864bd", "commit_message": "avcodec/g2meet: Fix framebuf size\n\nCurrently the code can in some cases draw tiles that hang outside the\nallocated buffer. This patch increases the buffer size to avoid out\nof array accesses. An alternative would be to fail if such tiles are\nencountered.\nI do not know if any valid files use such hanging tiles.\n\nFixes Ticket2971\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n \n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n", "func_hash": 49709330371647019348189373603886921255, "file_name": "g2meet.c", "file_hash": 165207066110261879036082118616062180464, "cwe": ["CWE-119"], "cve": "CVE-2013-7022", "cve_desc": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7022"}
{"idx": 158730, "project": "FFmpeg", "commit_id": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "commit_message": "ffv1dec: Check bits_per_raw_sample and colorspace for equality in ver 0/1 headers\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n     memset(state, 128, sizeof(state));\n \n     if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;\n         unsigned v= get_symbol(c, state, 0);\n         if (v >= 2) {\n             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n         }\n \n        colorspace     = get_symbol(c, state, 0); //YUV cs type\n        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;\n         chroma_planes  = get_rac(c, state);\n         chroma_h_shift = get_symbol(c, state, 0);\n         chroma_v_shift = get_symbol(c, state, 0);\n         transparency   = get_rac(c, state);\n \n         if (f->plane_count) {\n            if (   colorspace    != f->colorspace\n                || bits_per_raw_sample != f->avctx->bits_per_raw_sample\n                || chroma_planes != f->chroma_planes\n                 || chroma_h_shift!= f->chroma_h_shift\n                 || chroma_v_shift!= f->chroma_v_shift\n                 || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         }\n \n        f->colorspace     = colorspace;\n        f->avctx->bits_per_raw_sample = bits_per_raw_sample;\n         f->chroma_planes  = chroma_planes;\n         f->chroma_h_shift = chroma_h_shift;\n         f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}\n", "func_hash": 89588011034658391000654551724666371677, "file_name": "ffv1dec.c", "file_hash": 319230643551834163571899636845765840546, "cwe": ["CWE-119"], "cve": "CVE-2013-7020", "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7020"}
{"idx": 158734, "project": "FFmpeg", "commit_id": "780669ef7c23c00836a24921fcc6b03be2b8ca4a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/780669ef7c23c00836a24921fcc6b03be2b8ca4a", "commit_message": "avcodec/jpeg2000dec: non zero image offsets are not supported\n\nFixes out of array accesses\nFixes Ticket3080\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n     s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n     ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n \n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n     if (ncomponents <= 0) {\n         av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n                s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\n", "func_hash": 111165660664067912894378699928933381241, "file_name": "jpeg2000dec.c", "file_hash": 223101191426622229699083725655095766483, "cwe": ["CWE-119"], "cve": "CVE-2013-7012", "cve_desc": "The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not prevent attempts to use non-zero image offsets, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7012"}
{"idx": 158737, "project": "FFmpeg", "commit_id": "3819db745da2ac7fb3faacb116788c32f4753f34", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34", "commit_message": "avcodec/rpza: Perform pointer advance and checks before using the pointers\n\nFixes out of array accesses\nFixes Ticket2850\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 0, "func": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n    int pixel_ptr = -4;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n                ADVANCE_BLOCK()\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n             }\n             break;\n \n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n                ADVANCE_BLOCK();\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n            ADVANCE_BLOCK();\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                 }\n                 block_ptr += row_inc;\n             }\n             break;\n \n         /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n", "func_hash": 199142065752138389978163694222242641122, "file_name": "rpza.c", "file_hash": 145110260770130120514406915106775778424, "cwe": ["CWE-119"], "cve": "CVE-2013-7009", "cve_desc": "The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7009"}
{"idx": 158740, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 0, "func": "static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n \tif (mi < 0)\n \t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n \n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n \n\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }\n", "func_hash": 37065271855217370564920531672117301493, "file_name": "uio.c", "file_hash": 36047993049944990560762116378541603219, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 158741, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 0, "func": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n", "func_hash": 1623279895322387910027742317760626363, "file_name": "au1100fb.c", "file_hash": 77902258379140114528270461117122032874, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 158742, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 0, "func": " static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n \tstruct au1200fb_device *fbdev = info->par;\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n \n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n", "func_hash": 258558073391048829050024809501490522922, "file_name": "au1200fb.c", "file_hash": 40760652179933862360466729479889043833, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 158745, "project": "linux", "commit_id": "6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "commit_message": "qeth: avoid buffer overflow in snmp ioctl\n\nCheck user-defined length in snmp ioctl request and allow request\nonly if it fits into a qeth command buffer.\n\nSigned-off-by: Ursula Braun <ursula.braun@de.ibm.com>\nSigned-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>\nReviewed-by: Heiko Carstens <heicars2@linux.vnet.ibm.com>\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nCc: <stable@vger.kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n \tstruct qeth_cmd_buffer *iob;\n \tstruct qeth_ipa_cmd *cmd;\n \tstruct qeth_snmp_ureq *ureq;\n\tunsigned int req_len;\n \tstruct qeth_arp_query_info qinfo = {0, };\n \tint rc = 0;\n \n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n \t/* skip 4 bytes (data_len struct member) to get req_len */\n \tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n \t\treturn -EFAULT;\n\tif (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -\n\t\t       sizeof(struct qeth_ipacmd_hdr) -\n\t\t       sizeof(struct qeth_ipacmd_setadpparms_hdr)))\n\t\treturn -EINVAL;\n \tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n \tif (IS_ERR(ureq)) {\n \t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\n", "func_hash": 169202937829379525760239607583743710857, "file_name": "qeth_core_main.c", "file_hash": 172045772512734913850419912571012990938, "cwe": ["CWE-119"], "cve": "CVE-2013-6381", "cve_desc": "Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6381"}
{"idx": 158756, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 0, "func": "do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n \tif (len != set_arglen[SET_CMDID(cmd)]) {\n \t\tpr_err(\"set_ctl: len %u != %u\\n\",\n \t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n", "func_hash": 157614413276462146024331359000881642717, "file_name": "ip_vs_ctl.c", "file_hash": 105962925241335804425777375471367443832, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 184379, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 0, "func": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n {\n \tunsigned char arg[128];\n \tint ret = 0;\n\tunsigned int copylen;\n \n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n \tif (*len < get_arglen[GET_CMDID(cmd)]) {\n \t\tpr_err(\"get_ctl: len %u < %u\\n\",\n \t\t       *len, get_arglen[GET_CMDID(cmd)]);\n \t\treturn -EINVAL;\n \t}\n \n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n \t\treturn -EFAULT;\n \n \tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n", "func_hash": 17115367795766588006088732396184263937, "file_name": "ip_vs_ctl.c", "file_hash": 105962925241335804425777375471367443832, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 31176, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "int wvlan_set_netname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_netname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\tmemcpy(lp->NetworkName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_netname */\n", "func_hash": 162205244003191236476247108474641534195, "file_name": "wl_priv.c", "file_hash": 60757582669243507829230314014987153993, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 158762, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n", "func_hash": 43124070682619750693845041266416359812, "file_name": "wl_priv.c", "file_hash": 60757582669243507829230314014987153993, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 158763, "project": "linux", "commit_id": "c2c65cd2e14ada6de44cb527e7f1990bede24e15", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2c65cd2e14ada6de44cb527e7f1990bede24e15", "commit_message": "staging: ozwpan: prevent overflow in oz_cdev_write()\n\nWe need to check \"count\" so we don't overflow the ei->data buffer.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 0, "func": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}\n", "func_hash": 268989265383617722739012115893286768042, "file_name": "ozcdev.c", "file_hash": 237028343997351835750824134302673251173, "cwe": ["CWE-119"], "cve": "CVE-2013-4513", "cve_desc": "Buffer overflow in the oz_cdev_write function in drivers/staging/ozwpan/ozcdev.c in the Linux kernel before 3.12 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4513"}
{"idx": 158803, "project": "libtiff", "commit_id": "ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "commit_message": "fix possible OOB write in gif2tiff.c", "target": 0, "func": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n     }\n \n     if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}\n", "func_hash": 326773067396447758615241658626241255256, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-4244", "cve_desc": "The LZW decompressor in the gif2tiff tool in libtiff 4.0.3 and earlier allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) or possibly execute arbitrary code via a crafted GIF image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4244"}
{"idx": 158823, "project": "linux", "commit_id": "cea4dcfdad926a27a18e188720efe0f2c9403456", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456", "commit_message": "iscsi-target: fix heap buffer overflow on error\n\nIf a key was larger than 64 bytes, as checked by iscsi_check_key(), the\nerror response packet, generated by iscsi_add_notunderstood_response(),\nwould still attempt to copy the entire key into the packet, overflowing\nthe structure on the heap.\n\nRemote preauthentication kernel memory corruption was possible if a\ntarget was configured and listening on the network.\n\nCVE-2013-2850\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>", "target": 0, "func": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n \n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n \n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n", "func_hash": 336700731731125479647078589036761925390, "file_name": "iscsi_target_parameters.c", "file_hash": 260263344392188792862342421589644819959, "cwe": ["CWE-119"], "cve": "CVE-2013-2850", "cve_desc": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2850"}
{"idx": 158839, "project": "curl", "commit_id": "192c4f788d48f82c03e9cef40013f34370e90737", "project_url": "https://github.com/curl/curl", "commit_url": "https://github.com/bagder/curl/commit/192c4f788d48f82c03e9cef40013f34370e90737", "commit_message": "Curl_urldecode: no peeking beyond end of input buffer\n\nSecurity problem: CVE-2013-2174\n\nIf a program would give a string like \"%FF\" to curl_easy_unescape() but\nask for it to decode only the first byte, it would still parse and\ndecode the full hex sequence. The function then not only read beyond the\nallowed buffer but it would also deduct the *unsigned* counter variable\nfor how many more bytes there's left to read in the buffer by two,\nmaking the counter wrap. Continuing this, the function would go on\nreading beyond the buffer and soon writing beyond the allocated target\nbuffer...\n\nBug: http://curl.haxx.se/docs/adv_20130622.html\nReported-by: Timo Sirainen", "target": 0, "func": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}\n", "func_hash": 261717292064389369875559982566734886220, "file_name": "escape.c", "file_hash": 33651401652734190625226617558219220221, "cwe": ["CWE-119"], "cve": "CVE-2013-2174", "cve_desc": "Heap-based buffer overflow in the curl_easy_unescape function in lib/escape.c in cURL and libcurl 7.7 through 7.30.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string ending in a \"%\" (percent) character.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2174"}
{"idx": 158841, "project": "linux", "commit_id": "baff42ab1494528907bf4d5870359e31711746ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae", "commit_message": "net: Fix oops from tcp_collapse() when using splice()\n\ntcp_read_sock() can have a eat skbs without immediately advancing copied_seq.\nThis can cause a panic in tcp_collapse() if it is called as a result\nof the recv_actor dropping the socket lock.\n\nA userspace program that splices data from a socket to either another\nsocket or to a file can trigger this bug.\n\nSigned-off-by: Steven J. Magnani <steve@digidescorp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\n\t\t\tlen = skb->len - offset;\n\t\t\t/* Stop reading if we hit a patch of urgent data */\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If recv_actor drops the lock (e.g. TCP splice\n\t\t\t * receive) the skb pointer might be invalid when\n\t\t\t * getting here: tcp_collapse might have deleted it\n\t\t\t * while aggregating skbs from the socket queue.\n\t\t\t */\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n \t\tsk_eat_skb(sk, skb, 0);\n \t\tif (!desc->count)\n \t\t\tbreak;\n\t\ttp->copied_seq = seq;\n \t}\n \ttp->copied_seq = seq;\n \n\ttcp_rcv_space_adjust(sk);\n\n\t/* Clean up data we have read: This will do ACK frames. */\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}\n", "func_hash": 67110211699949058892652822621683468458, "file_name": "tcp.c", "file_hash": 163710130416565722142518083502942354011, "cwe": ["CWE-119"], "cve": "CVE-2013-2128", "cve_desc": "The tcp_read_sock function in net/ipv4/tcp.c in the Linux kernel before 2.6.34 does not properly manage skb consumption, which allows local users to cause a denial of service (system crash) via a crafted splice system call for a TCP socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2128"}
{"idx": 158843, "project": "linux", "commit_id": "929473ea05db455ad88cdc081f2adc556b8dc48f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/929473ea05db455ad88cdc081f2adc556b8dc48f", "commit_message": "usb: chipidea: Allow disabling streaming not only in udc mode\n\nWhen running a scp transfer using a USB/Ethernet adapter the following crash\nhappens:\n\n$ scp test.tar.gz fabio@192.168.1.100:/home/fabio\nfabio@192.168.1.100's password:\ntest.tar.gz                                      0%    0     0.0KB/s   --:-- ETA\n------------[ cut here ]------------\nWARNING: at net/sched/sch_generic.c:255 dev_watchdog+0x2cc/0x2f0()\nNETDEV WATCHDOG: eth0 (asix): transmit queue 0 timed out\nModules linked in:\nBacktrace:\n[<80011c94>] (dump_backtrace+0x0/0x10c) from [<804d3a5c>] (dump_stack+0x18/0x1c)\n r6:000000ff r5:80412388 r4:80685dc0 r3:80696cc0\n[<804d3a44>] (dump_stack+0x0/0x1c) from [<80021868>]\n(warn_slowpath_common+0x54/0x6c)\n[<80021814>] (warn_slowpath_common+0x0/0x6c) from [<80021924>]\n(warn_slowpath_fmt+0x38/0x40)\n...\n\nSetting SDIS (Stream Disable Mode- bit 4 of USBMODE register) fixes the problem.\n\nHowever, in current code CI13XXX_DISABLE_STREAMING flag is only set in udc mode,\nso allow disabling streaming also in host mode.\n\nTested on a mx6qsabrelite board.\n\nSuggested-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nReviewed-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\n \treturn ret;\n }\n", "func_hash": 202703564392681680115241017045440672641, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-2058", "cve_desc": "The host_start function in drivers/usb/chipidea/host.c in the Linux kernel before 3.7.4 does not properly support a certain non-streaming option, which allows local users to cause a denial of service (system crash) by sending a large amount of network traffic through a USB/Ethernet adapter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2058"}
{"idx": 158853, "project": "linux", "commit_id": "715230a44310a8cf66fbfb5a46f9a62a9b2de424", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424", "commit_message": "tg3: fix length overflow in VPD firmware parsing\n\nCommit 184b89044fb6e2a74611dafa69b1dce0d98612c6 (\"tg3: Use VPD fw version\nwhen present\") introduced VPD parsing that contained a potential length\noverflow.\n\nLimit the hardware's reported firmware string length (max 255 bytes) to\nstay inside the driver's firmware string length (32 bytes). On overflow,\ntruncate the formatted firmware string instead of potentially overwriting\nportions of the tg3 struct.\n\nhttp://cansecwest.com/slides/2013/PrivateCore%20CSW%202013.pdf\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Oded Horovitz <oded@privatecore.com>\nReported-by: Brad Spengler <spender@grsecurity.net>\nCc: stable@vger.kernel.org\nCc: Matt Carlson <mcarlson@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n \t\tif (j + len > block_end)\n \t\t\tgoto partno;\n \n\t\tif (len >= sizeof(tp->fw_ver))\n\t\t\tlen = sizeof(tp->fw_ver) - 1;\n\t\tmemset(tp->fw_ver, 0, sizeof(tp->fw_ver));\n\t\tsnprintf(tp->fw_ver, sizeof(tp->fw_ver), \"%.*s bc \", len,\n\t\t\t &vpd_data[j]);\n \t}\n \n partno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}\n", "func_hash": 339368621396240326813420275982009030986, "file_name": "tg3.c", "file_hash": 309569115333965795058510695340189645906, "cwe": ["CWE-119"], "cve": "CVE-2013-1929", "cve_desc": "Heap-based buffer overflow in the tg3_read_vpd function in drivers/net/ethernet/broadcom/tg3.c in the Linux kernel before 3.8.6 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via crafted firmware that specifies a long string in the Vital Product Data (VPD) data structure.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1929"}
{"idx": 158855, "project": "linux", "commit_id": "c0f5ecee4e741667b2493c742b60b6218d40b3aa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa", "commit_message": "USB: cdc-wdm: fix buffer overflow\n\nThe buffer for responses must not overflow.\nIf this would happen, set a flag, drop the data and return\nan error after user space has read all remaining data.\n\nSigned-off-by: Oliver Neukum <oliver@neukum.org>\nCC: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n\tint length = urb->actual_length;\n \n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\n skip_error:\n \twake_up(&desc->wait);\n \n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}\n", "func_hash": 232042914284621138013385320055714481189, "file_name": "cdc-wdm.c", "file_hash": 201237370339956394241335238293445181970, "cwe": ["CWE-119"], "cve": "CVE-2013-1860", "cve_desc": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1860"}
{"idx": 158870, "project": "linux", "commit_id": "ce0030c00f95cf9110d9cdcd41e901e1fb814417", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ce0030c00f95cf9110d9cdcd41e901e1fb814417", "commit_message": "None", "target": 0, "func": "static void call_console_drivers(unsigned start, unsigned end)\n{\n\tunsigned cur_index, start_print;\n\tstatic int msg_level = -1;\n\n\tBUG_ON(((int)(start - end)) > 0);\n\n\tcur_index = start;\n \tstart_print = start;\n \twhile (cur_index != end) {\n \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {\n\t\t\t/*\n\t\t\t * prepare buf_prefix, as a contiguous array,\n\t\t\t * to be processed by log_prefix function\n\t\t\t */\n\t\t\tchar buf_prefix[SYSLOG_PRI_MAX_LENGTH+1];\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) {\n\t\t\t\tbuf_prefix[i] = LOG_BUF(cur_index + i);\n\t\t\t}\n\t\t\tbuf_prefix[i] = '\\0'; /* force '\\0' as last string character */\n\n \t\t\t/* strip log prefix */\n\t\t\tcur_index += log_prefix((const char *)&buf_prefix, &msg_level, NULL);\n \t\t\tstart_print = cur_index;\n \t\t}\n \t\twhile (cur_index != end) {\n\t\t\tchar c = LOG_BUF(cur_index);\n\n\t\t\tcur_index++;\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (msg_level < 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * printk() has already given us loglevel tags in\n\t\t\t\t\t * the buffer.  This code is here in case the\n\t\t\t\t\t * log buffer has wrapped right round and scribbled\n\t\t\t\t\t * on those tags\n\t\t\t\t\t */\n\t\t\t\t\tmsg_level = default_message_loglevel;\n\t\t\t\t}\n\t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);\n\t\t\t\tmsg_level = -1;\n\t\t\t\tstart_print = cur_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_call_console_drivers(start_print, end, msg_level);\n}\n", "func_hash": 278336960793883449565927929632836812543, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-1772", "cve_desc": "The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1772"}
{"idx": 158871, "project": "tinc", "commit_id": "17a33dfd95b1a29e90db76414eb9622df9632320", "project_url": "https://github.com/gsliepen/tinc", "commit_url": "https://github.com/gsliepen/tinc/commit/17a33dfd95b1a29e90db76414eb9622df9632320", "commit_message": "Drop packets forwarded via TCP if they are too big (CVE-2013-1428).\n\nNormally all requests sent via the meta connections are checked so that they\ncannot be larger than the input buffer. However, when packets are forwarded via\nmeta connections, they are copied into a packet buffer without checking whether\nit fits into it. Since the packet buffer is allocated on the stack, this in\neffect allows an authenticated remote node to cause a stack overflow.\n\nThis issue was found by Martin Schobert.", "target": 0, "func": " void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \n\tif(len > sizeof outpkt.data)\n\t\treturn;\n\n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\n\treceive_packet(c->node, &outpkt);\n}\n", "func_hash": 237645872547157033698671999413216079111, "file_name": "net_packet.c", "file_hash": 84979222404728462495428936892737194515, "cwe": ["CWE-119"], "cve": "CVE-2013-1428", "cve_desc": "Stack-based buffer overflow in the receive_tcppacket function in net_packet.c in tinc before 1.0.21 and 1.1 before 1.1pre7 allows remote authenticated peers to cause a denial of service (crash) or possibly execute arbitrary code via a large TCP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1428"}
{"idx": 158873, "project": "krb5", "commit_id": "8ee70ec63931d1e38567905387ab9b1d45734d81", "project_url": "https://github.com/krb5/krb5", "commit_url": "https://github.com/krb5/krb5/commit/8ee70ec63931d1e38567905387ab9b1d45734d81", "commit_message": "KDC TGS-REQ null deref [CVE-2013-1416]\n\nBy sending an unusual but valid TGS-REQ, an authenticated remote\nattacker can cause the KDC process to crash by dereferencing a null\npointer.\n\nprep_reprocess_req() can cause a null pointer dereference when\nprocessing a service principal name.  Code in this function can\ninappropriately pass a null pointer to strlcpy().  Unmodified client\nsoftware can trivially trigger this vulnerability, but the attacker\nmust have already authenticated and received a valid Kerberos ticket.\n\nThe vulnerable code was introduced by the implementation of new\nservice principal realm referral functionality in krb5-1.7, but was\ncorrected as a side effect of the KDC refactoring in krb5-1.11.\n\nCVSSv2 vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:H/RL:O/RC:C\n\nticket: 7600 (new)\nversion_fixed: 1.10.5\nstatus: resolved", "target": 0, "func": "prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n             retval = ENOMEM;\n             goto cleanup;\n         }\n        if (comp1->data != NULL)\n            memcpy(comp1_str, comp1->data, comp1->length);\n \n         if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n              krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                 retval = ENOMEM;\n                 goto cleanup;\n             }\n            if (comp2->data != NULL)\n                memcpy(temp_buf, comp2->data, comp2->length);\n             retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n             free(temp_buf);\n             if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}\n", "func_hash": 167732044059211621819547423315877020969, "file_name": "do_tgs_req.c", "file_hash": 69088724082177518861401437051756458447, "cwe": ["CWE-119"], "cve": "CVE-2013-1416", "cve_desc": "The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1416"}
{"idx": 158880, "project": "linux", "commit_id": "89d7ae34cdda4195809a5a987f697a517a2a3177", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/89d7ae34cdda4195809a5a987f697a517a2a3177", "commit_message": "cipso: don't follow a NULL pointer when setsockopt() is called\n\nAs reported by Alan Cox, and verified by Lin Ming, when a user\nattempts to add a CIPSO option to a socket using the CIPSO_V4_TAG_LOCAL\ntag the kernel dies a terrible death when it attempts to follow a NULL\npointer (the skb argument to cipso_v4_validate() is NULL when called via\nthe setsockopt() syscall).\n\nThis patch fixes this by first checking to ensure that the skb is\nnon-NULL before using it to find the incoming network interface.  In\nthe unlikely case where the skb is NULL and the user attempts to add\na CIPSO option with the _TAG_LOCAL tag we return an error as this is\nnot something we want to allow.\n\nA simple reproducer, kindly supplied by Lin Ming, although you must\nhave the CIPSO DOI #3 configure on the system first or you will be\ncaught early in cipso_v4_validate():\n\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <linux/ip.h>\n\t#include <linux/in.h>\n\t#include <string.h>\n\n\tstruct local_tag {\n\t\tchar type;\n\t\tchar length;\n\t\tchar info[4];\n\t};\n\n\tstruct cipso {\n\t\tchar type;\n\t\tchar length;\n\t\tchar doi[4];\n\t\tstruct local_tag local;\n\t};\n\n\tint main(int argc, char **argv)\n\t{\n\t\tint sockfd;\n\t\tstruct cipso cipso = {\n\t\t\t.type = IPOPT_CIPSO,\n\t\t\t.length = sizeof(struct cipso),\n\t\t\t.local = {\n\t\t\t\t.type = 128,\n\t\t\t\t.length = sizeof(struct local_tag),\n\t\t\t},\n\t\t};\n\n\t\tmemset(cipso.doi, 0, 4);\n\t\tcipso.doi[3] = 3;\n\n\t\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t#define SOL_IP 0\n\t\tsetsockopt(sockfd, SOL_IP, IP_OPTIONS,\n\t\t\t&cipso, sizeof(struct cipso));\n\n\t\treturn 0;\n\t}\n\nCC: Lin Ming <mlin@ss.pku.edu.cn>\nReported-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: Paul Moore <pmoore@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase CIPSO_V4_TAG_LOCAL:\n \t\t\t/* This is a non-standard tag that we only allow for\n \t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. Further,\n\t\t\t * there is no legitimate reason for setting this from\n\t\t\t * userspace so reject it if skb is NULL. */\n\t\t\tif (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {\n \t\t\t\terr_offset = opt_iter;\n \t\t\t\tgoto validate_return_locked;\n \t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}\n", "func_hash": 203090929831454367454771625918575782687, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-0310", "cve_desc": "The cipso_v4_validate function in net/ipv4/cipso_ipv4.c in the Linux kernel before 3.4.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an IPOPT_CIPSO IP_OPTIONS setsockopt system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0310"}
{"idx": 158928, "project": "linux", "commit_id": "b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "commit_message": "batman-adv: Only write requested number of byte to user buffer\n\nDon't write more than the requested number of bytes of an batman-adv icmp\npacket to the userspace buffer. Otherwise unrelated userspace memory might get\noverridden by the kernel.\n\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nSigned-off-by: Marek Lindner <lindner_marek@yahoo.de>", "target": 0, "func": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n \n \tspin_unlock_bh(&socket_client->lock);\n \n\tpacket_len = min(count, socket_packet->icmp_len);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\n \n \tkfree(socket_packet);\n \n \tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}\n", "func_hash": 146563344002856956202954325132007595650, "file_name": "icmp_socket.c", "file_hash": 218189560527124045193594164952594783984, "cwe": ["CWE-119"], "cve": "CVE-2011-4604", "cve_desc": "The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4604"}
{"idx": 158952, "project": "linux", "commit_id": "d370af0ef7951188daeb15bae75db7ba57c67846", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846", "commit_message": "irda: validate peer name and attribute lengths\n\nLength fields provided by a peer for names and attributes may be longer\nthan the destination array sizes.  Validate lengths to prevent stack\nbuffer overflows.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 0, "func": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t/* 60 bytes */\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t/* 60 bytes */\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n \tn = 1;\n \n \tname_len = fp[n++];\n\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \n \tattr_len = fp[n++];\n\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n \n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t/* We have a match; send the value.  */\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}\n", "func_hash": 188363666428243788930341938329751308181, "file_name": "iriap.c", "file_hash": 2768355254666252778479089663776274149, "cwe": ["CWE-119"], "cve": "CVE-2011-1180", "cve_desc": "Multiple stack-based buffer overflows in the iriap_getvaluebyclass_indication function in net/irda/iriap.c in the Linux kernel before 2.6.39 allow remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging connectivity to an IrDA infrared network and sending a large integer value for a (1) name length or (2) attribute length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-1180"}
{"idx": 158959, "project": "linux", "commit_id": "f2e323ec96077642d397bb1c355def536d489d16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16", "commit_message": "[media] ttusb-dec: buffer overflow in ioctl\n\nWe need to add a limit check here so we don't overflow the buffer.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>", "target": 0, "func": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n", "func_hash": 152213072998875333849754242091004095658, "file_name": "ttusbdecfe.c", "file_hash": 218785497703789925227719447415859611077, "cwe": ["CWE-119"], "cve": "CVE-2014-8884", "cve_desc": "Stack-based buffer overflow in the ttusbdecfe_dvbs_diseqc_send_master_cmd function in drivers/media/usb/ttusb-dec/ttusbdecfe.c in the Linux kernel before 3.17.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via a large message length in an ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-8884"}
{"idx": 158978, "project": "ettercap", "commit_id": "e3abe7d7585ecc420a7cab73313216613aadad5a", "project_url": "https://github.com/Ettercap/ettercap", "commit_url": "https://github.com/Ettercap/ettercap/commit/e3abe7d7585ecc420a7cab73313216613aadad5a", "commit_message": "Fixed heap overflow caused by length", "target": 0, "func": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n                int length;\n                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n                GET_ULONG_BE(length, ptr, 1);\n               length -= 4;\n               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {\n                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n                   return NULL;\n               }\n               snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));\n                DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n             }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n", "func_hash": 235532748321396994144876978388407276282, "file_name": "ec_postgresql.c", "file_hash": 284688323983812357703764325378348258333, "cwe": ["CWE-119"], "cve": "CVE-2014-6395", "cve_desc": "Heap-based buffer overflow in the dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service or possibly execute arbitrary code via a crafted password length value that is inconsistent with the actual length of the password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6395"}
{"idx": 158993, "project": "linux", "commit_id": "206a81c18401c0cde6e579164f752c4b147324ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce", "commit_message": "lzo: properly check for overruns\n\nThe lzo decompressor can, if given some really crazy data, possibly\noverrun some variable types.  Modify the checking logic to properly\ndetect overruns before they happen.\n\nReported-by: \"Don A. Bailey\" <donb@securitymouse.com>\nTested-by: \"Don A. Bailey\" <donb@securitymouse.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 0, "func": " int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n \t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n \t\t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\t\tt += 255;\n \t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1, 0);\n \t\t\t\t\t}\n \t\t\t\t\tt += 15 + *ip++;\n \t\t\t\t}\n \t\t\t\tt += 3;\n copy_literal_run:\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t, 15) && HAVE_OP(t, 15))) {\n \t\t\t\t\tconst unsigned char *ie = ip + t;\n \t\t\t\t\tunsigned char *oe = op + t;\n \t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n \t\t\t\t} else\n #endif\n \t\t\t\t{\n\t\t\t\t\tNEED_OP(t, 0);\n\t\t\t\t\tNEED_IP(t, 3);\n \t\t\t\t\tdo {\n \t\t\t\t\t\t*op++ = *ip++;\n \t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n \t\t\t\tm_pos -= t >> 2;\n \t\t\t\tm_pos -= *ip++ << 2;\n \t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2, 0);\n \t\t\t\top[0] = m_pos[0];\n \t\t\t\top[1] = m_pos[1];\n \t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1, 0);\n \t\t\t\t}\n \t\t\t\tt += 31 + *ip++;\n\t\t\t\tNEED_IP(2, 0);\n \t\t\t}\n \t\t\tm_pos = op - 1;\n \t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tm_pos = op;\n\t\t\tm_pos -= (t & 8) << 11;\n\t\t\tt = (t & 7) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1, 0);\n \t\t\t\t}\n \t\t\t\tt += 7 + *ip++;\n\t\t\t\tNEED_IP(2, 0);\n \t\t\t}\n \t\t\tnext = get_unaligned_le16(ip);\n \t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t\tif (m_pos == op)\n\t\t\t\tgoto eof_found;\n\t\t\tm_pos -= 0x4000;\n\t\t}\n\t\tTEST_LB(m_pos);\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n \t\tif (op - m_pos >= 8) {\n \t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t, 15))) {\n \t\t\t\tdo {\n \t\t\t\t\tCOPY8(op, m_pos);\n \t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n \t\t\t\t\tm_pos += 8;\n \t\t\t\t} while (op < oe);\n \t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6, 0)) {\n \t\t\t\t\tstate = next;\n \t\t\t\t\tCOPY4(op, ip);\n \t\t\t\t\top += next;\n \t\t\t\t\tip += next;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t} else {\n\t\t\t\tNEED_OP(t, 0);\n \t\t\t\tdo {\n \t\t\t\t\t*op++ = *m_pos++;\n \t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n #endif\n \t\t{\n \t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t, 0);\n \t\t\top[0] = m_pos[0];\n \t\t\top[1] = m_pos[1];\n \t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n \t\tstate = next;\n \t\tt = next;\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6, 0) && HAVE_OP(4, 0))) {\n \t\t\tCOPY4(op, ip);\n \t\t\top += t;\n \t\t\tip += t;\n \t\t} else\n #endif\n \t\t{\n\t\t\tNEED_IP(t, 3);\n\t\t\tNEED_OP(t, 0);\n \t\t\twhile (t > 0) {\n \t\t\t\t*op++ = *ip++;\n \t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n", "func_hash": 174542836292707064346123364054688261425, "file_name": "lzo1x_decompress_safe.c", "file_hash": 52351594738285981777573668229644280332, "cwe": ["CWE-119"], "cve": "CVE-2014-4608", "cve_desc": "Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4608"}
{"idx": 158995, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 0, "func": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n \tif (url_len < 1)\n \t\treturn false;\n \n\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n", "func_hash": 278891602713911521721232005627227442838, "file_name": "util.c", "file_hash": 129321568267466402159371811359101293858, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 158996, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 0, "func": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n \tntime = __json_array_string(val, 7);\n \tclean = json_is_true(json_array_get(val, 8));\n \n\tif (!valid_hex(job_id) || !valid_hex(prev_hash) || !valid_hex(coinbase1) ||\n\t    !valid_hex(coinbase2) || !valid_hex(bbversion) || !valid_hex(nbit) ||\n\t    !valid_hex(ntime)) {\n \t\t/* Annoying but we must not leak memory */\n\t\tfree(job_id);\n\t\tfree(coinbase1);\n\t\tfree(coinbase2);\n \t\tgoto out;\n \t}\n \n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n", "func_hash": 31220049300174421749951479975200364815, "file_name": "util.c", "file_hash": 129321568267466402159371811359101293858, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 158997, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 0, "func": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n\tsnprintf(address, 254, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "func_hash": 279622017893359295959670642401765328571, "file_name": "util.c", "file_hash": 129321568267466402159371811359101293858, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 158999, "project": "php-src", "commit_id": "b34d7849ed90ced9345f8ea1c59bc8d101c18468", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/b34d7849ed90ced9345f8ea1c59bc8d101c18468", "commit_message": "Merge branch 'PHP-5.6'\n\n* PHP-5.6:\n  Fix potential segfault in dns_get_record()", "target": 0, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n \t\t\t\t\n \t\t\t\twhile (ll < dlen) {\n \t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (ll + 1);\n\t\t\t\t\t}\n \t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n \t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n \t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 42082954493828007775750322427269807585, "file_name": "dns.c", "file_hash": 226180146173155591083703597054314681623, "cwe": ["CWE-119"], "cve": "CVE-2014-4049", "cve_desc": "Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4049"}
{"idx": 159007, "project": "miniupnp", "commit_id": "3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "project_url": "https://github.com/miniupnp/miniupnp", "commit_url": "https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "commit_message": "miniwget.c: fixed potential buffer overrun", "target": 0, "func": "getHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n \t\t\t\t\t\t\tchunked = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t\twhile((i < (int)header_buf_used) && (header_buf[i]=='\\r' || header_buf[i] == '\\n'))\n \t\t\t\t\t\ti++;\n \t\t\t\t\tlinestart = i;\n \t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n", "func_hash": 331237893839884767142201326630204450580, "file_name": "miniwget.c", "file_hash": 168853020666456570587818425677132049522, "cwe": ["CWE-119"], "cve": "CVE-2014-3985", "cve_desc": "The getHTTPResponse function in miniwget.c in MiniUPnP 1.9 allows remote attackers to cause a denial of service (crash) via crafted headers that trigger an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3985"}
{"idx": 159018, "project": "php-src", "commit_id": "2fefae47716d501aec41c1102f3fd4531f070b05", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/2fefae47716d501aec41c1102f3fd4531f070b05", "commit_message": "Fixed Sec Bug #67717 segfault in dns_get_record CVE-2014-3597\n\nIncomplete fix for CVE-2014-4049\n\nCheck possible buffer overflow\n- pass real buffer end to dn_expand calls\n- check buffer len before each read", "target": 0, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\nstatic u_char *php_parserr(u_char *cp, u_char *end, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n {\n \tu_short type, class, dlen;\n \tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n \n \t*subarray = NULL;\n \n\tn = dn_expand(answer->qb2, end, cp, name, sizeof(name) - 2);\n \tif (n < 0) {\n \t\treturn NULL;\n \t}\n \tcp += n;\n \n\tCHECKCP(10);\n \tGETSHORT(type, cp);\n \tGETSHORT(class, cp);\n \tGETLONG(ttl, cp);\n \tGETSHORT(dlen, cp);\n\tCHECKCP(dlen);\n \tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n \t\tcp += dlen;\n \t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n \n \tswitch (type) {\n \t\tcase DNS_T_A:\n\t\t\tCHECKCP(4);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n \t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n \t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n \t\t\tcp += dlen;\n \t\t\tbreak;\n \t\tcase DNS_T_MX:\n\t\t\tCHECKCP(2);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n \t\t\tif (type == DNS_T_PTR) {\n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n \t\t\t}\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_HINFO:\n \t\t\t/* See RFC 1010 for values */\n \t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tCHECKCP(1);\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n\t\t\tCHECKCP(n);\n \t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\t\t\tCHECKCP(1);\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n\t\t\tCHECKCP(n);\n \t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n \t\t\tcp += n;\n \t\t\tbreak;\n \t\tcase DNS_T_TXT:\n \t\t\t{\n\t\t\t\tint l1 = 0, l2 = 0;\n \t\t\t\tzval *entries = NULL;\n \n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n \t\t\t\tMAKE_STD_ZVAL(entries);\n \t\t\t\tarray_init(entries);\n \t\t\t\t\n\t\t\t\twhile (l1 < dlen) {\n\t\t\t\t\tn = cp[l1];\n\t\t\t\t\tif ((l1 + n) >= dlen) {\n\t\t\t\t\t\tn = dlen - (l1 + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (n) {\n\t\t\t\t\t\tmemcpy(tp + l2 , cp + l1 + 1, n);\n\t\t\t\t\t\tadd_next_index_stringl(entries, cp + l1 + 1, n, 1);\n \t\t\t\t\t}\n\t\t\t\t\tl1 = l1 + n + 1;\n\t\t\t\t\tl2 = l2 + n;\n \t\t\t\t}\n\t\t\t\ttp[l2] = '\\0';\n \t\t\t\tcp += dlen;\n \n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, l2, 0);\n \t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SOA:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tCHECKCP(5*4);\n \t\t\tGETLONG(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"serial\", n);\n \t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n \t\t\tbreak;\n \t\tcase DNS_T_AAAA:\n \t\t\ttp = (u_char*)name;\n\t\t\tCHECKCP(8*2);\n \t\t\tfor(i=0; i < 8; i++) {\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_A6:\n \t\t\tp = cp;\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tCHECKCP(1);\n \t\t\tn = ((int)cp[0]) & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n \t\t\t\tcp++;\n \t\t\t}\n \t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tCHECKCP(2);\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n \t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n \t\t\ttp[0] = '\\0';\n \t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n \t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\t\tif (n < 0) {\n \t\t\t\t\treturn NULL;\n \t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SRV:\n\t\t\tCHECKCP(3*2);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"weight\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n \t\t\tbreak;\n \t\tcase DNS_T_NAPTR:\n\t\t\tCHECKCP(2*2);\n \t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"order\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\n\t\t\tCHECKCP(1);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)cp, n, 1);\n \t\t\tcp += n;\n\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 192548275441720818685588113727947464793, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3597", "cve_desc": "Multiple buffer overflows in the php_parserr function in ext/standard/dns.c in PHP before 5.4.32 and 5.5.x before 5.5.16 allow remote DNS servers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted DNS record, related to the dns_get_record function and the dn_expand function.  NOTE: this issue exists because of an incomplete fix for CVE-2014-4049.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3597"}
{"idx": 159024, "project": "linux", "commit_id": "844817e47eef14141cf59b8d5ac08dd11c0a9189", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/844817e47eef14141cf59b8d5ac08dd11c0a9189", "commit_message": "HID: picolcd: sanity check report size in raw_event() callback\n\nThe report passed to us from transport driver could potentially be\narbitrarily large, therefore we better sanity-check it so that raw_data\nthat we hold in picolcd_pending structure are always kept within proper\nbounds.\n\nCc: stable@vger.kernel.org\nReported-by: Steven Vittitoe <scvitti@google.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n \tif (!data)\n \t\treturn 1;\n \n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\n \tif (report->id == REPORT_KEY_STATE) {\n \t\tif (data->input_keys)\n \t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t/*\n\t\t * We let the caller of picolcd_send_and_wait() check if the\n\t\t * report we got is one of the expected ones or not.\n\t\t */\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}\n", "func_hash": 88186924224606894712660001209578635664, "file_name": "hid-picolcd_core.c", "file_hash": 54398981253658973866116694089898364478, "cwe": ["CWE-119"], "cve": "CVE-2014-3186", "cve_desc": "Buffer overflow in the picolcd_raw_event function in devices/hid/hid-picolcd_core.c in the PicoLCD HID device driver in the Linux kernel through 3.16.3, as used in Android on Nexus 7 devices, allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that sends a large report.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3186"}
{"idx": 159025, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 256834588490855446076505549688746966197, "file_name": "hid-cherry.c", "file_hash": 95105781901221436155724086271945955559, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 159026, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": "static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t/* the fixups that need to be done:\n\t\t *   - change led usage page to button for extra buttons\n\t\t *   - report size 8 count 1 must be size 1 count 8 for button\n\t\t *     bitfield\n \t\t *   - change the button usage range to 4-7 for the extra\n \t\t *     buttons\n \t\t */\n\t\tif (*rsize >= 75 &&\n \t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n \t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n \t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"fixing up Kye/Genius Ergo Mouse \"\n\t\t\t\t \"report descriptor\\n\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Gila Gaming Mouse\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"Genius Gx Imperator Keyboard\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Manticore Keyboard\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 10461272926352127171126962700267976879, "file_name": "hid-kye.c", "file_hash": 203442816039038892495284947516200817278, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 159027, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 0, "func": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n \tstruct usb_device_descriptor *udesc;\n \t__u16 bcdDevice, rev_maj, rev_min;\n \n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 91 && rdesc[83] == 0x26 &&\n \t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n \t\thid_info(hdev,\n \t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n \t\trdesc[84] = rdesc[89] = 0x4d;\n \t\trdesc[85] = rdesc[90] = 0x10;\n \t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 51 &&\n \t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n \t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n \t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}\n", "func_hash": 332754560908671207217151475475941392800, "file_name": "hid-lg.c", "file_hash": 208620246657497986001353256568567664160, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 1, "project": "savannah", "commit_id": "190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=190cef6eed37d0e73a73c1e205eb31d45ab60a3c", "commit_message": "None", "target": 1, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n  *session_data_size = psession.size;\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 266005388725654386397960628110885023158, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 2, "project": "savannah", "commit_id": "e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commitdiff;h=e82ef4545e9e98cbcb032f55d7c750b81e3a0450", "commit_message": "None", "target": 1, "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n", "func_hash": 162619476999663411812822607346255778028, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-4128", "cve_desc": "Buffer overflow in the gnutls_session_get_data function in lib/gnutls_session.c in GnuTLS 2.12.x before 2.12.14 and 3.x before 3.0.7, when used on a client that performs nonstandard session resumption, allows remote TLS servers to cause a denial of service (application crash) via a large SessionTicket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4128"}
{"idx": 41, "project": "pengutronix", "commit_id": "574ce994016107ad8ab0f845a785f28d7eaa5208", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_message": "None", "target": 1, "func": "static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,\n\t\t\t    char **target)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tuint32_t len;\n\tstruct packet *nfs_packet;\n\n\t/*\n\t * struct READLINK3args {\n\t * \tnfs_fh3 symlink;\n\t * };\n\t *\n\t * struct READLINK3resok {\n\t * \tpost_op_attr symlink_attributes;\n\t * \tnfspath3 data;\n\t * };\n\t *\n\t * struct READLINK3resfail {\n\t * \tpost_op_attr symlink_attributes;\n\t * }\n\t *\n\t * union READLINK3res switch (nfsstat3 status) {\n\t * case NFS3_OK:\n\t * \tREADLINK3resok resok;\n\t * default:\n\t * \tREADLINK3resfail resfail;\n\t * };\n\t */\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tp = nfs_add_fh3(p, fh);\n\n\tlen = p - &(data[0]);\n\n\tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);\n\tif (IS_ERR(nfs_packet))\n\t\treturn PTR_ERR(nfs_packet);\n\n\tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;\n\n \tp = nfs_read_post_op_attr(p, NULL);\n \n \tlen = ntoh32(net_read_uint32(p)); /* new path length */\n \tp++;\n \n \t*target = xzalloc(len + 1);\n\treturn 0;\n}\n", "func_hash": 165064796667373419921312233428470052444, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15938", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_req in fs/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15938"}
{"idx": 42, "project": "pengutronix", "commit_id": "84986ca024462058574432b5483f4bf9136c538d", "project_url": "https://git.pengutronix.de/cgit/barebox/commit/fs/nfs.c?h=next&id=574ce994016107ad8ab0f845a785f28d7eaa5208", "commit_url": "https://git.pengutronix.de/cgit/barebox/commit/net/nfs.c?h=next&id=84986ca024462058574432b5483f4bf9136c538d", "commit_message": "None", "target": 1, "func": "static int nfs_readlink_reply(unsigned char *pkt, unsigned len)\n {\n \tuint32_t *data;\n \tchar *path;\n\tint rlen;\n \tint ret;\n \n \tret = rpc_check_reply(pkt, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));\n\n\tdata++;\n \n \trlen = ntohl(net_read_uint32(data)); /* new path length */\n \n \tdata++;\n \tpath = (char *)data;\n\t} else {\n\t\tmemcpy(nfs_path, path, rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n", "func_hash": 197742048742816713437466148600234690021, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-15937", "cve_desc": "Pengutronix barebox through 2019.08.1 has a remote buffer overflow in nfs_readlink_reply in net/nfs.c because a length field is directly used for a memcpy.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-15937"}
{"idx": 63, "project": "libxfont", "commit_id": "d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_message": "None", "target": 1, "func": "BufCompressedFill (BufFilePtr f)\n{\n    CompressedFile  *file;\n    register char_type *stackp, *de_stack;\n    register char_type finchar;\n    register code_int code, oldcode, incode;\n    BufChar\t    *buf, *bufend;\n\n    file = (CompressedFile *) f->private;\n\n    buf = f->buffer;\n    bufend = buf + BUFFILESIZE;\n    stackp = file->stackp;\n    de_stack = file->de_stack;\n    finchar = file->finchar;\n    oldcode = file->oldcode;\n    while (buf < bufend) {\n\twhile (stackp > de_stack && buf < bufend)\n\t    *buf++ = *--stackp;\n\n\tif (buf == bufend)\n\t    break;\n\n\tif (oldcode == -1)\n\t    break;\n\n\tcode = getcode (file);\n\tif (code == -1)\n\t    break;\n    \n    \tif ( (code == CLEAR) && file->block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t    \tfile->tab_prefix[code] = 0;\n\t    file->clear_flg = 1;\n\t    file->free_ent = FIRST - 1;\n\t    if ( (code = getcode (file)) == -1 )\t/* O, untimely death! */\n\t    \tbreak;\n    \t}\n    \tincode = code;\n    \t/*\n     \t * Special case for KwKwK string.\n     \t */\n    \tif ( code >= file->free_ent ) {\n\t    *stackp++ = finchar;\n\t    code = oldcode;\n    \t}\n    \n    \t/*\n     \t * Generate output characters in reverse order\n      \t */\n     \twhile ( code >= 256 )\n     \t{\n \t    *stackp++ = file->tab_suffix[code];\n \t    code = file->tab_prefix[code];\n     \t}\n    \n    \t/*\n     \t * Generate the new entry.\n     \t */\n    \tif ( (code=file->free_ent) < file->maxmaxcode ) {\n\t    file->tab_prefix[code] = (unsigned short)oldcode;\n\t    file->tab_suffix[code] = finchar;\n\t    file->free_ent = code+1;\n    \t} \n\t/*\n\t * Remember previous code.\n\t */\n\toldcode = incode;\n    }\n    file->oldcode = oldcode;\n    file->stackp = stackp;\n    file->finchar = finchar;\n    if (buf == f->buffer) {\n\tf->left = 0;\n\treturn BUFFILEEOF;\n    }\n    f->bufp = f->buffer + 1;\n    f->left = (buf - f->buffer) - 1;\n    return f->buffer[0];\n}\n", "func_hash": 314816336443270992925734214319385584087, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-2895", "cve_desc": "The LZW decompressor in (1) the BufCompressedFill function in fontfile/decompress.c in X.Org libXfont before 1.4.4 and (2) compress/compress.c in 4.3BSD, as used in zopen.c in OpenBSD before 3.8, FreeBSD, NetBSD 4.0.x and 5.0.x before 5.0.3 and 5.1.x before 5.1.1, FreeType 2.1.9, and other products, does not properly handle code words that are absent from the decompression table when encountered, which allows context-dependent attackers to trigger an infinite loop or a heap-based buffer overflow, and possibly execute arbitrary code, via a crafted compressed stream, a related issue to CVE-2006-1168 and CVE-2011-2896.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2895"}
{"idx": 64, "project": "musl", "commit_id": "45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "project_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_url": "https://git.musl-libc.org/cgit/musl/commit/?id=45ca5d3fcb6f874bf5ba55d0e9651cef68515395", "commit_message": "None", "target": 1, "func": "static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)\n {\n \tchar tmp[256];\n \tstruct dpc_ctx *ctx = c;\n \tswitch (rr) {\n \tcase RR_A:\n \t\tif (len != 4) return -1;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);\n\t\tbreak;\n\tcase RR_AAAA:\n\t\tif (len != 16) return -1;\n\t\tctx->addrs[ctx->cnt].family = AF_INET6;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);\n\t\tbreak;\n\tcase RR_CNAME:\n\t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,\n\t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))\n\t\t\tstrcpy(ctx->canon, tmp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n", "func_hash": 212099417602244187828055587331477277729, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-15650", "cve_desc": "musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-15650"}
{"idx": 66, "project": "poppler", "commit_id": "b8682d868ddf7f741e93b791588af0932893f95c", "project_url": "https://github.com/freedesktop/poppler", "commit_url": "https://cgit.freedesktop.org/poppler/poppler/commit/utils/pdfseparate.cc?id=b8682d868ddf7f741e93b", "commit_message": "pdfseparate: improve the path building\n\nMake use of snprintf to limit the output to the pathName buffer;\nwhile I'm there, expand its size to 4096 (might help longer paths),\nalthough a better fix would be dynamically allocate its length\n(and/or using GooString, maybe).", "target": 1, "func": " bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[1024];\n   GooString *gfileName = new GooString (srcFileName);\n   PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n \n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n    firstPage = 1;\n  if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n    sprintf (pathName, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n     int errCode = doc->savePageAs(gpageName, pageNo);\n     if ( errCode != errNone) {\n      delete gpageName;\n      delete gfileName;\n      return false;\n    }\n    delete gpageName;\n  }\n  delete gfileName;\n  return true;\n}\n", "func_hash": 244634780333143587019078565382798831655, "file_name": "pdfseparate.cc", "file_hash": 64286020146444451993051060480447128164, "cwe": ["CWE-119"], "cve": "CVE-2013-4473", "cve_desc": "Stack-based buffer overflow in the extractPages function in utils/pdfseparate.cc in poppler before 0.24.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a source filename.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4473"}
{"idx": 96, "project": "savannah", "commit_id": "ba6b44f6745b14dce414761a8e4b35d31b176bba", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/wget.git/commit/?id=ba6b44f6745b14dce414761a8e4b35d31b176bba", "commit_message": "None", "target": 1, "func": "fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread, wgint startpos,\n\n              wgint *qtyread, wgint *qtywritten, double *elapsed, int flags,\n              FILE *out2)\n{\n  int ret = 0;\n#undef max\n#define max(a,b) ((a) > (b) ? (a) : (b))\n  int dlbufsize = max (BUFSIZ, 8 * 1024);\n  char *dlbuf = xmalloc (dlbufsize);\n\n  struct ptimer *timer = NULL;\n  double last_successful_read_tm = 0;\n\n  /* The progress gauge, set according to the user preferences. */\n  void *progress = NULL;\n\n  /* Non-zero if the progress gauge is interactive, i.e. if it can\n     continually update the display.  When true, smaller timeout\n     values are used so that the gauge can update the display when\n     data arrives slowly. */\n  bool progress_interactive = false;\n\n  bool exact = !!(flags & rb_read_exactly);\n\n  /* Used only by HTTP/HTTPS chunked transfer encoding.  */\n  bool chunked = flags & rb_chunked_transfer_encoding;\n  wgint skip = 0;\n\n  /* How much data we've read/written.  */\n  wgint sum_read = 0;\n  wgint sum_written = 0;\n  wgint remaining_chunk_size = 0;\n\n#ifdef HAVE_LIBZ\n  /* try to minimize the number of calls to inflate() and write_data() per\n     call to fd_read() */\n  unsigned int gzbufsize = dlbufsize * 4;\n  char *gzbuf = NULL;\n  z_stream gzstream;\n\n  if (flags & rb_compressed_gzip)\n    {\n      gzbuf = xmalloc (gzbufsize);\n      if (gzbuf != NULL)\n        {\n          gzstream.zalloc = zalloc;\n          gzstream.zfree = zfree;\n          gzstream.opaque = Z_NULL;\n          gzstream.next_in = Z_NULL;\n          gzstream.avail_in = 0;\n\n          #define GZIP_DETECT 32 /* gzip format detection */\n          #define GZIP_WINDOW 15 /* logarithmic window size (default: 15) */\n          ret = inflateInit2 (&gzstream, GZIP_DETECT | GZIP_WINDOW);\n          if (ret != Z_OK)\n            {\n              xfree (gzbuf);\n              errno = (ret == Z_MEM_ERROR) ? ENOMEM : EINVAL;\n              ret = -1;\n              goto out;\n            }\n        }\n      else\n        {\n          errno = ENOMEM;\n          ret = -1;\n          goto out;\n        }\n    }\n#endif\n\n  if (flags & rb_skip_startpos)\n    skip = startpos;\n\n  if (opt.show_progress)\n    {\n      const char *filename_progress;\n      /* If we're skipping STARTPOS bytes, pass 0 as the INITIAL\n         argument to progress_create because the indicator doesn't\n         (yet) know about \"skipping\" data.  */\n      wgint start = skip ? 0 : startpos;\n      if (opt.dir_prefix)\n        filename_progress = downloaded_filename + strlen (opt.dir_prefix) + 1;\n      else\n        filename_progress = downloaded_filename;\n      progress = progress_create (filename_progress, start, start + toread);\n      progress_interactive = progress_interactive_p (progress);\n    }\n\n  if (opt.limit_rate)\n    limit_bandwidth_reset ();\n\n  /* A timer is needed for tracking progress, for throttling, and for\n     tracking elapsed time.  If either of these are requested, start\n     the timer.  */\n  if (progress || opt.limit_rate || elapsed)\n    {\n      timer = ptimer_new ();\n      last_successful_read_tm = 0;\n    }\n\n  /* Use a smaller buffer for low requested bandwidths.  For example,\n     with --limit-rate=2k, it doesn't make sense to slurp in 16K of\n     data and then sleep for 8s.  With buffer size equal to the limit,\n     we never have to sleep for more than one second.  */\n  if (opt.limit_rate && opt.limit_rate < dlbufsize)\n    dlbufsize = opt.limit_rate;\n\n  /* Read from FD while there is data to read.  Normally toread==0\n     means that it is unknown how much data is to arrive.  However, if\n     EXACT is set, then toread==0 means what it says: that no data\n     should be read.  */\n  while (!exact || (sum_read < toread))\n    {\n      int rdsize;\n      double tmout = opt.read_timeout;\n\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                {\n                  ret = -1;\n                  break;\n                }\n              else if (out2 != NULL)\n                fwrite (line, 1, strlen (line), out2);\n\n               remaining_chunk_size = strtol (line, &endl, 16);\n               xfree (line);\n \n               if (remaining_chunk_size == 0)\n                 {\n                   ret = 0;\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                  break;\n                }\n            }\n\n          rdsize = MIN (remaining_chunk_size, dlbufsize);\n        }\n      else\n        rdsize = exact ? MIN (toread - sum_read, dlbufsize) : dlbufsize;\n\n      if (progress_interactive)\n        {\n          /* For interactive progress gauges, always specify a ~1s\n             timeout, so that the gauge can be updated regularly even\n             when the data arrives very slowly or stalls.  */\n          tmout = 0.95;\n          if (opt.read_timeout)\n            {\n              double waittm;\n              waittm = ptimer_read (timer) - last_successful_read_tm;\n              if (waittm + tmout > opt.read_timeout)\n                {\n                  /* Don't let total idle time exceed read timeout. */\n                  tmout = opt.read_timeout - waittm;\n                  if (tmout < 0)\n                    {\n                      /* We've already exceeded the timeout. */\n                      ret = -1, errno = ETIMEDOUT;\n                      break;\n                    }\n                }\n            }\n        }\n      ret = fd_read (fd, dlbuf, rdsize, tmout);\n\n      if (progress_interactive && ret < 0 && errno == ETIMEDOUT)\n        ret = 0;                /* interactive timeout, handled above */\n      else if (ret <= 0)\n        break;                  /* EOF or read error */\n\n      if (progress || opt.limit_rate || elapsed)\n        {\n          ptimer_measure (timer);\n          if (ret > 0)\n            last_successful_read_tm = ptimer_read (timer);\n        }\n\n      if (ret > 0)\n        {\n          int write_res;\n\n          sum_read += ret;\n\n#ifdef HAVE_LIBZ\n          if (gzbuf != NULL)\n            {\n              int err;\n              int towrite;\n              gzstream.avail_in = ret;\n              gzstream.next_in = (unsigned char *) dlbuf;\n\n              do\n                {\n                  gzstream.avail_out = gzbufsize;\n                  gzstream.next_out = (unsigned char *) gzbuf;\n\n                  err = inflate (&gzstream, Z_NO_FLUSH);\n\n                  switch (err)\n                    {\n                    case Z_MEM_ERROR:\n                      errno = ENOMEM;\n                      ret = -1;\n                      goto out;\n                    case Z_NEED_DICT:\n                    case Z_DATA_ERROR:\n                      errno = EINVAL;\n                      ret = -1;\n                      goto out;\n                    case Z_STREAM_END:\n                      if (exact && sum_read != toread)\n                        {\n                          DEBUGP((\"zlib stream ended unexpectedly after \"\n                                  \"%ld/%ld bytes\\n\", sum_read, toread));\n                        }\n                    }\n\n                  towrite = gzbufsize - gzstream.avail_out;\n                  write_res = write_data (out, out2, gzbuf, towrite, &skip,\n                                          &sum_written);\n                  if (write_res < 0)\n                    {\n                      ret = (write_res == -3) ? -3 : -2;\n                      goto out;\n                    }\n                }\n              while (gzstream.avail_out == 0);\n            }\n          else\n#endif\n            {\n              write_res = write_data (out, out2, dlbuf, ret, &skip,\n                                      &sum_written);\n              if (write_res < 0)\n                {\n                  ret = (write_res == -3) ? -3 : -2;\n                  goto out;\n                }\n            }\n\n          if (chunked)\n            {\n              remaining_chunk_size -= ret;\n              if (remaining_chunk_size == 0)\n                {\n                  char *line = fd_read_line (fd);\n                  if (line == NULL)\n                    {\n                      ret = -1;\n                      break;\n                    }\n                  else\n                    {\n                      if (out2 != NULL)\n                        fwrite (line, 1, strlen (line), out2);\n                      xfree (line);\n                    }\n                }\n            }\n        }\n\n      if (opt.limit_rate)\n        limit_bandwidth (ret, timer);\n\n      if (progress)\n        progress_update (progress, ret, ptimer_read (timer));\n#ifdef WINDOWS\n      if (toread > 0 && opt.show_progress)\n        ws_percenttitle (100.0 *\n                         (startpos + sum_read) / (startpos + toread));\n#endif\n    }\n", "func_hash": 323589515235597079129994725046166819711, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-13090", "cve_desc": "The retr.c:fd_read_body() function is called when processing OK responses. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to read the chunk in pieces of 8192 bytes by using the MIN() macro, but ends up passing the negative chunk length to retr.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument. The attacker can corrupt malloc metadata after the allocated buffer.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-13090"}
{"idx": 106, "project": "haproxy", "commit_id": "7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "https://git.haproxy.org/?p=haproxy-1.5.git;a=commit;h=7ec765568883b2d4e5a2796adbeb492a22ec9bd4", "commit_message": "None", "target": 1, "func": " void buffer_slow_realign(struct buffer *buf)\n {\n       /* two possible cases :\n        *   - the buffer is in one contiguous block, we move it in-place\n        *   - the buffer is in two blocks, we move it via the swap_buffer\n        */\n       if (buf->i) {\n               int block1 = buf->i;\n               int block2 = 0;\n               if (buf->p + buf->i > buf->data + buf->size) {\n                       /* non-contiguous block */\n                       block1 = buf->data + buf->size - buf->p;\n                       block2 = buf->p + buf->i - (buf->data + buf->size);\n               }\n               if (block2)\n                       memcpy(swap_buffer, buf->data, block2);\n               memmove(buf->data, buf->p, block1);\n               if (block2)\n                       memcpy(buf->data + block1, swap_buffer, block2);\n        }\n \n        buf->p = buf->data;\n }\n", "func_hash": 110551955760274715015247345529003415581, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-3281", "cve_desc": "The buffer_slow_realign function in HAProxy 1.5.x before 1.5.14 and 1.6-dev does not properly realign a buffer that is used for pending outgoing data, which allows remote attackers to obtain sensitive information (uninitialized memory contents of previous requests) via a crafted request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-3281"}
{"idx": 107, "project": "savannah", "commit_id": "3f872fe60463a931c5c766dbf8c36870c0023e88", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=3f872fe60463a931c5c766dbf8c36870c0023e88", "commit_message": "None", "target": 1, "func": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_register_event *emsg;\n  int len;\n\n  emsg = (struct msg_register_event *) buf;\n  len = sizeof (struct msg_register_event) +\n    filter->num_areas * sizeof (struct in_addr);\n   emsg->filter.typemask = htons (filter->typemask);\n   emsg->filter.origin = filter->origin;\n   emsg->filter.num_areas = filter->num_areas;\n   return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);\n }\n", "func_hash": 24569741928780254928487121835647969548, "file_name": "ospf_api.c", "file_hash": 292116959237005994810997282250604698459, "cwe": ["CWE-119"], "cve": "CVE-2013-2236", "cve_desc": "Stack-based buffer overflow in the new_msg_lsa_change_notify function in the OSPFD API (ospf_api.c) in Quagga before 0.99.22.2, when --enable-opaque-lsa and the -a command line option are used, allows remote attackers to cause a denial of service (crash) via a large LSA.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2236"}
{"idx": 123, "project": "netfilter", "commit_id": "2ae1099a42e6a0f06de305ca13a842ac83d4683e", "project_url": "https://git.netfilter.org/conntrack-tools", "commit_url": "https://git.netfilter.org/iptables/commit/iptables/xshared.c?id=2ae1099a42e6a0f06de305ca13a842ac83d4683e", "commit_message": "None", "target": 1, "func": " void add_param_to_argv(char *parsestart, int line)\n {\n\tint quote_open = 0, escaped = 0, param_len = 0;\n\tchar param_buffer[1024], *curchar;\n \n \t/* After fighting with strtok enough, here's now\n \t * a 'real' parser. According to Rusty I'm now no\n\t\t\t} else {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \tfor (curchar = parsestart; *curchar; curchar++) {\n \t\tif (quote_open) {\n \t\t\tif (escaped) {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \t\t\t\tescaped = 0;\n \t\t\t\tcontinue;\n \t\t\t} else if (*curchar == '\\\\') {\n\t\t}\n\n\t\tswitch (*curchar) {\n \t\t\t\tquote_open = 0;\n \t\t\t\t*curchar = '\"';\n \t\t\t} else {\n\t\t\t\tparam_buffer[param_len++] = *curchar;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* regular character, copy to buffer */\n\t\t\tparam_buffer[param_len++] = *curchar;\n\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n \t\tcase ' ':\n \t\tcase '\\t':\n \t\tcase '\\n':\n\t\t\tif (!param_len) {\n \t\t\t\t/* two spaces? */\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n \t\t\t/* regular character, copy to buffer */\n\t\t\tparam_buffer[param_len++] = *curchar;\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n\t\t\t\t\t      \"Parameter too long!\");\n \t\t\tcontinue;\n \t\t}\n \n\t\tparam_buffer[param_len] = '\\0';\n \n \t\t/* check if table name specified */\n\t\tif ((param_buffer[0] == '-' &&\n\t\t     param_buffer[1] != '-' &&\n\t\t     strchr(param_buffer, 't')) ||\n\t\t    (!strncmp(param_buffer, \"--t\", 3) &&\n\t\t     !strncmp(param_buffer, \"--table\", strlen(param_buffer)))) {\n \t\t\txtables_error(PARAMETER_PROBLEM,\n \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",\n \t\t\t\t      line, xt_params->program_name);\n \t\t}\n \n\t\tadd_argv(param_buffer, 0);\n\t\tparam_len = 0;\n \t}\n", "func_hash": 204920135878748692275786929565292679269, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2019-11360", "cve_desc": "A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-11360"}
{"idx": 128, "project": "xserver", "commit_id": "215f894965df5fb0bb45b107d84524e700d2073c", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=215f894965df5fb0bb45b107d84524e700d2073c", "commit_message": "dix: Disallow GenericEvent in SendEvent request.\n\nThe SendEvent request holds xEvent which is exactly 32 bytes long, no more,\nno less. Both ProcSendEvent and SProcSendEvent verify that the received data\nexactly match the request size. However nothing stops the client from passing\nin event with xEvent::type = GenericEvent and any value of\nxGenericEvent::length.\n\nIn the case of ProcSendEvent, the event will be eventually passed to\nWriteEventsToClient which will see that it is Generic event and copy the\narbitrary length from the receive buffer (and possibly past it) and send it to\nthe other client. This allows clients to copy unitialized heap memory out of X\nserver or to crash it.\n\nIn case of SProcSendEvent, it will attempt to swap the incoming event by\ncalling a swapping function from the EventSwapVector array. The swapped event\nis written to target buffer, which in this case is local xEvent variable. The\nxEvent variable is 32 bytes long, but the swapping functions for GenericEvents\nexpect that the target buffer has size matching the size of the source\nGenericEvent. This allows clients to cause stack buffer overflows.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 1, "func": "ProcSendEvent(ClientPtr client)\n{\n    WindowPtr pWin;\n    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */\n    DeviceIntPtr dev = PickPointer(client);\n    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);\n    SpritePtr pSprite = dev->spriteInfo->sprite;\n\n    REQUEST(xSendEventReq);\n\n    REQUEST_SIZE_MATCH(xSendEventReq);\n\n    /* libXext and other extension libraries may set the bit indicating\n     * that this event came from a SendEvent request so remove it\n     * since otherwise the event type may fail the range checks\n     * and cause an invalid BadValue error to be returned.\n     *\n     * This is safe to do since we later add the SendEvent bit (0x80)\n     * back in once we send the event to the client */\n\n    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);\n\n    /* The client's event type must be a core event type or one defined by an\n       extension. */\n\n    if (!((stuff->event.u.u.type > X_Reply &&\n           stuff->event.u.u.type < LASTEvent) ||\n          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&\n           stuff->event.u.u.type < (unsigned) lastEvent))) {\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {\n    }\n\n    if (stuff->destination == PointerWindow)\n        pWin = pSprite->win;\n    else if (stuff->destination == InputFocus) {\n        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;\n\n        if (inputFocus == NoneWin)\n            return Success;\n\n        /* If the input focus is PointerRootWin, send the event to where\n           the pointer is if possible, then perhaps propogate up to root. */\n        if (inputFocus == PointerRootWin)\n            inputFocus = GetCurrentRootWindow(dev);\n\n        if (IsParent(inputFocus, pSprite->win)) {\n            effectiveFocus = inputFocus;\n            pWin = pSprite->win;\n        }\n        else\n            effectiveFocus = pWin = inputFocus;\n    }\n    else\n        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);\n\n    if (!pWin)\n        return BadWindow;\n    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {\n        client->errorValue = stuff->propagate;\n        return BadValue;\n    }\n    stuff->event.u.u.type |= SEND_EVENT_BIT;\n    if (stuff->propagate) {\n        for (; pWin; pWin = pWin->parent) {\n            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,\n                         &stuff->event, 1))\n                return Success;\n            if (DeliverEventsToWindow(dev, pWin,\n                                      &stuff->event, 1, stuff->eventMask,\n                                      NullGrab))\n                return Success;\n            if (pWin == effectiveFocus)\n                return Success;\n            stuff->eventMask &= ~wDontPropagateMask(pWin);\n            if (!stuff->eventMask)\n                break;\n        }\n    }\n    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))\n        DeliverEventsToWindow(dev, pWin, &stuff->event,\n                              1, stuff->eventMask, NullGrab);\n    return Success;\n}\n", "func_hash": 36683317052216501366087070681901031177, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 129, "project": "xserver", "commit_id": "8caed4df36b1f802b4992edcfd282cbeeec35d9d", "project_url": "http://gitweb.freedesktop.org/?p=xorg/xserver", "commit_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=8caed4df36b1f802b4992edcfd282cbeeec35d9d", "commit_message": "Xi: Verify all events in ProcXSendExtensionEvent.\n\nThe requirement is that events have type in range\nEXTENSION_EVENT_BASE..lastEvent, but it was tested\nonly for first event of all.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>", "target": 1, "func": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n\n    if (stuff->num_events == 0)\n        return ret;\n\n     /* The client's event type must be one defined by an extension. */\n \n     first = ((xEvent *) &stuff[1]);\n    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&\n          (first->u.u.type < lastEvent))) {\n        client->errorValue = first->u.u.type;\n        return BadValue;\n     }\n \n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n\n    return ret;\n}\n", "func_hash": 288772859654498582457761658216356600870, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-10971", "cve_desc": "In the X.Org X server before 2017-06-19, a user authenticated to an X Session could crash or execute code in the context of the X Server by exploiting a stack overflow in the endianness conversion of X Events.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-10971"}
{"idx": 139, "project": "ghostscript", "commit_id": "c53183d4e7103e87368b7cfa15367a47d559e323", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c53183d4e7103e87368b7cfa15367a47d559e323", "commit_message": "None", "target": 1, "func": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    /* This function is copied verbatim from plfont.c */\n\n    int table_length;\n     int table_offset;\n \n     ulong format;\n    uint numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; /* post table pointer */\n \n     /* guess if the font type is not truetype */\n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }\n", "func_hash": 83736377691001723428427436308560857107, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9619", "cve_desc": "The xps_true_callback_glyph_name function in xps/xpsttf.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (Segmentation Violation and application crash) via a crafted file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9619"}
{"idx": 140, "project": "ghostscript", "commit_id": "3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=3c2aebbedd37fab054e80f2e315de07d7e9b5bdb", "commit_message": "None", "target": 1, "func": "xps_load_sfnt_name(xps_font_t *font, char *namep)\n {\n     byte *namedata;\n     int offset, length;\n    /*int format;*/\n    int count, stringoffset;\n    int found;\n    int i, k;\n\n    found = 0;\n    strcpy(namep, \"Unknown\");\n\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n        return;\n    }\n\n    /* validate the offset, and the data for the two\n     * values we're about to read\n     */\n    if (offset + 6 > font->length)\n    {\n        gs_warn(\"name table byte offset invalid\");\n        return;\n    }\n    namedata = font->data + offset;\n\n    /*format = u16(namedata + 0);*/\n    count = u16(namedata + 2);\n    stringoffset = u16(namedata + 4);\n\n    if (stringoffset + offset > font->length\n        || offset + 6 + count * 12 > font->length)\n    {\n        gs_warn(\"name table invalid\");\n        return;\n    }\n\n    if (length < 6 + (count * 12))\n    {\n        gs_warn(\"name table too short\");\n        return;\n    }\n\n    for (i = 0; i < count; i++)\n    {\n        byte *record = namedata + 6 + i * 12;\n        int pid = u16(record + 0);\n        int eid = u16(record + 2);\n        int langid = u16(record + 4);\n        int nameid = u16(record + 6);\n         length = u16(record + 8);\n         offset = u16(record + 10);\n \n         /* Full font name or postscript name */\n         if (nameid == 4 || nameid == 6)\n         {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n\n            if (pid == 3 && eid == 1 && langid == 0x409) /* windows unicode ucs-2, US */\n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n\n            if (pid == 3 && eid == 10 && langid == 0x409) /* windows unicode ucs-4, US */\n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n", "func_hash": 112369513254285676016910036571983121831, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-9618", "cve_desc": "The xps_load_sfnt_name function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-9618"}
{"idx": 150, "project": "openssl", "commit_id": "d0666f289ac013094bbbf547bfbcd616199b7d2d", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d0666f289ac013094bbbf547bfbcd616199b7d2d", "commit_message": "evp: prevent underflow in base64 decoding\n\nThis patch resolves RT ticket #2608.\n\nThanks to Robert Dugal for originally spotting this, and to David\nRamos for noticing that the ball had been dropped.\n\nSigned-off-by: Geoff Thorpe <geoff@openssl.org>", "target": 1, "func": "int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint seof= -1,eof=0,rv= -1,ret=0,i,v,tmp,n,ln,exp_nl;\n\tunsigned char *d;\n\n\tn=ctx->num;\n\td=ctx->enc_data;\n\tln=ctx->line_num;\n\texp_nl=ctx->expect_nl;\n\n\t/* last line of input. */\n\tif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF)))\n\t\t{ rv=0; goto end; }\n\t\t\n\t/* We parse the input data */\n\tfor (i=0; i<inl; i++)\n\t\t{\n\t\t/* If the current line is > 80 characters, scream alot */\n\t\tif (ln >= 80) { rv= -1; goto end; }\n\n\t\t/* Get char and put it into the buffer */\n\t\ttmp= *(in++);\n\t\tv=conv_ascii2bin(tmp);\n\t\t/* only save the good data :-) */\n\t\tif (!B64_NOT_BASE64(v))\n\t\t\t{\n\t\t\tOPENSSL_assert(n < (int)sizeof(ctx->enc_data));\n\t\t\td[n++]=tmp;\n\t\t\tln++;\n\t\t\t}\n\t\telse if (v == B64_ERROR)\n\t\t\t{\n\t\t\trv= -1;\n\t\t\tgoto end;\n\t\t\t}\n\n\t\t/* have we seen a '=' which is 'definitly' the last\n\t\t * input line.  seof will point to the character that\n\t\t * holds it. and eof will hold how many characters to\n\t\t * chop off. */\n\t\tif (tmp == '=')\n\t\t\t{\n\t\t\tif (seof == -1) seof=n;\n\t\t\teof++;\n\t\t\t}\n\n\t\tif (v == B64_CR)\n\t\t\t{\n\t\t\tln = 0;\n\t\t\tif (exp_nl)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t/* eoln */\n\t\tif (v == B64_EOLN)\n\t\t\t{\n\t\t\tln=0;\n\t\t\tif (exp_nl)\n\t\t\t\t{\n\t\t\t\texp_nl=0;\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\texp_nl=0;\n\n\t\t/* If we are at the end of input and it looks like a\n\t\t * line, process it. */\n\t\tif (((i+1) == inl) && (((n&3) == 0) || eof))\n\t\t\t{\n\t\t\tv=B64_EOF;\n\t\t\t/* In case things were given us in really small\n\t\t\t   records (so two '=' were given in separate\n\t\t\t   updates), eof may contain the incorrect number\n\t\t\t   of ending bytes to skip, so let's redo the count */\n\t\t\teof = 0;\n\t\t\tif (d[n-1] == '=') eof++;\n\t\t\tif (d[n-2] == '=') eof++;\n\t\t\t/* There will never be more than two '=' */\n\t\t\t}\n\n\t\tif ((v == B64_EOF && (n&3) == 0) || (n >= 64))\n\t\t\t{\n\t\t\t/* This is needed to work correctly on 64 byte input\n\t\t\t * lines.  We process the line and then need to\n\t\t\t * accept the '\\n' */\n\t\t\tif ((v != B64_EOF) && (n >= 64)) exp_nl=1;\n\t\t\tif (n > 0)\n\t\t\t\t{\n                                v=EVP_DecodeBlock(out,d,n);\n                                n=0;\n                                if (v < 0) { rv=0; goto end; }\n                                ret+=(v-eof);\n                                }\n                        else\n\t\t\t\teof=1;\n\t\t\t\tv=0;\n\t\t\t\t}\n\n\t\t\t/* This is the case where we have had a short\n\t\t\t * but valid input line */\n\t\t\tif ((v < ctx->length) && eof)\n\t\t\t\t{\n\t\t\t\trv=0;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tctx->length=v;\n\n\t\t\tif (seof >= 0) { rv=0; goto end; }\n\t\t\tout+=v;\n\t\t\t}\n\t\t}\n", "func_hash": 314448950255259267086706912584575387344, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2015-0292", "cve_desc": "Integer underflow in the EVP_DecodeUpdate function in crypto/evp/encode.c in the base64-decoding implementation in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted base64 data that triggers a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2015-0292"}
{"idx": 165, "project": "savannah", "commit_id": "7f2e4f4f553f6836be7683f66226afac3fa979b8", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7f2e4f4f553f6836be7683f66226afac3fa979b8", "commit_message": "None", "target": 1, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n       if ( p->glyph_enc == -1 && p->list.used > 2 )\n         p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n \n       FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n                                   sizeof ( unsigned long ) * 32 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 241612252320932154235102760135232983991, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5670", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) via vectors related to BDF fonts and an ENCODING field with a negative value.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5670"}
{"idx": 166, "project": "savannah", "commit_id": "07bdb6e289c7954e2a533039dc93c1c136099d2d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=07bdb6e289c7954e2a533039dc93c1c136099d2d", "commit_message": "None", "target": 1, "func": "  _bdf_parse_glyphs( char*          line,\n                     unsigned long  linelen,\n                     unsigned long  lineno,\n                     void*          call_data,\n                     void*          client_data )\n  {\n    int                c, mask_index;\n    char*              s;\n    unsigned char*     bp;\n    unsigned long      i, slen, nibbles;\n\n    _bdf_parse_t*      p;\n    bdf_glyph_t*       glyph;\n    bdf_font_t*        font;\n\n    FT_Memory          memory;\n    FT_Error           error = BDF_Err_Ok;\n\n    FT_UNUSED( call_data );\n    FT_UNUSED( lineno );        /* only used in debug mode */\n\n\n    p = (_bdf_parse_t *)client_data;\n\n    font   = p->font;\n    memory = font->memory;\n\n    /* Check for a comment. */\n    if ( ft_memcmp( line, \"COMMENT\", 7 ) == 0 )\n    {\n      linelen -= 7;\n\n      s = line + 7;\n      if ( *s != 0 )\n      {\n        s++;\n        linelen--;\n      }\n      error = _bdf_add_comment( p->font, s, linelen );\n      goto Exit;\n    }\n\n    /* The very first thing expected is the number of glyphs. */\n    if ( !( p->flags & _BDF_GLYPHS ) )\n    {\n      if ( ft_memcmp( line, \"CHARS\", 5 ) != 0 )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n        error = BDF_Err_Missing_Chars_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );\n\n      /* Make sure the number of glyphs is non-zero. */\n      if ( p->cnt == 0 )\n        font->glyphs_size = 64;\n\n      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */\n      /* number of code points available in Unicode).                 */\n      if ( p->cnt >= 0x110000UL )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"CHARS\" ));\n        error = BDF_Err_Invalid_Argument;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )\n        goto Exit;\n\n      p->flags |= _BDF_GLYPHS;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDFONT field. */\n    if ( ft_memcmp( line, \"ENDFONT\", 7 ) == 0 )\n    {\n      /* Sort the glyphs by encoding. */\n      ft_qsort( (char *)font->glyphs,\n                font->glyphs_used,\n                sizeof ( bdf_glyph_t ),\n                by_encoding );\n\n      p->flags &= ~_BDF_START;\n\n      goto Exit;\n    }\n\n    /* Check for the ENDCHAR field. */\n    if ( ft_memcmp( line, \"ENDCHAR\", 7 ) == 0 )\n    {\n      p->glyph_enc = 0;\n      p->flags    &= ~_BDF_GLYPH_BITS;\n\n      goto Exit;\n    }\n\n    /* Check whether a glyph is being scanned but should be */\n    /* ignored because it is an unencoded glyph.            */\n    if ( ( p->flags & _BDF_GLYPH )     &&\n         p->glyph_enc            == -1 &&\n         p->opts->keep_unencoded == 0  )\n      goto Exit;\n\n    /* Check for the STARTCHAR field. */\n    if ( ft_memcmp( line, \"STARTCHAR\", 9 ) == 0 )\n    {\n      /* Set the character name in the parse info first until the */\n      /* encoding can be checked for an unencoded character.      */\n      FT_FREE( p->glyph_name );\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      _bdf_list_shift( &p->list, 1 );\n\n      s = _bdf_list_join( &p->list, ' ', &slen );\n\n      if ( !s )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG8, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Invalid_File_Format;\n        goto Exit;\n      }\n\n      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )\n        goto Exit;\n\n      FT_MEM_COPY( p->glyph_name, s, slen + 1 );\n\n      p->flags |= _BDF_GLYPH;\n\n      FT_TRACE4(( DBGMSG1, lineno, s ));\n\n      goto Exit;\n    }\n\n    /* Check for the ENCODING field. */\n    if ( ft_memcmp( line, \"ENCODING\", 8 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_GLYPH ) )\n      {\n        /* Missing STARTCHAR field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"STARTCHAR\" ));\n        error = BDF_Err_Missing_Startchar_Field;\n        goto Exit;\n      }\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );\n\n      /* Normalize negative encoding values.  The specification only */\n      /* allows -1, but we can be more generous here.                */\n      if ( p->glyph_enc < -1 )\n        p->glyph_enc = -1;\n\n      /* Check for alternative encoding format. */\n      if ( p->glyph_enc == -1 && p->list.used > 2 )\n        p->glyph_enc = _bdf_atol( p->list.field[2], 0, 10 );\n\n      FT_TRACE4(( DBGMSG2, p->glyph_enc ));\n \n       /* Check that the encoding is in the Unicode range because  */\n       /* otherwise p->have (a bitmap with static size) overflows. */\n      if ( p->glyph_enc > 0                               &&\n           (size_t)p->glyph_enc >= sizeof ( p->have ) * 8 )\n       {\n         FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG5, lineno, \"ENCODING\" ));\n         error = BDF_Err_Invalid_File_Format;\n      }\n\n      /* Check whether this encoding has already been encountered. */\n      /* If it has then change it to unencoded so it gets added if */\n      /* indicated.                                                */\n      if ( p->glyph_enc >= 0 )\n      {\n        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )\n        {\n          /* Emit a message saying a glyph has been moved to the */\n          /* unencoded area.                                     */\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG12,\n                      p->glyph_enc, p->glyph_name ));\n          p->glyph_enc = -1;\n          font->modified = 1;\n        }\n        else\n          _bdf_set_glyph_modified( p->have, p->glyph_enc );\n      }\n\n      if ( p->glyph_enc >= 0 )\n      {\n        /* Make sure there are enough glyphs allocated in case the */\n        /* number of characters happen to be wrong.                */\n        if ( font->glyphs_used == font->glyphs_size )\n        {\n          if ( FT_RENEW_ARRAY( font->glyphs,\n                               font->glyphs_size,\n                               font->glyphs_size + 64 ) )\n            goto Exit;\n\n          font->glyphs_size += 64;\n        }\n\n        glyph           = font->glyphs + font->glyphs_used++;\n        glyph->name     = p->glyph_name;\n        glyph->encoding = p->glyph_enc;\n\n        /* Reset the initial glyph info. */\n        p->glyph_name = 0;\n      }\n      else\n      {\n        /* Unencoded glyph.  Check whether it should */\n        /* be added or not.                          */\n        if ( p->opts->keep_unencoded != 0 )\n        {\n          /* Allocate the next unencoded glyph. */\n          if ( font->unencoded_used == font->unencoded_size )\n          {\n            if ( FT_RENEW_ARRAY( font->unencoded ,\n                                 font->unencoded_size,\n                                 font->unencoded_size + 4 ) )\n              goto Exit;\n\n            font->unencoded_size += 4;\n          }\n\n          glyph           = font->unencoded + font->unencoded_used;\n          glyph->name     = p->glyph_name;\n          glyph->encoding = font->unencoded_used++;\n        }\n        else\n          /* Free up the glyph name if the unencoded shouldn't be */\n          /* kept.                                                */\n          FT_FREE( p->glyph_name );\n\n        p->glyph_name = 0;\n      }\n\n      /* Clear the flags that might be added when width and height are */\n      /* checked for consistency.                                      */\n      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );\n\n      p->flags |= _BDF_ENCODING;\n\n      goto Exit;\n    }\n\n    /* Point at the glyph being constructed. */\n    if ( p->glyph_enc == -1 )\n      glyph = font->unencoded + ( font->unencoded_used - 1 );\n    else\n      glyph = font->glyphs + ( font->glyphs_used - 1 );\n\n    /* Check whether a bitmap is being constructed. */\n    if ( p->flags & _BDF_BITMAP )\n    {\n      /* If there are more rows than are specified in the glyph metrics, */\n      /* ignore the remaining lines.                                     */\n      if ( p->row >= (unsigned long)glyph->bbx.height )\n      {\n        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )\n        {\n          FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG13, glyph->encoding ));\n          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;\n          font->modified = 1;\n        }\n\n        goto Exit;\n      }\n\n      /* Only collect the number of nibbles indicated by the glyph     */\n      /* metrics.  If there are more columns, they are simply ignored. */\n      nibbles = glyph->bpr << 1;\n      bp      = glyph->bitmap + p->row * glyph->bpr;\n\n      for ( i = 0; i < nibbles; i++ )\n      {\n        c = line[i];\n        if ( !sbitset( hdigits, c ) )\n          break;\n        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );\n        if ( i + 1 < nibbles && ( i & 1 ) )\n          *++bp = 0;\n      }\n\n      /* If any line has not enough columns,            */\n      /* indicate they have been padded with zero bits. */\n      if ( i < nibbles                            &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG16, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      /* Remove possible garbage at the right. */\n      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;\n      if ( glyph->bbx.width )\n        *bp &= nibble_mask[mask_index];\n\n      /* If any line has extra columns, indicate they have been removed. */\n      if ( i == nibbles                           &&\n           sbitset( hdigits, line[nibbles] )      &&\n           !( p->flags & _BDF_GLYPH_WIDTH_CHECK ) )\n      {\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG14, glyph->encoding ));\n        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;\n        font->modified  = 1;\n      }\n\n      p->row++;\n      goto Exit;\n    }\n\n    /* Expect the SWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"SWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n      p->flags |= _BDF_SWIDTH;\n\n      goto Exit;\n    }\n\n    /* Expect the DWIDTH (scalable width) field next. */\n    if ( ft_memcmp( line, \"DWIDTH\", 6 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );\n\n      if ( !( p->flags & _BDF_SWIDTH ) )\n      {\n        /* Missing SWIDTH field.  Emit an auto correction message and set */\n        /* the scalable width from the device width.                      */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG9, lineno ));\n\n        glyph->swidth = (unsigned short)FT_MulDiv(\n                          glyph->dwidth, 72000L,\n                          (FT_Long)( font->point_size *\n                                     font->resolution_x ) );\n      }\n\n      p->flags |= _BDF_DWIDTH;\n      goto Exit;\n    }\n\n    /* Expect the BBX field next. */\n    if ( ft_memcmp( line, \"BBX\", 3 ) == 0 )\n    {\n      if ( !( p->flags & _BDF_ENCODING ) )\n        goto Missing_Encoding;\n\n      error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n      if ( error )\n        goto Exit;\n\n      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );\n      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );\n      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );\n      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );\n\n      /* Generate the ascent and descent of the character. */\n      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );\n      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );\n\n      /* Determine the overall font bounding box as the characters are */\n      /* loaded so corrections can be done later if indicated.         */\n      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );\n      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );\n\n      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );\n\n      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );\n      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );\n      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );\n\n      if ( !( p->flags & _BDF_DWIDTH ) )\n      {\n        /* Missing DWIDTH field.  Emit an auto correction message and set */\n        /* the device width to the glyph width.                           */\n        FT_TRACE2(( \"_bdf_parse_glyphs: \" ACMSG10, lineno ));\n        glyph->dwidth = glyph->bbx.width;\n      }\n\n      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */\n      /* value if necessary.                                            */\n      if ( p->opts->correct_metrics != 0 )\n      {\n        /* Determine the point size of the glyph. */\n        unsigned short  sw = (unsigned short)FT_MulDiv(\n                               glyph->dwidth, 72000L,\n                               (FT_Long)( font->point_size *\n                                          font->resolution_x ) );\n\n\n        if ( sw != glyph->swidth )\n        {\n          glyph->swidth = sw;\n\n          if ( p->glyph_enc == -1 )\n            _bdf_set_glyph_modified( font->umod,\n                                     font->unencoded_used - 1 );\n          else\n            _bdf_set_glyph_modified( font->nmod, glyph->encoding );\n\n          p->flags       |= _BDF_SWIDTH_ADJ;\n          font->modified  = 1;\n        }\n      }\n\n      p->flags |= _BDF_BBX;\n      goto Exit;\n    }\n\n    /* And finally, gather up the bitmap. */\n    if ( ft_memcmp( line, \"BITMAP\", 6 ) == 0 )\n    {\n      unsigned long  bitmap_size;\n\n\n      if ( !( p->flags & _BDF_BBX ) )\n      {\n        /* Missing BBX field. */\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"BBX\" ));\n        error = BDF_Err_Missing_Bbx_Field;\n        goto Exit;\n      }\n\n      /* Allocate enough space for the bitmap. */\n      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;\n\n      bitmap_size = glyph->bpr * glyph->bbx.height;\n      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )\n      {\n        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG4, lineno ));\n        error = BDF_Err_Bbx_Too_Big;\n        goto Exit;\n      }\n      else\n        glyph->bytes = (unsigned short)bitmap_size;\n\n      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )\n        goto Exit;\n\n      p->row    = 0;\n      p->flags |= _BDF_BITMAP;\n\n      goto Exit;\n    }\n\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG9, lineno ));\n    error = BDF_Err_Invalid_File_Format;\n    goto Exit;\n\n  Missing_Encoding:\n    /* Missing ENCODING field. */\n    FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENCODING\" ));\n    error = BDF_Err_Missing_Encoding_Field;\n\n  Exit:\n    if ( error && ( p->flags & _BDF_GLYPH ) )\n      FT_FREE( p->glyph_name );\n\n    return error;\n  }\n", "func_hash": 339135483814426971995983985697178320662, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-5669", "cve_desc": "The _bdf_parse_glyphs function in FreeType before 2.4.11 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to BDF fonts and an incorrect calculation that triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-5669"}
{"idx": 179, "project": "savannah", "commit_id": "18a8f0d9943369449bc4de92d411c78fb08d616c", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=18a8f0d9943369449bc4de92d411c78fb08d616c", "commit_message": "None", "target": 1, "func": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count && i < 64; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= FT_MIN( string_count, 64 ) )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n", "func_hash": 233045259701863811358636688341910118112, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9672", "cve_desc": "Array index error in the parse_fond function in base/ftmac.c in FreeType before 2.5.4 allows remote attackers to cause a denial of service (out-of-bounds read) or obtain sensitive information from process memory via a crafted FOND resource in a Mac font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9672"}
{"idx": 200, "project": "savannah", "commit_id": "f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=f0292bb9920aa1dbfed5f53861e7c7a89b35833a", "commit_message": "None", "target": 1, "func": "  tt_sbit_decoder_load_image( TT_SBitDecoder  decoder,\n                              FT_UInt         glyph_index,\n                              FT_Int          x_pos,\n                              FT_Int          y_pos )\n  {\n    /*\n     *  First, we find the correct strike range that applies to this\n     *  glyph index.\n     */\n\n    FT_Byte*  p          = decoder->eblc_base + decoder->strike_index_array;\n    FT_Byte*  p_limit    = decoder->eblc_limit;\n    FT_ULong  num_ranges = decoder->strike_index_count;\n    FT_UInt   start, end, index_format, image_format;\n    FT_ULong  image_start = 0, image_end = 0, image_offset;\n\n\n    for ( ; num_ranges > 0; num_ranges-- )\n    {\n      start = FT_NEXT_USHORT( p );\n      end   = FT_NEXT_USHORT( p );\n\n      if ( glyph_index >= start && glyph_index <= end )\n        goto FoundRange;\n\n      p += 4;  /* ignore index offset */\n    }\n    goto NoBitmap;\n\n  FoundRange:\n    image_offset = FT_NEXT_ULONG( p );\n\n    /* overflow check */\n    p = decoder->eblc_base + decoder->strike_index_array;\n    if ( image_offset > (FT_ULong)( p_limit - p ) )\n      goto Failure;\n\n    p += image_offset;\n    if ( p + 8 > p_limit )\n      goto NoBitmap;\n\n    /* now find the glyph's location and extend within the ebdt table */\n    index_format = FT_NEXT_USHORT( p );\n    image_format = FT_NEXT_USHORT( p );\n    image_offset = FT_NEXT_ULONG ( p );\n\n    switch ( index_format )\n    {\n    case 1: /* 4-byte offsets relative to `image_offset' */\n      p += 4 * ( glyph_index - start );\n      if ( p + 8 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_ULONG( p );\n      image_end   = FT_NEXT_ULONG( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 2: /* big metrics, constant image size */\n      {\n        FT_ULong  image_size;\n\n\n        if ( p + 12 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        image_start = image_size * ( glyph_index - start );\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    case 3: /* 2-byte offsets relative to 'image_offset' */\n      p += 2 * ( glyph_index - start );\n      if ( p + 4 > p_limit )\n        goto NoBitmap;\n\n      image_start = FT_NEXT_USHORT( p );\n      image_end   = FT_NEXT_USHORT( p );\n\n      if ( image_start == image_end )  /* missing glyph */\n        goto NoBitmap;\n      break;\n\n    case 4: /* sparse glyph array with (glyph,offset) pairs */\n      {\n        FT_ULong  mm, num_glyphs;\n\n\n        if ( p + 4 > p_limit )\n          goto NoBitmap;\n\n         num_glyphs = FT_NEXT_ULONG( p );\n \n         /* overflow check for p + ( num_glyphs + 1 ) * 4 */\n        if ( num_glyphs > (FT_ULong)( ( ( p_limit - p ) >> 2 ) - 1 ) )\n           goto NoBitmap;\n \n         for ( mm = 0; mm < num_glyphs; mm++ )\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n          {\n            image_start = FT_NEXT_USHORT( p );\n            p          += 2;\n            image_end   = FT_PEEK_USHORT( p );\n            break;\n          }\n          p += 2;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n      }\n      break;\n\n    case 5: /* constant metrics with sparse glyph codes */\n    case 19:\n      {\n        FT_ULong  image_size, mm, num_glyphs;\n\n\n        if ( p + 16 > p_limit )\n          goto NoBitmap;\n\n        image_size = FT_NEXT_ULONG( p );\n\n        if ( tt_sbit_decoder_load_metrics( decoder, &p, p_limit, 1 ) )\n          goto NoBitmap;\n\n        num_glyphs = FT_NEXT_ULONG( p );\n\n        /* overflow check for p + 2 * num_glyphs */\n        if ( num_glyphs > (FT_ULong)( ( p_limit - p ) >> 1 ) )\n          goto NoBitmap;\n\n        for ( mm = 0; mm < num_glyphs; mm++ )\n        {\n          FT_UInt  gindex = FT_NEXT_USHORT( p );\n\n\n          if ( gindex == glyph_index )\n            break;\n        }\n\n        if ( mm >= num_glyphs )\n          goto NoBitmap;\n\n        image_start = image_size * mm;\n        image_end   = image_start + image_size;\n      }\n      break;\n\n    default:\n      goto NoBitmap;\n    }\n", "func_hash": 28994602925432626900683012190657933065, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-9656", "cve_desc": "The tt_sbit_decoder_load_image function in sfnt/ttsbit.c in FreeType before 2.5.4 does not properly check for an integer overflow, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted OpenType font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-9656"}
{"idx": 204, "project": "savannah", "commit_id": "3774fc08b502c3e685afca098b6e8a195aded6a0", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3774fc08b502c3e685afca098b6e8a195aded6a0", "commit_message": "None", "target": 1, "func": "  ps_parser_to_token( PS_Parser  parser,\n                      T1_Token   token )\n  {\n    FT_Byte*  cur;\n    FT_Byte*  limit;\n    FT_Int    embed;\n\n\n    token->type  = T1_TOKEN_TYPE_NONE;\n    token->start = NULL;\n    token->limit = NULL;\n\n    /* first of all, skip leading whitespace */\n    ps_parser_skip_spaces( parser );\n\n    cur   = parser->cursor;\n    limit = parser->limit;\n\n    if ( cur >= limit )\n      return;\n\n    switch ( *cur )\n    {\n      /************* check for literal string *****************/\n    case '(':\n      token->type  = T1_TOKEN_TYPE_STRING;\n      token->start = cur;\n\n      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for programs/array *****************/\n    case '{':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      token->start = cur;\n\n      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )\n        token->limit = cur;\n      break;\n\n      /************* check for table/array ********************/\n      /* XXX: in theory we should also look for \"<<\"          */\n      /*      since this is semantically equivalent to \"[\";   */\n      /*      in practice it doesn't matter (?)               */\n    case '[':\n      token->type  = T1_TOKEN_TYPE_ARRAY;\n      embed        = 1;\n      token->start = cur++;\n\n      /* we need this to catch `[ ]' */\n      parser->cursor = cur;\n      ps_parser_skip_spaces( parser );\n      cur = parser->cursor;\n\n      while ( cur < limit && !parser->error )\n      {\n        /* XXX: this is wrong because it does not      */\n        /*      skip comments, procedures, and strings */\n        if ( *cur == '[' )\n          embed++;\n        else if ( *cur == ']' )\n        {\n          embed--;\n          if ( embed <= 0 )\n          {\n            token->limit = ++cur;\n            break;\n          }\n        }\n\n        parser->cursor = cur;\n        ps_parser_skip_PS_token( parser );\n        /* we need this to catch `[XXX ]' */\n        ps_parser_skip_spaces  ( parser );\n        cur = parser->cursor;\n      }\n      break;\n\n      /* ************ otherwise, it is any token **************/\n    default:\n      token->start = cur;\n      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;\n      ps_parser_skip_PS_token( parser );\n      cur = parser->cursor;\n      if ( !parser->error )\n        token->limit = cur;\n    }\n\n    if ( !token->limit )\n    {\n      token->start = NULL;\n      token->type  = T1_TOKEN_TYPE_NONE;\n    }\n\n    parser->cursor = cur;\n  }\n\n\n  /* NB: `tokens' can be NULL if we only want to count */\n  /* the number of array elements                      */\n\n  FT_LOCAL_DEF( void )\n  ps_parser_to_token_array( PS_Parser  parser,\n                            T1_Token   tokens,\n                            FT_UInt    max_tokens,\n                            FT_Int*    pnum_tokens )\n  {\n    T1_TokenRec  master;\n\n\n    *pnum_tokens = -1;\n\n    /* this also handles leading whitespace */\n    ps_parser_to_token( parser, &master );\n\n    if ( master.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      FT_Byte*  old_cursor = parser->cursor;\n      FT_Byte*  old_limit  = parser->limit;\n      T1_Token  cur        = tokens;\n      T1_Token  limit      = cur + max_tokens;\n\n\n      /* don't include outermost delimiters */\n      parser->cursor = master.start + 1;\n      parser->limit  = master.limit - 1;\n\n      while ( parser->cursor < parser->limit )\n      {\n        T1_TokenRec  token;\n\n\n        ps_parser_to_token( parser, &token );\n        if ( !token.type )\n          break;\n\n        if ( tokens && cur < limit )\n          *cur = token;\n\n        cur++;\n      }\n\n      *pnum_tokens = (FT_Int)( cur - tokens );\n\n      parser->cursor = old_cursor;\n      parser->limit  = old_limit;\n    }\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `coords' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_coords'            */\n\n  static FT_Int\n  ps_tocoordarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_coords,\n                   FT_Short*  coords )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* check for the beginning of an array; otherwise, only one number */\n    /* will be read                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the coordinates */\n    while ( cur < limit )\n    {\n      FT_Short  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( coords && count >= max_coords )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( coords ? &coords[count] : &dummy ) =\n        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n  /* first character must be a delimiter or a part of a number */\n  /* NB: `values' can be NULL if we just want to skip the      */\n  /*     array; in this case we ignore `max_values'            */\n  /*                                                           */\n  /* return number of successfully parsed values               */\n\n  static FT_Int\n  ps_tofixedarray( FT_Byte*  *acur,\n                   FT_Byte*   limit,\n                   FT_Int     max_values,\n                   FT_Fixed*  values,\n                   FT_Int     power_ten )\n  {\n    FT_Byte*  cur   = *acur;\n    FT_Int    count = 0;\n    FT_Byte   c, ender;\n\n\n    if ( cur >= limit )\n      goto Exit;\n\n    /* Check for the beginning of an array.  Otherwise, only one number */\n    /* will be read.                                                    */\n    c     = *cur;\n    ender = 0;\n\n    if ( c == '[' )\n      ender = ']';\n    else if ( c == '{' )\n      ender = '}';\n\n    if ( ender )\n      cur++;\n\n    /* now, read the values */\n    while ( cur < limit )\n    {\n      FT_Fixed  dummy;\n      FT_Byte*  old_cur;\n\n\n      /* skip whitespace in front of data */\n      skip_spaces( &cur, limit );\n      if ( cur >= limit )\n        goto Exit;\n\n      if ( *cur == ender )\n      {\n        cur++;\n        break;\n      }\n\n      old_cur = cur;\n\n      if ( values && count >= max_values )\n        break;\n\n      /* call PS_Conv_ToFixed() even if coords == NULL */\n      /* to properly parse number at `cur'             */\n      *( values ? &values[count] : &dummy ) =\n        PS_Conv_ToFixed( &cur, limit, power_ten );\n\n      if ( old_cur == cur )\n      {\n        count = -1;\n        goto Exit;\n      }\n      else\n        count++;\n\n      if ( !ender )\n        break;\n    }\n\n  Exit:\n    *acur = cur;\n    return count;\n  }\n\n\n#if 0\n\n  static FT_String*\n  ps_tostring( FT_Byte**  cursor,\n               FT_Byte*   limit,\n               FT_Memory  memory )\n  {\n    FT_Byte*    cur = *cursor;\n    FT_UInt     len = 0;\n    FT_Int      count;\n    FT_String*  result;\n    FT_Error    error;\n\n\n    /* XXX: some stupid fonts have a `Notice' or `Copyright' string     */\n    /*      that simply doesn't begin with an opening parenthesis, even */\n    /*      though they have a closing one!  E.g. \"amuncial.pfb\"        */\n    /*                                                                  */\n    /*      We must deal with these ill-fated cases there.  Note that   */\n    /*      these fonts didn't work with the old Type 1 driver as the   */\n    /*      notice/copyright was not recognized as a valid string token */\n    /*      and made the old token parser commit errors.                */\n\n    while ( cur < limit && ( *cur == ' ' || *cur == '\\t' ) )\n      cur++;\n    if ( cur + 1 >= limit )\n      return 0;\n\n    if ( *cur == '(' )\n      cur++;  /* skip the opening parenthesis, if there is one */\n\n    *cursor = cur;\n    count   = 0;\n\n    /* then, count its length */\n    for ( ; cur < limit; cur++ )\n    {\n      if ( *cur == '(' )\n        count++;\n\n      else if ( *cur == ')' )\n      {\n        count--;\n        if ( count < 0 )\n          break;\n      }\n    }\n\n    len = (FT_UInt)( cur - *cursor );\n    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )\n      return 0;\n\n    /* now copy the string */\n    FT_MEM_COPY( result, *cursor, len );\n    result[len] = '\\0';\n    *cursor = cur;\n    return result;\n  }\n\n#endif /* 0 */\n\n\n  static int\n  ps_tobool( FT_Byte*  *acur,\n             FT_Byte*   limit )\n  {\n    FT_Byte*  cur    = *acur;\n    FT_Bool   result = 0;\n\n\n    /* return 1 if we find `true', 0 otherwise */\n    if ( cur + 3 < limit &&\n         cur[0] == 't'   &&\n         cur[1] == 'r'   &&\n         cur[2] == 'u'   &&\n         cur[3] == 'e'   )\n    {\n      result = 1;\n      cur   += 5;\n    }\n    else if ( cur + 4 < limit &&\n              cur[0] == 'f'   &&\n              cur[1] == 'a'   &&\n              cur[2] == 'l'   &&\n              cur[3] == 's'   &&\n              cur[4] == 'e'   )\n    {\n      result = 0;\n      cur   += 6;\n    }\n\n    *acur = cur;\n    return result;\n  }\n\n\n  /* load a simple field (i.e. non-table) into the current list of objects */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field( PS_Parser       parser,\n                        const T1_Field  field,\n                        void**          objects,\n                        FT_UInt         max_objects,\n                        FT_ULong*       pflags )\n  {\n    T1_TokenRec   token;\n    FT_Byte*      cur;\n    FT_Byte*      limit;\n    FT_UInt       count;\n    FT_UInt       idx;\n    FT_Error      error;\n    T1_FieldType  type;\n\n\n    /* this also skips leading whitespace */\n    ps_parser_to_token( parser, &token );\n    if ( !token.type )\n      goto Fail;\n\n    count = 1;\n    idx   = 0;\n    cur   = token.start;\n    limit = token.limit;\n\n    type = field->type;\n\n    /* we must detect arrays in /FontBBox */\n    if ( type == T1_FIELD_TYPE_BBOX )\n    {\n      T1_TokenRec  token2;\n      FT_Byte*     old_cur   = parser->cursor;\n      FT_Byte*     old_limit = parser->limit;\n\n\n      /* don't include delimiters */\n      parser->cursor = token.start + 1;\n      parser->limit  = token.limit - 1;\n\n      ps_parser_to_token( parser, &token2 );\n      parser->cursor = old_cur;\n      parser->limit  = old_limit;\n\n      if ( token2.type == T1_TOKEN_TYPE_ARRAY )\n      {\n        type = T1_FIELD_TYPE_MM_BBOX;\n        goto FieldArray;\n      }\n    }\n    else if ( token.type == T1_TOKEN_TYPE_ARRAY )\n    {\n      count = max_objects;\n\n    FieldArray:\n      /* if this is an array and we have no blend, an error occurs */\n      if ( max_objects == 0 )\n        goto Fail;\n\n      idx = 1;\n\n      /* don't include delimiters */\n      cur++;\n      limit--;\n    }\n\n    for ( ; count > 0; count--, idx++ )\n    {\n      FT_Byte*    q      = (FT_Byte*)objects[idx] + field->offset;\n      FT_Long     val;\n      FT_String*  string = NULL;\n\n\n      skip_spaces( &cur, limit );\n\n      switch ( type )\n      {\n      case T1_FIELD_TYPE_BOOL:\n        val = ps_tobool( &cur, limit );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED:\n        val = PS_Conv_ToFixed( &cur, limit, 0 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_FIXED_1000:\n        val = PS_Conv_ToFixed( &cur, limit, 3 );\n        goto Store_Integer;\n\n      case T1_FIELD_TYPE_INTEGER:\n        val = PS_Conv_ToInt( &cur, limit );\n        /* fall through */\n\n      Store_Integer:\n        switch ( field->size )\n        {\n        case (8 / FT_CHAR_BIT):\n          *(FT_Byte*)q = (FT_Byte)val;\n          break;\n\n        case (16 / FT_CHAR_BIT):\n          *(FT_UShort*)q = (FT_UShort)val;\n          break;\n\n        case (32 / FT_CHAR_BIT):\n          *(FT_UInt32*)q = (FT_UInt32)val;\n          break;\n\n        default:                /* for 64-bit systems */\n          *(FT_Long*)q = val;\n        }\n        break;\n\n      case T1_FIELD_TYPE_STRING:\n      case T1_FIELD_TYPE_KEY:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_UInt    len    = (FT_UInt)( limit - cur );\n\n\n          if ( cur >= limit )\n            break;\n\n          /* we allow both a string or a name   */\n          /* for cases like /FontName (foo) def */\n          if ( token.type == T1_TOKEN_TYPE_KEY )\n          {\n            /* don't include leading `/' */\n            len--;\n            cur++;\n          }\n          else if ( token.type == T1_TOKEN_TYPE_STRING )\n          {\n            /* don't include delimiting parentheses    */\n            /* XXX we don't handle <<...>> here        */\n            /* XXX should we convert octal escapes?    */\n            /*     if so, what encoding should we use? */\n            cur++;\n            len -= 2;\n          }\n          else\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected a name or string\\n\"\n                       \"                     \"\n                       \" but found token of type %d instead\\n\",\n                       token.type ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          /* for this to work (FT_String**)q must have been */\n          /* initialized to NULL                            */\n          if ( *(FT_String**)q )\n          {\n            FT_TRACE0(( \"ps_parser_load_field: overwriting field %s\\n\",\n                        field->ident ));\n            FT_FREE( *(FT_String**)q );\n            *(FT_String**)q = NULL;\n          }\n\n          if ( FT_ALLOC( string, len + 1 ) )\n            goto Exit;\n\n          FT_MEM_COPY( string, cur, len );\n          string[len] = 0;\n\n          *(FT_String**)q = string;\n        }\n        break;\n\n      case T1_FIELD_TYPE_BBOX:\n        {\n          FT_Fixed  temp[4];\n          FT_BBox*  bbox = (FT_BBox*)q;\n          FT_Int    result;\n\n\n          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );\n\n          if ( result < 4 )\n          {\n            FT_ERROR(( \"ps_parser_load_field:\"\n                       \" expected four integers in bounding box\\n\" ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n\n          bbox->xMin = FT_RoundFix( temp[0] );\n          bbox->yMin = FT_RoundFix( temp[1] );\n          bbox->xMax = FT_RoundFix( temp[2] );\n          bbox->yMax = FT_RoundFix( temp[3] );\n        }\n        break;\n\n      case T1_FIELD_TYPE_MM_BBOX:\n        {\n          FT_Memory  memory = parser->memory;\n          FT_Fixed*  temp   = NULL;\n          FT_Int     result;\n          FT_UInt    i;\n\n\n          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )\n            goto Exit;\n\n          for ( i = 0; i < 4; i++ )\n          {\n            result = ps_tofixedarray( &cur, limit, (FT_Int)max_objects,\n                                      temp + i * max_objects, 0 );\n            if ( result < 0 || (FT_UInt)result < max_objects )\n            {\n              FT_ERROR(( \"ps_parser_load_field:\"\n                         \" expected %d integer%s in the %s subarray\\n\"\n                         \"                     \"\n                         \" of /FontBBox in the /Blend dictionary\\n\",\n                         max_objects, max_objects > 1 ? \"s\" : \"\",\n                         i == 0 ? \"first\"\n                                : ( i == 1 ? \"second\"\n                                           : ( i == 2 ? \"third\"\n                                                      : \"fourth\" ) ) ));\n              error = FT_THROW( Invalid_File_Format );\n\n              FT_FREE( temp );\n              goto Exit;\n            }\n\n            skip_spaces( &cur, limit );\n          }\n\n          for ( i = 0; i < max_objects; i++ )\n          {\n            FT_BBox*  bbox = (FT_BBox*)objects[i];\n\n\n            bbox->xMin = FT_RoundFix( temp[i                  ] );\n            bbox->yMin = FT_RoundFix( temp[i +     max_objects] );\n            bbox->xMax = FT_RoundFix( temp[i + 2 * max_objects] );\n            bbox->yMax = FT_RoundFix( temp[i + 3 * max_objects] );\n          }\n\n          FT_FREE( temp );\n        }\n        break;\n\n      default:\n        /* an error occurred */\n        goto Fail;\n      }\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    error = FT_Err_Ok;\n\n  Exit:\n    return error;\n\n  Fail:\n    error = FT_THROW( Invalid_File_Format );\n    goto Exit;\n  }\n\n\n#define T1_MAX_TABLE_ELEMENTS  32\n\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_load_field_table( PS_Parser       parser,\n                              const T1_Field  field,\n                              void**          objects,\n                              FT_UInt         max_objects,\n                              FT_ULong*       pflags )\n  {\n    T1_TokenRec  elements[T1_MAX_TABLE_ELEMENTS];\n    T1_Token     token;\n    FT_Int       num_elements;\n    FT_Error     error = FT_Err_Ok;\n    FT_Byte*     old_cursor;\n    FT_Byte*     old_limit;\n    T1_FieldRec  fieldrec = *(T1_Field)field;\n\n\n    fieldrec.type = T1_FIELD_TYPE_INTEGER;\n    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||\n         field->type == T1_FIELD_TYPE_BBOX        )\n      fieldrec.type = T1_FIELD_TYPE_FIXED;\n\n    ps_parser_to_token_array( parser, elements,\n                              T1_MAX_TABLE_ELEMENTS, &num_elements );\n    if ( num_elements < 0 )\n    {\n      error = FT_ERR( Ignore );\n      goto Exit;\n    }\n    if ( (FT_UInt)num_elements > field->array_max )\n      num_elements = (FT_Int)field->array_max;\n\n    old_cursor = parser->cursor;\n    old_limit  = parser->limit;\n\n    /* we store the elements count if necessary;           */\n    /* we further assume that `count_offset' can't be zero */\n    if ( field->type != T1_FIELD_TYPE_BBOX && field->count_offset != 0 )\n      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =\n        (FT_Byte)num_elements;\n\n    /* we now load each element, adjusting the field.offset on each one */\n    token = elements;\n    for ( ; num_elements > 0; num_elements--, token++ )\n    {\n      parser->cursor = token->start;\n      parser->limit  = token->limit;\n\n      error = ps_parser_load_field( parser,\n                                    &fieldrec,\n                                    objects,\n                                    max_objects,\n                                    0 );\n      if ( error )\n        break;\n\n      fieldrec.offset += fieldrec.size;\n    }\n\n#if 0  /* obsolete -- keep for reference */\n    if ( pflags )\n      *pflags |= 1L << field->flag_bit;\n#else\n    FT_UNUSED( pflags );\n#endif\n\n    parser->cursor = old_cursor;\n    parser->limit  = old_limit;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Long )\n  ps_parser_to_int( PS_Parser  parser )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToInt( &parser->cursor, parser->limit );\n  }\n\n\n  /* first character must be `<' if `delimiters' is non-zero */\n\n  FT_LOCAL_DEF( FT_Error )\n  ps_parser_to_bytes( PS_Parser  parser,\n                      FT_Byte*   bytes,\n                      FT_Offset  max_bytes,\n                      FT_ULong*  pnum_bytes,\n                      FT_Bool    delimiters )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_Byte*  cur;\n\n\n    ps_parser_skip_spaces( parser );\n    cur = parser->cursor;\n\n    if ( cur >= parser->limit )\n      goto Exit;\n\n    if ( delimiters )\n    {\n      if ( *cur != '<' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing starting delimiter `<'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,\n                                          parser->limit,\n                                          bytes,\n                                          max_bytes );\n\n    if ( delimiters )\n    {\n      if ( cur < parser->limit && *cur != '>' )\n      {\n        FT_ERROR(( \"ps_parser_to_bytes: Missing closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      cur++;\n    }\n\n    parser->cursor = cur;\n\n  Exit:\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Fixed )\n  ps_parser_to_fixed( PS_Parser  parser,\n                      FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_coord_array( PS_Parser  parser,\n                            FT_Int     max_coords,\n                            FT_Short*  coords )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tocoordarray( &parser->cursor, parser->limit,\n                            max_coords, coords );\n  }\n\n\n  FT_LOCAL_DEF( FT_Int )\n  ps_parser_to_fixed_array( PS_Parser  parser,\n                            FT_Int     max_values,\n                            FT_Fixed*  values,\n                            FT_Int     power_ten )\n  {\n    ps_parser_skip_spaces( parser );\n    return ps_tofixedarray( &parser->cursor, parser->limit,\n                            max_values, values, power_ten );\n  }\n\n\n#if 0\n\n  FT_LOCAL_DEF( FT_String* )\n  T1_ToString( PS_Parser  parser )\n  {\n    return ps_tostring( &parser->cursor, parser->limit, parser->memory );\n  }\n\n\n  FT_LOCAL_DEF( FT_Bool )\n  T1_ToBool( PS_Parser  parser )\n  {\n    return ps_tobool( &parser->cursor, parser->limit );\n  }\n\n#endif /* 0 */\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_init( PS_Parser  parser,\n                  FT_Byte*   base,\n                  FT_Byte*   limit,\n                  FT_Memory  memory )\n  {\n    parser->error  = FT_Err_Ok;\n    parser->base   = base;\n    parser->limit  = limit;\n    parser->cursor = base;\n    parser->memory = memory;\n    parser->funcs  = ps_parser_funcs;\n  }\n\n\n  FT_LOCAL_DEF( void )\n  ps_parser_done( PS_Parser  parser )\n  {\n    FT_UNUSED( parser );\n  }\n\n\n  /*************************************************************************/\n  /*************************************************************************/\n  /*****                                                               *****/\n  /*****                            T1 BUILDER                         *****/\n  /*****                                                               *****/\n  /*************************************************************************/\n  /*************************************************************************/\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_init                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Initializes a given glyph builder.                                 */\n  /*                                                                       */\n  /* <InOut>                                                               */\n  /*    builder :: A pointer to the glyph builder to initialize.           */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    face    :: The current face object.                                */\n  /*                                                                       */\n  /*    size    :: The current size object.                                */\n  /*                                                                       */\n  /*    glyph   :: The current glyph object.                               */\n  /*                                                                       */\n  /*    hinting :: Whether hinting should be applied.                      */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_init( T1_Builder    builder,\n                   FT_Face       face,\n                   FT_Size       size,\n                   FT_GlyphSlot  glyph,\n                   FT_Bool       hinting )\n  {\n    builder->parse_state = T1_Parse_Start;\n    builder->load_points = 1;\n\n    builder->face   = face;\n    builder->glyph  = glyph;\n    builder->memory = face->memory;\n\n    if ( glyph )\n    {\n      FT_GlyphLoader  loader = glyph->internal->loader;\n\n\n      builder->loader  = loader;\n      builder->base    = &loader->base.outline;\n      builder->current = &loader->current.outline;\n      FT_GlyphLoader_Rewind( loader );\n\n      builder->hints_globals = size->internal;\n      builder->hints_funcs   = NULL;\n\n      if ( hinting )\n        builder->hints_funcs = glyph->internal->glyph_hints;\n    }\n\n    builder->pos_x = 0;\n    builder->pos_y = 0;\n\n    builder->left_bearing.x = 0;\n    builder->left_bearing.y = 0;\n    builder->advance.x      = 0;\n    builder->advance.y      = 0;\n\n    builder->funcs = t1_builder_funcs;\n  }\n\n\n  /*************************************************************************/\n  /*                                                                       */\n  /* <Function>                                                            */\n  /*    t1_builder_done                                                    */\n  /*                                                                       */\n  /* <Description>                                                         */\n  /*    Finalizes a given glyph builder.  Its contents can still be used   */\n  /*    after the call, but the function saves important information       */\n  /*    within the corresponding glyph slot.                               */\n  /*                                                                       */\n  /* <Input>                                                               */\n  /*    builder :: A pointer to the glyph builder to finalize.             */\n  /*                                                                       */\n  FT_LOCAL_DEF( void )\n  t1_builder_done( T1_Builder  builder )\n  {\n    FT_GlyphSlot  glyph = builder->glyph;\n\n\n    if ( glyph )\n      glyph->outline = *builder->base;\n  }\n\n\n  /* check that there is enough space for `count' more points */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_check_points( T1_Builder  builder,\n                           FT_Int      count )\n  {\n    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );\n  }\n\n\n  /* add a new point, do not check space */\n  FT_LOCAL_DEF( void )\n  t1_builder_add_point( T1_Builder  builder,\n                        FT_Pos      x,\n                        FT_Pos      y,\n                        FT_Byte     flag )\n  {\n    FT_Outline*  outline = builder->current;\n\n\n    if ( builder->load_points )\n    {\n      FT_Vector*  point   = outline->points + outline->n_points;\n      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n\n\n      point->x = FIXED_TO_INT( x );\n      point->y = FIXED_TO_INT( y );\n      *control = (FT_Byte)( flag ? FT_CURVE_TAG_ON : FT_CURVE_TAG_CUBIC );\n    }\n    outline->n_points++;\n  }\n\n\n  /* check space for a new on-curve point, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_point1( T1_Builder  builder,\n                         FT_Pos      x,\n                         FT_Pos      y )\n  {\n    FT_Error  error;\n\n\n    error = t1_builder_check_points( builder, 1 );\n    if ( !error )\n      t1_builder_add_point( builder, x, y, 1 );\n\n    return error;\n  }\n\n\n  /* check space for a new contour, then add it */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_add_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Error     error;\n\n\n    /* this might happen in invalid fonts */\n    if ( !outline )\n    {\n      FT_ERROR(( \"t1_builder_add_contour: no outline to add points to\\n\" ));\n      return FT_THROW( Invalid_File_Format );\n    }\n\n    if ( !builder->load_points )\n    {\n      outline->n_contours++;\n      return FT_Err_Ok;\n    }\n\n    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );\n    if ( !error )\n    {\n      if ( outline->n_contours > 0 )\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n\n      outline->n_contours++;\n    }\n\n    return error;\n  }\n\n\n  /* if a path was begun, add its first on-curve point */\n  FT_LOCAL_DEF( FT_Error )\n  t1_builder_start_point( T1_Builder  builder,\n                          FT_Pos      x,\n                          FT_Pos      y )\n  {\n    FT_Error  error = FT_ERR( Invalid_File_Format );\n\n\n    /* test whether we are building a new contour */\n\n    if ( builder->parse_state == T1_Parse_Have_Path )\n      error = FT_Err_Ok;\n    else\n    {\n      builder->parse_state = T1_Parse_Have_Path;\n      error = t1_builder_add_contour( builder );\n      if ( !error )\n        error = t1_builder_add_point1( builder, x, y );\n    }\n\n    return error;\n  }\n\n\n  /* close the current contour */\n  FT_LOCAL_DEF( void )\n  t1_builder_close_contour( T1_Builder  builder )\n  {\n    FT_Outline*  outline = builder->current;\n    FT_Int       first;\n\n\n    if ( !outline )\n      return;\n\n     first = outline->n_contours <= 1\n             ? 0 : outline->contours[outline->n_contours - 2] + 1;\n \n     /* We must not include the last point in the path if it */\n     /* is located on the first point.                       */\n     if ( outline->n_points > 1 )\n      if ( p1->x == p2->x && p1->y == p2->y )\n        if ( *control == FT_CURVE_TAG_ON )\n          outline->n_points--;\n    }\n\n    if ( outline->n_contours > 0 )\n    {\n      /* Don't add contours only consisting of one point, i.e.,  */\n      /* check whether the first and the last point is the same. */\n      if ( first == outline->n_points - 1 )\n      {\n        outline->n_contours--;\n        outline->n_points--;\n      }\n      else\n        outline->contours[outline->n_contours - 1] =\n          (short)( outline->n_points - 1 );\n    }\n  }\n", "func_hash": 328688916561979850895211877372718866822, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-8287", "cve_desc": "FreeType 2 before 2017-03-26 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_builder_close_contour function in psaux/psobjs.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-8287"}
{"idx": 216, "project": "savannah", "commit_id": "94e01571507835ff59dd8ce2a0b56a4b566965a4", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commit;h=94e01571507835ff59dd8ce2a0b56a4b566965a4", "commit_message": "None", "target": 1, "func": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n   return 0;\n }\n", "func_hash": 85463602567582995767126053202641542542, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-7476", "cve_desc": "Gnulib before 2017-04-26 has a heap-based buffer overflow with the TZ environment variable. The error is in the save_abbr function in time_rz.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-7476"}
{"idx": 217, "project": "savannah", "commit_id": "59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=59eb9f8cfe7d1df379a2318316d1f04f80fba54a", "commit_message": "None", "target": 1, "func": "  ft_var_readpackedpoints( FT_Stream  stream,\n                           FT_UInt   *point_cnt )\n  {\n    FT_UShort *points;\n    FT_Int     n;\n    FT_Int     runcnt;\n    FT_Int     i;\n     FT_Int     j;\n     FT_Int     first;\n     FT_Memory  memory = stream->memory;\n    FT_Error   error = TT_Err_Ok;\n \n     FT_UNUSED( error );\n \n\n    *point_cnt = n = FT_GET_BYTE();\n    if ( n == 0 )\n      return ALL_POINTS;\n\n    if ( n & GX_PT_POINTS_ARE_WORDS )\n      n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );\n\n    if ( FT_NEW_ARRAY( points, n ) )\n      return NULL;\n\n    i = 0;\n    while ( i < n )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_PT_POINTS_ARE_WORDS )\n      {\n         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n         first  = points[i++] = FT_GET_USHORT();\n \n        if ( runcnt < 1 )\n           goto Exit;\n \n         /* first point not included in runcount */\n        for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_USHORT() );\n      }\n      else\n       {\n         first = points[i++] = FT_GET_BYTE();\n \n        if ( runcnt < 1 )\n           goto Exit;\n \n         for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_BYTE() );\n      }\n    }\n\n  Exit:\n    return points;\n  }\n", "func_hash": 176444419672545527315649492039587951909, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-3855", "cve_desc": "Buffer overflow in the ft_var_readpackedpoints function in truetype/ttgxvar.c in FreeType 2.4.3 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted TrueType GX font.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-3855"}
{"idx": 218, "project": "ghostscript", "commit_id": "39b1e54b2968620723bf32e96764c88797714879", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=39b1e54b2968620723bf32e96764c88797714879", "commit_message": "None", "target": 1, "func": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n \n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n", "func_hash": 334604983653907615489271299004330168271, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10194", "cve_desc": "The set_text_distance function in devices/vector/gdevpdts.c in the pdfwrite component in Artifex Ghostscript through 9.22 does not prevent overflows in text-positioning calculation, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PDF document.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10194"}
{"idx": 219, "project": "haproxy", "commit_id": "3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "project_url": "https://github.com/haproxy/haproxy", "commit_url": "http://git.haproxy.org/?p=haproxy.git;a=commitdiff;h=3f0e1ec70173593f4c2b3681b26c04a4ed5fc588", "commit_message": "BUG/CRITICAL: h2: fix incorrect frame length check\n\nThe incoming H2 frame length was checked against the max_frame_size\nsetting instead of being checked against the bufsize. The max_frame_size\nonly applies to outgoing traffic and not to incoming one, so if a large\nenough frame size is advertised in the SETTINGS frame, a wrapped frame\nwill be defragmented into a temporary allocated buffer where the second\nfragment my overflow the heap by up to 16 kB.\n\nIt is very unlikely that this can be exploited for code execution given\nthat buffers are very short lived and their address not realistically\npredictable in production, but the likeliness of an immediate crash is\nabsolutely certain.\n\nThis fix must be backported to 1.8.\n\nMany thanks to Jordan Zebor from F5 Networks for reporting this issue\nin a responsible way.", "target": 1, "func": "static void h2_process_demux(struct h2c *h2c)\n{\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn;\n\n\tif (unlikely(h2c->st0 < H2_CS_FRAME_H)) {\n\t\tif (h2c->st0 == H2_CS_PREFACE) {\n\t\t\tif (unlikely(h2c_frt_recv_preface(h2c) <= 0)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\th2c->max_id = 0;\n\t\t\th2c->st0 = H2_CS_SETTINGS1;\n\t\t}\n\n\t\tif (h2c->st0 == H2_CS_SETTINGS1) {\n\t\t\tstruct h2_fh hdr;\n\n\t\t\t/* ensure that what is pending is a valid SETTINGS frame\n\t\t\t * without an ACK.\n\t\t\t */\n\t\t\tif (!h2_get_frame_hdr(h2c->dbuf, &hdr)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (hdr.sid || hdr.ft != H2_FT_SETTINGS || hdr.ff & H2_F_SETTINGS_ACK) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_ERROR2;\n                                goto fail;\n                        }\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > h2c->mfs) {\n                                /* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* that's OK, switch to FRAME_P to process it */\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t}\n\t}\n\n\t/* process as many incoming frames as possible below */\n\twhile (h2c->dbuf->i) {\n\t\tint ret = 0;\n\n\t\tif (h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_H) {\n\t\t\tstruct h2_fh hdr;\n\n                        if (!h2_peek_frame_hdr(h2c->dbuf, &hdr))\n                                break;\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > h2c->mfs) {\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR;\n                                break;\n\t\t\t}\n\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t\th2_skip_frame_hdr(h2c->dbuf);\n\t\t}\n\n\t\t/* Only H2_CS_FRAME_P and H2_CS_FRAME_A here */\n\t\th2s = h2c_st_by_id(h2c, h2c->dsi);\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tgoto strm_err;\n\n\t\tif (h2s->st == H2_SS_IDLE &&\n\t\t    h2c->dft != H2_FT_HEADERS && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than HEADERS or PRIORITY in\n\t\t\t * this state MUST be treated as a connection error\n\t\t\t */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\th2c->st0 = H2_CS_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h2s->st == H2_SS_HREM && h2c->dft != H2_FT_WINDOW_UPDATE &&\n\t\t    h2c->dft != H2_FT_RST_STREAM && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than WU/PRIO/RST in\n\t\t\t * this state MUST be treated as a stream error\n\t\t\t */\n\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\t/* Below the management of frames received in closed state is a\n\t\t * bit hackish because the spec makes strong differences between\n\t\t * streams closed by receiving RST, sending RST, and seeing ES\n\t\t * in both directions. In addition to this, the creation of a\n\t\t * new stream reusing the identifier of a closed one will be\n\t\t * detected here. Given that we cannot keep track of all closed\n\t\t * streams forever, we consider that unknown closed streams were\n\t\t * closed on RST received, which allows us to respond with an\n\t\t * RST without breaking the connection (eg: to abort a transfer).\n\t\t * Some frames have to be silently ignored as well.\n\t\t */\n\t\tif (h2s->st == H2_SS_CLOSED && h2c->dsi) {\n\t\t\tif (h2c->dft == H2_FT_HEADERS || h2c->dft == H2_FT_PUSH_PROMISE) {\n\t\t\t\t/* #5.1.1: The identifier of a newly\n\t\t\t\t * established stream MUST be numerically\n\t\t\t\t * greater than all streams that the initiating\n\t\t\t\t * endpoint has opened or reserved. This\n\t\t\t\t * governs streams that are opened using a\n\t\t\t\t * HEADERS frame and streams that are reserved\n\t\t\t\t * using PUSH_PROMISE. An endpoint that\n\t\t\t\t * receives an unexpected stream identifier\n\t\t\t\t * MUST respond with a connection error.\n\t\t\t\t */\n\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\tif (h2s->flags & H2_SF_RST_RCVD) {\n\t\t\t\t/* RFC7540#5.1:closed: an endpoint that\n\t\t\t\t * receives any frame other than PRIORITY after\n\t\t\t\t * receiving a RST_STREAM MUST treat that as a\n\t\t\t\t * stream error of type STREAM_CLOSED.\n\t\t\t\t *\n\t\t\t\t * Note that old streams fall into this category\n\t\t\t\t * and will lead to an RST being sent.\n\t\t\t\t */\n\t\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\t/* RFC7540#5.1:closed: if this state is reached as a\n\t\t\t * result of sending a RST_STREAM frame, the peer that\n\t\t\t * receives the RST_STREAM might have already sent\n\t\t\t * frames on the stream that cannot be withdrawn. An\n\t\t\t * endpoint MUST ignore frames that it receives on\n\t\t\t * closed streams after it has sent a RST_STREAM\n\t\t\t * frame. An endpoint MAY choose to limit the period\n\t\t\t * over which it ignores frames and treat frames that\n\t\t\t * arrive after this time as being in error.\n\t\t\t */\n\t\t\tif (!(h2s->flags & H2_SF_RST_SENT)) {\n\t\t\t\t/* RFC7540#5.1:closed: any frame other than\n\t\t\t\t * PRIO/WU/RST in this state MUST be treated as\n\t\t\t\t * a connection error\n\t\t\t\t */\n\t\t\t\tif (h2c->dft != H2_FT_RST_STREAM &&\n\t\t\t\t    h2c->dft != H2_FT_PRIORITY &&\n\t\t\t\t    h2c->dft != H2_FT_WINDOW_UPDATE) {\n\t\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\t\tgoto strm_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if 0\n\n\t\t/* graceful shutdown, ignore streams whose ID is higher than\n\t\t * the one advertised in GOAWAY. RFC7540#6.8.\n\t\t */\n\t\tif (unlikely(h2c->last_sid >= 0) && h2c->dsi > h2c->last_sid) {\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t\tgoto strm_err;\n\t\t}\n#endif\n\n\t\tswitch (h2c->dft) {\n\t\tcase H2_FT_SETTINGS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_settings(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_settings(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PING:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_ping(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_ping(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_WINDOW_UPDATE:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_window_update(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_CONTINUATION:\n\t\t\t/* we currently don't support CONTINUATION frames since\n\t\t\t * we have nowhere to store the partial HEADERS frame.\n\t\t\t * Let's abort the stream on an INTERNAL_ERROR here.\n\t\t\t */\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P) {\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase H2_FT_HEADERS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_headers(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_DATA:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_data(h2c, h2s);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_send_strm_wu(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PRIORITY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_priority(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_RST_STREAM:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_rst_stream(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_GOAWAY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_goaway(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PUSH_PROMISE:\n\t\t\t/* not permitted here, RFC7540#5.1 */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\tbreak;\n\n\t\t\t/* implement all extra frame types here */\n\t\tdefault:\n\t\t\t/* drop frames that we ignore. They may be larger than\n\t\t\t * the buffer so we drain all of their contents until\n\t\t\t * we reach the end.\n\t\t\t */\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t}\n\n\tstrm_err:\n\t\t/* We may have to send an RST if not done yet */\n\t\tif (h2s->st == H2_SS_ERROR)\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tret = h2c_send_rst_stream(h2c, h2s);\n\n\t\t/* error or missing data condition met above ? */\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 != H2_CS_FRAME_H) {\n\t\t\tbi_del(h2c->dbuf, h2c->dfl);\n\t\t\th2c->st0 = H2_CS_FRAME_H;\n\t\t}\n\t}\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM)))\n\t\th2c_send_conn_wu(h2c);\n\n fail:\n\t/* we can go here on missing data, blocked response or error */\n\treturn;\n}\n", "func_hash": 197791135802871490452896068201538076195, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2018-10184", "cve_desc": "An issue was discovered in HAProxy before 1.8.8. The incoming H2 frame length was checked against the max_frame_size setting instead of being checked against the bufsize. The max_frame_size only applies to outgoing traffic and not to incoming, so if a large enough frame size is advertised in the SETTINGS frame, a wrapped frame will be defragmented into a temporary allocated buffer where the second fragment may overflow the heap by up to 16 kB. It is very unlikely that this can be exploited for code execution given that buffers are very short lived and their addresses not realistically predictable in production, but the likelihood of an immediate crash is absolutely certain.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-10184"}
{"idx": 223, "project": "libXvMC", "commit_id": "2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXvMC/commit/?id=2cd95e7da8367cccdcdd5c9b160012d1dec5cbdb", "commit_message": "None", "target": 1, "func": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n", "func_hash": 225773238597816987128397211875317401076, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-7953", "cve_desc": "Buffer underflow in X.org libXvMC before 1.0.10 allows remote X servers to have unspecified impact via an empty string.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-7953"}
{"idx": 233, "project": "tartarus", "commit_id": "4ff22863d895cb7ebfced4cf923a012a614adaa8", "project_url": "https://git.tartarus.org/?p=simon/putty", "commit_url": "https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=4ff22863d895cb7ebfced4cf923a012a614adaa8", "commit_message": "None", "target": 1, "func": "static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)\n{\n    int i;\n    struct ssh_channel *c;\n\n    if (enable == ssh->throttled_all)\n\treturn;\n    ssh->throttled_all = enable;\n    ssh->overall_bufsize = bufsize;\n    if (!ssh->channels)\n\treturn;\n    for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {\n\tswitch (c->type) {\n\t  case CHAN_MAINSESSION:\n\t    /*\n\t     * This is treated separately, outside the switch.\n\t     */\n\t    break;\n            x11_override_throttle(c->u.x11.xconn, enable);\n            break;\n          case CHAN_AGENT:\n           /* Agent channels require no buffer management. */\n            break;\n          case CHAN_SOCKDATA:\n            pfd_override_throttle(c->u.pfd.pf, enable);\n\nstatic void ssh_agent_callback(void *sshv, void *reply, int replylen)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->auth_agent_query = NULL;\n\n    ssh->agent_response = reply;\n    ssh->agent_response_len = replylen;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_authconn(ssh, NULL, -1, NULL);\n}\n\nstatic void ssh_dialog_callback(void *sshv, int ret)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->user_response = ret;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    /*\n     * This may have unfrozen the SSH connection, so do a\n     * queued-data run.\n     */\n    ssh_process_queued_incoming_data(ssh);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n     ssh_process_queued_incoming_data(ssh);\n }\n \nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n {\n    struct ssh_channel *c = (struct ssh_channel *)cv;\n    const void *sentreply = reply;\n     c->u.a.pending = NULL;\n    c->u.a.outstanding_requests--;\n    if (!sentreply) {\n       /* Fake SSH_AGENT_FAILURE. */\n       sentreply = \"\\0\\0\\0\\1\\5\";\n        replylen = 5;\n     }\n    ssh_send_channel_data(c, sentreply, replylen);\n    if (reply)\n       sfree(reply);\n     /*\n     * If we've already seen an incoming EOF but haven't sent an\n     * outgoing one, this may be the moment to send it.\n      */\n    if (c->u.a.outstanding_requests == 0 && (c->closes & CLOSES_RCVD_EOF))\n         sshfwd_write_eof(c);\n }\n \n /*\n  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'\n  * non-NULL, otherwise just close the connection. `client_reason' == NULL\n\t\t\t struct Packet *pktin)\n{\n    int i, j, ret;\n    unsigned char cookie[8], *ptr;\n    struct MD5Context md5c;\n    struct do_ssh1_login_state {\n\tint crLine;\n\tint len;\n\tunsigned char *rsabuf;\n        const unsigned char *keystr1, *keystr2;\n\tunsigned long supported_ciphers_mask, supported_auths_mask;\n\tint tried_publickey, tried_agent;\n\tint tis_auth_refused, ccard_auth_refused;\n\tunsigned char session_id[16];\n\tint cipher_type;\n\tvoid *publickey_blob;\n\tint publickey_bloblen;\n\tchar *publickey_comment;\n\tint privatekey_available, privatekey_encrypted;\n\tprompts_t *cur_prompt;\n\tchar c;\n\tint pwpkt_type;\n\tunsigned char request[5], *response, *p;\n\tint responselen;\n\tint keyi, nkeys;\n\tint authed;\n\tstruct RSAKey key;\n\tBignum challenge;\n\tchar *commentp;\n\tint commentlen;\n        int dlgret;\n\tFilename *keyfile;\n        struct RSAKey servkey, hostkey;\n    };\n    crState(do_ssh1_login_state);\n\n    crBeginState;\n\n    if (!pktin)\n\tcrWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_PUBLIC_KEY) {\n\tbombout((\"Public key packet not received\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Received public keys\");\n\n    ptr = ssh_pkt_getdata(pktin, 8);\n    if (!ptr) {\n\tbombout((\"SSH-1 public key packet stopped before random cookie\"));\n\tcrStop(0);\n    }\n    memcpy(cookie, ptr, 8);\n\n    if (!ssh1_pkt_getrsakey(pktin, &s->servkey, &s->keystr1) ||\n\t!ssh1_pkt_getrsakey(pktin, &s->hostkey, &s->keystr2)) {\t\n\tbombout((\"Failed to read SSH-1 public keys from public key packet\"));\n\tcrStop(0);\n    }\n\n    /*\n     * Log the host key fingerprint.\n     */\n    {\n\tchar logmsg[80];\n\tlogevent(\"Host key fingerprint is:\");\n\tstrcpy(logmsg, \"      \");\n\ts->hostkey.comment = NULL;\n\trsa_fingerprint(logmsg + strlen(logmsg),\n\t\t\tsizeof(logmsg) - strlen(logmsg), &s->hostkey);\n\tlogevent(logmsg);\n    }\n\n    ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);\n    s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);\n    s->supported_auths_mask = ssh_pkt_getuint32(pktin);\n    if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))\n\ts->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);\n\n    ssh->v1_local_protoflags =\n\tssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;\n    ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;\n\n    MD5Init(&md5c);\n    MD5Update(&md5c, s->keystr2, s->hostkey.bytes);\n    MD5Update(&md5c, s->keystr1, s->servkey.bytes);\n    MD5Update(&md5c, cookie, 8);\n    MD5Final(s->session_id, &md5c);\n\n    for (i = 0; i < 32; i++)\n\tssh->session_key[i] = random_byte();\n\n    /*\n     * Verify that the `bits' and `bytes' parameters match.\n     */\n    if (s->hostkey.bits > s->hostkey.bytes * 8 ||\n\ts->servkey.bits > s->servkey.bytes * 8) {\n\tbombout((\"SSH-1 public keys were badly formatted\"));\n\tcrStop(0);\n    }\n\n    s->len = (s->hostkey.bytes > s->servkey.bytes ?\n              s->hostkey.bytes : s->servkey.bytes);\n\n    s->rsabuf = snewn(s->len, unsigned char);\n\n    /*\n     * Verify the host key.\n     */\n    {\n\t/*\n\t * First format the key into a string.\n\t */\n\tint len = rsastr_len(&s->hostkey);\n\tchar fingerprint[100];\n\tchar *keystr = snewn(len, char);\n\trsastr_fmt(keystr, &s->hostkey);\n\trsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);\n\n        /* First check against manually configured host keys. */\n        s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);\n        if (s->dlgret == 0) {          /* did not match */\n            bombout((\"Host key did not appear in manually configured list\"));\n            sfree(keystr);\n            crStop(0);\n        } else if (s->dlgret < 0) { /* none configured; use standard handling */\n            ssh_set_frozen(ssh, 1);\n            s->dlgret = verify_ssh_host_key(ssh->frontend,\n                                            ssh->savedhost, ssh->savedport,\n                                            \"rsa\", keystr, fingerprint,\n                                            ssh_dialog_callback, ssh);\n            sfree(keystr);\n#ifdef FUZZING\n\t    s->dlgret = 1;\n#endif\n            if (s->dlgret < 0) {\n                do {\n                    crReturn(0);\n                    if (pktin) {\n                        bombout((\"Unexpected data from server while waiting\"\n                                 \" for user host key response\"));\n                        crStop(0);\n                    }\n                } while (pktin || inlen > 0);\n                s->dlgret = ssh->user_response;\n            }\n            ssh_set_frozen(ssh, 0);\n\n            if (s->dlgret == 0) {\n                ssh_disconnect(ssh, \"User aborted at host key verification\",\n                               NULL, 0, TRUE);\n                crStop(0);\n            }\n        } else {\n            sfree(keystr);\n        }\n    }\n\n    for (i = 0; i < 32; i++) {\n\ts->rsabuf[i] = ssh->session_key[i];\n\tif (i < 16)\n\t    s->rsabuf[i] ^= s->session_id[i];\n    }\n\n    if (s->hostkey.bytes > s->servkey.bytes) {\n\tret = rsaencrypt(s->rsabuf, 32, &s->servkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);\n    } else {\n\tret = rsaencrypt(s->rsabuf, 32, &s->hostkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);\n    }\n    if (!ret) {\n\tbombout((\"SSH-1 public key encryptions failed due to bad formatting\"));\n\tcrStop(0);\t\n    }\n\n    logevent(\"Encrypted session key\");\n\n    {\n\tint cipher_chosen = 0, warn = 0;\n\tconst char *cipher_string = NULL;\n\tint i;\n\tfor (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {\n\t    int next_cipher = conf_get_int_int(ssh->conf,\n\t\t\t\t\t       CONF_ssh_cipherlist, i);\n\t    if (next_cipher == CIPHER_WARN) {\n\t\t/* If/when we choose a cipher, warn about it */\n\t\twarn = 1;\n\t    } else if (next_cipher == CIPHER_AES) {\n\t\t/* XXX Probably don't need to mention this. */\n\t\tlogevent(\"AES not supported in SSH-1, skipping\");\n\t    } else {\n\t\tswitch (next_cipher) {\n\t\t  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;\n\t\t\t\t\tcipher_string = \"3DES\"; break;\n\t\t  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;\n\t\t\t\t\tcipher_string = \"Blowfish\"; break;\n\t\t  case CIPHER_DES:\ts->cipher_type = SSH_CIPHER_DES;\n\t\t\t\t\tcipher_string = \"single-DES\"; break;\n\t\t}\n\t\tif (s->supported_ciphers_mask & (1 << s->cipher_type))\n\t\t    cipher_chosen = 1;\n\t    }\n\t}\n\tif (!cipher_chosen) {\n\t    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)\n\t\tbombout((\"Server violates SSH-1 protocol by not \"\n\t\t\t \"supporting 3DES encryption\"));\n\t    else\n\t\t/* shouldn't happen */\n\t\tbombout((\"No supported ciphers found\"));\n\t    crStop(0);\n\t}\n\n\t/* Warn about chosen cipher if necessary. */\n\tif (warn) {\n            ssh_set_frozen(ssh, 1);\n\t    s->dlgret = askalg(ssh->frontend, \"cipher\", cipher_string,\n\t\t\t       ssh_dialog_callback, ssh);\n\t    if (s->dlgret < 0) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for user response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\ts->dlgret = ssh->user_response;\n\t    }\n            ssh_set_frozen(ssh, 0);\n\t    if (s->dlgret == 0) {\n\t\tssh_disconnect(ssh, \"User aborted at cipher warning\", NULL,\n\t\t\t       0, TRUE);\n\t\tcrStop(0);\n\t    }\n        }\n    }\n\n    switch (s->cipher_type) {\n      case SSH_CIPHER_3DES:\n\tlogevent(\"Using 3DES encryption\");\n\tbreak;\n      case SSH_CIPHER_DES:\n\tlogevent(\"Using single-DES encryption\");\n\tbreak;\n      case SSH_CIPHER_BLOWFISH:\n\tlogevent(\"Using Blowfish encryption\");\n\tbreak;\n    }\n\n    send_packet(ssh, SSH1_CMSG_SESSION_KEY,\n\t\tPKT_CHAR, s->cipher_type,\n\t\tPKT_DATA, cookie, 8,\n\t\tPKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,\n\t\tPKT_DATA, s->rsabuf, s->len,\n\t\tPKT_INT, ssh->v1_local_protoflags, PKT_END);\n\n    logevent(\"Trying to enable encryption...\");\n\n    sfree(s->rsabuf);\n\n    ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :\n\t\t   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :\n\t\t   &ssh_3des);\n    ssh->v1_cipher_ctx = ssh->cipher->make_context();\n    ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);\n    logeventf(ssh, \"Initialised %s encryption\", ssh->cipher->text_name);\n\n    ssh->crcda_ctx = crcda_make_context();\n    logevent(\"Installing CRC compensation attack detector\");\n\n    if (s->servkey.modulus) {\n\tsfree(s->servkey.modulus);\n\ts->servkey.modulus = NULL;\n    }\n    if (s->servkey.exponent) {\n\tsfree(s->servkey.exponent);\n\ts->servkey.exponent = NULL;\n    }\n    if (s->hostkey.modulus) {\n\tsfree(s->hostkey.modulus);\n\ts->hostkey.modulus = NULL;\n    }\n    if (s->hostkey.exponent) {\n\tsfree(s->hostkey.exponent);\n\ts->hostkey.exponent = NULL;\n    }\n    crWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_SUCCESS) {\n\tbombout((\"Encryption not successfully enabled\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Successfully started encryption\");\n\n    fflush(stdout); /* FIXME eh? */\n    {\n\tif ((ssh->username = get_remote_username(ssh->conf)) == NULL) {\n\t    int ret; /* need not be kept over crReturn */\n\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH login name\");\n\t    add_prompt(s->cur_prompt, dupstr(\"login as: \"), TRUE);\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a username. Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, \"No username provided\", NULL, 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);\n\t    free_prompts(s->cur_prompt);\n\t}\n\n\tsend_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);\n\t{\n\t    char *userlog = dupprintf(\"Sent username \\\"%s\\\"\", ssh->username);\n\t    logevent(userlog);\n\t    if (flags & FLAG_INTERACTIVE &&\n\t\t(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {\n\t\tc_write_str(ssh, userlog);\n\t\tc_write_str(ssh, \"\\r\\n\");\n\t    }\n\t    sfree(userlog);\n\t}\n    }\n\n    crWaitUntil(pktin);\n\n    if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {\n\t/* We must not attempt PK auth. Pretend we've already tried it. */\n\ts->tried_publickey = s->tried_agent = 1;\n    } else {\n\ts->tried_publickey = s->tried_agent = 0;\n    }\n    s->tis_auth_refused = s->ccard_auth_refused = 0;\n    /*\n     * Load the public half of any configured keyfile for later use.\n     */\n    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n    if (!filename_is_null(s->keyfile)) {\n\tint keytype;\n\tlogeventf(ssh, \"Reading key file \\\"%.150s\\\"\",\n\t\t  filename_to_str(s->keyfile));\n\tkeytype = key_type(s->keyfile);\n\tif (keytype == SSH_KEYTYPE_SSH1 ||\n            keytype == SSH_KEYTYPE_SSH1_PUBLIC) {\n\t    const char *error;\n\t    if (rsakey_pubblob(s->keyfile,\n\t\t\t       &s->publickey_blob, &s->publickey_bloblen,\n\t\t\t       &s->publickey_comment, &error)) {\n                s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);\n                if (!s->privatekey_available)\n                    logeventf(ssh, \"Key file contains public key only\");\n\t\ts->privatekey_encrypted = rsakey_encrypted(s->keyfile,\n                                                           NULL);\n\t    } else {\n\t\tchar *msgbuf;\n\t\tlogeventf(ssh, \"Unable to load key (%s)\", error);\n\t\tmsgbuf = dupprintf(\"Unable to load key file \"\n\t\t\t\t   \"\\\"%.150s\\\" (%s)\\r\\n\",\n\t\t\t\t   filename_to_str(s->keyfile),\n\t\t\t\t   error);\n\t\tc_write_str(ssh, msgbuf);\n\t\tsfree(msgbuf);\n\t\ts->publickey_blob = NULL;\n\t    }\n\t} else {\n\t    char *msgbuf;\n\t    logeventf(ssh, \"Unable to use this key file (%s)\",\n\t\t      key_type_to_str(keytype));\n\t    msgbuf = dupprintf(\"Unable to use key file \\\"%.150s\\\"\"\n\t\t\t       \" (%s)\\r\\n\",\n\t\t\t       filename_to_str(s->keyfile),\n\t\t\t       key_type_to_str(keytype));\n\t    c_write_str(ssh, msgbuf);\n\t    sfree(msgbuf);\n\t    s->publickey_blob = NULL;\n\t}\n    } else\n\ts->publickey_blob = NULL;\n\n    while (pktin->type == SSH1_SMSG_FAILURE) {\n\ts->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;\n\n\tif (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {\n\t    /*\n\t     * Attempt RSA authentication using Pageant.\n\t     */\n\t    void *r;\n\n\t    s->authed = FALSE;\n\t    s->tried_agent = 1;\n\t    logevent(\"Pageant is running. Requesting keys.\");\n\n\t    /* Request the keys held by the agent. */\n\t    PUT_32BIT(s->request, 1);\n\t    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;\n            ssh->auth_agent_query = agent_query(\n                s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);\n\t    if (ssh->auth_agent_query) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for agent response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\tr = ssh->agent_response;\n\t\ts->responselen = ssh->agent_response_len;\n\t    }\n\t    s->response = (unsigned char *) r;\n\t    if (s->response && s->responselen >= 5 &&\n\t\ts->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {\n\t\ts->p = s->response + 5;\n\t\ts->nkeys = toint(GET_32BIT(s->p));\n                if (s->nkeys < 0) {\n                    logeventf(ssh, \"Pageant reported negative key count %d\",\n                              s->nkeys);\n                    s->nkeys = 0;\n                }\n\t\ts->p += 4;\n\t\tlogeventf(ssh, \"Pageant has %d SSH-1 keys\", s->nkeys);\n\t\tfor (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {\n\t\t    unsigned char *pkblob = s->p;\n\t\t    s->p += 4;\n\t\t    {\n\t\t\tint n, ok = FALSE;\n\t\t\tdo {\t       /* do while (0) to make breaking easy */\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.exponent);\n\t\t\t    if (n < 0)\n\t\t\t\tbreak;\n\t\t\t    s->p += n;\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.modulus);\n\t\t\t    if (n < 0)\n                                break;\n\t\t\t    s->p += n;\n\t\t\t    if (s->responselen - (s->p-s->response) < 4)\n\t\t\t\tbreak;\n\t\t\t    s->commentlen = toint(GET_32BIT(s->p));\n\t\t\t    s->p += 4;\n\t\t\t    if (s->commentlen < 0 ||\n                                toint(s->responselen - (s->p-s->response)) <\n\t\t\t\ts->commentlen)\n\t\t\t\tbreak;\n\t\t\t    s->commentp = (char *)s->p;\n\t\t\t    s->p += s->commentlen;\n\t\t\t    ok = TRUE;\n\t\t\t} while (0);\n\t\t\tif (!ok) {\n\t\t\t    logevent(\"Pageant key list packet was truncated\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (s->publickey_blob) {\n\t\t\tif (!memcmp(pkblob, s->publickey_blob,\n\t\t\t\t    s->publickey_bloblen)) {\n\t\t\t    logeventf(ssh, \"Pageant key #%d matches \"\n\t\t\t\t      \"configured key file\", s->keyi);\n\t\t\t    s->tried_publickey = 1;\n\t\t\t} else\n\t\t\t    /* Skip non-configured key */\n\t\t\t    continue;\n\t\t    }\n\t\t    logeventf(ssh, \"Trying Pageant key #%d\", s->keyi);\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t\tPKT_BIGNUM, s->key.modulus, PKT_END);\n\t\t    crWaitUntil(pktin);\n\t\t    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t\tlogevent(\"Key refused\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    logevent(\"Received RSA challenge\");\n\t\t    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\n\t\t    {\n\t\t\tchar *agentreq, *q, *ret;\n\t\t\tvoid *vret;\n\t\t\tint len, retlen;\n\t\t\tlen = 1 + 4;   /* message type, bit count */\n\t\t\tlen += ssh1_bignum_length(s->key.exponent);\n\t\t\tlen += ssh1_bignum_length(s->key.modulus);\n\t\t\tlen += ssh1_bignum_length(s->challenge);\n\t\t\tlen += 16;     /* session id */\n\t\t\tlen += 4;      /* response format */\n\t\t\tagentreq = snewn(4 + len, char);\n\t\t\tPUT_32BIT(agentreq, len);\n\t\t\tq = agentreq + 4;\n\t\t\t*q++ = SSH1_AGENTC_RSA_CHALLENGE;\n\t\t\tPUT_32BIT(q, bignum_bitcount(s->key.modulus));\n\t\t\tq += 4;\n\t\t\tq += ssh1_write_bignum(q, s->key.exponent);\n\t\t\tq += ssh1_write_bignum(q, s->key.modulus);\n\t\t\tq += ssh1_write_bignum(q, s->challenge);\n\t\t\tmemcpy(q, s->session_id, 16);\n\t\t\tq += 16;\n\t\t\tPUT_32BIT(q, 1);\t/* response format */\n                        ssh->auth_agent_query = agent_query(\n                            agentreq, len + 4, &vret, &retlen,\n                            ssh_agent_callback, ssh);\n\t\t\tif (ssh->auth_agent_query) {\n\t\t\t    sfree(agentreq);\n\t\t\t    do {\n\t\t\t\tcrReturn(0);\n\t\t\t\tif (pktin) {\n\t\t\t\t    bombout((\"Unexpected data from server\"\n\t\t\t\t\t     \" while waiting for agent\"\n\t\t\t\t\t     \" response\"));\n\t\t\t\t    crStop(0);\n\t\t\t\t}\n\t\t\t    } while (pktin || inlen > 0);\n\t\t\t    vret = ssh->agent_response;\n\t\t\t    retlen = ssh->agent_response_len;\n\t\t\t} else\n\t\t\t    sfree(agentreq);\n\t\t\tret = vret;\n\t\t\tif (ret) {\n\t\t\t    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {\n\t\t\t\tlogevent(\"Sending Pageant's response\");\n\t\t\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\t\t    PKT_DATA, ret + 5, 16,\n\t\t\t\t\t    PKT_END);\n\t\t\t\tsfree(ret);\n\t\t\t\tcrWaitUntil(pktin);\n\t\t\t\tif (pktin->type == SSH1_SMSG_SUCCESS) {\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response accepted\");\n\t\t\t\t    if (flags & FLAG_VERBOSE) {\n\t\t\t\t\tc_write_str(ssh, \"Authenticated using\"\n\t\t\t\t\t\t    \" RSA key \\\"\");\n\t\t\t\t\tc_write(ssh, s->commentp,\n\t\t\t\t\t\ts->commentlen);\n\t\t\t\t\tc_write_str(ssh, \"\\\" from agent\\r\\n\");\n\t\t\t\t    }\n\t\t\t\t    s->authed = TRUE;\n\t\t\t\t} else\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response not accepted\");\n\t\t\t    } else {\n\t\t\t\tlogevent\n\t\t\t\t    (\"Pageant failed to answer challenge\");\n\t\t\t\tsfree(ret);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    logevent(\"No reply received from Pageant\");\n\t\t\t}\n\t\t    }\n\t\t    freebn(s->key.exponent);\n\t\t    freebn(s->key.modulus);\n\t\t    freebn(s->challenge);\n\t\t    if (s->authed)\n\t\t\tbreak;\n\t\t}\n\t\tsfree(s->response);\n\t\tif (s->publickey_blob && !s->tried_publickey)\n\t\t    logevent(\"Configured key file not in Pageant\");\n\t    } else {\n                logevent(\"Failed to get reply from Pageant\");\n            }\n\t    if (s->authed)\n\t\tbreak;\n\t}\n\tif (s->publickey_blob && s->privatekey_available &&\n            !s->tried_publickey) {\n\t    /*\n\t     * Try public key authentication with the specified\n\t     * key file.\n\t     */\n\t    int got_passphrase; /* need not be kept over crReturn */\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Trying public key authentication.\\r\\n\");\n\t    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t    logeventf(ssh, \"Trying public key \\\"%s\\\"\",\n\t\t      filename_to_str(s->keyfile));\n\t    s->tried_publickey = 1;\n\t    got_passphrase = FALSE;\n\t    while (!got_passphrase) {\n\t\t/*\n\t\t * Get a passphrase, if necessary.\n\t\t */\n\t\tchar *passphrase = NULL;    /* only written after crReturn */\n\t\tconst char *error;\n\t\tif (!s->privatekey_encrypted) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"No passphrase required.\\r\\n\");\n\t\t    passphrase = NULL;\n\t\t} else {\n\t\t    int ret; /* need not be kept over crReturn */\n\t\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t\t    s->cur_prompt->to_server = FALSE;\n\t\t    s->cur_prompt->name = dupstr(\"SSH key passphrase\");\n\t\t    add_prompt(s->cur_prompt,\n\t\t\t       dupprintf(\"Passphrase for key \\\"%.100s\\\": \",\n\t\t\t\t\t s->publickey_comment), FALSE);\n\t\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t\t    while (ret < 0) {\n\t\t\tssh->send_ok = 1;\n\t\t\tcrWaitUntil(!pktin);\n\t\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\t\tssh->send_ok = 0;\n\t\t    }\n\t\t    if (!ret) {\n\t\t\t/* Failed to get a passphrase. Terminate. */\n\t\t\tfree_prompts(s->cur_prompt);\n\t\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\",\n\t\t\t\t       0, TRUE);\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    passphrase = dupstr(s->cur_prompt->prompts[0]->result);\n\t\t    free_prompts(s->cur_prompt);\n\t\t}\n\t\t/*\n\t\t * Try decrypting key with passphrase.\n\t\t */\n\t\ts->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t\tret = loadrsakey(s->keyfile, &s->key, passphrase,\n\t\t\t\t &error);\n\t\tif (passphrase) {\n\t\t    smemclr(passphrase, strlen(passphrase));\n\t\t    sfree(passphrase);\n\t\t}\n\t\tif (ret == 1) {\n\t\t    /* Correct passphrase. */\n\t\t    got_passphrase = TRUE;\n\t\t} else if (ret == 0) {\n\t\t    c_write_str(ssh, \"Couldn't load private key from \");\n\t\t    c_write_str(ssh, filename_to_str(s->keyfile));\n\t\t    c_write_str(ssh, \" (\");\n\t\t    c_write_str(ssh, error);\n\t\t    c_write_str(ssh, \").\\r\\n\");\n\t\t    got_passphrase = FALSE;\n\t\t    break;\t       /* go and try something else */\n\t\t} else if (ret == -1) {\n\t\t    c_write_str(ssh, \"Wrong passphrase.\\r\\n\"); /* FIXME */\n\t\t    got_passphrase = FALSE;\n\t\t    /* and try again */\n\t\t} else {\n\t\t    assert(0 && \"unexpected return from loadrsakey()\");\n\t\t    got_passphrase = FALSE;   /* placate optimisers */\n\t\t}\n\t    }\n\n\t    if (got_passphrase) {\n\n\t\t/*\n\t\t * Send a public key attempt.\n\t\t */\n\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t    PKT_BIGNUM, s->key.modulus, PKT_END);\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    c_write_str(ssh, \"Server refused our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t}\n\t\tif (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t    bombout((\"Bizarre response to offer of public key\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\t{\n\t\t    int i;\n\t\t    unsigned char buffer[32];\n\t\t    Bignum challenge, response;\n\n\t\t    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    response = rsadecrypt(challenge, &s->key);\n\t\t    freebn(s->key.private_exponent);/* burn the evidence */\n\n\t\t    for (i = 0; i < 32; i++) {\n\t\t\tbuffer[i] = bignum_byte(response, 31 - i);\n\t\t    }\n\n\t\t    MD5Init(&md5c);\n\t\t    MD5Update(&md5c, buffer, 32);\n\t\t    MD5Update(&md5c, s->session_id, 16);\n\t\t    MD5Final(buffer, &md5c);\n\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\tPKT_DATA, buffer, 16, PKT_END);\n\n\t\t    freebn(challenge);\n\t\t    freebn(response);\n\t\t}\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"Failed to authenticate with\"\n\t\t\t\t    \" our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t\t    bombout((\"Bizarre response to RSA authentication response\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\tbreak;\t\t       /* we're through! */\n\t    }\n\n\t}\n\n\t/*\n\t * Otherwise, try various forms of password-like authentication.\n\t */\n\ts->cur_prompt = new_prompts(ssh->frontend);\n\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&\n\t    !s->tis_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;\n\t    logevent(\"Requested TIS authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {\n\t\tlogevent(\"TIS authentication declined\");\n\t\tif (flags & FLAG_INTERACTIVE)\n\t\t    c_write_str(ssh, \"TIS authentication refused.\\r\\n\");\n\t\ts->tis_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"TIS challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received TIS challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH TIS authentication\");\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using TIS authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&\n\t    !s->ccard_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;\n\t    logevent(\"Requested CryptoCard authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {\n\t\tlogevent(\"CryptoCard authentication declined\");\n\t\tc_write_str(ssh, \"CryptoCard authentication refused.\\r\\n\");\n\t\ts->ccard_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"CryptoCard challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received CryptoCard challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH CryptoCard authentication\");\n\t\ts->cur_prompt->name_reqd = FALSE;\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using CryptoCard authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {\n\t\tbombout((\"No supported authentication methods available\"));\n\t\tcrStop(0);\n\t    }\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH password\");\n\t    add_prompt(s->cur_prompt, dupprintf(\"%s@%s's password: \",\n\t\t\t\t\t\tssh->username, ssh->savedhost),\n\t\t       FALSE);\n\t}\n\n\t/*\n\t * Show password prompt, having first obtained it via a TIS\n\t * or CryptoCard exchange if we're doing TIS or CryptoCard\n\t * authentication.\n\t */\n\t{\n\t    int ret; /* need not be kept over crReturn */\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a password (for example\n\t\t * because one was supplied on the command line\n\t\t * which has already failed to work). Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\", 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t}\n\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    /*\n\t     * Defence against traffic analysis: we send a\n\t     * whole bunch of packets containing strings of\n\t     * different lengths. One of these strings is the\n\t     * password, in a SSH1_CMSG_AUTH_PASSWORD packet.\n\t     * The others are all random data in\n\t     * SSH1_MSG_IGNORE packets. This way a passive\n\t     * listener can't tell which is the password, and\n\t     * hence can't deduce the password length.\n\t     * \n\t     * Anybody with a password length greater than 16\n\t     * bytes is going to have enough entropy in their\n\t     * password that a listener won't find it _that_\n\t     * much help to know how long it is. So what we'll\n\t     * do is:\n\t     * \n\t     *  - if password length < 16, we send 15 packets\n\t     *    containing string lengths 1 through 15\n\t     * \n\t     *  - otherwise, we let N be the nearest multiple\n\t     *    of 8 below the password length, and send 8\n\t     *    packets containing string lengths N through\n\t     *    N+7. This won't obscure the order of\n\t     *    magnitude of the password length, but it will\n\t     *    introduce a bit of extra uncertainty.\n\t     * \n\t     * A few servers can't deal with SSH1_MSG_IGNORE, at\n\t     * least in this context. For these servers, we need\n\t     * an alternative defence. We make use of the fact\n\t     * that the password is interpreted as a C string:\n\t     * so we can append a NUL, then some random data.\n\t     * \n\t     * A few servers can deal with neither SSH1_MSG_IGNORE\n\t     * here _nor_ a padded password string.\n\t     * For these servers we are left with no defences\n\t     * against password length sniffing.\n\t     */\n\t    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&\n\t        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can deal with SSH1_MSG_IGNORE, so\n\t\t * we can use the primary defence.\n\t\t */\n\t\tint bottom, top, pwlen, i;\n\t\tchar *randomstr;\n\n\t\tpwlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (pwlen < 16) {\n\t\t    bottom = 0;    /* zero length passwords are OK! :-) */\n\t\t    top = 15;\n\t\t} else {\n\t\t    bottom = pwlen & ~7;\n\t\t    top = bottom + 7;\n\t\t}\n\n\t\tassert(pwlen >= bottom && pwlen <= top);\n\n\t\trandomstr = snewn(top + 1, char);\n\n\t\tfor (i = bottom; i <= top; i++) {\n\t\t    if (i == pwlen) {\n\t\t\tdefer_packet(ssh, s->pwpkt_type,\n                                     PKT_STR,s->cur_prompt->prompts[0]->result,\n\t\t\t\t     PKT_END);\n\t\t    } else {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    do {\n\t\t\t\trandomstr[j] = random_byte();\n\t\t\t    } while (randomstr[j] == '\\0');\n\t\t\t}\n\t\t\trandomstr[i] = '\\0';\n\t\t\tdefer_packet(ssh, SSH1_MSG_IGNORE,\n\t\t\t\t     PKT_STR, randomstr, PKT_END);\n\t\t    }\n\t\t}\n\t\tlogevent(\"Sending password with camouflage packets\");\n\t\tssh_pkt_defersend(ssh);\n\t\tsfree(randomstr);\n\t    } \n\t    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can't deal with SSH1_MSG_IGNORE\n\t\t * but can deal with padded passwords, so we\n\t\t * can use the secondary defence.\n\t\t */\n\t\tchar string[64];\n\t\tchar *ss;\n\t\tint len;\n\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (len < sizeof(string)) {\n\t\t    ss = string;\n\t\t    strcpy(string, s->cur_prompt->prompts[0]->result);\n\t\t    len++;\t       /* cover the zero byte */\n\t\t    while (len < sizeof(string)) {\n\t\t\tstring[len++] = (char) random_byte();\n\t\t    }\n\t\t} else {\n\t\t    ss = s->cur_prompt->prompts[0]->result;\n\t\t}\n\t\tlogevent(\"Sending length-padded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n\t\t\t    PKT_INT, len, PKT_DATA, ss, len,\n\t\t\t    PKT_END);\n\t    } else {\n\t\t/*\n\t\t * The server is believed unable to cope with\n\t\t * any of our password camouflage methods.\n\t\t */\n\t\tint len;\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tlogevent(\"Sending unpadded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n                            PKT_INT, len,\n\t\t\t    PKT_DATA, s->cur_prompt->prompts[0]->result, len,\n\t\t\t    PKT_END);\n\t    }\n\t} else {\n\t    send_packet(ssh, s->pwpkt_type,\n\t\t\tPKT_STR, s->cur_prompt->prompts[0]->result,\n\t\t\tPKT_END);\n\t}\n\tlogevent(\"Sent password\");\n\tfree_prompts(s->cur_prompt);\n\tcrWaitUntil(pktin);\n\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Access denied\\r\\n\");\n\t    logevent(\"Authentication refused\");\n\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t    bombout((\"Strange packet received, type %d\", pktin->type));\n\t    crStop(0);\n\t}\n    }\n\n    /* Clear up */\n    if (s->publickey_blob) {\n\tsfree(s->publickey_blob);\n\tsfree(s->publickey_comment);\n    }\n\n    logevent(\"Authentication successful\");\n\n    crFinish(1);\n}\n\nstatic void ssh_channel_try_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    assert(c->pending_eof);          /* precondition for calling us */\n    if (c->halfopen)\n        return;                 /* can't close: not even opened yet */\n    if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)\n        return;              /* can't send EOF: pending outgoing data */\n\n    c->pending_eof = FALSE;            /* we're about to send it */\n    if (ssh->version == 1) {\n        send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,\n                    PKT_END);\n        c->closes |= CLOSES_SENT_EOF;\n    } else {\n        struct Packet *pktout;\n        pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);\n        ssh2_pkt_adduint32(pktout, c->remoteid);\n        ssh2_pkt_send(ssh, pktout);\n        c->closes |= CLOSES_SENT_EOF;\n\tssh2_channel_check_close(c);\n    }\n}\n\nConf *sshfwd_get_conf(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    return ssh->conf;\n}\n\nvoid sshfwd_write_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    if (c->closes & CLOSES_SENT_EOF)\n        return;\n\n    c->pending_eof = TRUE;\n    ssh_channel_try_eof(c);\n}\n\nvoid sshfwd_unclean_close(struct ssh_channel *c, const char *err)\n{\n    Ssh ssh = c->ssh;\n    char *reason;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    reason = dupprintf(\"due to local error: %s\", err);\n    ssh_channel_close_local(c, reason);\n    sfree(reason);\n    c->pending_eof = FALSE;   /* this will confuse a zombie channel */\n\n    ssh2_channel_check_close(c);\n}\n\nint sshfwd_write(struct ssh_channel *c, char *buf, int len)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn 0;\n\n    return ssh_send_channel_data(c, buf, len);\n}\n\nvoid sshfwd_unthrottle(struct ssh_channel *c, int bufsize)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    ssh_channel_unthrottle(c, bufsize);\n}\n\nstatic void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)\n{\n    struct queued_handler *qh = ssh->qhead;\n\n    assert(qh != NULL);\n\n    assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);\n\n    if (qh->msg1 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;\n    }\n    if (qh->msg2 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;\n    }\n\n    if (qh->next) {\n\tssh->qhead = qh->next;\n\n\tif (ssh->qhead->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;\n\t}\n\tif (ssh->qhead->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qhead = ssh->qtail = NULL;\n    }\n\n    qh->handler(ssh, pktin, qh->ctx);\n\n    sfree(qh);\n}\n\nstatic void ssh_queue_handler(Ssh ssh, int msg1, int msg2,\n\t\t\t      chandler_fn_t handler, void *ctx)\n{\n    struct queued_handler *qh;\n\n    qh = snew(struct queued_handler);\n    qh->msg1 = msg1;\n    qh->msg2 = msg2;\n    qh->handler = handler;\n    qh->ctx = ctx;\n    qh->next = NULL;\n\n    if (ssh->qtail == NULL) {\n\tssh->qhead = qh;\n\n\tif (qh->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;\n\t}\n\tif (qh->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qtail->next = qh;\n    }\n    ssh->qtail = qh;\n}\n\nstatic void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)\n{\n    struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;\n\n    if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :\n\t\t\tSSH2_MSG_REQUEST_SUCCESS)) {\n\tlogeventf(ssh, \"Remote port forwarding from %s enabled\",\n\t\t  pf->sportdesc);\n    } else {\n\tlogeventf(ssh, \"Remote port forwarding from %s refused\",\n\t\t  pf->sportdesc);\n\n\trpf = del234(ssh->rportfwds, pf);\n\tassert(rpf == pf);\n\tpf->pfrec->remote = NULL;\n\tfree_rportfwd(pf);\n    }\n}\n\nint ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,\n                               void *share_ctx)\n{\n    struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);\n    pf->dhost = NULL;\n    pf->dport = 0;\n    pf->share_ctx = share_ctx;\n    pf->shost = dupstr(shost);\n    pf->sport = sport;\n    pf->sportdesc = NULL;\n    if (!ssh->rportfwds) {\n        assert(ssh->version == 2);\n        ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n    }\n    if (add234(ssh->rportfwds, pf) != pf) {\n        sfree(pf->shost);\n        sfree(pf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nstatic void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,\n                                                void *ctx)\n{\n    share_got_pkt_from_server(ctx, pktin->type,\n                              pktin->body, pktin->length);\n}\n\nvoid ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)\n{\n    ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,\n                      ssh_sharing_global_request_response, share_ctx);\n}\n\nstatic void ssh_setup_portfwd(Ssh ssh, Conf *conf)\n{\n    struct ssh_portfwd *epf;\n    int i;\n    char *key, *val;\n\n    if (!ssh->portfwds) {\n\tssh->portfwds = newtree234(ssh_portcmp);\n    } else {\n\t/*\n\t * Go through the existing port forwardings and tag them\n\t * with status==DESTROY. Any that we want to keep will be\n\t * re-enabled (status==KEEP) as we go through the\n\t * configuration and find out which bits are the same as\n\t * they were before.\n\t */\n\tstruct ssh_portfwd *epf;\n\tint i;\n\tfor (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\t    epf->status = DESTROY;\n    }\n\n    for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\tchar *kp, *kp2, *vp, *vp2;\n\tchar address_family, type;\n\tint sport,dport,sserv,dserv;\n\tchar *sports, *dports, *saddr, *host;\n\n\tkp = key;\n\n\taddress_family = 'A';\n\ttype = 'L';\n\tif (*kp == 'A' || *kp == '4' || *kp == '6')\n\t    address_family = *kp++;\n\tif (*kp == 'L' || *kp == 'R')\n\t    type = *kp++;\n\n\tif ((kp2 = host_strchr(kp, ':')) != NULL) {\n\t    /*\n\t     * There's a colon in the middle of the source port\n\t     * string, which means that the part before it is\n\t     * actually a source address.\n\t     */\n\t    char *saddr_tmp = dupprintf(\"%.*s\", (int)(kp2 - kp), kp);\n            saddr = host_strduptrim(saddr_tmp);\n            sfree(saddr_tmp);\n\t    sports = kp2+1;\n\t} else {\n\t    saddr = NULL;\n\t    sports = kp;\n\t}\n\tsport = atoi(sports);\n\tsserv = 0;\n\tif (sport == 0) {\n\t    sserv = 1;\n\t    sport = net_service_lookup(sports);\n\t    if (!sport) {\n\t\tlogeventf(ssh, \"Service lookup failed for source\"\n\t\t\t  \" port \\\"%s\\\"\", sports);\n\t    }\n\t}\n\n\tif (type == 'L' && !strcmp(val, \"D\")) {\n            /* dynamic forwarding */\n\t    host = NULL;\n\t    dports = NULL;\n\t    dport = -1;\n\t    dserv = 0;\n            type = 'D';\n        } else {\n            /* ordinary forwarding */\n\t    vp = val;\n\t    vp2 = vp + host_strcspn(vp, \":\");\n\t    host = dupprintf(\"%.*s\", (int)(vp2 - vp), vp);\n\t    if (*vp2)\n\t\tvp2++;\n\t    dports = vp2;\n\t    dport = atoi(dports);\n\t    dserv = 0;\n\t    if (dport == 0) {\n\t\tdserv = 1;\n\t\tdport = net_service_lookup(dports);\n\t\tif (!dport) {\n\t\t    logeventf(ssh, \"Service lookup failed for destination\"\n\t\t\t      \" port \\\"%s\\\"\", dports);\n\t\t}\n\t    }\n\t}\n\n\tif (sport && dport) {\n\t    /* Set up a description of the source port. */\n\t    struct ssh_portfwd *pfrec, *epfrec;\n\n\t    pfrec = snew(struct ssh_portfwd);\n\t    pfrec->type = type;\n\t    pfrec->saddr = saddr;\n\t    pfrec->sserv = sserv ? dupstr(sports) : NULL;\n\t    pfrec->sport = sport;\n\t    pfrec->daddr = host;\n\t    pfrec->dserv = dserv ? dupstr(dports) : NULL;\n\t    pfrec->dport = dport;\n\t    pfrec->local = NULL;\n\t    pfrec->remote = NULL;\n\t    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :\n\t\t\t\t    address_family == '6' ? ADDRTYPE_IPV6 :\n\t\t\t\t    ADDRTYPE_UNSPEC);\n\n\t    epfrec = add234(ssh->portfwds, pfrec);\n\t    if (epfrec != pfrec) {\n\t\tif (epfrec->status == DESTROY) {\n\t\t    /*\n\t\t     * We already have a port forwarding up and running\n\t\t     * with precisely these parameters. Hence, no need\n\t\t     * to do anything; simply re-tag the existing one\n\t\t     * as KEEP.\n\t\t     */\n\t\t    epfrec->status = KEEP;\n\t\t}\n\t\t/*\n\t\t * Anything else indicates that there was a duplicate\n\t\t * in our input, which we'll silently ignore.\n\t\t */\n\t\tfree_portfwd(pfrec);\n\t    } else {\n\t\tpfrec->status = CREATE;\n\t    }\n\t} else {\n\t    sfree(saddr);\n\t    sfree(host);\n\t}\n    }\n\n    /*\n     * Now go through and destroy any port forwardings which were\n     * not re-enabled.\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == DESTROY) {\n\t    char *message;\n\n\t    message = dupprintf(\"%s port forwarding from %s%s%d\",\n\t\t\t\tepf->type == 'L' ? \"local\" :\n\t\t\t\tepf->type == 'R' ? \"remote\" : \"dynamic\",\n\t\t\t\tepf->saddr ? epf->saddr : \"\",\n\t\t\t\tepf->saddr ? \":\" : \"\",\n\t\t\t\tepf->sport);\n\n\t    if (epf->type != 'D') {\n\t\tchar *msg2 = dupprintf(\"%s to %s:%d\", message,\n\t\t\t\t       epf->daddr, epf->dport);\n\t\tsfree(message);\n\t\tmessage = msg2;\n\t    }\n\n\t    logeventf(ssh, \"Cancelling %s\", message);\n\t    sfree(message);\n\n\t    /* epf->remote or epf->local may be NULL if setting up a\n\t     * forwarding failed. */\n\t    if (epf->remote) {\n\t\tstruct ssh_rportfwd *rpf = epf->remote;\n\t\tstruct Packet *pktout;\n\n\t\t/*\n\t\t * Cancel the port forwarding at the server\n\t\t * end.\n\t\t */\n\t\tif (ssh->version == 1) {\n\t\t    /*\n\t\t     * We cannot cancel listening ports on the\n\t\t     * server side in SSH-1! There's no message\n\t\t     * to support it. Instead, we simply remove\n\t\t     * the rportfwd record from the local end\n\t\t     * so that any connections the server tries\n\t\t     * to make on it are rejected.\n\t\t     */\n\t\t} else {\n\t\t    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t    ssh2_pkt_addstring(pktout, \"cancel-tcpip-forward\");\n\t\t    ssh2_pkt_addbool(pktout, 0);/* _don't_ want reply */\n\t\t    if (epf->saddr) {\n\t\t\tssh2_pkt_addstring(pktout, epf->saddr);\n\t\t    } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n\t\t\t/* XXX: rport_acceptall may not represent\n\t\t\t * what was used to open the original connection,\n\t\t\t * since it's reconfigurable. */\n\t\t\tssh2_pkt_addstring(pktout, \"\");\n\t\t    } else {\n\t\t\tssh2_pkt_addstring(pktout, \"localhost\");\n\t\t    }\n\t\t    ssh2_pkt_adduint32(pktout, epf->sport);\n\t\t    ssh2_pkt_send(ssh, pktout);\n\t\t}\n\n\t\tdel234(ssh->rportfwds, rpf);\n\t\tfree_rportfwd(rpf);\n\t    } else if (epf->local) {\n\t\tpfl_terminate(epf->local);\n\t    }\n\n\t    delpos234(ssh->portfwds, i);\n\t    free_portfwd(epf);\n\t    i--;\t\t       /* so we don't skip one in the list */\n\t}\n\n    /*\n     * And finally, set up any new port forwardings (status==CREATE).\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == CREATE) {\n\t    char *sportdesc, *dportdesc;\n\t    sportdesc = dupprintf(\"%s%s%s%s%d%s\",\n\t\t\t\t  epf->saddr ? epf->saddr : \"\",\n\t\t\t\t  epf->saddr ? \":\" : \"\",\n\t\t\t\t  epf->sserv ? epf->sserv : \"\",\n\t\t\t\t  epf->sserv ? \"(\" : \"\",\n\t\t\t\t  epf->sport,\n\t\t\t\t  epf->sserv ? \")\" : \"\");\n\t    if (epf->type == 'D') {\n\t\tdportdesc = NULL;\n\t    } else {\n\t\tdportdesc = dupprintf(\"%s:%s%s%d%s\",\n\t\t\t\t      epf->daddr,\n\t\t\t\t      epf->dserv ? epf->dserv : \"\",\n\t\t\t\t      epf->dserv ? \"(\" : \"\",\n\t\t\t\t      epf->dport,\n\t\t\t\t      epf->dserv ? \")\" : \"\");\n\t    }\n\n\t    if (epf->type == 'L') {\n                char *err = pfl_listen(epf->daddr, epf->dport,\n                                       epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s forwarding to %s%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc, dportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n                if (err)\n                    sfree(err);\n\t    } else if (epf->type == 'D') {\n\t\tchar *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s SOCKS dynamic forwarding%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n\n                if (err)\n                    sfree(err);\n\t    } else {\n\t\tstruct ssh_rportfwd *pf;\n\n\t\t/*\n\t\t * Ensure the remote port forwardings tree exists.\n\t\t */\n\t\tif (!ssh->rportfwds) {\n\t\t    if (ssh->version == 1)\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh1);\n\t\t    else\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n\t\t}\n\n\t\tpf = snew(struct ssh_rportfwd);\n                pf->share_ctx = NULL;\n                pf->dhost = dupstr(epf->daddr);\n\t\tpf->dport = epf->dport;\n                if (epf->saddr) {\n                    pf->shost = dupstr(epf->saddr);\n                } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n                    pf->shost = dupstr(\"\");\n                } else {\n                    pf->shost = dupstr(\"localhost\");\n                }\n\t\tpf->sport = epf->sport;\n\t\tif (add234(ssh->rportfwds, pf) != pf) {\n\t\t    logeventf(ssh, \"Duplicate remote port forwarding to %s:%d\",\n\t\t\t      epf->daddr, epf->dport);\n\t\t    sfree(pf);\n\t\t} else {\n\t\t    logeventf(ssh, \"Requesting remote port %s\"\n\t\t\t      \" forward to %s\", sportdesc, dportdesc);\n\n\t\t    pf->sportdesc = sportdesc;\n\t\t    sportdesc = NULL;\n\t\t    epf->remote = pf;\n\t\t    pf->pfrec = epf;\n\n\t\t    if (ssh->version == 1) {\n\t\t\tsend_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,\n\t\t\t\t    PKT_INT, epf->sport,\n\t\t\t\t    PKT_STR, epf->daddr,\n\t\t\t\t    PKT_INT, epf->dport,\n\t\t\t\t    PKT_END);\n\t\t\tssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,\n\t\t\t\t\t  SSH1_SMSG_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    } else {\n\t\t\tstruct Packet *pktout;\n\t\t\tpktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tssh2_pkt_addstring(pktout, \"tcpip-forward\");\n\t\t\tssh2_pkt_addbool(pktout, 1);/* want reply */\n\t\t\tssh2_pkt_addstring(pktout, pf->shost);\n\t\t\tssh2_pkt_adduint32(pktout, pf->sport);\n\t\t\tssh2_pkt_send(ssh, pktout);\n\n\t\t\tssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,\n\t\t\t\t\t  SSH2_MSG_REQUEST_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    }\n\t\t}\n\t    }\n\t    sfree(sportdesc);\n\t    sfree(dportdesc);\n\t}\n}\n\nstatic void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)\n{\n    char *string;\n    int stringlen, bufsize;\n\n    ssh_pkt_getstring(pktin, &string, &stringlen);\n    if (string == NULL) {\n\tbombout((\"Incoming terminal data packet was badly formed\"));\n\treturn;\n    }\n\n    bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,\n\t\t\t   string, stringlen);\n    if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {\n\tssh->v1_stdout_throttling = 1;\n\tssh_throttle_conn(ssh, +1);\n    }\n}\n\nstatic void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * X-Server. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    logevent(\"Received X11 connect request\");\n    /* Refuse if X11 forwarding is disabled. */\n    if (!ssh->X11_fwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n\tlogevent(\"Rejected X11 connect request\");\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\n\tssh_channel_init(c);\n\tc->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_X11;\t/* identify channel type */\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT,\n                    c->localid, PKT_END);\n        logevent(\"Opened X11 forward channel\");\n    }\n}\n\nstatic void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * agent. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    /* Refuse if agent forwarding is disabled. */\n    if (!ssh->agentfwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\tssh_channel_init(c);\n\tc->remoteid = remoteid;\n\tc->halfopen = FALSE;\n\tc->type = CHAN_AGENT;\t/* identify channel type */\n\tc->u.a.lensofar = 0;\n\tc->u.a.message = NULL;\n\tc->u.a.pending = NULL;\n\tc->u.a.outstanding_requests = 0;\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t    PKT_INT, c->remoteid, PKT_INT, c->localid,\n\t\t    PKT_END);\n    }\n}\n\nstatic void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to a\n     * forwarded port. Give them back a local channel number. */\n    struct ssh_rportfwd pf, *pfp;\n    int remoteid;\n    int hostsize, port;\n    char *host;\n    char *err;\n\n    remoteid = ssh_pkt_getuint32(pktin);\n    ssh_pkt_getstring(pktin, &host, &hostsize);\n    port = ssh_pkt_getuint32(pktin);\n\n    pf.dhost = dupprintf(\"%.*s\", hostsize, NULLTOEMPTY(host));\n    pf.dport = port;\n    pfp = find234(ssh->rportfwds, &pf, NULL);\n\n    if (pfp == NULL) {\n\tlogeventf(ssh, \"Rejected remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n        struct ssh_channel *c = snew(struct ssh_channel);\n        c->ssh = ssh;\n\n\tlogeventf(ssh, \"Received remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\terr = pfd_connect(&c->u.pfd.pf, pf.dhost, port,\n                          c, ssh->conf, pfp->pfrec->addressfamily);\n\tif (err != NULL) {\n\t    logeventf(ssh, \"Port open failed: %s\", err);\n            sfree(err);\n\t    sfree(c);\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t\tPKT_INT, remoteid, PKT_END);\n\t} else {\n\t    ssh_channel_init(c);\n\t    c->remoteid = remoteid;\n\t    c->halfopen = FALSE;\n\t    c->type = CHAN_SOCKDATA;\t/* identify channel type */\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t\tPKT_INT, c->remoteid, PKT_INT,\n\t\t\tc->localid, PKT_END);\n\t    logevent(\"Forwarded port opened successfully\");\n\t}\n    }\n\n    sfree(pf.dhost);\n}\n\nstatic void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)\n{\n    struct ssh_channel *c;\n\n    c = ssh_channel_msg(ssh, pktin);\n    if (c && c->type == CHAN_SOCKDATA) {\n\tc->remoteid = ssh_pkt_getuint32(pktin);\n\tc->halfopen = FALSE;\n\tc->throttling_conn = 0;\n\tpfd_confirm(c->u.pfd.pf);\n    }\n\n    if (c && c->pending_eof) {\n\t/*\n\t * We have a pending close on this channel,\n\t * which we decided on before the server acked\n\t * the channel open. So now we know the\n\t * remoteid, we can close it again.\n\t */\n        ssh_channel_try_eof(c);\n    }\n}\n\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_AGENT;   /* identify channel type */\n       c->u.a.lensofar = 0;\n       c->u.a.message = NULL;\n        c->u.a.pending = NULL;\n       c->u.a.outstanding_requests = 0;\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT, c->localid,\n                    PKT_END);\n\tdel234(ssh->channels, c);\n\tsfree(c);\n    }\n}\n", "func_hash": 325909590182680995779527787302149618683, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6542", "cve_desc": "The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6542"}
{"idx": 241, "project": "virglrenderer", "commit_id": "e534b51ca3c3cd25f3990589932a9ed711c59b27", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=e534b51ca3c3cd25f3990589932a9ed711c59b27", "commit_message": "gallium/tgsi: fix overflow in parse property\n\nIn parse_identifier, it doesn't stop copying '*pcur'\nuntill encounter the NULL. As the 'ret' has a\nfixed-size buffer, if the '*pcur' has a long string,\nthere will be a buffer overflow. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "static boolean parse_identifier( const char **pcur, char *ret )\n {\n    const char *cur = *pcur;\n    int i = 0;\n    if (is_alpha_underscore( cur )) {\n       ret[i++] = *cur++;\n      while (is_alpha_underscore( cur ) || is_digit( cur ))\n          ret[i++] = *cur++;\n       ret[i++] = '\\0';\n       *pcur = cur;\n       return TRUE;\n\n/* Parse floating point.\n */\nstatic boolean parse_float( const char **pcur, float *val )\n{\n   const char *cur = *pcur;\n   boolean integral_part = FALSE;\n   boolean fractional_part = FALSE;\n\n   if (*cur == '0' && *(cur + 1) == 'x') {\n      union fi fi;\n      fi.ui = strtoul(cur, NULL, 16);\n      *val = fi.f;\n      cur += 10;\n      goto out;\n   }\n\n   *val = (float) atof( cur );\n   if (*cur == '-' || *cur == '+')\n      cur++;\n   if (is_digit( cur )) {\n      cur++;\n      integral_part = TRUE;\n      while (is_digit( cur ))\n         cur++;\n   }\n   if (*cur == '.') {\n      cur++;\n      if (is_digit( cur )) {\n         cur++;\n         fractional_part = TRUE;\n         while (is_digit( cur ))\n            cur++;\n      }\n   }\n   if (!integral_part && !fractional_part)\n      return FALSE;\n   if (uprcase( *cur ) == 'E') {\n      cur++;\n      if (*cur == '-' || *cur == '+')\n         cur++;\n      if (is_digit( cur )) {\n         cur++;\n         while (is_digit( cur ))\n            cur++;\n      }\n      else\n         return FALSE;\n   }\n\nout:\n   *pcur = cur;\n   return TRUE;\n}\n\nstatic boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)\n{\n   const char *cur = *pcur;\n   union {\n      double dval;\n      uint32_t uval[2];\n   } v;\n\n   v.dval = strtod(cur, (char**)pcur);\n   if (*pcur == cur)\n      return FALSE;\n\n   *val0 = v.uval[0];\n   *val1 = v.uval[1];\n\n   return TRUE;\n}\n\nstruct translate_ctx\n{\n   const char *text;\n   const char *cur;\n   struct tgsi_token *tokens;\n   struct tgsi_token *tokens_cur;\n   struct tgsi_token *tokens_end;\n   struct tgsi_header *header;\n   unsigned processor : 4;\n   unsigned implied_array_size : 6;\n   unsigned num_immediates;\n};\n\nstatic void report_error(struct translate_ctx *ctx, const char *format, ...)\n{\n   va_list args;\n   int line = 1;\n   int column = 1;\n   const char *itr = ctx->text;\n\n   debug_printf(\"\\nTGSI asm error: \");\n\n   va_start(args, format);\n   _debug_vprintf(format, args);\n   va_end(args);\n\n   while (itr != ctx->cur) {\n      if (*itr == '\\n') {\n         column = 1;\n         ++line;\n      }\n      ++column;\n      ++itr;\n   }\n\n   debug_printf(\" [%d : %d] \\n\", line, column);\n}\n\n/* Parse shader header.\n * Return TRUE for one of the following headers.\n *    FRAG\n *    GEOM\n *    VERT\n */\nstatic boolean parse_header( struct translate_ctx *ctx )\n{\n   uint processor;\n\n   if (str_match_nocase_whole( &ctx->cur, \"FRAG\" ))\n      processor = TGSI_PROCESSOR_FRAGMENT;\n   else if (str_match_nocase_whole( &ctx->cur, \"VERT\" ))\n      processor = TGSI_PROCESSOR_VERTEX;\n   else if (str_match_nocase_whole( &ctx->cur, \"GEOM\" ))\n      processor = TGSI_PROCESSOR_GEOMETRY;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_CTRL\" ))\n      processor = TGSI_PROCESSOR_TESS_CTRL;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_EVAL\" ))\n      processor = TGSI_PROCESSOR_TESS_EVAL;\n   else if (str_match_nocase_whole( &ctx->cur, \"COMP\" ))\n      processor = TGSI_PROCESSOR_COMPUTE;\n   else {\n      report_error( ctx, \"Unknown header\" );\n      return FALSE;\n   }\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   ctx->header = (struct tgsi_header *) ctx->tokens_cur++;\n   *ctx->header = tgsi_build_header();\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );\n   ctx->processor = processor;\n\n   return TRUE;\n}\n\nstatic boolean parse_label( struct translate_ctx *ctx, uint *val )\n{\n   const char *cur = ctx->cur;\n\n   if (parse_uint( &cur, val )) {\n      eat_opt_white( &cur );\n      if (*cur == ':') {\n         cur++;\n         ctx->cur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_file( const char **pcur, uint *file )\n{\n   uint i;\n\n   for (i = 0; i < TGSI_FILE_COUNT; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {\n         *pcur = cur;\n         *file = i;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_opt_writemask(\n   struct translate_ctx *ctx,\n   uint *writemask )\n{\n   const char *cur;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      cur++;\n      *writemask = TGSI_WRITEMASK_NONE;\n      eat_opt_white( &cur );\n      if (uprcase( *cur ) == 'X') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_X;\n      }\n      if (uprcase( *cur ) == 'Y') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Y;\n      }\n      if (uprcase( *cur ) == 'Z') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Z;\n      }\n      if (uprcase( *cur ) == 'W') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_W;\n      }\n\n      if (*writemask == TGSI_WRITEMASK_NONE) {\n         report_error( ctx, \"Writemask expected\" );\n         return FALSE;\n      }\n\n      ctx->cur = cur;\n   }\n   else {\n      *writemask = TGSI_WRITEMASK_XYZW;\n   }\n   return TRUE;\n}\n\n\n/* <register_file_bracket> ::= <file> `['\n */\nstatic boolean\nparse_register_file_bracket(\n   struct translate_ctx *ctx,\n   uint *file )\n{\n   if (!parse_file( &ctx->cur, file )) {\n      report_error( ctx, \"Unknown register file\" );\n      return FALSE;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '[') {\n      report_error( ctx, \"Expected `['\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* <register_file_bracket_index> ::= <register_file_bracket> <uint>\n */\nstatic boolean\nparse_register_file_bracket_index(\n   struct translate_ctx *ctx,\n   uint *file,\n   int *index )\n{\n   uint uindex;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   *index = (int) uindex;\n   return TRUE;\n}\n\n/* Parse simple 1d register operand.\n *    <register_dst> ::= <register_file_bracket_index> `]'\n */\nstatic boolean\nparse_register_1d(struct translate_ctx *ctx,\n                  uint *file,\n                  int *index )\n{\n   if (!parse_register_file_bracket_index( ctx, file, index ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\nstruct parsed_bracket {\n   int index;\n\n   uint ind_file;\n   int ind_index;\n   uint ind_comp;\n   uint ind_array;\n};\n\n\nstatic boolean\nparse_register_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets)\n{\n   const char *cur;\n   uint uindex;\n\n   memset(brackets, 0, sizeof(struct parsed_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   cur = ctx->cur;\n   if (parse_file( &cur, &brackets->ind_file )) {\n      if (!parse_register_1d( ctx, &brackets->ind_file,\n                              &brackets->ind_index ))\n         return FALSE;\n      eat_opt_white( &ctx->cur );\n\n      if (*ctx->cur == '.') {\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n\n         switch (uprcase(*ctx->cur)) {\n         case 'X':\n            brackets->ind_comp = TGSI_SWIZZLE_X;\n            break;\n         case 'Y':\n            brackets->ind_comp = TGSI_SWIZZLE_Y;\n            break;\n         case 'Z':\n            brackets->ind_comp = TGSI_SWIZZLE_Z;\n            break;\n         case 'W':\n            brackets->ind_comp = TGSI_SWIZZLE_W;\n            break;\n         default:\n            report_error(ctx, \"Expected indirect register swizzle component `x', `y', `z' or `w'\");\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n      }\n\n      if (*ctx->cur == '+' || *ctx->cur == '-')\n         parse_int( &ctx->cur, &brackets->index );\n      else\n         brackets->index = 0;\n   }\n   else {\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      brackets->index = (int) uindex;\n      brackets->ind_file = TGSI_FILE_NULL;\n      brackets->ind_index = 0;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   if (*ctx->cur == '(') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &brackets->ind_array )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_opt_register_src_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets,\n   int *parsed_brackets)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_brackets = 0;\n\n   eat_opt_white( &cur );\n   if (cur[0] == '[') {\n      ++cur;\n      ctx->cur = cur;\n\n      if (!parse_register_bracket(ctx, brackets))\n         return FALSE;\n\n      *parsed_brackets = 1;\n   }\n\n   return TRUE;\n}\n\n\n/* Parse source register operand.\n *    <register_src> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `+' <uint> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `-' <uint> `]'\n */\nstatic boolean\nparse_register_src(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstruct parsed_dcl_bracket {\n   uint first;\n   uint last;\n};\n\nstatic boolean\nparse_register_dcl_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_dcl_bracket *bracket)\n{\n   uint uindex;\n   memset(bracket, 0, sizeof(struct parsed_dcl_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      /* it can be an empty bracket [] which means its range\n       * is from 0 to some implied size */\n      if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {\n         bracket->first = 0;\n         bracket->last = ctx->implied_array_size - 1;\n         goto cleanup;\n      }\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   bracket->first = uindex;\n\n   eat_opt_white( &ctx->cur );\n\n   if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {\n      uint uindex;\n\n      ctx->cur += 2;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal integer\" );\n         return FALSE;\n      }\n      bracket->last = (int) uindex;\n      eat_opt_white( &ctx->cur );\n   }\n   else {\n      bracket->last = bracket->first;\n   }\n\ncleanup:\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]' or `..'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* Parse register declaration.\n *    <register_dcl> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket_index> `..' <index> `]'\n */\nstatic boolean\nparse_register_dcl(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_dcl_bracket *brackets,\n   int *num_brackets)\n{\n   const char *cur;\n\n   *num_brackets = 0;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_dcl_bracket( ctx, &brackets[0] ))\n      return FALSE;\n\n   *num_brackets = 1;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (cur[0] == '[') {\n      bool is_in = *file == TGSI_FILE_INPUT;\n      bool is_out = *file == TGSI_FILE_OUTPUT;\n\n      ++cur;\n      ctx->cur = cur;\n      if (!parse_register_dcl_bracket( ctx, &brackets[1] ))\n         return FALSE;\n      /* for geometry shader we don't really care about\n       * the first brackets it's always the size of the\n       * input primitive. so we want to declare just\n       * the index relevant to the semantics which is in\n       * the second bracket */\n\n      /* tessellation has similar constraints to geometry shader */\n      if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {\n         brackets[0] = brackets[1];\n         *num_brackets = 1;\n      } else {\n         *num_brackets = 2;\n      }\n   }\n\n   return TRUE;\n}\n\n\n/* Parse destination register operand.*/\nstatic boolean\nparse_register_dst(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_dst_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_dst_register *dst )\n{\n   uint file;\n   uint writemask;\n   const char *cur;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (!parse_register_dst( ctx, &file, &bracket[0] ))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   dst->Register.File = file;\n   if (parsed_opt_brackets) {\n      dst->Register.Dimension = 1;\n      dst->Dimension.Indirect = 0;\n      dst->Dimension.Dimension = 0;\n      dst->Dimension.Index = bracket[0].index;\n\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         dst->Dimension.Indirect = 1;\n         dst->DimIndirect.File = bracket[0].ind_file;\n         dst->DimIndirect.Index = bracket[0].ind_index;\n         dst->DimIndirect.Swizzle = bracket[0].ind_comp;\n         dst->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   dst->Register.Index = bracket[0].index;\n   dst->Register.WriteMask = writemask;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      dst->Register.Indirect = 1;\n      dst->Indirect.File = bracket[0].ind_file;\n      dst->Indirect.Index = bracket[0].ind_index;\n      dst->Indirect.Swizzle = bracket[0].ind_comp;\n      dst->Indirect.ArrayID = bracket[0].ind_array;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_optional_swizzle(\n   struct translate_ctx *ctx,\n   uint *swizzle,\n   boolean *parsed_swizzle,\n   int components)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_swizzle = FALSE;\n\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < components; i++) {\n         if (uprcase( *cur ) == 'X')\n            swizzle[i] = TGSI_SWIZZLE_X;\n         else if (uprcase( *cur ) == 'Y')\n            swizzle[i] = TGSI_SWIZZLE_Y;\n         else if (uprcase( *cur ) == 'Z')\n            swizzle[i] = TGSI_SWIZZLE_Z;\n         else if (uprcase( *cur ) == 'W')\n            swizzle[i] = TGSI_SWIZZLE_W;\n         else {\n\t    report_error( ctx, \"Expected register swizzle component `x', `y', `z' or `w'\" );\n\t    return FALSE;\n         }\n         cur++;\n      }\n      *parsed_swizzle = TRUE;\n      ctx->cur = cur;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_src_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_src_register *src )\n{\n   uint file;\n   uint swizzle[4];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (*ctx->cur == '-') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Negate = 1;\n   }\n\n   if (*ctx->cur == '|') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Absolute = 1;\n   }\n\n   if (!parse_register_src(ctx, &file, &bracket[0]))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   src->Register.File = file;\n   if (parsed_opt_brackets) {\n      src->Register.Dimension = 1;\n      src->Dimension.Indirect = 0;\n      src->Dimension.Dimension = 0;\n      src->Dimension.Index = bracket[0].index;\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         src->Dimension.Indirect = 1;\n         src->DimIndirect.File = bracket[0].ind_file;\n         src->DimIndirect.Index = bracket[0].ind_index;\n         src->DimIndirect.Swizzle = bracket[0].ind_comp;\n         src->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   src->Register.Index = bracket[0].index;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      src->Register.Indirect = 1;\n      src->Indirect.File = bracket[0].ind_file;\n      src->Indirect.Index = bracket[0].ind_index;\n      src->Indirect.Swizzle = bracket[0].ind_comp;\n      src->Indirect.ArrayID = bracket[0].ind_array;\n   }\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n      if (parsed_swizzle) {\n         src->Register.SwizzleX = swizzle[0];\n         src->Register.SwizzleY = swizzle[1];\n         src->Register.SwizzleZ = swizzle[2];\n         src->Register.SwizzleW = swizzle[3];\n      }\n   }\n\n   if (src->Register.Absolute) {\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != '|') {\n         report_error( ctx, \"Expected `|'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n\n\n   return TRUE;\n}\n\nstatic boolean\nparse_texoffset_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_texture_offset *src )\n{\n   uint file;\n   uint swizzle[3];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket;\n\n   if (!parse_register_src(ctx, &file, &bracket))\n      return FALSE;\n\n   src->File = file;\n   src->Index = bracket.index;\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {\n      if (parsed_swizzle) {\n         src->SwizzleX = swizzle[0];\n         src->SwizzleY = swizzle[1];\n         src->SwizzleZ = swizzle[2];\n      }\n   }\n\n   return TRUE;\n}\n\nstatic boolean\nmatch_inst(const char **pcur,\n           unsigned *saturate,\n           const struct tgsi_opcode_info *info)\n{\n   const char *cur = *pcur;\n\n   /* simple case: the whole string matches the instruction name */\n   if (str_match_nocase_whole(&cur, info->mnemonic)) {\n      *pcur = cur;\n      *saturate = 0;\n      return TRUE;\n   }\n\n   if (str_match_no_case(&cur, info->mnemonic)) {\n      /* the instruction has a suffix, figure it out */\n      if (str_match_nocase_whole(&cur, \"_SAT\")) {\n         *pcur = cur;\n         *saturate = 1;\n         return TRUE;\n      }\n   }\n\n   return FALSE;\n}\n\nstatic boolean\nparse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n         cur++;\n         eat_opt_white( &cur );\n         ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\n/* parses a 4-touple of the form {x, y, z, w}\n * where x, y, z, w are numbers */\nstatic boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,\n                                    union tgsi_immediate_data *values)\n{\n   unsigned i;\n   int ret;\n\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '{') {\n      report_error( ctx, \"Expected `{'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   for (i = 0; i < 4; i++) {\n      eat_opt_white( &ctx->cur );\n      if (i > 0) {\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      switch (type) {\n      case TGSI_IMM_FLOAT64:\n         ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);\n         i++;\n         break;\n      case TGSI_IMM_FLOAT32:\n         ret = parse_float(&ctx->cur, &values[i].Float);\n         break;\n      case TGSI_IMM_UINT32:\n         ret = parse_uint(&ctx->cur, &values[i].Uint);\n         break;\n      case TGSI_IMM_INT32:\n         ret = parse_int(&ctx->cur, &values[i].Int);\n         break;\n      default:\n         assert(0);\n         ret = FALSE;\n         break;\n      }\n\n      if (!ret) {\n         report_error( ctx, \"Expected immediate constant\" );\n         return FALSE;\n      }\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '}') {\n      report_error( ctx, \"Expected `}'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n\n   return TRUE;\n}\n\nstatic boolean parse_declaration( struct translate_ctx *ctx )\n{\n   struct tgsi_full_declaration decl;\n   uint file;\n   struct parsed_dcl_bracket brackets[2];\n   int num_brackets;\n   uint writemask;\n   const char *cur, *cur2;\n   uint advance;\n   boolean is_vs_input;\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))\n      return FALSE;\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   decl = tgsi_default_full_declaration();\n   decl.Declaration.File = file;\n   decl.Declaration.UsageMask = writemask;\n\n   if (num_brackets == 1) {\n      decl.Range.First = brackets[0].first;\n      decl.Range.Last = brackets[0].last;\n   } else {\n      decl.Range.First = brackets[1].first;\n      decl.Range.Last = brackets[1].last;\n\n      decl.Declaration.Dimension = 1;\n      decl.Dim.Index2D = brackets[0].first;\n   }\n\n   is_vs_input = (file == TGSI_FILE_INPUT &&\n                  ctx->processor == TGSI_PROCESSOR_VERTEX);\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',') {\n      cur2 = cur;\n      cur2++;\n      eat_opt_white( &cur2 );\n      if (str_match_nocase_whole( &cur2, \"ARRAY\" )) {\n         int arrayid;\n         if (*cur2 != '(') {\n            report_error( ctx, \"Expected `('\" );\n            return FALSE;\n         }\n         cur2++;\n         eat_opt_white( &cur2 );\n         if (!parse_int( &cur2, &arrayid )) {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         eat_opt_white( &cur2 );\n         if (*cur2 != ')') {\n            report_error( ctx, \"Expected `)'\" );\n            return FALSE;\n         }\n         cur2++;\n         decl.Declaration.Array = 1;\n         decl.Array.ArrayID = arrayid;\n         ctx->cur = cur = cur2;\n      }\n   }\n\n   if (*cur == ',' && !is_vs_input) {\n      uint i, j;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (file == TGSI_FILE_RESOURCE) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.Resource.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n\n         cur2 = cur;\n         eat_opt_white(&cur2);\n         while (*cur2 == ',') {\n            cur2++;\n            eat_opt_white(&cur2);\n            if (str_match_nocase_whole(&cur2, \"RAW\")) {\n               decl.Resource.Raw = 1;\n\n            } else if (str_match_nocase_whole(&cur2, \"WR\")) {\n               decl.Resource.Writable = 1;\n\n            } else {\n               break;\n            }\n            cur = cur2;\n            eat_opt_white(&cur2);\n         }\n\n         ctx->cur = cur;\n\n      } else if (file == TGSI_FILE_SAMPLER_VIEW) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.SamplerView.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n         eat_opt_white( &cur );\n         if (*cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ++cur;\n         eat_opt_white( &cur );\n         for (j = 0; j < 4; ++j) {\n            for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {\n               if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {\n                  switch (j) {\n                  case 0:\n                     decl.SamplerView.ReturnTypeX = i;\n                     break;\n                  case 1:\n                     decl.SamplerView.ReturnTypeY = i;\n                     break;\n                  case 2:\n                     decl.SamplerView.ReturnTypeZ = i;\n                     break;\n                  case 3:\n                     decl.SamplerView.ReturnTypeW = i;\n                     break;\n                  default:\n                     assert(0);\n                  }\n                  break;\n               }\n            }\n            if (i == TGSI_RETURN_TYPE_COUNT) {\n               if (j == 0 || j >  2) {\n                  report_error(ctx, \"Expected type name\");\n                  return FALSE;\n               }\n               break;\n            } else {\n               cur2 = cur;\n               eat_opt_white( &cur2 );\n               if (*cur2 == ',') {\n                  cur2++;\n                  eat_opt_white( &cur2 );\n                  cur = cur2;\n                  continue;\n               } else\n                  break;\n            }\n         }\n         if (j < 4) {\n            decl.SamplerView.ReturnTypeY =\n               decl.SamplerView.ReturnTypeZ =\n               decl.SamplerView.ReturnTypeW =\n               decl.SamplerView.ReturnTypeX;\n         }\n         ctx->cur = cur;\n      } else {\n         if (str_match_nocase_whole(&cur, \"LOCAL\")) {\n            decl.Declaration.Local = 1;\n            ctx->cur = cur;\n         }\n\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n         if (*cur == ',') {\n            cur++;\n            eat_opt_white( &cur );\n\n            for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {\n               if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {\n                  uint index;\n\n                  cur2 = cur;\n                  eat_opt_white( &cur2 );\n                  if (*cur2 == '[') {\n                     cur2++;\n                     eat_opt_white( &cur2 );\n                     if (!parse_uint( &cur2, &index )) {\n                        report_error( ctx, \"Expected literal integer\" );\n                        return FALSE;\n                     }\n                     eat_opt_white( &cur2 );\n                     if (*cur2 != ']') {\n                        report_error( ctx, \"Expected `]'\" );\n                        return FALSE;\n                     }\n                     cur2++;\n\n                     decl.Semantic.Index = index;\n\n                     cur = cur2;\n                  }\n\n                  decl.Declaration.Semantic = 1;\n                  decl.Semantic.Name = i;\n\n                  ctx->cur = cur;\n                  break;\n               }\n            }\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {\n            decl.Declaration.Interpolate = 1;\n            decl.Interp.Interpolate = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n      if (i == TGSI_INTERPOLATE_COUNT) {\n         report_error( ctx, \"Expected semantic or interpolate attribute\" );\n         return FALSE;\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {\n            decl.Interp.Location = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n\n   advance = tgsi_build_full_declaration(\n      &decl,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\nstatic boolean parse_immediate( struct translate_ctx *ctx )\n{\n   struct tgsi_full_immediate imm;\n   uint advance;\n   int type;\n\n   if (*ctx->cur == '[') {\n      uint uindex;\n\n      ++ctx->cur;\n\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n\n      if (uindex != ctx->num_immediates) {\n         report_error( ctx, \"Immediates must be sorted\" );\n         return FALSE;\n      }\n\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ']') {\n         report_error( ctx, \"Expected `]'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {\n      if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))\n         break;\n   }\n   if (type == Elements(tgsi_immediate_type_names)) {\n      report_error( ctx, \"Expected immediate type\" );\n      return FALSE;\n   }\n\n   imm = tgsi_default_full_immediate();\n   imm.Immediate.NrTokens += 4;\n   imm.Immediate.DataType = type;\n   parse_immediate_data(ctx, type, imm.u);\n\n   advance = tgsi_build_full_immediate(\n      &imm,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   ctx->num_immediates++;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_primitive( const char **pcur, uint *primitive )\n{\n   uint i;\n\n   for (i = 0; i < PIPE_PRIM_MAX; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {\n         *primitive = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {\n         *fs_coord_origin = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {\n         *fs_coord_pixel_center = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\n\nstatic boolean parse_property( struct translate_ctx *ctx )\n{\n   struct tgsi_full_property prop;\n   uint property_name;\n   uint values[8];\n   uint advance;\n   char id[64];\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n   if (!parse_identifier( &ctx->cur, id )) {\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n         break;\n      }\n   }\n", "func_hash": 142817990104108566810102542927701673732, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-6209", "cve_desc": "Stack-based buffer overflow in the parse_identifier function in tgsi_text.c in the TGSI auxiliary module in the Gallium driver in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to parsing properties.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-6209"}
{"idx": 242, "project": "virglrenderer", "commit_id": "114688c526fe45f341d75ccd1d85473c3b08f7a7", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=114688c526fe45f341d75ccd1d85473c3b08f7a7", "commit_message": "renderer: fix heap overflow in vertex elements state create\n\nThe 'num_elements' can be controlled by the guest but the\n'vrend_vertex_element_array' has a fixed 'elements' field.\nThis can cause a heap overflow. Add sanity check of 'num_elements'.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n    if (!v)\n       return ENOMEM;\n \n    v->count = num_elements;\n    for (i = 0; i < num_elements; i++) {\n       memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n", "func_hash": 127813115019639337707795536823961346235, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2017-5994", "cve_desc": "Heap-based buffer overflow in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and crash) via the num_elements parameter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5994"}
{"idx": 246, "project": "infradead", "commit_id": "14cae65318d3ef1f7d449e463b72b6934e82f1c2", "project_url": "http://git.infradead.org/?p=mtd-2.6", "commit_url": "http://git.infradead.org/users/dwmw2/openconnect.git/commitdiff/14cae65318d3ef1f7d449e463b72b6934e82f1c2", "commit_message": "None", "target": 1, "func": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n \n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\t\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\n\tfree(banner);\n}\t\n", "func_hash": 174272131383202600271920404270020112167, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2012-3291", "cve_desc": "Heap-based buffer overflow in OpenConnect 3.18 allows remote servers to cause a denial of service via a crafted greeting banner.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-3291"}
{"idx": 254, "project": "virglrenderer", "commit_id": "28894a30a17a84529be102b21118e55d6c9f23fa", "project_url": "https://gitlab.freedesktop.org/virgl/virglrenderer", "commit_url": "https://cgit.freedesktop.org/virglrenderer/commit/src/gallium/auxiliary/tgsi/tgsi_text.c?id=28894a30a17a84529be102b21118e55d6c9f23fa", "commit_message": "gallium/tgsi: fix oob access in parse instruction\n\nWhen parsing texture instruction, it doesn't stop if the\n'cur' is ',', the loop variable 'i' will also be increased\nand be used to index the 'inst.TexOffsets' array. This can lead\nan oob access issue. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>", "target": 1, "func": "parse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n", "func_hash": 207706300612945852467345419819110560855, "file_name": "tgsi_text.c", "file_hash": 168133196584781827023897723824575291202, "cwe": ["CWE-119"], "cve": "CVE-2017-5580", "cve_desc": "The parse_instruction function in gallium/auxiliary/tgsi/tgsi_text.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (out-of-bounds array access and process crash) via a crafted texture instruction.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2017-5580"}
{"idx": 263, "project": "savannah", "commit_id": "888cd1843e935fe675cf2ac303116d4ed5b9d54b", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=888cd1843e935fe675cf2ac303116d4ed5b9d54b", "commit_message": "None", "target": 1, "func": "  Ins_IUP( INS_ARG )\n  {\n    IUP_WorkerRec  V;\n    FT_Byte        mask;\n\n    FT_UInt   first_point;   /* first point of contour        */\n    FT_UInt   end_point;     /* end point (last+1) of contour */\n\n    FT_UInt   first_touched; /* first touched point in contour   */\n    FT_UInt   cur_touched;   /* current touched point in contour */\n\n    FT_UInt   point;         /* current point   */\n    FT_Short  contour;       /* current contour */\n\n    FT_UNUSED_ARG;\n\n\n    /* ignore empty outlines */\n    if ( CUR.pts.n_contours == 0 )\n      return;\n\n    if ( CUR.opcode & 1 )\n    {\n      mask   = FT_CURVE_TAG_TOUCH_X;\n      V.orgs = CUR.pts.org;\n      V.curs = CUR.pts.cur;\n      V.orus = CUR.pts.orus;\n    }\n    else\n    {\n      mask   = FT_CURVE_TAG_TOUCH_Y;\n      V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );\n      V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );\n      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );\n    }\n    V.max_points = CUR.pts.n_points;\n\n    contour = 0;\n    point   = 0;\n\n    do\n    {\n       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;\n       first_point = point;\n \n      if ( CUR.pts.n_points <= end_point )\n        end_point = CUR.pts.n_points;\n \n       while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )\n         point++;\n\n      if ( point <= end_point )\n      {\n        first_touched = point;\n        cur_touched   = point;\n\n        point++;\n\n        while ( point <= end_point )\n        {\n          if ( ( CUR.pts.tags[point] & mask ) != 0 )\n          {\n            if ( point > 0 )\n              _iup_worker_interpolate( &V,\n                                       cur_touched + 1,\n                                       point - 1,\n                                       cur_touched,\n                                       point );\n            cur_touched = point;\n          }\n\n          point++;\n        }\n\n        if ( cur_touched == first_touched )\n          _iup_worker_shift( &V, first_point, end_point, cur_touched );\n        else\n        {\n          _iup_worker_interpolate( &V,\n                                   (FT_UShort)( cur_touched + 1 ),\n                                   end_point,\n                                   cur_touched,\n                                   first_touched );\n\n          if ( first_touched > 0 )\n            _iup_worker_interpolate( &V,\n                                     first_point,\n                                     first_touched - 1,\n                                     cur_touched,\n                                     first_touched );\n        }\n      }\n      contour++;\n    } while ( contour < CUR.pts.n_contours );\n  }\n", "func_hash": 271982803099189327229111379866845675067, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2520", "cve_desc": "Heap-based buffer overflow in the Ins_IUP function in truetype/ttinterp.c in FreeType before 2.4.0, when TrueType bytecode support is enabled, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2520"}
{"idx": 264, "project": "savannah", "commit_id": "b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=b2ea64bcc6c385a8e8318f9c759450a07df58b6d", "commit_message": "None", "target": 1, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n       FT_TRACE3(( \"POST fragment[%d]: offsets=0x%08x, rlen=0x%08x, flags=0x%04x\\n\",\n                    i, offsets[i], rlen, flags ));\n \n       /* the flags are part of the resource, so rlen >= 2.  */\n       /* but some fonts declare rlen = 0 for empty fragment */\n       if ( rlen > 2 )\n\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        if ( pfb_lenpos + 3 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        if ( pfb_pos + 6 > pfb_len + 2 )\n          goto Exit2;\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n      }\n\n      error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n      if ( error )\n        goto Exit2;\n      pfb_pos += rlen;\n    }\n\n    if ( pfb_pos + 2 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_pos++] = 0x80;\n    pfb_data[pfb_pos++] = 3;\n\n    if ( pfb_lenpos + 3 > pfb_len + 2 )\n      goto Exit2;\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 239474837185248719277265167606864341043, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2519", "cve_desc": "Heap-based buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted length value in a POST fragment header in a font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2519"}
{"idx": 267, "project": "savannah", "commit_id": "c69891a1345640096fbf396e8dd567fe879ce233", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c69891a1345640096fbf396e8dd567fe879ce233", "commit_message": "None", "target": 1, "func": "  Mac_Read_POST_Resource( FT_Library  library,\n                          FT_Stream   stream,\n                          FT_Long    *offsets,\n                          FT_Long     resource_cnt,\n                          FT_Long     face_index,\n                          FT_Face    *aface )\n  {\n    FT_Error   error  = FT_Err_Cannot_Open_Resource;\n    FT_Memory  memory = library->memory;\n    FT_Byte*   pfb_data;\n    int        i, type, flags;\n    FT_Long    len;\n    FT_Long    pfb_len, pfb_pos, pfb_lenpos;\n    FT_Long    rlen, temp;\n\n\n    if ( face_index == -1 )\n      face_index = 0;\n    if ( face_index != 0 )\n      return error;\n\n    /* Find the length of all the POST resources, concatenated.  Assume */\n    /* worst case (each resource in its own section).                   */\n    pfb_len = 0;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit;\n      if ( FT_READ_LONG( temp ) )\n        goto Exit;\n      pfb_len += temp + 6;\n    }\n\n    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n      goto Exit;\n\n    pfb_data[0] = 0x80;\n    pfb_data[1] = 1;            /* Ascii section */\n    pfb_data[2] = 0;            /* 4-byte length, fill in later */\n    pfb_data[3] = 0;\n    pfb_data[4] = 0;\n    pfb_data[5] = 0;\n    pfb_pos     = 6;\n    pfb_lenpos  = 2;\n\n    len = 0;\n    type = 1;\n    for ( i = 0; i < resource_cnt; ++i )\n    {\n      error = FT_Stream_Seek( stream, offsets[i] );\n      if ( error )\n        goto Exit2;\n      if ( FT_READ_LONG( rlen ) )\n        goto Exit;\n      if ( FT_READ_USHORT( flags ) )\n        goto Exit;\n      rlen -= 2;                    /* the flags are part of the resource */\n      if ( ( flags >> 8 ) == type )\n        len += rlen;\n      else\n      {\n        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n        if ( ( flags >> 8 ) == 5 )      /* End of font mark */\n          break;\n\n        pfb_data[pfb_pos++] = 0x80;\n\n        type = flags >> 8;\n        len = rlen;\n\n        pfb_data[pfb_pos++] = (FT_Byte)type;\n        pfb_lenpos          = pfb_pos;\n        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n        pfb_data[pfb_pos++] = 0;\n       }\n \n       error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );\n       pfb_pos += rlen;\n     }\n\n    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );\n    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );\n    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );\n    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );\n\n    return open_face_from_buffer( library,\n                                  pfb_data,\n                                  pfb_pos,\n                                  face_index,\n                                  \"type1\",\n                                  aface );\n\n  Exit2:\n    FT_FREE( pfb_data );\n\n  Exit:\n    return error;\n  }\n", "func_hash": 66761366277063878236162927407801840545, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2010-2499", "cve_desc": "Buffer overflow in the Mac_Read_POST_Resource function in base/ftobjs.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted LaserWriter PS font file with an embedded PFB fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-2499"}
{"idx": 287, "project": "samba", "commit_id": "9280051bfba337458722fb157f3082f93cbd9f2b", "project_url": "https://github.com/samba-team/samba", "commit_url": "https://git.samba.org/?p=samba.git;a=commit;h=9280051bfba337458722fb157f3082f93cbd9f2b", "commit_message": "s3: Fix an uninitialized variable read\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>\n\nThanks for that,\n\nVolker\n\nFix bug #7254 (An uninitialized variable read could cause an smbd crash).", "target": 1, "func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n        file_save(\"negotiate.dat\", blob1.data, blob1.length);\n #endif\n \n       p2 = (char *)req->buf + data_blob_len;\n \n        p2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n                                     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}\n", "func_hash": 252100526266913255109910552885875245221, "file_name": "sesssetup.c", "file_hash": 150796593669683248561162249993165628892, "cwe": ["CWE-119"], "cve": "CVE-2010-1642", "cve_desc": "The reply_sesssetup_and_X_spnego function in sesssetup.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to trigger an out-of-bounds read, and cause a denial of service (process crash), via a \\xff\\xff security blob length in a Session Setup AndX request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-1642"}
{"idx": 289, "project": "enlightment", "commit_id": "37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=37a96801663b7b4cd3fbe56cc0eb8b6a17e766a8", "commit_message": "None", "target": 1, "func": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = calloc(w, sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   if (!rows)\n     {\n        goto quit2;\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n \n    if (im->loader || immediate_load || progress)\n      {\n         bg = gif->SBackGroundColor;\n         cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n         im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n           {\n              for (j = 0; j < w; j++)\n                {\n                  if (rows[i][j] == transp)\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                   per += per_inc;\n                   if (progress && (((int)per) != last_per)\n                       && (((int)per) % progress_granularity == 0))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n", "func_hash": 29413401693515776488286177132255863480, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3994", "cve_desc": "The GIF loader in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (application crash) or obtain sensitive information via a crafted image, which triggers an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3994"}
{"idx": 290, "project": "enlightment", "commit_id": "ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "project_url": "https://git.enlightenment.org/legacy/imlib2", "commit_url": "https://git.enlightenment.org/legacy/imlib2.git/commit/?id=ce94edca1ccfbe314cb7cd9453433fad404ec7ef", "commit_message": "None", "target": 1, "func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n", "func_hash": 36599931638812584056030971307038057704, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-3993", "cve_desc": "Off-by-one error in the __imlib_MergeUpdate function in lib/updates.c in imlib2 before 1.4.9 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via crafted coordinates.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-3993"}
{"idx": 354, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 1, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_gpgsm_t gpgsm = (engine_gpgsm_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (gpgsm->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (gpgsm->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (gpgsm->status.fnc)\n\t    err = gpgsm->status.fnc (gpgsm->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && gpgsm->colon.fnc && gpgsm->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              gpgsm->colon.any = 0;\n              err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (gpgsm->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &gpgsm->colon.attic.line;\n\t  int *alinelen = &gpgsm->colon.attic.linelen;\n\n\t  if (gpgsm->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 gpgsm->colon.attic.linesize += linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      gpgsm->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = gpgsm->colon.fnc (gpgsm->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && gpgsm->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (gpgsm->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (gpgsm->status.fnc)\n\t\terr = gpgsm->status.fnc (gpgsm->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", gpgsm,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (gpgsm, keyword);\n          assuan_write_line (gpgsm->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (gpgsm->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 7203629874001971214417650726602123623, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 355, "project": "gnupg", "commit_id": "2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "project_url": "http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg", "commit_url": "https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gpgme.git;a=commit;h=2cbd76f7911fc215845e89b50d6af5ff4a83dd77", "commit_message": "None", "target": 1, "func": "status_handler (void *opaque, int fd)\n{\n  struct io_cb_data *data = (struct io_cb_data *) opaque;\n  engine_uiserver_t uiserver = (engine_uiserver_t) data->handler_value;\n  gpgme_error_t err = 0;\n  char *line;\n  size_t linelen;\n\n  do\n    {\n      err = assuan_read_line (uiserver->assuan_ctx, &line, &linelen);\n      if (err)\n\t{\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: error from assuan (%d) getting status line : %s\",\n                  fd, err, gpg_strerror (err));\n\t}\n      else if (linelen >= 3\n\t       && line[0] == 'E' && line[1] == 'R' && line[2] == 'R'\n\t       && (line[3] == '\\0' || line[3] == ' '))\n\t{\n\t  if (line[3] == ' ')\n\t    err = atoi (&line[4]);\n\t  if (! err)\n\t    err = gpg_error (GPG_ERR_GENERAL);\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: ERR line - mapped to: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  /* Try our best to terminate the connection friendly.  */\n\t  /*\t  assuan_write_line (uiserver->assuan_ctx, \"BYE\"); */\n\t}\n      else if (linelen >= 2\n\t       && line[0] == 'O' && line[1] == 'K'\n\t       && (line[2] == '\\0' || line[2] == ' '))\n\t{\n\t  if (uiserver->status.fnc)\n\t    err = uiserver->status.fnc (uiserver->status.fnc_value,\n\t\t\t\t     GPGME_STATUS_EOF, \"\");\n\n\t  if (!err && uiserver->colon.fnc && uiserver->colon.any)\n            {\n              /* We must tell a colon function about the EOF. We do\n                 this only when we have seen any data lines.  Note\n                 that this inlined use of colon data lines will\n                 eventually be changed into using a regular data\n                 channel. */\n              uiserver->colon.any = 0;\n              err = uiserver->colon.fnc (uiserver->colon.fnc_value, NULL);\n            }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: OK line - final status: %s\",\n                  fd, err ? gpg_strerror (err) : \"ok\");\n\t  _gpgme_io_close (uiserver->status_cb.fd);\n\t  return err;\n\t}\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->colon.fnc)\n        {\n\t  /* We are using the colon handler even for plain inline data\n             - strange name for that function but for historic reasons\n             we keep it.  */\n          /* FIXME We can't use this for binary data because we\n             assume this is a string.  For the current usage of colon\n             output it is correct.  */\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst;\n          char **aline = &uiserver->colon.attic.line;\n\t  int *alinelen = &uiserver->colon.attic.linelen;\n\n\t  if (uiserver->colon.attic.linesize < *alinelen + linelen + 1)\n\t    {\n\t      char *newline = realloc (*aline, *alinelen + linelen + 1);\n\t      if (!newline)\n\t\terr = gpg_error_from_syserror ();\n              else\n                {\n                  *aline = newline;\n                 uiserver->colon.attic.linesize += linelen + 1;\n                }\n            }\n          if (!err)\n\t    {\n\t      dst = *aline + *alinelen;\n\n\t      while (!err && src < end)\n\t\t{\n\t\t  if (*src == '%' && src + 2 < end)\n\t\t    {\n\t\t      /* Handle escaped characters.  */\n\t\t      ++src;\n\t\t      *dst = _gpgme_hextobyte (src);\n\t\t      (*alinelen)++;\n\t\t      src += 2;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst = *src++;\n\t\t      (*alinelen)++;\n\t\t    }\n\n\t\t  if (*dst == '\\n')\n\t\t    {\n\t\t      /* Terminate the pending line, pass it to the colon\n\t\t\t handler and reset it.  */\n\n\t\t      uiserver->colon.any = 1;\n\t\t      if (*alinelen > 1 && *(dst - 1) == '\\r')\n\t\t\tdst--;\n\t\t      *dst = '\\0';\n\n\t\t      /* FIXME How should we handle the return code?  */\n\t\t      err = uiserver->colon.fnc (uiserver->colon.fnc_value, *aline);\n\t\t      if (!err)\n\t\t\t{\n\t\t\t  dst = *aline;\n\t\t\t  *alinelen = 0;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    dst++;\n\t\t}\n\t    }\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D line; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'D' && line[1] == ' '\n\t       && uiserver->inline_data)\n        {\n          char *src = line + 2;\n\t  char *end = line + linelen;\n\t  char *dst = src;\n          gpgme_ssize_t nwritten;\n\n          linelen = 0;\n          while (src < end)\n            {\n              if (*src == '%' && src + 2 < end)\n                {\n                  /* Handle escaped characters.  */\n                  ++src;\n                  *dst++ = _gpgme_hextobyte (src);\n                  src += 2;\n                }\n              else\n                *dst++ = *src++;\n\n              linelen++;\n            }\n\n          src = line + 2;\n          while (linelen > 0)\n            {\n              nwritten = gpgme_data_write (uiserver->inline_data, src, linelen);\n              if (!nwritten || (nwritten < 0 && errno != EINTR)\n                  || nwritten > linelen)\n                {\n                  err = gpg_error_from_syserror ();\n                  break;\n                }\n              src += nwritten;\n              linelen -= nwritten;\n            }\n\n          TRACE2 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: D inlinedata; final status: %s\",\n                  fd, err? gpg_strerror (err):\"ok\");\n        }\n      else if (linelen > 2\n\t       && line[0] == 'S' && line[1] == ' ')\n\t{\n\t  char *rest;\n\t  gpgme_status_code_t r;\n\n\t  rest = strchr (line + 2, ' ');\n\t  if (!rest)\n\t    rest = line + linelen; /* set to an empty string */\n\t  else\n\t    *(rest++) = 0;\n\n\t  r = _gpgme_parse_status (line + 2);\n\n\t  if (r >= 0)\n\t    {\n\t      if (uiserver->status.fnc)\n\t\terr = uiserver->status.fnc (uiserver->status.fnc_value, r, rest);\n\t    }\n\t  else\n\t    fprintf (stderr, \"[UNKNOWN STATUS]%s %s\", line + 2, rest);\n          TRACE3 (DEBUG_CTX, \"gpgme:status_handler\", uiserver,\n\t\t  \"fd 0x%x: S line (%s) - final status: %s\",\n                  fd, line+2, err? gpg_strerror (err):\"ok\");\n\t}\n      else if (linelen >= 7\n               && line[0] == 'I' && line[1] == 'N' && line[2] == 'Q'\n               && line[3] == 'U' && line[4] == 'I' && line[5] == 'R'\n               && line[6] == 'E'\n               && (line[7] == '\\0' || line[7] == ' '))\n        {\n          char *keyword = line+7;\n\n          while (*keyword == ' ')\n            keyword++;;\n          default_inq_cb (uiserver, keyword);\n          assuan_write_line (uiserver->assuan_ctx, \"END\");\n        }\n\n    }\n  while (!err && assuan_pending_line (uiserver->assuan_ctx));\n\n  return err;\n}\n", "func_hash": 77372948009689993078192342243939039842, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3564", "cve_desc": "Multiple heap-based buffer overflows in the status_handler function in (1) engine-gpgsm.c and (2) engine-uiserver.c in GPGME before 1.5.1 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to \"different line lengths in a specific order.\"", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3564"}
{"idx": 367, "project": "openssl", "commit_id": "578b956fe741bf8e84055547b1e83c28dd902c73", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=578b956fe741bf8e84055547b1e83c28dd902c73", "commit_message": "Fix memory issues in BIO_*printf functions\n\nThe internal |fmtstr| function used in processing a \"%s\" format string\nin the BIO_*printf functions could overflow while calculating the length\nof a string and cause an OOB read when printing very long strings.\n\nAdditionally the internal |doapr_outch| function can attempt to write to\nan OOB memory location (at an offset from the NULL pointer) in the event of\na memory allocation failure. In 1.0.2 and below this could be caused where\nthe size of a buffer to be allocated is greater than INT_MAX. E.g. this\ncould be in processing a very long \"%s\" format string. Memory leaks can also\noccur.\n\nThese issues will only occur on certain platforms where sizeof(size_t) >\nsizeof(int). E.g. many 64 bit systems. The first issue may mask the second\nissue dependent on compiler behaviour.\n\nThese problems could enable attacks where large amounts of untrusted data\nis passed to the BIO_*printf functions. If applications use these functions\nin this way then they could be vulnerable. OpenSSL itself uses these\nfunctions when printing out human-readable dumps of ASN.1 data. Therefore\napplications that print this data could be vulnerable if the data is from\nuntrusted sources. OpenSSL command line applications could also be\nvulnerable where they print out ASN.1 data, or if untrusted data is passed\nas command line arguments.\n\nLibssl is not considered directly vulnerable. Additionally certificates etc\nreceived via remote connections via libssl are also unlikely to be able to\ntrigger these issues because of message size limits enforced within libssl.\n\nCVE-2016-0799\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 1, "func": " _dopr(char **sbuffer,\n       char **buffer,\n       size_t *maxlen,\n      size_t *retlen, int *truncated, const char *format, va_list args)\n{\n    char ch;\n    LLONG value;\n    LDOUBLE fvalue;\n    char *strvalue;\n    int min;\n    int max;\n    int state;\n    int flags;\n    int cflags;\n    size_t currlen;\n\n    state = DP_S_DEFAULT;\n    flags = currlen = cflags = min = 0;\n    max = -1;\n    ch = *format++;\n\n    while (state != DP_S_DONE) {\n        if (ch == '\\0' || (buffer == NULL && currlen >= *maxlen))\n            state = DP_S_DONE;\n\n        switch (state) {\n        case DP_S_DEFAULT:\n             if (ch == '%')\n                 state = DP_S_FLAGS;\n             else\n                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\n             ch = *format++;\n             break;\n         case DP_S_FLAGS:\n            case '-':\n                flags |= DP_F_MINUS;\n                ch = *format++;\n                break;\n            case '+':\n                flags |= DP_F_PLUS;\n                ch = *format++;\n                break;\n            case ' ':\n                flags |= DP_F_SPACE;\n                ch = *format++;\n                break;\n            case '#':\n                flags |= DP_F_NUM;\n                ch = *format++;\n                break;\n            case '0':\n                flags |= DP_F_ZERO;\n                ch = *format++;\n                break;\n            default:\n                state = DP_S_MIN;\n                break;\n            }\n            break;\n        case DP_S_MIN:\n            if (isdigit((unsigned char)ch)) {\n                min = 10 * min + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                min = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_DOT;\n            } else\n                state = DP_S_DOT;\n            break;\n        case DP_S_DOT:\n            if (ch == '.') {\n                state = DP_S_MAX;\n                ch = *format++;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MAX:\n            if (isdigit((unsigned char)ch)) {\n                if (max < 0)\n                    max = 0;\n                max = 10 * max + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                max = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_MOD;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MOD:\n            switch (ch) {\n            case 'h':\n                cflags = DP_C_SHORT;\n                ch = *format++;\n                break;\n            case 'l':\n                if (*format == 'l') {\n                    cflags = DP_C_LLONG;\n                    format++;\n                } else\n                    cflags = DP_C_LONG;\n                ch = *format++;\n                break;\n            case 'q':\n                cflags = DP_C_LLONG;\n                ch = *format++;\n                break;\n            case 'L':\n                cflags = DP_C_LDOUBLE;\n                ch = *format++;\n                break;\n            default:\n                break;\n            }\n            state = DP_S_CONV;\n            break;\n        case DP_S_CONV:\n            switch (ch) {\n            case 'd':\n            case 'i':\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (short int)va_arg(args, int);\n                    break;\n                case DP_C_LONG:\n                    value = va_arg(args, long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, LLONG);\n                    break;\n                default:\n                    value = va_arg(args, int);\n                     value = va_arg(args, int);\n                     break;\n                 }\n                fmtint(sbuffer, buffer, &currlen, maxlen,\n                       value, 10, min, max, flags);\n                 break;\n             case 'X':\n                 flags |= DP_F_UP;\n            case 'o':\n            case 'u':\n                flags |= DP_F_UNSIGNED;\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (unsigned short int)va_arg(args, unsigned int);\n                    break;\n                case DP_C_LONG:\n                    value = (LLONG) va_arg(args, unsigned long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, unsigned LLONG);\n                    break;\n                default:\n                    value = (LLONG) va_arg(args, unsigned int);\n                    break;\n                     value = (LLONG) va_arg(args, unsigned int);\n                     break;\n                 }\n                fmtint(sbuffer, buffer, &currlen, maxlen, value,\n                       ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\n                       min, max, flags);\n                 break;\n             case 'f':\n                 if (cflags == DP_C_LDOUBLE)\n                     fvalue = va_arg(args, LDOUBLE);\n                 else\n                     fvalue = va_arg(args, double);\n                fmtfp(sbuffer, buffer, &currlen, maxlen,\n                      fvalue, min, max, flags);\n                 break;\n             case 'E':\n                 flags |= DP_F_UP;\n                    fvalue = va_arg(args, double);\n                break;\n            case 'G':\n                flags |= DP_F_UP;\n            case 'g':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                break;\n            case 'c':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                     fvalue = va_arg(args, double);\n                 break;\n             case 'c':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen,\n                            va_arg(args, int));\n                 break;\n             case 's':\n                 strvalue = va_arg(args, char *);\n                }\n                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                       flags, min, max);\n                     else\n                         max = *maxlen;\n                 }\n                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\n                       flags, min, max);\n                 break;\n             case 'p':\n                 value = (long)va_arg(args, void *);\n                fmtint(sbuffer, buffer, &currlen, maxlen,\n                       value, 16, min, max, flags | DP_F_NUM);\n                 break;\n             case 'n':          /* XXX */\n                 if (cflags == DP_C_SHORT) {\n                } else if (cflags == DP_C_LLONG) { /* XXX */\n                    LLONG *num;\n                    num = va_arg(args, LLONG *);\n                    *num = (LLONG) currlen;\n                } else {\n                    int *num;\n                    num = va_arg(args, int *);\n                    *num = currlen;\n                }\n                break;\n            case '%':\n                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\n                break;\n            case 'w':\n                /* not supported yet, treat as next char */\n                 }\n", "func_hash": 309192226193988062421957531577393101030, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2842", "cve_desc": "The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2842"}
{"idx": 368, "project": "savannah", "commit_id": "a3bc7e9400b214a0f078fdb19596ba54214a1442", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/quagga.git/commit/?id=a3bc7e9400b214a0f078fdb19596ba54214a1442", "commit_message": "None", "target": 1, "func": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = AF_INET;\n       psize = PSIZE (prefixlen);\n      if (prefixlen < 88)\n\t{\n\t  zlog_err (\"prefix length is less than 88: %d\", prefixlen);\n\t  return -1;\n\t}\n       /* Copyr label to prefix. */\n      tagpnt = pnt;;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - 88;\n      memcpy (&p.u.prefix, pnt + 11, psize - 11);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}\n", "func_hash": 189301502052689275853315045175183465473, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2342", "cve_desc": "The bgp_nlri_parse_vpnv4 function in bgp_mplsvpn.c in the VPNv4 NLRI parser in bgpd in Quagga before 1.0.20160309, when a certain VPNv4 configuration is used, relies on a Labeled-VPN SAFI routes-data length field during a data copy, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2342"}
{"idx": 383, "project": "openssl", "commit_id": "2919516136a4227d9e6d8f2fe66ef976aaf8c561", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/?p=openssl.git;a=commitdiff;h=2919516136a4227d9e6d8f2fe66ef976aaf8c561", "commit_message": "Prevent EBCDIC overread for very long strings\n\nASN1 Strings that are over 1024 bytes can cause an overread in\napplications using the X509_NAME_oneline() function on EBCDIC systems.\nThis could result in arbitrary stack data being returned in the buffer.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2176\n\nReviewed-by: Andy Polyakov <appro@openssl.org>", "target": 1, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n                         ? sizeof ebcdic_buf : num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n", "func_hash": 92428507097973547653884047469651088423, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-2176", "cve_desc": "The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2176"}
{"idx": 398, "project": "ghostscript", "commit_id": "60dabde18d7fe12b19da8b509bdfee9cc886aafc", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=60dabde18d7fe12b19da8b509bdfee9cc886aafc", "commit_message": "None", "target": 1, "func": " xps_parse_color(xps_document *doc, char *base_uri, char *string,\n                fz_colorspace **csp, float *samples)\n {\n        char *p;\n        int i, n;\n        char buf[1024];\n        char *profile;\n \n       *csp = fz_device_rgb(doc->ctx);\n \n        samples[0] = 1;\n        samples[1] = 0;\n\tsamples[3] = 0;\n\n\tif (string[0] == '#')\n\t{\n\t\tif (strlen(string) == 9)\n\t\t{\n\t\t\tsamples[0] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[1] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[2] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t\tsamples[3] = unhex(string[7]) * 16 + unhex(string[8]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsamples[0] = 255;\n\t\t\tsamples[1] = unhex(string[1]) * 16 + unhex(string[2]);\n\t\t\tsamples[2] = unhex(string[3]) * 16 + unhex(string[4]);\n\t\t\tsamples[3] = unhex(string[5]) * 16 + unhex(string[6]);\n\t\t}\n\n\t\tsamples[0] /= 255;\n\t\tsamples[1] /= 255;\n\t\tsamples[2] /= 255;\n\t\tsamples[3] /= 255;\n\t}\n\n\telse if (string[0] == 's' && string[1] == 'c' && string[2] == '#')\n\t{\n\t\tif (count_commas(string) == 2)\n\t\t\tsscanf(string, \"sc#%g,%g,%g\", samples + 1, samples + 2, samples + 3);\n\t\tif (count_commas(string) == 3)\n\t\t\tsscanf(string, \"sc#%g,%g,%g,%g\", samples, samples + 1, samples + 2, samples + 3);\n\t}\n\n\telse if (strstr(string, \"ContextColor \") == string)\n\t{\n\t\t/* Crack the string for profile name and sample values */\n\t\tfz_strlcpy(buf, string, sizeof buf);\n\n\t\tprofile = strchr(buf, ' ');\n                profile = strchr(buf, ' ');\n                if (!profile)\n                {\n                       fz_warn(doc->ctx, \"cannot find icc profile uri in '%s'\", string);\n                        return;\n                }\n \n\t\tp = strchr(profile, ' ');\n                p = strchr(profile, ' ');\n                if (!p)\n                {\n                       fz_warn(doc->ctx, \"cannot find component values in '%s'\", profile);\n                        return;\n                }\n \n                *p++ = 0;\n                n = count_commas(p) + 1;\n                i = 0;\n                while (i < n)\n                {\n\t\t\t\tp ++;\n\t\t}\n\t\twhile (i < n)\n\t\t{\n\t\t\tsamples[i++] = 0;\n\t\t}\n\n\t\t/* TODO: load ICC profile */\n\t\tswitch (n)\n\t\t{\n\t\tcase 2: *csp = fz_device_gray(doc->ctx); break;\n\t\tcase 4: *csp = fz_device_rgb(doc->ctx); break;\n\t\tcase 5: *csp = fz_device_cmyk(doc->ctx); break;\n                /* TODO: load ICC profile */\n                switch (n)\n                {\n               case 2: *csp = fz_device_gray(doc->ctx); break;\n               case 4: *csp = fz_device_rgb(doc->ctx); break;\n               case 5: *csp = fz_device_cmyk(doc->ctx); break;\n               default: *csp = fz_device_gray(doc->ctx); break;\n                }\n        }\n }\n\tfor (i = 0; i < colorspace->n; i++)\n\t\tdoc->color[i] = samples[i + 1];\n\tdoc->alpha = samples[0] * doc->opacity[doc->opacity_top];\n}\n", "func_hash": 173680462593951007227148221492379395830, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-2013", "cve_desc": "Stack-based buffer overflow in the xps_parse_color function in xps/xps-common.c in MuPDF 1.3 and earlier allows remote attackers to execute arbitrary code via a large number of entries in the ContextColor value of the Fill attribute in a Path element.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-2013"}
{"idx": 409, "project": "libav", "commit_id": "5a396bb3a66a61a68b80f2369d0249729bf85e04", "project_url": "https://github.com/libav/libav", "commit_url": "https://git.libav.org/?p=libav.git;a=commitdiff;h=5a396bb3a66a61a68b80f2369d0249729bf85e04", "commit_message": "dv: Fix null pointer dereference due to ach=0\n\ndv: Fix null pointer dereference due to ach=0\n\nFixes part2 of CVE-2011-3929\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nReviewed-by: Roman Shaposhnik <roman@shaposhnik.org>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Alex Converse <alex.converse@gmail.com>", "target": 1, "func": "int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = avpriv_dv_frame_profile(c->sys, buf, buf_size)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   /* Broken frame, or not enough data */\n    }\n\n    /* Queueing audio packet */\n    /* FIXME: in case of no audio/bad audio we have to do something */\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n        ppcm[i] = c->audio_buf[i];\n     }\n    dv_extract_audio(buf, ppcm, c->sys);\n \n     /* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. */\n        if (buf[1] & 0x0C) {\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        } else {\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n            c->abytes += size;\n        }\n    } else {\n        c->abytes += size;\n    }\n", "func_hash": 106330760518707613007105817589614452739, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3929", "cve_desc": "The avpriv_dv_produce_packet function in libavcodec in FFmpeg 0.7.x before 0.7.12 and 0.8.x before 0.8.11 and in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.5, and 0.8.x before 0.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) and possibly execute arbitrary code via a crafted DV file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3929"}
{"idx": 410, "project": "harfbuzz", "commit_id": "81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "project_url": "https://github.com/behdad/harfbuzz", "commit_url": "https://cgit.freedesktop.org/harfbuzz.old/commit/?id=81c8ef785b079980ad5b46be4fe7c7bf156dbf65", "commit_message": "None", "target": 1, "func": "static HB_Error  Lookup_MarkMarkPos( GPOS_Instance*    gpi,\n\t\t\t\t     HB_GPOS_SubTable* st,\n\t\t\t\t     HB_Buffer        buffer,\n\t\t\t\t     HB_UShort         flags,\n\t\t\t\t     HB_UShort         context_length,\n\t\t\t\t     int               nesting_level )\n{\n  HB_UShort        i, j, mark1_index, mark2_index, property, class;\n  HB_Fixed           x_mark1_value, y_mark1_value,\n\t\t   x_mark2_value, y_mark2_value;\n  HB_Error         error;\n  HB_GPOSHeader*  gpos = gpi->gpos;\n  HB_MarkMarkPos* mmp = &st->markmark;\n\n  HB_MarkArray*    ma1;\n  HB_Mark2Array*   ma2;\n  HB_Mark2Record*  m2r;\n  HB_Anchor*       mark1_anchor;\n  HB_Anchor*       mark2_anchor;\n\n  HB_Position    o;\n\n  HB_UNUSED(nesting_level);\n\n  if ( context_length != 0xFFFF && context_length < 1 )\n    return HB_Err_Not_Covered;\n\n  if ( flags & HB_LOOKUP_FLAG_IGNORE_MARKS )\n    return HB_Err_Not_Covered;\n\n  if ( CHECK_Property( gpos->gdef, IN_CURITEM(),\n\t\t       flags, &property ) )\n    return error;\n\n  error = _HB_OPEN_Coverage_Index( &mmp->Mark1Coverage, IN_CURGLYPH(),\n\t\t\t  &mark1_index );\n  if ( error )\n    return error;\n\n  /* now we search backwards for a suitable mark glyph until a non-mark\n     glyph                                                */\n\n  if ( buffer->in_pos == 0 )\n    return HB_Err_Not_Covered;\n\n  i = 1;\n  j = buffer->in_pos - 1;\n  while ( i <= buffer->in_pos )\n  {\n    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),\n\t\t\t\t\t&property );\n    if ( error )\n      return error;\n\n    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )\n      return HB_Err_Not_Covered;\n\n    if ( flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )\n    {\n      if ( property == (flags & 0xFF00) )\n        break;\n    }\n    else\n      break;\n\n    i++;\n     j--;\n   }\n \n   error = _HB_OPEN_Coverage_Index( &mmp->Mark2Coverage, IN_GLYPH( j ),\n \t\t\t  &mark2_index );\n   if ( error )\n\n  if ( mark1_index >= ma1->MarkCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  class        = ma1->MarkRecord[mark1_index].Class;\n  mark1_anchor = &ma1->MarkRecord[mark1_index].MarkAnchor;\n\n  if ( class >= mmp->ClassCount )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  ma2 = &mmp->Mark2Array;\n\n  if ( mark2_index >= ma2->Mark2Count )\n    return ERR(HB_Err_Invalid_SubTable);\n\n  m2r          = &ma2->Mark2Record[mark2_index];\n  mark2_anchor = &m2r->Mark2Anchor[class];\n\n  error = Get_Anchor( gpi, mark1_anchor, IN_CURGLYPH(),\n\t\t      &x_mark1_value, &y_mark1_value );\n  if ( error )\n    return error;\n  error = Get_Anchor( gpi, mark2_anchor, IN_GLYPH( j ),\n\t\t      &x_mark2_value, &y_mark2_value );\n  if ( error )\n    return error;\n\n  /* anchor points are not cumulative */\n\n  o = POSITION( buffer->in_pos );\n\n  o->x_pos     = x_mark2_value - x_mark1_value;\n  o->y_pos     = y_mark2_value - y_mark1_value;\n  o->x_advance = 0;\n  o->y_advance = 0;\n  o->back      = 1;\n\n  (buffer->in_pos)++;\n\n  return HB_Err_Ok;\n}\n", "func_hash": 311194674003134329769297107152985881683, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2011-3193", "cve_desc": "Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3193"}
{"idx": 432, "project": "openssl", "commit_id": "1632ef744872edc2aa2a53d487d3e79c965a4ad3", "project_url": "https://github.com/openssl/openssl", "commit_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=1632ef744872edc2aa2a53d487d3e79c965a4ad3", "commit_message": "Fix for CVE-2014-0195\n\nA buffer overrun attack can be triggered by sending invalid DTLS fragments\nto an OpenSSL DTLS client or server. This is potentially exploitable to\nrun arbitrary code on a vulnerable client or server.\n\nFixed by adding consistency check for DTLS fragments.\n\nThanks to Jri Aedla for reporting this issue.", "target": 1, "func": "dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t/* Determine maximum allowed message size. Depends on (user set)\n\t * maximum certificate length, but 16k is minimum.\n\t */\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\n\t/* Try to find item in queue */\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n                frag->msg_header.frag_off = 0;\n                }\n        else\n                frag = (hm_fragment*) item->data;\n \n        /* If message is already reassembled, this must be a\n         * retransmit and can be dropped.\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n", "func_hash": 277478106358864729741213619139959810391, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-0195", "cve_desc": "The dtls1_reassemble_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly validate fragment lengths in DTLS ClientHello messages, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) via a long non-initial fragment.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0195"}
{"idx": 448, "project": "libxfont", "commit_id": "4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=4d024ac10f964f6bd372ae0dd14f02772a6e5f63", "commit_message": "None", "target": 1, "func": "bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState,\n\t\t  int bit, int byte, int glyph, int scan)\n{\n    unsigned char *line;\n    register CharInfoPtr ci;\n    int         i,\n                ndx,\n                nchars,\n                nignored;\n    unsigned int char_row, char_col;\n    int         numEncodedGlyphs = 0;\n    CharInfoPtr *bdfEncoding[256];\n    BitmapFontPtr  bitmapFont;\n    BitmapExtraPtr bitmapExtra;\n    CARD32     *bitmapsSizes;\n    unsigned char        lineBuf[BDFLINELEN];\n    int         nencoding;\n\n    bitmapFont = (BitmapFontPtr) pFont->fontPrivate;\n    bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;\n\n    if (bitmapExtra) {\n\tbitmapsSizes = bitmapExtra->bitmapsSizes;\n\tfor (i = 0; i < GLYPHPADOPTIONS; i++)\n\t    bitmapsSizes[i] = 0;\n    } else\n\tbitmapsSizes = NULL;\n\n    bzero(bdfEncoding, sizeof(bdfEncoding));\n    bitmapFont->metrics = NULL;\n    ndx = 0;\n\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\n    if ((!line) || (sscanf((char *) line, \"CHARS %d\", &nchars) != 1)) {\n\tbdfError(\"bad 'CHARS' in bdf file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars < 1) {\n\tbdfError(\"invalid number of CHARS in BDF file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars > INT32_MAX / sizeof(CharInfoRec)) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    ci = calloc(nchars, sizeof(CharInfoRec));\n    if (!ci) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    bitmapFont->metrics = ci;\n\n    if (bitmapExtra) {\n\tbitmapExtra->glyphNames = malloc(nchars * sizeof(Atom));\n\tif (!bitmapExtra->glyphNames) {\n\t    bdfError(\"Couldn't allocate glyphNames (%d*%d)\\n\",\n\t\t     nchars, (int) sizeof(Atom));\n\t    goto BAILOUT;\n\t}\n    }\n    if (bitmapExtra) {\n\tbitmapExtra->sWidths = malloc(nchars * sizeof(int));\n\tif (!bitmapExtra->sWidths) {\n\t    bdfError(\"Couldn't allocate sWidth (%d *%d)\\n\",\n\t\t     nchars, (int) sizeof(int));\n\t    return FALSE;\n\t}\n    }\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n    pFont->info.firstRow = 256;\n    pFont->info.lastRow = 0;\n    pFont->info.firstCol = 256;\n    pFont->info.lastCol = 0;\n    nignored = 0;\n    for (ndx = 0; (ndx < nchars) && (line) && (bdfIsPrefix(line, \"STARTCHAR\"));) {\n\tint         t;\n\tint         wx;\t\t/* x component of width */\n\tint         wy;\t\t/* y component of width */\n\tint         bw;\t\t/* bounding-box width */\n\tint         bh;\t\t/* bounding-box height */\n\tint         bl;\t\t/* bounding-box left */\n\tint         bb;\t\t/* bounding-box bottom */\n\tint         enc,\n\t            enc2;\t/* encoding */\n\tunsigned char *p;\t/* temp pointer into line */\n \tchar        charName[100];\n \tint         ignore;\n \n\tif (sscanf((char *) line, \"STARTCHAR %s\", charName) != 1) {\n \t    bdfError(\"bad character name in BDF file\\n\");\n \t    goto BAILOUT;\t/* bottom of function, free and return error */\n \t}\n\tif (bitmapExtra)\n\t    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif (!line || (t = sscanf((char *) line, \"ENCODING %d %d\", &enc, &enc2)) < 1) {\n\t    bdfError(\"bad 'ENCODING' in BDF file\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (enc < -1 || (t == 2 && enc2 < -1)) {\n\t    bdfError(\"bad ENCODING value\");\n\t    goto BAILOUT;\n\t}\n\tif (t == 2 && enc == -1)\n\t    enc = enc2;\n\tignore = 0;\n\tif (enc == -1) {\n\t    if (!bitmapExtra) {\n\t\tnignored++;\n\t\tignore = 1;\n\t    }\n\t} else if (enc > MAXENCODING) {\n\t    bdfError(\"char '%s' has encoding too large (%d)\\n\",\n\t\t     charName, enc);\n\t} else {\n\t    char_row = (enc >> 8) & 0xFF;\n\t    char_col = enc & 0xFF;\n\t    if (char_row < pFont->info.firstRow)\n\t\tpFont->info.firstRow = char_row;\n\t    if (char_row > pFont->info.lastRow)\n\t\tpFont->info.lastRow = char_row;\n\t    if (char_col < pFont->info.firstCol)\n\t\tpFont->info.firstCol = char_col;\n\t    if (char_col > pFont->info.lastCol)\n\t\tpFont->info.lastCol = char_col;\n\t    if (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t\tbdfEncoding[char_row] = malloc(256 * sizeof(CharInfoPtr));\n\t\tif (!bdfEncoding[char_row]) {\n\t\t    bdfError(\"Couldn't allocate row %d of encoding (%d*%d)\\n\",\n\t\t\t     char_row, INDICES, (int) sizeof(CharInfoPtr));\n\t\t    goto BAILOUT;\n\t\t}\n\t\tfor (i = 0; i < 256; i++)\n\t\t    bdfEncoding[char_row][i] = (CharInfoPtr) NULL;\n\t    }\n\t    if (bdfEncoding[char_row] != NULL) {\n\t\tbdfEncoding[char_row][char_col] = ci;\n\t\tnumEncodedGlyphs++;\n\t    }\n\t}\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"SWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'SWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"SWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (bitmapExtra)\n\t    bitmapExtra->sWidths[ndx] = wx;\n\n/* 5/31/89 (ef) -- we should be able to ditch the character and recover */\n/*\t\tfrom all of these.\t\t\t\t\t*/\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"DWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'DWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"DWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"BBX %d %d %d %d\", &bw, &bh, &bl, &bb) != 4)) {\n\t    bdfError(\"bad 'BBX'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif ((bh < 0) || (bw < 0)) {\n\t    bdfError(\"character '%s' has a negative sized bitmap, %dx%d\\n\",\n\t\t     charName, bw, bh);\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((line) && (bdfIsPrefix(line, \"ATTRIBUTES\"))) {\n\t    for (p = line + strlen(\"ATTRIBUTES \");\n\t\t    (*p == ' ') || (*p == '\\t');\n\t\t    p++)\n\t\t /* empty for loop */ ;\n\t    ci->metrics.attributes = (bdfHexByte(p) << 8) + bdfHexByte(p + 2);\n\t    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\t} else\n\t    ci->metrics.attributes = 0;\n\n\tif (!line || !bdfIsPrefix(line, \"BITMAP\")) {\n\t    bdfError(\"missing 'BITMAP'\\n\");\n\t    goto BAILOUT;\n\t}\n\t/* collect data for generated properties */\n\tif ((strlen(charName) == 1)) {\n\t    if ((charName[0] >= '0') && (charName[0] <= '9')) {\n\t\tpState->digitWidths += wx;\n\t\tpState->digitCount++;\n\t    } else if (charName[0] == 'x') {\n\t\tpState->exHeight = (bh + bb) <= 0 ? bh : bh + bb;\n\t    }\n\t}\n\tif (!ignore) {\n\t    ci->metrics.leftSideBearing = bl;\n\t    ci->metrics.rightSideBearing = bl + bw;\n\t    ci->metrics.ascent = bh + bb;\n\t    ci->metrics.descent = -bb;\n\t    ci->metrics.characterWidth = wx;\n\t    ci->bits = NULL;\n\t    bdfReadBitmap(ci, file, bit, byte, glyph, scan, bitmapsSizes);\n\t    ci++;\n\t    ndx++;\n\t} else\n\t    bdfSkipBitmap(file, bh);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\t/* get STARTCHAR or\n\t\t\t\t\t\t\t * ENDFONT */\n    }\n\n    if (ndx + nignored != nchars) {\n\tbdfError(\"%d too few characters\\n\", nchars - (ndx + nignored));\n\tgoto BAILOUT;\n    }\n    nchars = ndx;\n    bitmapFont->num_chars = nchars;\n    if ((line) && (bdfIsPrefix(line, \"STARTCHAR\"))) {\n\tbdfError(\"more characters than specified\\n\");\n\tgoto BAILOUT;\n    }\n    if ((!line) || (!bdfIsPrefix(line, \"ENDFONT\"))) {\n\tbdfError(\"missing 'ENDFONT'\\n\");\n\tgoto BAILOUT;\n    }\n    if (numEncodedGlyphs == 0)\n\tbdfWarning(\"No characters with valid encodings\\n\");\n\n    nencoding = (pFont->info.lastRow - pFont->info.firstRow + 1) *\n\t(pFont->info.lastCol - pFont->info.firstCol + 1);\n    bitmapFont->encoding = calloc(NUM_SEGMENTS(nencoding),sizeof(CharInfoPtr*));\n    if (!bitmapFont->encoding) {\n\tbdfError(\"Couldn't allocate ppCI (%d,%d)\\n\",\n                 NUM_SEGMENTS(nencoding),\n                 (int) sizeof(CharInfoPtr*));\n\tgoto BAILOUT;\n    }\n    pFont->info.allExist = TRUE;\n    i = 0;\n    for (char_row = pFont->info.firstRow;\n\t    char_row <= pFont->info.lastRow;\n\t    char_row++) {\n\tif (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t    pFont->info.allExist = FALSE;\n            i += pFont->info.lastCol - pFont->info.firstCol + 1;\n\t} else {\n\t    for (char_col = pFont->info.firstCol;\n\t\t    char_col <= pFont->info.lastCol;\n\t\t    char_col++) {\n\t\tif (!bdfEncoding[char_row][char_col])\n\t\t    pFont->info.allExist = FALSE;\n                else {\n                    if (!bitmapFont->encoding[SEGMENT_MAJOR(i)]) {\n                        bitmapFont->encoding[SEGMENT_MAJOR(i)]=\n                            calloc(BITMAP_FONT_SEGMENT_SIZE,\n                                   sizeof(CharInfoPtr));\n                        if (!bitmapFont->encoding[SEGMENT_MAJOR(i)])\n                            goto BAILOUT;\n                    }\n                    ACCESSENCODINGL(bitmapFont->encoding,i) =\n                        bdfEncoding[char_row][char_col];\n                }\n                i++;\n            }\n\t}\n    }\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    return (TRUE);\nBAILOUT:\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    /* bdfFreeFontBits will clean up the rest */\n    return (FALSE);\n}\n", "func_hash": 130454261969297534776999866382375298733, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-6462", "cve_desc": "Stack-based buffer overflow in the bdfReadCharacters function in bitmap/bdfread.c in X.Org libXfont 1.1 through 1.4.6 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a long string in a character name in a BDF font file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6462"}
{"idx": 462, "project": "libbsd", "commit_id": "c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "project_url": "https://gitlab.freedesktop.org/libbsd/libbsd", "commit_url": "https://cgit.freedesktop.org/libbsd/commit/?id=c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7", "commit_message": "Fix heap buffer overflow in fgetwln()\n\nIn the function fgetwln() there's a 4 byte heap overflow.\n\nThere is a while loop that has this check to see whether there's still\nenough space in the buffer:\n\n\t\tif (!fb->len || wused > fb->len) {\n\nIf this is true more memory gets allocated. However this test won't be\ntrue if wused == fb->len, but at that point wused already points out\nof the buffer. Some lines later there's a write to the buffer:\n\n\t\tfb->wbuf[wused++] = wc;\n\nThis bug was found with the help of address sanitizer.\n\nWarned-by: ASAN\nFixes: https://bugs.freedesktop.org/show_bug.cgi?id=93881\nSigned-off-by: Guillem Jover <guillem@hadrons.org>", "target": 1, "func": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n", "func_hash": 111742657801644456380340973720301242850, "file_name": "fgetwln.c", "file_hash": 917190743564002721116809438866317831, "cwe": ["CWE-119"], "cve": "CVE-2016-2090", "cve_desc": "Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-2090"}
{"idx": 511, "project": "libxfont", "commit_id": "5bf703700ee4a5d6eae20da07cb7a29369667aef", "project_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=d11ee5886e9d9ec610051a206b135a4cdc1e09a0", "commit_url": "https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=5bf703700ee4a5d6eae20da07cb7a29369667aef", "commit_message": "None", "target": 1, "func": "CatalogueRescan (FontPathElementPtr fpe)\n{\n    CataloguePtr\tcat = fpe->private;\n    char\t\tlink[MAXFONTFILENAMELEN];\n    char\t\tdest[MAXFONTFILENAMELEN];\n    char\t\t*attrib;\n    FontPathElementPtr\tsubfpe;\n    struct stat\t\tstatbuf;\n    const char\t\t*path;\n    DIR\t\t\t*dir;\n    struct dirent\t*entry;\n    int\t\t\tlen;\n    int\t\t\tpathlen;\n\n    path = fpe->name + strlen(CataloguePrefix);\n    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))\n\treturn BadFontPath;\n\n    if (statbuf.st_mtime <= cat->mtime)\n\treturn Successful;\n\n    dir = opendir(path);\n    if (dir == NULL)\n    {\n\txfree(cat);\n\treturn BadFontPath;\n    }\n\n    CatalogueUnrefFPEs (fpe);\n     while (entry = readdir(dir), entry != NULL)\n     {\n \tsnprintf(link, sizeof link, \"%s/%s\", path, entry->d_name);\n\tlen = readlink(link, dest, sizeof dest);\n \tif (len < 0)\n \t    continue;\n\tdest[len] = '\\0';\n\n\tif (dest[0] != '/')\n\t{\n\t   pathlen = strlen(path);\n\t   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);\n\t   memcpy(dest, path, pathlen);\n\t   memcpy(dest + pathlen, \"/\", 1);\n\t   len += pathlen + 1;\n\t}\n\n\tattrib = strchr(link, ':');\n\tif (attrib && len + strlen(attrib) < sizeof dest)\n\t{\n\t    memcpy(dest + len, attrib, strlen(attrib));\n\t    len += strlen(attrib);\n\t}\n\n\tsubfpe = xalloc(sizeof *subfpe);\n\tif (subfpe == NULL)\n\t    continue;\n\n\t/* The fonts returned by OpenFont will point back to the\n\t * subfpe they come from.  So set the type of the subfpe to\n\t * what the catalogue fpe was assigned, so calls to CloseFont\n\t * (which uses font->fpe->type) goes to CatalogueCloseFont. */\n\tsubfpe->type = fpe->type;\n\tsubfpe->name_length = len;\n\tsubfpe->name = xalloc (len + 1);\n\tif (subfpe == NULL)\n\t{\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tmemcpy(subfpe->name, dest, len);\n\tsubfpe->name[len] = '\\0';\n\n\t/* The X server will manipulate the subfpe ref counts\n\t * associated with the font in OpenFont and CloseFont, so we\n\t * have to make sure it's valid. */\n\tsubfpe->refcount = 1;\n\n\tif (FontFileInitFPE (subfpe) != Successful)\n\t{\n\t    xfree(subfpe->name);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tif (CatalogueAddFPE(cat, subfpe) != Successful)\n\t{\n\t    FontFileFreeFPE (subfpe);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n    }\n\n    closedir(dir);\n\n    qsort(cat->fpeList,\n\t  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);\n\n    cat->mtime = statbuf.st_mtime;\n\n    return Successful;\n}\n", "func_hash": 320948107529517805290902775059513993785, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2007-5199", "cve_desc": "A single byte overflow in catalogue.c in X.Org libXfont 1.3.1 allows remote attackers to have unspecified impact.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2007-5199"}
{"idx": 535, "project": "savannah", "commit_id": "a0d7fe4589651c64bd16ddaaa634030bb0455866", "project_url": "https://git.savannah.gnu.org/gitweb/?p=gnutls", "commit_url": "https://git.savannah.gnu.org/cgit/patch.git/commit/src/pch.c?id=a0d7fe4589651c64bd16ddaaa634030bb0455866", "commit_message": "None", "target": 1, "func": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = p_line[line][p_len[line] - 1] == '\\n';\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}\n", "func_hash": 109748454555121695743182615951035156943, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-10713", "cve_desc": "An issue was discovered in GNU patch before 2.7.6. Out-of-bounds access within pch_write_line() in pch.c can possibly lead to DoS via a crafted input file.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-10713"}
{"idx": 540, "project": "ghostscript", "commit_id": "e698d5c11d27212aa1098bc5b1673a3378563092", "project_url": "http://git.ghostscript.com/?p=mupdf", "commit_url": "http://git.ghostscript.com/?p=jbig2dec.git;a=commit;h=e698d5c11d27212aa1098bc5b1673a3378563092", "commit_message": "None", "target": 1, "func": "jbig2_decode_gray_scale_image(Jbig2Ctx *ctx, Jbig2Segment *segment,\n                              const byte *data, const size_t size,\n                              bool GSMMR, uint32_t GSW, uint32_t GSH,\n                              uint32_t GSBPP, bool GSUSESKIP, Jbig2Image *GSKIP, int GSTEMPLATE, Jbig2ArithCx *GB_stats)\n {\n     uint8_t **GSVALS = NULL;\n     size_t consumed_bytes = 0;\n    int i, j, code, stride;\n    int x, y;\n     Jbig2Image **GSPLANES;\n     Jbig2GenericRegionParams rparams;\n     Jbig2WordStream *ws = NULL;\n    Jbig2ArithState *as = NULL;\n\n    /* allocate GSPLANES */\n    GSPLANES = jbig2_new(ctx, Jbig2Image *, GSBPP);\n    if (GSPLANES == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %d bytes for GSPLANES\", GSBPP);\n        return NULL;\n    }\n\n    for (i = 0; i < GSBPP; ++i) {\n        GSPLANES[i] = jbig2_image_new(ctx, GSW, GSH);\n         if (GSPLANES[i] == NULL) {\n             jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %dx%d image for GSPLANES\", GSW, GSH);\n             /* free already allocated */\n            for (j = i - 1; j >= 0; --j) {\n                jbig2_image_release(ctx, GSPLANES[j]);\n            }\n             jbig2_free(ctx->allocator, GSPLANES);\n             return NULL;\n         }\n        }\n    }\n", "func_hash": 304560407984194980999184469502825270703, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2016-9601", "cve_desc": "ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2016-9601"}
{"idx": 570, "project": "nbd", "commit_id": "3ef52043861ab16352d49af89e048ba6339d6df8", "project_url": "https://github.com/yoe/nbd", "commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8", "commit_message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.", "target": 1, "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n \t\t\terr(\"Request too big!\");\n #ifdef DODBG\n \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n", "func_hash": 21610058009013440610924702255406066217, "file_name": "nbd-server.c", "file_hash": 204775428507829937641077380751146136112, "cwe": ["CWE-119"], "cve": "CVE-2011-0530", "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-0530"}
{"idx": 627, "project": "linux", "commit_id": "79549c6dfda0603dba9a70a53467ce62d9335c33", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33", "commit_message": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n", "func_hash": 297010684195110082025299424642759875579, "file_name": "cred.c", "file_hash": 39275897372619240457371967102068403083, "cwe": ["CWE-119"], "cve": "CVE-2012-2745", "cve_desc": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-2745"}
{"idx": 678, "project": "suhosin", "commit_id": "73b1968ee30f6d9d2dae497544b910e68e114bfa", "project_url": "https://github.com/stefanesser/suhosin", "commit_url": "https://github.com/stefanesser/suhosin/commit/73b1968ee30f6d9d2dae497544b910e68e114bfa", "commit_message": "Fixed stack based buffer overflow in transparent cookie encryption (see separate advisory)", "target": 1, "func": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n \t\n \tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n \t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n \treturn d_url;\n }\n", "func_hash": 41838469559935618440812276411540013889, "file_name": "header.c", "file_hash": 22878982287999907022125918925783518498, "cwe": ["CWE-119"], "cve": "CVE-2012-0807", "cve_desc": "Stack-based buffer overflow in the suhosin_encrypt_single_cookie function in the transparent cookie-encryption feature in the Suhosin extension before 0.9.33 for PHP, when suhosin.cookie.encrypt and suhosin.multiheader are enabled, might allow remote attackers to execute arbitrary code via a long string that is used in a Set-Cookie HTTP header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2012-0807"}
{"idx": 754, "project": "linux", "commit_id": "15291164b22a357cb211b618adfef4fa82fc0de3", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/15291164b22a357cb211b618adfef4fa82fc0de3", "commit_message": "jbd2: clear BH_Delay & BH_Unwritten in journal_unmap_buffer\n\njournal_unmap_buffer()'s zap_buffer: code clears a lot of buffer head\nstate ala discard_buffer(), but does not touch _Delay or _Unwritten as\ndiscard_buffer() does.\n\nThis can be problematic in some areas of the ext4 code which assume\nthat if they have found a buffer marked unwritten or delay, then it's\na live one.  Perhaps those spots should check whether it is mapped\nas well, but if jbd2 is going to tear down a buffer, let's really\ntear it down completely.\n\nWithout this I get some fsx failures on sub-page-block filesystems\nup until v3.2, at which point 4e96b2dbbf1d7e81f22047a50f862555a6cb87cb\nand 189e868fa8fdca702eb9db9d8afc46b5cb9144c9 make the failures go\naway, because buried within that large change is some more flag\nclearing.  I still think it's worth doing in jbd2, since\n->invalidatepage leads here directly, and it's the right place\nto clear away these flags.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org", "target": 1, "func": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\tint ret;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * buffer can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. So we just set j_next_transaction to the\n\t\t * running transaction (if there is one) and mark\n\t\t * buffer as freed so that commit code knows it should\n\t\t * clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\twrite_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n \tclear_buffer_mapped(bh);\n \tclear_buffer_req(bh);\n \tclear_buffer_new(bh);\n \tbh->b_bdev = NULL;\n \treturn may_free;\n }\n", "func_hash": 113708723622617744945038418263908097733, "file_name": "transaction.c", "file_hash": 47966770736610397294923539281850275183, "cwe": ["CWE-119"], "cve": "CVE-2011-4086", "cve_desc": "The journal_unmap_buffer function in fs/jbd2/transaction.c in the Linux kernel before 3.3.1 does not properly handle the _Delay and _Unwritten buffer head states, which allows local users to cause a denial of service (system crash) by leveraging the presence of an ext4 filesystem that was mounted with a journal.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4086"}
{"idx": 758, "project": "linux", "commit_id": "c85ce65ecac078ab1a1835c87c4a6319cf74660a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a", "commit_message": "b43: allocate receive buffers big enough for max frame len + offset\n\nOtherwise, skb_put inside of dma_rx can fail...\n\n\thttps://bugzilla.kernel.org/show_bug.cgi?id=32042\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nAcked-by: Larry Finger <Larry.Finger@lwfinger.net>\nCc: stable@kernel.org", "target": 1, "func": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n \t\tdmaaddr = meta->dmaaddr;\n \t\tgoto drop_recycle_buffer;\n \t}\n\tif (unlikely(len > ring->rx_buffersize)) {\n \t\t/* The data did not fit into one descriptor buffer\n \t\t * and is split over multiple buffers.\n \t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}\n", "func_hash": 104346933262330900978913399332634585939, "file_name": "dma.c", "file_hash": 2031226938724601320339783189743185185, "cwe": ["CWE-119"], "cve": "CVE-2011-3359", "cve_desc": "The dma_rx function in drivers/net/wireless/b43/dma.c in the Linux kernel before 2.6.39 does not properly allocate receive buffers, which allows remote attackers to cause a denial of service (system crash) via a crafted frame.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3359"}
{"idx": 759, "project": "linux", "commit_id": "c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae", "commit_message": "fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message\n\nFUSE_NOTIFY_INVAL_ENTRY didn't check the length of the write so the\nmessage processing could overrun and result in a \"kernel BUG at\nfs/fuse/dev.c:629!\"\n\nReported-by: Han-Wen Nienhuys <hanwenn@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org", "target": 1, "func": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}\n", "func_hash": 64929278621445786641724855732949782650, "file_name": "dev.c", "file_hash": 242934778288113498357673577108769973314, "cwe": ["CWE-119"], "cve": "CVE-2011-3353", "cve_desc": "Buffer overflow in the fuse_notify_inval_entry function in fs/fuse/dev.c in the Linux kernel before 3.1 allows local users to cause a denial of service (BUG_ON and system crash) by leveraging the ability to mount a FUSE filesystem.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-3353"}
{"idx": 854, "project": "linux", "commit_id": "cae13fe4cc3f24820ffb990c09110626837e85d4", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4", "commit_message": "Fix for buffer overflow in ldm_frag_add not sufficient\n\nAs Ben Hutchings discovered [1], the patch for CVE-2011-1017 (buffer\noverflow in ldm_frag_add) is not sufficient.  The original patch in\ncommit c340b1d64000 (\"fs/partitions/ldm.c: fix oops caused by corrupted\npartition table\") does not consider that, for subsequent fragments,\npreviously allocated memory is used.\n\n[1] http://lkml.org/lkml/2011/5/6/407\n\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n", "func_hash": 164142535356774616118975210091758939882, "file_name": "ldm.c", "file_hash": 72782463213063020085568894103416042932, "cwe": ["CWE-119"], "cve": "CVE-2011-2182", "cve_desc": "The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-2182"}
{"idx": 885, "project": "linux", "commit_id": "7572777eef78ebdee1ecb7c258c0ef94d35bad16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16", "commit_message": "fuse: verify ioctl retries\n\nVerify that the total length of the iovec returned in FUSE_IOCTL_RETRY\ndoesn't overflow iov_length().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: Tejun Heo <tj@kernel.org>\nCC: <stable@kernel.org>         [2.6.31+]", "target": 1, "func": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n \t\tin_iov = page_address(iov_page);\n \t\tout_iov = in_iov + in_iovs;\n \n \t\tgoto retry;\n \t}\n \n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\n", "func_hash": 265577904395187415417640424029624842814, "file_name": "file.c", "file_hash": 190320006487793698673771520320607608387, "cwe": ["CWE-119"], "cve": "CVE-2010-4650", "cve_desc": "Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2010-4650"}
{"idx": 888, "project": "linux", "commit_id": "f5563318ff1bde15b10e736e97ffce13be08bc1a", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f5563318ff1bde15b10e736e97ffce13be08bc1a", "commit_message": "wireless: radiotap: fix parsing buffer overrun\n\nWhen parsing an invalid radiotap header, the parser can overrun\nthe buffer that is passed in because it doesn't correctly check\n 1) the minimum radiotap header size\n 2) the space for extended bitmaps\n\nThe first issue doesn't affect any in-kernel user as they all\ncheck the minimum size before calling the radiotap function.\nThe second issue could potentially affect the kernel if an skb\nis passed in that consists only of the radiotap header with a\nlot of extended bitmaps that extend past the SKB. In that case\na read-only buffer overrun by at most 4 bytes is possible.\n\nFix this by adding the appropriate checks to the parser.\n\nCc: stable@vger.kernel.org\nReported-by: Evan Huus <eapache@gmail.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>", "target": 1, "func": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n \t/* Linux only supports version 0 radiotap format */\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n \t\t\t */\n \n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}\n", "func_hash": 202083656134031078857371790539548342481, "file_name": "radiotap.c", "file_hash": 86018721253196034830238904808493686912, "cwe": ["CWE-119"], "cve": "CVE-2013-7027", "cve_desc": "The ieee80211_radiotap_iterator_init function in net/wireless/radiotap.c in the Linux kernel before 3.11.7 does not check whether a frame contains any data outside of the header, which might allow attackers to cause a denial of service (buffer over-read) via a crafted header.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7027"}
{"idx": 893, "project": "FFmpeg", "commit_id": "f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/f31011e9abfb2ae75bb32bc44e2c34194c8dc40a", "commit_message": "avcodec/parser: reset indexes on realloc failure\n\nFixes Ticket2982\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n\n    /* Copy overread bytes from last frame into buffer. */\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n\n    /* flush remaining if EOF */\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n\n    pc->last_index= pc->index;\n\n    /* copy into buffer end return */\n     if(next == END_NOT_FOUND){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n \n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n         pc->index += *buf_size;\n        return -1;\n    }\n\n    *buf_size=\n    pc->overread_index= pc->index + next;\n\n     /* append to buffer */\n     if(pc->index){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n             memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n\n    /* store overread bytes */\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n\n    return 0;\n}\n", "func_hash": 222309056610865204382267494971212653031, "file_name": "parser.c", "file_hash": 161485228604924499795333847261985724199, "cwe": ["CWE-119"], "cve": "CVE-2013-7023", "cve_desc": "The ff_combine_frame function in libavcodec/parser.c in FFmpeg before 2.1 does not properly handle certain memory-allocation errors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7023"}
{"idx": 894, "project": "FFmpeg", "commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e07ac727c1cc9eed39e7f9117c97006f719864bd", "commit_message": "avcodec/g2meet: Fix framebuf size\n\nCurrently the code can in some cases draw tiles that hang outside the\nallocated buffer. This patch increases the buffer size to avoid out\nof array accesses. An alternative would be to fail if such tiles are\nencountered.\nI do not know if any valid files use such hanging tiles.\n\nFixes Ticket2971\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n \n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n", "func_hash": 255877059988693141105119960061023166155, "file_name": "g2meet.c", "file_hash": 290068666600478234047325352245656051849, "cwe": ["CWE-119"], "cve": "CVE-2013-7022", "cve_desc": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7022"}
{"idx": 896, "project": "FFmpeg", "commit_id": "b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f", "commit_message": "ffv1dec: Check bits_per_raw_sample and colorspace for equality in ver 0/1 headers\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n     memset(state, 128, sizeof(state));\n \n     if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n         unsigned v= get_symbol(c, state, 0);\n         if (v >= 2) {\n             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n         }\n \n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n         chroma_planes  = get_rac(c, state);\n         chroma_h_shift = get_symbol(c, state, 0);\n         chroma_v_shift = get_symbol(c, state, 0);\n         transparency   = get_rac(c, state);\n \n         if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                 || chroma_h_shift!= f->chroma_h_shift\n                 || chroma_v_shift!= f->chroma_v_shift\n                 || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         }\n \n         f->chroma_planes  = chroma_planes;\n         f->chroma_h_shift = chroma_h_shift;\n         f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}\n", "func_hash": 145906591874544820355065071924399305170, "file_name": "ffv1dec.c", "file_hash": 84436554014232129853499938047934081021, "cwe": ["CWE-119"], "cve": "CVE-2013-7020", "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7020"}
{"idx": 905, "project": "FFmpeg", "commit_id": "780669ef7c23c00836a24921fcc6b03be2b8ca4a", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/780669ef7c23c00836a24921fcc6b03be2b8ca4a", "commit_message": "avcodec/jpeg2000dec: non zero image offsets are not supported\n\nFixes out of array accesses\nFixes Ticket3080\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n     s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n     ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n \n     if (ncomponents <= 0) {\n         av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n                s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\n", "func_hash": 85678138236663394668367920105380330110, "file_name": "jpeg2000dec.c", "file_hash": 302431616552773541513179460515872757808, "cwe": ["CWE-119"], "cve": "CVE-2013-7012", "cve_desc": "The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not prevent attempts to use non-zero image offsets, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7012"}
{"idx": 909, "project": "FFmpeg", "commit_id": "3819db745da2ac7fb3faacb116788c32f4753f34", "project_url": "https://github.com/FFmpeg/FFmpeg", "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34", "commit_message": "avcodec/rpza: Perform pointer advance and checks before using the pointers\n\nFixes out of array accesses\nFixes Ticket2850\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>", "target": 1, "func": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n    int pixel_ptr = 0;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                 }\n                 block_ptr += row_inc;\n             }\n            ADVANCE_BLOCK();\n             break;\n \n         /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n", "func_hash": 269902084834802765407826520872887191624, "file_name": "rpza.c", "file_hash": 178523187513410238379567792994301398349, "cwe": ["CWE-119"], "cve": "CVE-2013-7009", "cve_desc": "The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-7009"}
{"idx": 911, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 1, "func": "static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n \tif (mi < 0)\n \t\treturn -EINVAL;\n \n\tvma->vm_ops = &uio_physical_vm_ops;\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }\n", "func_hash": 124769329517591234580599514826095154999, "file_name": "uio.c", "file_hash": 189572155418256998497990912527406881994, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 912, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 1, "func": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n }\n", "func_hash": 177273139877749557163219661985792046530, "file_name": "au1100fb.c", "file_hash": 171201343492238263084724078982982932789, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 913, "project": "linux", "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "commit_message": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.", "target": 1, "func": " static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n \n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n }\n", "func_hash": 67752722467221074330046327748380108876, "file_name": "au1200fb.c", "file_hash": 20588446351461834577785008862824021623, "cwe": ["CWE-119"], "cve": "CVE-2013-6763", "cve_desc": "The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6763"}
{"idx": 916, "project": "linux", "commit_id": "6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62", "commit_message": "qeth: avoicd buffer overflow in snmp ioctl\n\nCheck user-defined length in snmp ioctl request and allow request\nonly if it fits into a qeth command buffer.\n\nSigned-off-by: Ursula Braun <ursula.braun@de.ibm.com>\nSigned-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>\nReviewed-by: Heiko Carstens <heicars2@linux.vnet.ibm.com>\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nCc: <stable@vger.kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n \tstruct qeth_cmd_buffer *iob;\n \tstruct qeth_ipa_cmd *cmd;\n \tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n \tstruct qeth_arp_query_info qinfo = {0, };\n \tint rc = 0;\n \n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n \t/* skip 4 bytes (data_len struct member) to get req_len */\n \tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n \t\treturn -EFAULT;\n \tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n \tif (IS_ERR(ureq)) {\n \t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}\n", "func_hash": 104798081715700399925516111463035480914, "file_name": "qeth_core_main.c", "file_hash": 236635939498951116139550717805292308904, "cwe": ["CWE-119"], "cve": "CVE-2013-6381", "cve_desc": "Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-6381"}
{"idx": 931, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 1, "func": "do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (len != set_arglen[SET_CMDID(cmd)]) {\n \t\tpr_err(\"set_ctl: len %u != %u\\n\",\n \t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}\n", "func_hash": 83673314409807091768576788287268941887, "file_name": "ip_vs_ctl.c", "file_hash": 16053961743391224455400816259714533604, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 9228, "project": "linux", "commit_id": "04bcef2a83f40c6db24222b27a52892cba39dffb", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb", "commit_message": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>", "target": 1, "func": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n {\n \tunsigned char arg[128];\n \tint ret = 0;\n \n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (*len < get_arglen[GET_CMDID(cmd)]) {\n \t\tpr_err(\"get_ctl: len %u < %u\\n\",\n \t\t       *len, get_arglen[GET_CMDID(cmd)]);\n \t\treturn -EINVAL;\n \t}\n \n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n \t\treturn -EFAULT;\n \n \tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n", "func_hash": 171209038462118155141573118053075919369, "file_name": "ip_vs_ctl.c", "file_hash": 16053961743391224455400816259714533604, "cwe": ["CWE-119"], "cve": "CVE-2013-4588", "cve_desc": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4588"}
{"idx": 936, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n {\n \tstruct wl_private *lp = wl_priv(dev);\n \tunsigned long flags;\n \tint         ret = 0;\n \t/*------------------------------------------------------------------------*/\n \n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n \twl_lock(lp, &flags);\n \n \tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n \n \t/* Commit the adapter parameters */\n \twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */\n", "func_hash": 62431484736668092588406280640396277708, "file_name": "wl_priv.c", "file_hash": 140308459115906431610874421688851747022, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 937, "project": "linux", "commit_id": "b5e2f339865fb443107e5b10603e53bbc92dc054", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "commit_message": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n", "func_hash": 192300055996805061518087593122531999232, "file_name": "wl_priv.c", "file_hash": 140308459115906431610874421688851747022, "cwe": ["CWE-119"], "cve": "CVE-2013-4514", "cve_desc": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4514"}
{"idx": 938, "project": "linux", "commit_id": "c2c65cd2e14ada6de44cb527e7f1990bede24e15", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c2c65cd2e14ada6de44cb527e7f1990bede24e15", "commit_message": "staging: ozwpan: prevent overflow in oz_cdev_write()\n\nWe need to check \"count\" so we don't overflow the ei->data buffer.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "target": 1, "func": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}\n", "func_hash": 33191172042980294618689596958041133974, "file_name": "ozcdev.c", "file_hash": 132604815029829941913919591246238407625, "cwe": ["CWE-119"], "cve": "CVE-2013-4513", "cve_desc": "Buffer overflow in the oz_cdev_write function in drivers/staging/ozwpan/ozcdev.c in the Linux kernel before 3.12 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted write operation.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4513"}
{"idx": 979, "project": "libtiff", "commit_id": "ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "project_url": "https://github.com/vadz/libtiff", "commit_url": "https://github.com/vadz/libtiff/commit/ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "commit_message": "fix possible OOB write in gif2tiff.c", "target": 1, "func": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n     }\n \n     if (oldcode == -1) {\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}\n", "func_hash": 49639759056433865662554059812328933578, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-4244", "cve_desc": "The LZW decompressor in the gif2tiff tool in libtiff 4.0.3 and earlier allows context-dependent attackers to cause a denial of service (out-of-bounds write and crash) or possibly execute arbitrary code via a crafted GIF image.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-4244"}
{"idx": 1014, "project": "linux", "commit_id": "cea4dcfdad926a27a18e188720efe0f2c9403456", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456", "commit_message": "iscsi-target: fix heap buffer overflow on error\n\nIf a key was larger than 64 bytes, as checked by iscsi_check_key(), the\nerror response packet, generated by iscsi_add_notunderstood_response(),\nwould still attempt to copy the entire key into the packet, overflowing\nthe structure on the heap.\n\nRemote preauthentication kernel memory corruption was possible if a\ntarget was configured and listening on the network.\n\nCVE-2013-2850\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>", "target": 1, "func": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n \n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n \n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n", "func_hash": 100762060795839649631362584880083269766, "file_name": "iscsi_target_parameters.c", "file_hash": 259649241332208477666489010222901186765, "cwe": ["CWE-119"], "cve": "CVE-2013-2850", "cve_desc": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2850"}
{"idx": 1040, "project": "curl", "commit_id": "192c4f788d48f82c03e9cef40013f34370e90737", "project_url": "https://github.com/curl/curl", "commit_url": "https://github.com/bagder/curl/commit/192c4f788d48f82c03e9cef40013f34370e90737", "commit_message": "Curl_urldecode: no peeking beyond end of input buffer\n\nSecurity problem: CVE-2013-2174\n\nIf a program would give a string like \"%FF\" to curl_easy_unescape() but\nask for it to decode only the first byte, it would still parse and\ndecode the full hex sequence. The function then not only read beyond the\nallowed buffer but it would also deduct the *unsigned* counter variable\nfor how many more bytes there's left to read in the buffer by two,\nmaking the counter wrap. Continuing this, the function would go on\nreading beyond the buffer and soon writing beyond the allocated target\nbuffer...\n\nBug: http://curl.haxx.se/docs/adv_20130622.html\nReported-by: Timo Sirainen", "target": 1, "func": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}\n", "func_hash": 85709973777579247011240190240020563804, "file_name": "escape.c", "file_hash": 170290579417472248714355406167155549130, "cwe": ["CWE-119"], "cve": "CVE-2013-2174", "cve_desc": "Heap-based buffer overflow in the curl_easy_unescape function in lib/escape.c in cURL and libcurl 7.7 through 7.30.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string ending in a \"%\" (percent) character.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2174"}
{"idx": 1043, "project": "linux", "commit_id": "baff42ab1494528907bf4d5870359e31711746ae", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae", "commit_message": "net: Fix oops from tcp_collapse() when using splice()\n\ntcp_read_sock() can have a eat skbs without immediately advancing copied_seq.\nThis can cause a panic in tcp_collapse() if it is called as a result\nof the recv_actor dropping the socket lock.\n\nA userspace program that splices data from a socket to either another\nsocket or to a file can trigger this bug.\n\nSigned-off-by: Steven J. Magnani <steve@digidescorp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\n\t\t\tlen = skb->len - offset;\n\t\t\t/* Stop reading if we hit a patch of urgent data */\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If recv_actor drops the lock (e.g. TCP splice\n\t\t\t * receive) the skb pointer might be invalid when\n\t\t\t * getting here: tcp_collapse might have deleted it\n\t\t\t * while aggregating skbs from the socket queue.\n\t\t\t */\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n \t\tsk_eat_skb(sk, skb, 0);\n \t\tif (!desc->count)\n \t\t\tbreak;\n \t}\n \ttp->copied_seq = seq;\n \n\ttcp_rcv_space_adjust(sk);\n\n\t/* Clean up data we have read: This will do ACK frames. */\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}\n", "func_hash": 199403613559602624417210486913245263722, "file_name": "tcp.c", "file_hash": 12402514951805329113272490821094356586, "cwe": ["CWE-119"], "cve": "CVE-2013-2128", "cve_desc": "The tcp_read_sock function in net/ipv4/tcp.c in the Linux kernel before 2.6.34 does not properly manage skb consumption, which allows local users to cause a denial of service (system crash) via a crafted splice system call for a TCP socket.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2128"}
{"idx": 1045, "project": "linux", "commit_id": "929473ea05db455ad88cdc081f2adc556b8dc48f", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/929473ea05db455ad88cdc081f2adc556b8dc48f", "commit_message": "usb: chipidea: Allow disabling streaming not only in udc mode\n\nWhen running a scp transfer using a USB/Ethernet adapter the following crash\nhappens:\n\n$ scp test.tar.gz fabio@192.168.1.100:/home/fabio\nfabio@192.168.1.100's password:\ntest.tar.gz                                      0%    0     0.0KB/s   --:-- ETA\n------------[ cut here ]------------\nWARNING: at net/sched/sch_generic.c:255 dev_watchdog+0x2cc/0x2f0()\nNETDEV WATCHDOG: eth0 (asix): transmit queue 0 timed out\nModules linked in:\nBacktrace:\n[<80011c94>] (dump_backtrace+0x0/0x10c) from [<804d3a5c>] (dump_stack+0x18/0x1c)\n r6:000000ff r5:80412388 r4:80685dc0 r3:80696cc0\n[<804d3a44>] (dump_stack+0x0/0x1c) from [<80021868>]\n(warn_slowpath_common+0x54/0x6c)\n[<80021814>] (warn_slowpath_common+0x0/0x6c) from [<80021924>]\n(warn_slowpath_fmt+0x38/0x40)\n...\n\nSetting SDIS (Stream Disable Mode- bit 4 of USBMODE register) fixes the problem.\n\nHowever, in current code CI13XXX_DISABLE_STREAMING flag is only set in udc mode,\nso allow disabling streaming also in host mode.\n\nTested on a mx6qsabrelite board.\n\nSuggested-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Fabio Estevam <fabio.estevam@freescale.com>\nReviewed-by: Peter Chen <peter.chen@freescale.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \n \treturn ret;\n }\n", "func_hash": 178357202326078378305249559512498247150, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-2058", "cve_desc": "The host_start function in drivers/usb/chipidea/host.c in the Linux kernel before 3.7.4 does not properly support a certain non-streaming option, which allows local users to cause a denial of service (system crash) by sending a large amount of network traffic through a USB/Ethernet adapter.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-2058"}
{"idx": 1056, "project": "linux", "commit_id": "715230a44310a8cf66fbfb5a46f9a62a9b2de424", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424", "commit_message": "tg3: fix length overflow in VPD firmware parsing\n\nCommit 184b89044fb6e2a74611dafa69b1dce0d98612c6 (\"tg3: Use VPD fw version\nwhen present\") introduced VPD parsing that contained a potential length\noverflow.\n\nLimit the hardware's reported firmware string length (max 255 bytes) to\nstay inside the driver's firmware string length (32 bytes). On overflow,\ntruncate the formatted firmware string instead of potentially overwriting\nportions of the tg3 struct.\n\nhttp://cansecwest.com/slides/2013/PrivateCore%20CSW%202013.pdf\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Oded Horovitz <oded@privatecore.com>\nReported-by: Brad Spengler <spender@grsecurity.net>\nCc: stable@vger.kernel.org\nCc: Matt Carlson <mcarlson@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n \t\tif (j + len > block_end)\n \t\t\tgoto partno;\n \n\t\tmemcpy(tp->fw_ver, &vpd_data[j], len);\n\t\tstrncat(tp->fw_ver, \" bc \", vpdlen - len - 1);\n \t}\n \n partno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}\n", "func_hash": 112924613750397927048878971722801062246, "file_name": "tg3.c", "file_hash": 243393128707233256134232884343250797214, "cwe": ["CWE-119"], "cve": "CVE-2013-1929", "cve_desc": "Heap-based buffer overflow in the tg3_read_vpd function in drivers/net/ethernet/broadcom/tg3.c in the Linux kernel before 3.8.6 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via crafted firmware that specifies a long string in the Vital Product Data (VPD) data structure.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1929"}
{"idx": 1058, "project": "linux", "commit_id": "c0f5ecee4e741667b2493c742b60b6218d40b3aa", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa", "commit_message": "USB: cdc-wdm: fix buffer overflow\n\nThe buffer for responses must not overflow.\nIf this would happen, set a flag, drop the data and return\nan error after user space has read all remaining data.\n\nSigned-off-by: Oliver Neukum <oliver@neukum.org>\nCC: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n \n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\n skip_error:\n \twake_up(&desc->wait);\n \n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}\n", "func_hash": 263555284317390403116045523741699148008, "file_name": "cdc-wdm.c", "file_hash": 233028530119557432442483269940793032392, "cwe": ["CWE-119"], "cve": "CVE-2013-1860", "cve_desc": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1860"}
{"idx": 1079, "project": "linux", "commit_id": "ce0030c00f95cf9110d9cdcd41e901e1fb814417", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/ce0030c00f95cf9110d9cdcd41e901e1fb814417", "commit_message": "None", "target": 1, "func": "static void call_console_drivers(unsigned start, unsigned end)\n{\n\tunsigned cur_index, start_print;\n\tstatic int msg_level = -1;\n\n\tBUG_ON(((int)(start - end)) > 0);\n\n\tcur_index = start;\n \tstart_print = start;\n \twhile (cur_index != end) {\n \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {\n \t\t\t/* strip log prefix */\n\t\t\tcur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);\n \t\t\tstart_print = cur_index;\n \t\t}\n \t\twhile (cur_index != end) {\n\t\t\tchar c = LOG_BUF(cur_index);\n\n\t\t\tcur_index++;\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (msg_level < 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * printk() has already given us loglevel tags in\n\t\t\t\t\t * the buffer.  This code is here in case the\n\t\t\t\t\t * log buffer has wrapped right round and scribbled\n\t\t\t\t\t * on those tags\n\t\t\t\t\t */\n\t\t\t\t\tmsg_level = default_message_loglevel;\n\t\t\t\t}\n\t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);\n\t\t\t\tmsg_level = -1;\n\t\t\t\tstart_print = cur_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_call_console_drivers(start_print, end, msg_level);\n}\n", "func_hash": 150497347424301985399622499839907794574, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-1772", "cve_desc": "The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1772"}
{"idx": 1080, "project": "tinc", "commit_id": "17a33dfd95b1a29e90db76414eb9622df9632320", "project_url": "https://github.com/gsliepen/tinc", "commit_url": "https://github.com/gsliepen/tinc/commit/17a33dfd95b1a29e90db76414eb9622df9632320", "commit_message": "Drop packets forwarded via TCP if they are too big (CVE-2013-1428).\n\nNormally all requests sent via the meta connections are checked so that they\ncannot be larger than the input buffer. However, when packets are forwarded via\nmeta connections, they are copied into a packet buffer without checking whether\nit fits into it. Since the packet buffer is allocated on the stack, this in\neffect allows an authenticated remote node to cause a stack overflow.\n\nThis issue was found by Martin Schobert.", "target": 1, "func": " void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\n\treceive_packet(c->node, &outpkt);\n}\n", "func_hash": 130046906967549597758760447336187151115, "file_name": "net_packet.c", "file_hash": 8171485538728046229010566792464281342, "cwe": ["CWE-119"], "cve": "CVE-2013-1428", "cve_desc": "Stack-based buffer overflow in the receive_tcppacket function in net_packet.c in tinc before 1.0.21 and 1.1 before 1.1pre7 allows remote authenticated peers to cause a denial of service (crash) or possibly execute arbitrary code via a large TCP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1428"}
{"idx": 1083, "project": "krb5", "commit_id": "8ee70ec63931d1e38567905387ab9b1d45734d81", "project_url": "https://github.com/krb5/krb5", "commit_url": "https://github.com/krb5/krb5/commit/8ee70ec63931d1e38567905387ab9b1d45734d81", "commit_message": "KDC TGS-REQ null deref [CVE-2013-1416]\n\nBy sending an unusual but valid TGS-REQ, an authenticated remote\nattacker can cause the KDC process to crash by dereferencing a null\npointer.\n\nprep_reprocess_req() can cause a null pointer dereference when\nprocessing a service principal name.  Code in this function can\ninappropriately pass a null pointer to strlcpy().  Unmodified client\nsoftware can trivially trigger this vulnerability, but the attacker\nmust have already authenticated and received a valid Kerberos ticket.\n\nThe vulnerable code was introduced by the implementation of new\nservice principal realm referral functionality in krb5-1.7, but was\ncorrected as a side effect of the KDC refactoring in krb5-1.11.\n\nCVSSv2 vector: AV:N/AC:L/Au:S/C:N/I:N/A:C/E:H/RL:O/RC:C\n\nticket: 7600 (new)\nversion_fixed: 1.10.5\nstatus: resolved", "target": 1, "func": "prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n             retval = ENOMEM;\n             goto cleanup;\n         }\n        strlcpy(comp1_str,comp1->data,comp1->length+1);\n \n         if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n              krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                 retval = ENOMEM;\n                 goto cleanup;\n             }\n            strlcpy(temp_buf, comp2->data,comp2->length+1);\n             retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n             free(temp_buf);\n             if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}\n", "func_hash": 26445768461799658627820158469477432629, "file_name": "do_tgs_req.c", "file_hash": 132430812994884879432256969693246573359, "cwe": ["CWE-119"], "cve": "CVE-2013-1416", "cve_desc": "The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-1416"}
{"idx": 1092, "project": "linux", "commit_id": "89d7ae34cdda4195809a5a987f697a517a2a3177", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/89d7ae34cdda4195809a5a987f697a517a2a3177", "commit_message": "cipso: don't follow a NULL pointer when setsockopt() is called\n\nAs reported by Alan Cox, and verified by Lin Ming, when a user\nattempts to add a CIPSO option to a socket using the CIPSO_V4_TAG_LOCAL\ntag the kernel dies a terrible death when it attempts to follow a NULL\npointer (the skb argument to cipso_v4_validate() is NULL when called via\nthe setsockopt() syscall).\n\nThis patch fixes this by first checking to ensure that the skb is\nnon-NULL before using it to find the incoming network interface.  In\nthe unlikely case where the skb is NULL and the user attempts to add\na CIPSO option with the _TAG_LOCAL tag we return an error as this is\nnot something we want to allow.\n\nA simple reproducer, kindly supplied by Lin Ming, although you must\nhave the CIPSO DOI #3 configure on the system first or you will be\ncaught early in cipso_v4_validate():\n\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <linux/ip.h>\n\t#include <linux/in.h>\n\t#include <string.h>\n\n\tstruct local_tag {\n\t\tchar type;\n\t\tchar length;\n\t\tchar info[4];\n\t};\n\n\tstruct cipso {\n\t\tchar type;\n\t\tchar length;\n\t\tchar doi[4];\n\t\tstruct local_tag local;\n\t};\n\n\tint main(int argc, char **argv)\n\t{\n\t\tint sockfd;\n\t\tstruct cipso cipso = {\n\t\t\t.type = IPOPT_CIPSO,\n\t\t\t.length = sizeof(struct cipso),\n\t\t\t.local = {\n\t\t\t\t.type = 128,\n\t\t\t\t.length = sizeof(struct local_tag),\n\t\t\t},\n\t\t};\n\n\t\tmemset(cipso.doi, 0, 4);\n\t\tcipso.doi[3] = 3;\n\n\t\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t#define SOL_IP 0\n\t\tsetsockopt(sockfd, SOL_IP, IP_OPTIONS,\n\t\t\t&cipso, sizeof(struct cipso));\n\n\t\treturn 0;\n\t}\n\nCC: Lin Ming <mlin@ss.pku.edu.cn>\nReported-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: Paul Moore <pmoore@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase CIPSO_V4_TAG_LOCAL:\n \t\t\t/* This is a non-standard tag that we only allow for\n \t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. */\n\t\t\tif (!(skb->dev->flags & IFF_LOOPBACK)) {\n \t\t\t\terr_offset = opt_iter;\n \t\t\t\tgoto validate_return_locked;\n \t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}\n", "func_hash": 254520361513953381472265258043035062652, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2013-0310", "cve_desc": "The cipso_v4_validate function in net/ipv4/cipso_ipv4.c in the Linux kernel before 3.4.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an IPOPT_CIPSO IP_OPTIONS setsockopt system call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2013-0310"}
{"idx": 1151, "project": "linux", "commit_id": "b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "commit_message": "batman-adv: Only write requested number of byte to user buffer\n\nDon't write more than the requested number of bytes of an batman-adv icmp\npacket to the userspace buffer. Otherwise unrelated userspace memory might get\noverridden by the kernel.\n\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nSigned-off-by: Marek Lindner <lindner_marek@yahoo.de>", "target": 1, "func": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n \n \tspin_unlock_bh(&socket_client->lock);\n \n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n \n\tpacket_len = socket_packet->icmp_len;\n \tkfree(socket_packet);\n \n \tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}\n", "func_hash": 85869577016758360857678073749575889128, "file_name": "icmp_socket.c", "file_hash": 220335110825043841438594946572360754188, "cwe": ["CWE-119"], "cve": "CVE-2011-4604", "cve_desc": "The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-4604"}
{"idx": 1176, "project": "linux", "commit_id": "d370af0ef7951188daeb15bae75db7ba57c67846", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846", "commit_message": "irda: validate peer name and attribute lengths\n\nLength fields provided by a peer for names and attributes may be longer\nthan the destination array sizes.  Validate lengths to prevent stack\nbuffer overflows.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>", "target": 1, "func": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t/* 60 bytes */\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t/* 60 bytes */\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n \tn = 1;\n \n \tname_len = fp[n++];\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \n \tattr_len = fp[n++];\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n \n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t/* We have a match; send the value.  */\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}\n", "func_hash": 289039370717523292092463182568935459370, "file_name": "iriap.c", "file_hash": 294293270431801760606108261927776973010, "cwe": ["CWE-119"], "cve": "CVE-2011-1180", "cve_desc": "Multiple stack-based buffer overflows in the iriap_getvaluebyclass_indication function in net/irda/iriap.c in the Linux kernel before 2.6.39 allow remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging connectivity to an IrDA infrared network and sending a large integer value for a (1) name length or (2) attribute length.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2011-1180"}
{"idx": 1184, "project": "linux", "commit_id": "f2e323ec96077642d397bb1c355def536d489d16", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16", "commit_message": "[media] ttusb-dec: buffer overflow in ioctl\n\nWe need to add a limit check here so we don't overflow the buffer.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>", "target": 1, "func": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n", "func_hash": 192608949045328579601369441585250086987, "file_name": "ttusbdecfe.c", "file_hash": 24169251397313178037362556408074084271, "cwe": ["CWE-119"], "cve": "CVE-2014-8884", "cve_desc": "Stack-based buffer overflow in the ttusbdecfe_dvbs_diseqc_send_master_cmd function in drivers/media/usb/ttusb-dec/ttusbdecfe.c in the Linux kernel before 3.17.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via a large message length in an ioctl call.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-8884"}
{"idx": 1205, "project": "ettercap", "commit_id": "e3abe7d7585ecc420a7cab73313216613aadad5a", "project_url": "https://github.com/Ettercap/ettercap", "commit_url": "https://github.com/Ettercap/ettercap/commit/e3abe7d7585ecc420a7cab73313216613aadad5a", "commit_message": "Fixed heap overflow caused by length", "target": 1, "func": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n                int length;\n                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n                GET_ULONG_BE(length, ptr, 1);\n               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n               conn_status->password[length - 4] = 0;\n                DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n             }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n", "func_hash": 113723108844572007792416732313477179140, "file_name": "ec_postgresql.c", "file_hash": 75203240410363383935232600633355556579, "cwe": ["CWE-119"], "cve": "CVE-2014-6395", "cve_desc": "Heap-based buffer overflow in the dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service or possibly execute arbitrary code via a crafted password length value that is inconsistent with the actual length of the password.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-6395"}
{"idx": 1234, "project": "linux", "commit_id": "206a81c18401c0cde6e579164f752c4b147324ce", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce", "commit_message": "lzo: properly check for overruns\n\nThe lzo decompressor can, if given some really crazy data, possibly\noverrun some variable types.  Modify the checking logic to properly\ndetect overruns before they happen.\n\nReported-by: \"Don A. Bailey\" <donb@securitymouse.com>\nTested-by: \"Don A. Bailey\" <donb@securitymouse.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>", "target": 1, "func": " int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n \t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n \t\t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\t\tt += 255;\n \t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1);\n \t\t\t\t\t}\n \t\t\t\t\tt += 15 + *ip++;\n \t\t\t\t}\n \t\t\t\tt += 3;\n copy_literal_run:\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t + 15) && HAVE_OP(t + 15))) {\n \t\t\t\t\tconst unsigned char *ie = ip + t;\n \t\t\t\t\tunsigned char *oe = op + t;\n \t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n \t\t\t\t} else\n #endif\n \t\t\t\t{\n\t\t\t\t\tNEED_OP(t);\n\t\t\t\t\tNEED_IP(t + 3);\n \t\t\t\t\tdo {\n \t\t\t\t\t\t*op++ = *ip++;\n \t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n \t\t\t\tm_pos -= t >> 2;\n \t\t\t\tm_pos -= *ip++ << 2;\n \t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2);\n \t\t\t\top[0] = m_pos[0];\n \t\t\t\top[1] = m_pos[1];\n \t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n \t\t\t\t}\n \t\t\t\tt += 31 + *ip++;\n\t\t\t\tNEED_IP(2);\n \t\t\t}\n \t\t\tm_pos = op - 1;\n \t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tm_pos = op;\n\t\t\tm_pos -= (t & 8) << 11;\n\t\t\tt = (t & 7) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n \t\t\t\twhile (unlikely(*ip == 0)) {\n \t\t\t\t\tt += 255;\n \t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n \t\t\t\t}\n \t\t\t\tt += 7 + *ip++;\n\t\t\t\tNEED_IP(2);\n \t\t\t}\n \t\t\tnext = get_unaligned_le16(ip);\n \t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t\tif (m_pos == op)\n\t\t\t\tgoto eof_found;\n\t\t\tm_pos -= 0x4000;\n\t\t}\n\t\tTEST_LB(m_pos);\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n \t\tif (op - m_pos >= 8) {\n \t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t + 15))) {\n \t\t\t\tdo {\n \t\t\t\t\tCOPY8(op, m_pos);\n \t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n \t\t\t\t\tm_pos += 8;\n \t\t\t\t} while (op < oe);\n \t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6)) {\n \t\t\t\t\tstate = next;\n \t\t\t\t\tCOPY4(op, ip);\n \t\t\t\t\top += next;\n \t\t\t\t\tip += next;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t} else {\n\t\t\t\tNEED_OP(t);\n \t\t\t\tdo {\n \t\t\t\t\t*op++ = *m_pos++;\n \t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n #endif\n \t\t{\n \t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t);\n \t\t\top[0] = m_pos[0];\n \t\t\top[1] = m_pos[1];\n \t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n \t\tstate = next;\n \t\tt = next;\n #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6) && HAVE_OP(4))) {\n \t\t\tCOPY4(op, ip);\n \t\t\top += t;\n \t\t\tip += t;\n \t\t} else\n #endif\n \t\t{\n\t\t\tNEED_IP(t + 3);\n\t\t\tNEED_OP(t);\n \t\t\twhile (t > 0) {\n \t\t\t\t*op++ = *ip++;\n \t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n", "func_hash": 274406254790435141604534304938072258803, "file_name": "lzo1x_decompress_safe.c", "file_hash": 59242432641946222716090607137357863371, "cwe": ["CWE-119"], "cve": "CVE-2014-4608", "cve_desc": "Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4608"}
{"idx": 1236, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 1, "func": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n \tif (url_len < 1)\n \t\treturn false;\n \n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n", "func_hash": 268425937881460227077617707628391335121, "file_name": "util.c", "file_hash": 312757577260077548189069559014533960677, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 1237, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 1, "func": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n \tntime = __json_array_string(val, 7);\n \tclean = json_is_true(json_array_get(val, 8));\n \n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n \t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n \t\tgoto out;\n \t}\n \n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n", "func_hash": 84334959585750243556126605758413185403, "file_name": "util.c", "file_hash": 206367765513721418997031203388162533294, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 1238, "project": "cgminer", "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e", "project_url": "https://github.com/ckolivas/cgminer", "commit_url": "https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e", "commit_message": "Do some random sanity checking for stratum message parsing", "target": 1, "func": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n\tsprintf(address, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "func_hash": 137361347459447412875947908752625113506, "file_name": "util.c", "file_hash": 206367765513721418997031203388162533294, "cwe": ["CWE-119"], "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4502"}
{"idx": 1242, "project": "php-src", "commit_id": "b34d7849ed90ced9345f8ea1c59bc8d101c18468", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/b34d7849ed90ced9345f8ea1c59bc8d101c18468", "commit_message": "Merge branch 'PHP-5.6'\n\n* PHP-5.6:\n  Fix potential segfault in dns_get_record()", "target": 1, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n \t\t\t\t\n \t\t\t\twhile (ll < dlen) {\n \t\t\t\t\tn = cp[ll];\n \t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n \t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n \t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 61555348514619221447360707443484627048, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-4049", "cve_desc": "Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-4049"}
{"idx": 1251, "project": "miniupnp", "commit_id": "3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "project_url": "https://github.com/miniupnp/miniupnp", "commit_url": "https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "commit_message": "miniwget.c: fixed potential buffer overrun", "target": 1, "func": "getHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n \t\t\t\t\t\t\tchunked = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t\twhile(header_buf[i]=='\\r' || header_buf[i] == '\\n')\n \t\t\t\t\t\ti++;\n \t\t\t\t\tlinestart = i;\n \t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n", "func_hash": 306297354977511070065482433729517457700, "file_name": "miniwget.c", "file_hash": 99482104209569075149952687843099296030, "cwe": ["CWE-119"], "cve": "CVE-2014-3985", "cve_desc": "The getHTTPResponse function in miniwget.c in MiniUPnP 1.9 allows remote attackers to cause a denial of service (crash) via crafted headers that trigger an out-of-bounds read.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3985"}
{"idx": 1277, "project": "php-src", "commit_id": "2fefae47716d501aec41c1102f3fd4531f070b05", "project_url": "https://github.com/php/php-src", "commit_url": "https://github.com/php/php-src/commit/2fefae47716d501aec41c1102f3fd4531f070b05", "commit_message": "Fixed Sec Bug #67717 segfault in dns_get_record CVE-2014-3597\n\nIncomplete fix for CVE-2014-4049\n\nCheck possible buffer overflow\n- pass real buffer end to dn_expand calls\n- check buffer len before each read", "target": 1, "func": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n {\n \tu_short type, class, dlen;\n \tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n \n \t*subarray = NULL;\n \n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n \tif (n < 0) {\n \t\treturn NULL;\n \t}\n \tcp += n;\n \n \tGETSHORT(type, cp);\n \tGETSHORT(class, cp);\n \tGETLONG(ttl, cp);\n \tGETSHORT(dlen, cp);\n \tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n \t\tcp += dlen;\n \t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n \n \tswitch (type) {\n \t\tcase DNS_T_A:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n \t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n \t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n \t\t\tcp += dlen;\n \t\t\tbreak;\n \t\tcase DNS_T_MX:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n \t\t\tif (type == DNS_T_PTR) {\n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n \t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_HINFO:\n \t\t\t/* See RFC 1010 for values */\n \t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n \t\t\tcp += n;\n \t\t\tn = *cp & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n \t\t\tcp += n;\n \t\t\tbreak;\n \t\tcase DNS_T_TXT:\n \t\t\t{\n\t\t\t\tint ll = 0;\n \t\t\t\tzval *entries = NULL;\n \n \t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n \t\t\t\tMAKE_STD_ZVAL(entries);\n \t\t\t\tarray_init(entries);\n \t\t\t\t\n\t\t\t\twhile (ll < dlen) {\n\t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\tn = dlen - (ll + 1);\n \t\t\t\t\t}\n\t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n\t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n\t\t\t\t\tll = ll + n + 1;\n \t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n \t\t\t\tcp += dlen;\n \n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n \t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SOA:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n \t\t\tGETLONG(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"serial\", n);\n \t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n \t\t\tbreak;\n \t\tcase DNS_T_AAAA:\n \t\t\ttp = (u_char*)name;\n \t\t\tfor(i=0; i < 8; i++) {\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n \t\tcase DNS_T_A6:\n \t\t\tp = cp;\n \t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n \t\t\tn = ((int)cp[0]) & 0xFF;\n \t\t\tcp++;\n \t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n \t\t\t\tcp++;\n \t\t\t}\n \t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n \t\t\t\tGETSHORT(s, cp);\n \t\t\t\tif (s != 0) {\n \t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n \t\t\ttp[0] = '\\0';\n \t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n \t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\t\tif (n < 0) {\n \t\t\t\t\treturn NULL;\n \t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase DNS_T_SRV:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pri\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"weight\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n \t\t\tcp += n;\n \t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n \t\t\tbreak;\n \t\tcase DNS_T_NAPTR:\n \t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"order\", n);\n \t\t\tGETSHORT(n, cp);\n \t\t\tadd_assoc_long(*subarray, \"pref\", n);\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n \t\t\tcp += n;\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n \t\t\tcp += n;\n \t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n \t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n \t\t\tif (n < 0) {\n \t\t\t\treturn NULL;\n \t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n", "func_hash": 192550270728735179499592366180467891975, "file_name": "None", "file_hash": null, "cwe": ["CWE-119"], "cve": "CVE-2014-3597", "cve_desc": "Multiple buffer overflows in the php_parserr function in ext/standard/dns.c in PHP before 5.4.32 and 5.5.x before 5.5.16 allow remote DNS servers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted DNS record, related to the dns_get_record function and the dn_expand function.  NOTE: this issue exists because of an incomplete fix for CVE-2014-4049.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3597"}
{"idx": 1288, "project": "linux", "commit_id": "844817e47eef14141cf59b8d5ac08dd11c0a9189", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/844817e47eef14141cf59b8d5ac08dd11c0a9189", "commit_message": "HID: picolcd: sanity check report size in raw_event() callback\n\nThe report passed to us from transport driver could potentially be\narbitrarily large, therefore we better sanity-check it so that raw_data\nthat we hold in picolcd_pending structure are always kept within proper\nbounds.\n\nCc: stable@vger.kernel.org\nReported-by: Steven Vittitoe <scvitti@google.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n \tif (!data)\n \t\treturn 1;\n \n \tif (report->id == REPORT_KEY_STATE) {\n \t\tif (data->input_keys)\n \t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t/*\n\t\t * We let the caller of picolcd_send_and_wait() check if the\n\t\t * report we got is one of the expected ones or not.\n\t\t */\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}\n", "func_hash": 336846250312050028232066323392072383213, "file_name": "hid-picolcd_core.c", "file_hash": 186782659027372809911748564926739155996, "cwe": ["CWE-119"], "cve": "CVE-2014-3186", "cve_desc": "Buffer overflow in the picolcd_raw_event function in devices/hid/hid-picolcd_core.c in the PicoLCD HID device driver in the Linux kernel through 3.16.3, as used in Android on Nexus 7 devices, allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that sends a large report.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3186"}
{"idx": 1290, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 45538586871323178624538960674889390064, "file_name": "hid-cherry.c", "file_hash": 187455207934208845636828150080769233950, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 1291, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": "static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t/* the fixups that need to be done:\n\t\t *   - change led usage page to button for extra buttons\n\t\t *   - report size 8 count 1 must be size 1 count 8 for button\n\t\t *     bitfield\n \t\t *   - change the button usage range to 4-7 for the extra\n \t\t *     buttons\n \t\t */\n\t\tif (*rsize >= 74 &&\n \t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n \t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n \t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"fixing up Kye/Genius Ergo Mouse \"\n\t\t\t\t \"report descriptor\\n\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Gila Gaming Mouse\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"Genius Gx Imperator Keyboard\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Manticore Keyboard\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}\n", "func_hash": 61701421720071808882903110031752917362, "file_name": "hid-kye.c", "file_hash": 236592989497276142238000662973665272399, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
{"idx": 1292, "project": "linux", "commit_id": "4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "project_url": "https://github.com/torvalds/linux", "commit_url": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214", "commit_message": "HID: fix a couple of off-by-ones\n\nThere are a few very theoretical off-by-one bugs in report descriptor size\nchecking when performing a pre-parsing fixup. Fix those.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>", "target": 1, "func": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n \tstruct usb_device_descriptor *udesc;\n \t__u16 bcdDevice, rev_maj, rev_min;\n \n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 90 && rdesc[83] == 0x26 &&\n \t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n \t\thid_info(hdev,\n \t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n \t\trdesc[84] = rdesc[89] = 0x4d;\n \t\trdesc[85] = rdesc[90] = 0x10;\n \t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 50 &&\n \t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n \t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n \t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}\n", "func_hash": 279704939167865611128772246993871300695, "file_name": "hid-lg.c", "file_hash": 90537780722919720067199362868331773823, "cwe": ["CWE-119"], "cve": "CVE-2014-3184", "cve_desc": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.", "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2014-3184"}
