[
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 891,
    "critical_vars": [
      "lzx->inbuf"
    ],
    "function": "lzxd_free",
    "filename": "clamav/CVE-2017-6419/CVE-2017-6419_CWE-119_a83773682e856ad6529ba6db8d1792e6d515d7f1_lzxd.c.diff",
    "function_code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}",
    "label": "True",
    "variable_definitions": {
      "lzx->inbuf": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 896,
    "critical_vars": [
      "lzx->inbuf"
    ],
    "function": "lzxd_free",
    "filename": "clamav/CVE-2017-6419/CVE-2017-6419_CWE-119_a83773682e856ad6529ba6db8d1792e6d515d7f1_lzxd.c.diff",
    "function_code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    if(lzx->inbuf)\n        sys->free(lzx->inbuf);\n    if(lzx->window)\n        sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}",
    "label": "False",
    "variable_definitions": {
      "lzx->inbuf": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 747,
    "critical_vars": [
      "j"
    ],
    "function": "cli_scanpe",
    "filename": "clamav/CVE-2014-9050/CVE-2014-9050_CWE-119_fc3794a54d2affe5770c1f876484a871c783e91e_pe.c.diff",
    "function_code": "\nint cli_scanpe(cli_ctx *ctx)\n{\n\tuint16_t e_magic; /* DOS signature (\"MZ\") */\n\tuint16_t nsections;\n\tuint32_t e_lfanew; /* address of new exe header */\n\tuint32_t ep, vep; /* entry point (raw, virtual) */\n\tuint8_t polipos = 0;\n\ttime_t timestamp;\n\tstruct pe_image_file_hdr file_hdr;\n\tunion {\n\t    struct pe_image_optional_hdr64 opt64;\n\t    struct pe_image_optional_hdr32 opt32;\n\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size, j;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\tstruct cli_pe_hook_data pedata;\n#ifdef HAVE__INTERNAL__SHA_COLLECT\n\tint sha_collect = ctx->sha_collect;\n#endif\n    const char *archtype=NULL, *subsystem=NULL;\n\tuint32_t viruses_found = 0;\n#if HAVE_JSON\n        int toval = 0;\n        struct json_object *pe_json=NULL;\n        char jsonbuf[128];\n#endif\n\n    if(!ctx) {\n\tcli_errmsg(\"cli_scanpe: ctx == NULL\\n\");\n\treturn CL_ENULLARG;\n    }\n\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        pe_json = get_pe_property(ctx);\n    }\n#endif\n    map = *ctx->fmap;\n    if(fmap_readn(map, &e_magic, 0, sizeof(e_magic)) != sizeof(e_magic)) {\n\tcli_dbgmsg(\"Can't read DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE && EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE_OLD) {\n\tcli_dbgmsg(\"Invalid DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &e_lfanew, 58 + sizeof(e_magic), sizeof(e_lfanew)) != sizeof(e_lfanew)) {\n\tcli_dbgmsg(\"Can't read new header address\\n\");\n\t/* truncated header? */\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    e_lfanew = EC32(e_lfanew);\n    cli_dbgmsg(\"e_lfanew == %d\\n\", e_lfanew);\n    if(!e_lfanew) {\n\tcli_dbgmsg(\"Not a PE file\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &file_hdr, e_lfanew, sizeof(struct pe_image_file_hdr)) != sizeof(struct pe_image_file_hdr)) {\n\t/* bad information in e_lfanew - probably not a PE file */\n\tcli_dbgmsg(\"Can't read file header\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC32(file_hdr.Magic) != PE_IMAGE_NT_SIGNATURE) {\n\tcli_dbgmsg(\"Invalid PE signature (probably NE file)\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(file_hdr.Characteristics) & 0x2000) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"DLL\");\n#endif\n\tcli_dbgmsg(\"File type: DLL\\n\");\n\tdll = 1;\n    } else if(EC16(file_hdr.Characteristics) & 0x01) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"EXE\");\n#endif\n\tcli_dbgmsg(\"File type: Executable\\n\");\n    }\n\n    switch(EC16(file_hdr.Machine)) {\n\tcase 0x0:\n        archtype = \"Unknown\";\n\t    break;\n\tcase 0x14c:\n        archtype = \"80386\";\n\t    break;\n\tcase 0x14d:\n        archtype = \"80486\";\n\t    break;\n\tcase 0x14e:\n        archtype = \"80586\";\n\t    break;\n\tcase 0x160:\n        archtype = \"R30000 (big-endian)\";\n\t    break;\n\tcase 0x162:\n        archtype = \"R3000\";\n\t    break;\n\tcase 0x166:\n        archtype = \"R4000\";\n\t    break;\n\tcase 0x168:\n        archtype = \"R10000\";\n\t    break;\n\tcase 0x184:\n        archtype = \"DEC Alpha AXP\";\n\t    break;\n\tcase 0x284:\n        archtype = \"DEC Alpha AXP 64bit\";\n\t    break;\n\tcase 0x1f0:\n        archtype = \"PowerPC\";\n\t    break;\n\tcase 0x200:\n        archtype = \"IA64\";\n\t    break;\n\tcase 0x268:\n        archtype = \"M68k\";\n\t    break;\n\tcase 0x266:\n        archtype = \"MIPS16\";\n\t    break;\n\tcase 0x366:\n        archtype = \"MIPS+FPU\";\n\t    break;\n\tcase 0x466:\n        archtype = \"MIPS16+FPU\";\n\t    break;\n\tcase 0x1a2:\n        archtype = \"Hitachi SH3\";\n\t    break;\n\tcase 0x1a3:\n        archtype = \"Hitachi SH3-DSP\";\n\t    break;\n\tcase 0x1a4:\n        archtype = \"Hitachi SH3-E\";\n\t    break;\n\tcase 0x1a6:\n        archtype = \"Hitachi SH4\";\n\t    break;\n\tcase 0x1a8:\n        archtype = \"Hitachi SH5\";\n\t    break;\n\tcase 0x1c0:\n        archtype = \"ARM\";\n\t    break;\n\tcase 0x1c2:\n        archtype = \"THUMB\";\n\t    break;\n\tcase 0x1d3:\n        archtype = \"AM33\";\n\t    break;\n\tcase 0x520:\n        archtype = \"Infineon TriCore\";\n\t    break;\n\tcase 0xcef:\n        archtype = \"CEF\";\n\t    break;\n\tcase 0xebc:\n        archtype = \"EFI Byte Code\";\n\t    break;\n\tcase 0x9041:\n        archtype = \"M32R\";\n\t    break;\n\tcase 0xc0ee:\n        archtype = \"CEEE\";\n\t    break;\n\tcase 0x8664:\n        archtype = \"AMD64\";\n\t    break;\n\tdefault:\n        archtype = \"Unknown\";\n    }\n\n    if ((archtype)) {\n        cli_dbgmsg(\"Machine type: %s\\n\", archtype);\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"ArchType\", archtype);\n#endif\n    }\n\n    nsections = EC16(file_hdr.NumberOfSections);\n    if(nsections < 1 || nsections > 96) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadNumberOfSections\");\n#endif\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\tif(!ctx->corrupted_input) {\n\t    if(nsections)\n\t\tcli_warnmsg(\"PE file contains %d sections\\n\", nsections);\n\t    else\n\t\tcli_warnmsg(\"PE file contains no sections\\n\");\n\t}\n\treturn CL_CLEAN;\n    }\n    cli_dbgmsg(\"NumberOfSections: %d\\n\", nsections);\n\n    timestamp = (time_t) EC32(file_hdr.TimeDateStamp);\n    cli_dbgmsg(\"TimeDateStamp: %s\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"TimeDateStamp\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n#endif\n\n    cli_dbgmsg(\"SizeOfOptionalHeader: %x\\n\", EC16(file_hdr.SizeOfOptionalHeader));\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"SizeOfOptionalHeader\", EC16(file_hdr.SizeOfOptionalHeader));\n#endif\n\n    if (EC16(file_hdr.SizeOfOptionalHeader) < sizeof(struct pe_image_optional_hdr32)) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSize\");\n#endif\n        cli_dbgmsg(\"SizeOfOptionalHeader too small\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    at = e_lfanew + sizeof(struct pe_image_file_hdr);\n    if(fmap_readn(map, &optional_hdr32, at, sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr32)) {\n        cli_dbgmsg(\"Can't read optional file header\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_optional_hdr32);\n\n    /* This will be a chicken and egg problem until we drop 9x */\n    if(EC16(optional_hdr64.Magic)==PE32P_SIGNATURE) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSizePE32Plus\");\n#endif\n        if(EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr64)) {\n\t    /* FIXME: need to play around a bit more with xp64 */\n\t    cli_dbgmsg(\"Incorrect SizeOfOptionalHeader for PE32+\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tpe_plus = 1;\n    }\n\n    if(!pe_plus) { /* PE */\n\tif (EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr32)) {\n\t    /* Seek to the end of the long header */\n\t    at += EC16(file_hdr.SizeOfOptionalHeader)-sizeof(struct pe_image_optional_hdr32);\n\t}\n\n\tif(DCONF & PE_CONF_UPACK)\n\t    upack = (EC16(file_hdr.SizeOfOptionalHeader)==0x148);\n\n\tvep = EC32(optional_hdr32.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr32.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr32.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr32.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr32.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr32.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr32.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr32.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr32.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n\tdirs = optional_hdr32.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr32.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr32.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr32.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr32.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr32.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr32.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr32.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n\n    } else { /* PE+ */\n        /* read the remaining part of the header */\n        if(fmap_readn(map, &optional_hdr32 + 1, at, sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) {\n\t    cli_dbgmsg(\"Can't read optional file header\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tat += sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32);\n\tvep = EC32(optional_hdr64.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr64.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE32+\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr64.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr64.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr64.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr64.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr64.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr64.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr64.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n\tdirs = optional_hdr64.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr64.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr64.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr64.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr64.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr64.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr64.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr64.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n    }\n\n#if HAVE_JSON\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", vep);\n        cli_jsonstr(pe_json, \"EntryPoint\", jsonbuf);\n    }\n#endif\n\n\n    switch(pe_plus ? EC16(optional_hdr64.Subsystem) : EC16(optional_hdr32.Subsystem)) {\n\tcase 0:\n        subsystem = \"Unknown\";\n\t    break;\n\tcase 1:\n        subsystem = \"Native (svc)\";\n\t    native = 1;\n\t    break;\n\tcase 2:\n        subsystem = \"Win32 GUI\";\n\t    break;\n\tcase 3:\n        subsystem = \"Win32 console\";\n\t    break;\n\tcase 5:\n        subsystem = \"OS/2 console\";\n\t    break;\n\tcase 7:\n        subsystem = \"POSIX console\";\n\t    break;\n\tcase 8:\n        subsystem = \"Native Win9x driver\";\n\t    break;\n\tcase 9:\n        subsystem = \"WinCE GUI\";\n\t    break;\n\tcase 10:\n        subsystem = \"EFI application\";\n\t    break;\n\tcase 11:\n        subsystem = \"EFI driver\";\n\t    break;\n\tcase 12:\n        subsystem = \"EFI runtime driver\";\n\t    break;\n\tcase 13:\n        subsystem = \"EFI ROM image\";\n\t    break;\n\tcase 14:\n        subsystem = \"Xbox\";\n\t    break;\n\tcase 16:\n        subsystem = \"Boot application\";\n\t    break;\n\tdefault:\n        subsystem = \"Unknown\";\n    }\n\n    cli_dbgmsg(\"Subsystem: %s\\n\", subsystem);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Subsystem\", subsystem);\n#endif\n\n    cli_dbgmsg(\"------------------------------------\\n\");\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment)) || (pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment))%0x1000)) {\n        cli_dbgmsg(\"Bad virtual alignemnt\\n\");\n\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment)) || (pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment))%0x200)) {\n        cli_dbgmsg(\"Bad file alignemnt\\n\");\n\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    fsize = map->len;\n\n    section_hdr = (struct pe_image_section_hdr *) cli_calloc(nsections, sizeof(struct pe_image_section_hdr));\n\n    if(!section_hdr) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\treturn CL_EMEM;\n    }\n\n    exe_sections = (struct cli_exe_section *) cli_calloc(nsections, sizeof(struct cli_exe_section));\n    \n    if(!exe_sections) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\tfree(section_hdr);\n\treturn CL_EMEM;\n    }\n\n    valign = (pe_plus)?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment);\n    falign = (pe_plus)?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment);\n\n    if(fmap_readn(map, section_hdr, at, sizeof(struct pe_image_section_hdr)*nsections) != (int)(nsections*sizeof(struct pe_image_section_hdr))) {\n        cli_dbgmsg(\"Can't read section header\\n\");\n\tcli_dbgmsg(\"Possibly broken PE file\\n\");\n\tfree(section_hdr);\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_section_hdr)*nsections;\n\n    for(i = 0; falign!=0x200 && i<nsections; i++) {\n\t/* file alignment fallback mode - blah */\n\tif (falign && section_hdr[i].SizeOfRawData && EC32(section_hdr[i].PointerToRawData)%falign && !(EC32(section_hdr[i].PointerToRawData)%0x200)) {\n\t    cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");\n\t    falign = 0x200;\n\t}\n    }\n\n    hdr_size = PESALIGN(hdr_size, valign); /* Aligned headers virtual size */\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    for(i = 0; i < nsections; i++) {\n\tstrncpy(sname, (char *) section_hdr[i].Name, 8);\n\tsname[8] = 0;\n\texe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n\texe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n\texe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n\texe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n\texe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n\texe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */\n\texe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n\texe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n\texe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n            free(section_hdr);\n            free(exe_sections);\n            return CL_ETIMEOUT;\n        }\n#endif\n\n\tif (!exe_sections[i].vsz && exe_sections[i].rsz)\n\t    exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);\n\n\tif (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))\n\t    exe_sections[i].rsz = fsize - exe_sections[i].raw;\n\t\n\tcli_dbgmsg(\"Section %d\\n\", i);\n\tcli_dbgmsg(\"Section name: %s\\n\", sname);\n\tcli_dbgmsg(\"Section data (from headers - in memory)\\n\");\n\tcli_dbgmsg(\"VirtualSize: 0x%x 0x%x\\n\", exe_sections[i].uvsz, exe_sections[i].vsz);\n\tcli_dbgmsg(\"VirtualAddress: 0x%x 0x%x\\n\", exe_sections[i].urva, exe_sections[i].rva);\n\tcli_dbgmsg(\"SizeOfRawData: 0x%x 0x%x\\n\", exe_sections[i].ursz, exe_sections[i].rsz);\n\tcli_dbgmsg(\"PointerToRawData: 0x%x 0x%x\\n\", exe_sections[i].uraw, exe_sections[i].raw);\n\n\tif(exe_sections[i].chr & 0x20) {\n\t    cli_dbgmsg(\"Section contains executable code\\n\");\n\n\t    if(exe_sections[i].vsz < exe_sections[i].rsz) {\n\t\tcli_dbgmsg(\"Section contains free space\\n\");\n\t\t/*\n\t\tcli_dbgmsg(\"Dumping %d bytes\\n\", section_hdr.SizeOfRawData - section_hdr.VirtualSize);\n\t\tddump(desc, section_hdr.PointerToRawData + section_hdr.VirtualSize, section_hdr.SizeOfRawData - section_hdr.VirtualSize, cli_gentemp(NULL));\n\t\t*/\n\n\t    }\n\t}\n\n\tif(exe_sections[i].chr & 0x20000000)\n\t    cli_dbgmsg(\"Section's memory is executable\\n\");\n\n\tif(exe_sections[i].chr & 0x80000000)\n\t    cli_dbgmsg(\"Section's memory is writeable\\n\");\n\n\tif (DETECT_BROKEN_PE && (!valign || (exe_sections[i].urva % valign))) { /* Bad virtual alignment */\n\t    cli_dbgmsg(\"VirtualAddress is misaligned\\n\");\n\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n\t    if (exe_sections[i].raw >= fsize) { /* really broken */\n\t      cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n\t      cli_dbgmsg(\"------------------------------------\\n\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\tif(DETECT_BROKEN_PE) {\n\t\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\t    return CL_VIRUS;\n\t\t}\n\t\treturn CL_CLEAN; /* no ninjas to see here! move along! */\n\t    }\n\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    /* check hash section sigs */\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);\n\t        if (ret != CL_CLEAN) {\n\t            if (ret != CL_VIRUS)\n\t                cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));\n\t\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t            free(section_hdr);\n\t            free(exe_sections);\n\t            return ret;\n\t        }\n\t    }\n\t}\n\tcli_dbgmsg(\"------------------------------------\\n\");\n\n\tif (exe_sections[i].urva>>31 || exe_sections[i].uvsz>>31 || (exe_sections[i].rsz && exe_sections[i].uraw>>31) || exe_sections[i].ursz>>31) {\n\t    cli_dbgmsg(\"Found PE values with sign bit set\\n\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\n\tif(!i) {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva!=hdr_size) { /* Bad first section RVA */\n\t        cli_dbgmsg(\"First section is in the wrong place\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    min = exe_sections[i].rva;\n\t    max = exe_sections[i].rva + exe_sections[i].rsz;\n\t} else {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva - exe_sections[i-1].urva != exe_sections[i-1].vsz) { /* No holes, no overlapping, no virtual disorder */\n\t        cli_dbgmsg(\"Virtually misplaced section (wrong order, overlapping, non contiguous)\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    if(exe_sections[i].rva < min)\n\t        min = exe_sections[i].rva;\n\n\t    if(exe_sections[i].rva + exe_sections[i].rsz > max) {\n\t        max = exe_sections[i].rva + exe_sections[i].rsz;\n\t\toverlays = exe_sections[i].raw + exe_sections[i].rsz;\n\t    }\n\t}\n    }\n\n    free(section_hdr);\n\n    if(!(ep = cli_rawaddr(vep, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\tcli_dbgmsg(\"EntryPoint out of file\\n\");\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"EntryPointOffset\", ep);\n\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n\n    cli_dbgmsg(\"EntryPoint offset: 0x%x (%d)\\n\", ep, ep);\n\n    if(pe_plus) { /* Do not continue for PE32+ files */\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    epsize = fmap_readn(map, epbuff, ep, 4096);\n\n\n    /* Disasm scan disabled since it's now handled by the bytecode */\n\n    /* CLI_UNPTEMP(\"DISASM\",(exe_sections,0)); */\n    /* if(disasmbuf((unsigned char*)epbuff, epsize, ndesc)) */\n    /* \tret = cli_scandesc(ndesc, ctx, CL_TYPE_PE_DISASM, 1, NULL, AC_SCAN_VIR); */\n    /* close(ndesc); */\n    /* CLI_TMPUNLK(); */\n    /* free(tempfile); */\n    /* if(ret == CL_VIRUS) { */\n    /* \tfree(exe_sections); */\n    /* \treturn ret; */\n    /* } */\n\n    if(overlays) {\n\tint overlays_sz = fsize - overlays;\n\tif(overlays_sz > 0) {\n\t    ret = cli_scanishield(ctx, overlays, overlays_sz);\n\t    if(ret != CL_CLEAN) {\n\t\tfree(exe_sections);\n\t\treturn ret;\n\t    }\n\t}\n    }\n\n    pedata.nsections = nsections;\n    pedata.ep = ep;\n    pedata.offset = 0;\n    memcpy(&pedata.file_hdr, &file_hdr, sizeof(file_hdr));\n    memcpy(&pedata.opt32, &pe_opt.opt32, sizeof(pe_opt.opt32));\n    memcpy(&pedata.opt64, &pe_opt.opt64, sizeof(pe_opt.opt64));\n    memcpy(&pedata.dirs, dirs, sizeof(pedata.dirs));\n    pedata.e_lfanew = e_lfanew;\n    pedata.overlays = overlays;\n    pedata.overlays_sz = fsize - overlays;\n    pedata.hdr_size = hdr_size;\n\n    /* Bytecode BC_PE_ALL hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\tfree(exe_sections);\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_ALL, map);\n    switch (ret) {\n        case CL_ENULLARG:\n            cli_warnmsg(\"cli_scanpe: NULL argument supplied\\n\");\n            break;\n        case CL_VIRUS:\n        case CL_BREAK:\n            free(exe_sections);\n            cli_bytecode_context_destroy(bc_ctx);\n            return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN;\n    }\n    cli_bytecode_context_destroy(bc_ctx);\n    /* Attempt to detect some popular polymorphic viruses */\n\n    /* W32.Parite.B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_PARITE) && !dll && epsize == 4096 && ep == exe_sections[nsections - 1].raw) {\n        const char *pt = cli_memstr(epbuff, 4040, \"\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00\", 15);\n\tif(pt) {\n\t    pt += 15;\n\t    if((((uint32_t)cli_readint32(pt) ^ (uint32_t)cli_readint32(pt + 4)) == 0x505a4f) && (((uint32_t)cli_readint32(pt + 8) ^ (uint32_t)cli_readint32(pt + 12)) == 0xffffb) && (((uint32_t)cli_readint32(pt + 16) ^ (uint32_t)cli_readint32(pt + 20)) == 0xb8)) {\n\t        cli_append_virus(ctx,\"Heuristics.W32.Parite.B\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n    }\n\n    /* Kriz */\n    if(SCAN_ALGO && (DCONF & PE_CONF_KRIZ) && epsize >= 200 && CLI_ISCONTAINED(exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz, ep, 0x0fd2) && epbuff[1]=='\\x9c' && epbuff[2]=='\\x60') {\n\tenum {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSXORPRFX,KZSXOR,KZSDDELTA,KZSLOOP,KZSTOP};\n\tuint8_t kzs[] = {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSTRASH,KZSXORPRFX,KZSXOR,KZSTRASH,KZSDDELTA,KZSTRASH,KZSLOOP,KZSTOP};\n\tuint8_t *kzstate = kzs;\n\tuint8_t *kzcode = (uint8_t *)epbuff + 3;\n\tuint8_t kzdptr=0xff, kzdsize=0xff;\n\tint kzlen = 197, kzinitlen=0xffff, kzxorlen=-1;\n\tcli_dbgmsg(\"in kriz\\n\");\n\n\twhile(*kzstate!=KZSTOP) {\n\t    uint8_t op;\n\t    if(kzlen<=6) break;\n\t    op = *kzcode++;\n\t    kzlen--;\n\t    switch (*kzstate) {\n\t    case KZSTRASH: case KZSGETSIZE: {\n\t\tint opsz=0;\n\t\tswitch(op) {\n\t\tcase 0x81:\n\t\t    kzcode+=5;\n\t\t    kzlen-=5;\n\t\t    break;\n\t\tcase 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbd: case 0xbe: case 0xbf:\n\t\t    if(*kzstate==KZSGETSIZE && cli_readint32(kzcode)==0x0fd2) {\n\t\t\tkzinitlen = kzlen-5;\n\t\t\tkzdsize=op-0xb8;\n\t\t\tkzstate++;\n\t\t\top=4; /* fake the register to avoid breaking out */\n\t\t\tcli_dbgmsg(\"kriz: using #%d as size counter\\n\", kzdsize);\n\t\t    }\n\t\t    opsz=4;\n\t\tcase 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4d: case 0x4e: case 0x4f:\n\t\t    op&=7;\n\t\t    if(op!=kzdptr && op!=kzdsize) {\n\t\t\tkzcode+=opsz;\n\t\t\tkzlen-=opsz;\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t    kzcode--;\n\t\t    kzlen++;\n\t\t    kzstate++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    case KZSCDELTA:\n\t\tif(op==0xe8 && (uint32_t)cli_readint32(kzcode) < 0xff) {\n\t\t    kzlen-=*kzcode+4;\n\t\t    kzcode+=*kzcode+4;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSPDELTA:\n\t\tif((op&0xf8)==0x58 && (kzdptr=op-0x58)!=4) {\n\t\t    kzstate++;\n\t\t    cli_dbgmsg(\"kriz: using #%d as pointer\\n\", kzdptr);\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSXORPRFX:\n\t\tkzstate++;\n\t\tif(op==0x3e) break;\n\t    case KZSXOR:\n\t\tif (op==0x80 && *kzcode==kzdptr+0xb0) {\n\t\t    kzxorlen=kzlen;\n\t\t    kzcode+=+6;\n\t\t    kzlen-=+6;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSDDELTA:\n\t\tif (op==kzdptr+0x48) kzstate++;\n\t\telse *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSLOOP:\n\t\tif (op==kzdsize+0x48 && *kzcode==0x75 && kzlen-(int8_t)kzcode[1]-3<=kzinitlen && kzlen-(int8_t)kzcode[1]>=kzxorlen) {\n\t\t    cli_append_virus(ctx,\"Heuristics.W32.Kriz\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t\tcli_dbgmsg(\"kriz: loop out of bounds, corrupted sample?\\n\");\n\t\tkzstate++;\n\t    }\n\t}\n    }\n\n    /* W32.Magistr.A/B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_MAGISTR) && !dll && (nsections>1) && (exe_sections[nsections - 1].chr & 0x80000000)) {\n        uint32_t rsize, vsize, dam = 0;\n\n\tvsize = exe_sections[nsections - 1].uvsz;\n\trsize = exe_sections[nsections - 1].rsz;\n\tif(rsize < exe_sections[nsections - 1].ursz) {\n\t    rsize = exe_sections[nsections - 1].ursz;\n\t    dam = 1;\n\t}\n\n\tif(vsize >= 0x612c && rsize >= 0x612c && ((vsize & 0xff) == 0xec)) {\n\t\tint bw = rsize < 0x7000 ? rsize : 0x7000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x2c\\x61\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx, dam ? \"Heuristics.W32.Magistr.A.dam\" : \"Heuristics.W32.Magistr.A\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t    }\n\n\t} else if(rsize >= 0x7000 && vsize >= 0x7000 && ((vsize & 0xff) == 0xed)) {\n\t\tint bw = rsize < 0x8000 ? rsize : 0x8000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x04\\x72\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx,dam ? \"Heuristics.W32.Magistr.B.dam\" : \"Heuristics.W32.Magistr.B\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t} \n\t    }\n\t}\n    }\n\n    /* W32.Polipos.A */\n    while(polipos && !dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && (EC16(optional_hdr32.Subsystem) == 2 || EC16(optional_hdr32.Subsystem) == 3) && EC16(file_hdr.Machine) == 0x14c && optional_hdr32.SizeOfStackReserve >= 0x80000) {\n\tuint32_t jump, jold, *jumps = NULL;\n\tconst uint8_t *code;\n\tunsigned int xsjs = 0;\n\n\tif(exe_sections[0].rsz > CLI_MAX_ALLOCATION) break;\n\n\tif(!exe_sections[0].rsz) break;\n\tif(!(code=fmap_need_off_once(map, exe_sections[0].raw, exe_sections[0].rsz))) break;\n\tfor(i=0; i<exe_sections[0].rsz - 5; i++) {\n\t    if((uint8_t)(code[i]-0xe8) > 1) continue;\n\t    jump = cli_rawaddr(exe_sections[0].rva+i+5+cli_readint32(&code[i+1]), exe_sections, nsections, &err, fsize, hdr_size);\n\t    if(err || !CLI_ISCONTAINED(exe_sections[polipos].raw, exe_sections[polipos].rsz, jump, 9)) continue;\n\t    if(xsjs % 128 == 0) {\n\t\tif(xsjs == 1280) break;\n\t\tif(!(jumps=(uint32_t *)cli_realloc2(jumps, (xsjs+128)*sizeof(uint32_t)))) {\n\t\t    free(exe_sections);\n\t\t    return CL_EMEM;\n\t\t}\n\t    }\n\t    j=0;\n\t    for(; j<xsjs; j++) {\n\t\tif(jumps[j]<jump) continue;\n\t\tif(jumps[j]==jump) {\n\t\t    xsjs--;\n\t\t    break;\n\t\t}\n\t\tjold=jumps[j];\n\t\tjumps[j]=jump;\n\t\tjump=jold;\n\t    }\n\t    jumps[j]=jump;\n\t    xsjs++;\n\t}\n\tif(!xsjs) break;\n\tcli_dbgmsg(\"Polipos: Checking %d xsect jump(s)\\n\", xsjs);\n\tfor(i=0;i<xsjs;i++) {\n\t    if(!(code = fmap_need_off_once(map, jumps[i], 9))) continue;\n\t    if((jump=cli_readint32(code))==0x60ec8b55 || (code[4]==0x0ec && ((jump==0x83ec8b55 && code[6]==0x60) || (jump==0x81ec8b55 && !code[7] && !code[8])))) {\n\t\tcli_append_virus(ctx,\"Heuristics.W32.Polipos.A\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(jumps);\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n\tfree(jumps);\n\tbreak;\n    }\n\n    /* Trojan.Swizzor.Gen */\n    if (SCAN_ALGO && (DCONF & PE_CONF_SWIZZOR) && nsections > 1 && fsize > 64*1024 && fsize < 4*1024*1024) {\n\t    if(dirs[2].Size) {\n\t\t    struct swizz_stats *stats = cli_calloc(1, sizeof(*stats));\n\t\t    unsigned int m = 1000;\n\t\t    ret = CL_CLEAN;\n\n\t\t    if (!stats)\n\t\t\t    ret = CL_EMEM;\n\t\t    else {\n\t\t\t    cli_parseres_special(EC32(dirs[2].VirtualAddress), EC32(dirs[2].VirtualAddress), map, exe_sections, nsections, fsize, hdr_size, 0, 0, &m, stats);\n\t\t\t    if ((ret = cli_detect_swizz(stats)) == CL_VIRUS) {\n\t\t\t\tcli_append_virus(ctx,\"Heuristics.Trojan.Swizzor.Gen\");\n\t\t\t    }\n\t\t\t    free(stats);\n\t\t    }\n\t\t    if (ret != CL_CLEAN) {\n\t\t\tif (!(ret == CL_VIRUS && SCAN_ALL)) {\n\t\t\t    free(exe_sections);\n\t\t\t    return ret;\n\t\t\t}\n\t\t\tviruses_found++;\n\t\t    }\n\t    }\n    }\n\n\n    /* !!!!!!!!!!!!!!    PACKERS START HERE    !!!!!!!!!!!!!! */\n    corrupted_cur = ctx->corrupted_input;\n    ctx->corrupted_input = 2; /* caller will reset on return */\n\n\n    /* UPX, FSG, MEW support */\n\n    /* try to find the first section with physical size == 0 */\n    found = 0;\n    if(DCONF & (PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW)) {\n\tfor(i = 0; i < (unsigned int) nsections - 1; i++) {\n\t    if(!exe_sections[i].rsz && exe_sections[i].vsz && exe_sections[i + 1].rsz && exe_sections[i + 1].vsz) {\n\t\tfound = 1;\n\t\tcli_dbgmsg(\"UPX/FSG/MEW: empty section found - assuming compression\\n\");\n#if HAVE_JSON\n        cli_jsonbool(pe_json, \"HasEmptySection\", 1);\n#endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    /* MEW support */\n    if (found && (DCONF & PE_CONF_MEW) && epsize>=16 && epbuff[0]=='\\xe9') {\n\tuint32_t fileoffset;\n\tconst char *tbuff;\n\n\tfileoffset = (vep + cli_readint32(epbuff + 1) + 5);\n\twhile (fileoffset == 0x154 || fileoffset == 0x158) {\n\t    char *src;\n\t    uint32_t offdiff, uselzma;\n\n\t    cli_dbgmsg (\"MEW: found MEW characteristics %08X + %08X + 5 = %08X\\n\", \n\t\t\tcli_readint32(epbuff + 1), vep, cli_readint32(epbuff + 1) + vep + 5);\n\n\t    if(!(tbuff = fmap_need_off_once(map, fileoffset, 0xb0)))\n\t\tbreak;\n\t    if (fileoffset == 0x154) cli_dbgmsg(\"MEW: Win9x compatibility was set!\\n\");\n\t    else cli_dbgmsg(\"MEW: Win9x compatibility was NOT set!\\n\");\n\n\t    if((offdiff = cli_readint32(tbuff+1) - EC32(optional_hdr32.ImageBase)) <= exe_sections[i + 1].rva || offdiff >= exe_sections[i + 1].rva + exe_sections[i + 1].raw - 4) {\n\t        cli_dbgmsg(\"MEW: ESI is not in proper section\\n\");\n\t\tbreak;\n\t    }\n\t    offdiff -= exe_sections[i + 1].rva;\n\n\t    if(!exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: mew section is empty\\n\");\n\t\tbreak;\n\t    }\n\t    ssize = exe_sections[i + 1].vsz;\n\t    dsize = exe_sections[i].vsz;\n\n\t    cli_dbgmsg(\"MEW: ssize %08x dsize %08x offdiff: %08x\\n\", ssize, dsize, offdiff);\n\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize, dsize));\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize + dsize, exe_sections[i + 1].rsz));\n\n\t    if (exe_sections[i + 1].rsz < offdiff + 12 || exe_sections[i + 1].rsz > ssize) {\n\t        cli_dbgmsg(\"MEW: Size mismatch: %08x\\n\", exe_sections[i + 1].rsz);\n\t\tbreak;\n\t    }\n\n\t    /* allocate needed buffer */\n\t    if (!(src = cli_calloc (ssize + dsize, sizeof(char)))) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((bytes = fmap_readn(map, src + dsize, exe_sections[i + 1].raw, exe_sections[i + 1].rsz)) != exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: Can't read %d bytes [read: %lu]\\n\", exe_sections[i + 1].rsz, (unsigned long)bytes);\n\t\tfree(exe_sections);\n\t\tfree(src);\n\t\treturn CL_EREAD;\n\t    }\n\t    cli_dbgmsg(\"MEW: %u (%08x) bytes read\\n\", (unsigned int)bytes, (unsigned int)bytes);\n\n\t    /* count offset to lzma proc, if lzma used, 0xe8 -> call */\n\t    if (tbuff[0x7b] == '\\xe8') {\n\t        if (!CLI_ISCONTAINED(exe_sections[1].rva, exe_sections[1].vsz, cli_readint32(tbuff + 0x7c) + fileoffset + 0x80, 4)) {\n\t\t    cli_dbgmsg(\"MEW: lzma proc out of bounds!\\n\");\n\t\t    free(src);\n\t\t    break; /* to next unpacker in chain */\n\t\t}\n\t\tuselzma = cli_readint32(tbuff + 0x7c) - (exe_sections[0].rva - fileoffset - 0x80);\n\t    } else {\n\t        uselzma = 0;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"MEW\");\n#endif\n\n\t    CLI_UNPTEMP(\"MEW\",(src,exe_sections,0));\n\t    CLI_UNPRESULTS(\"MEW\",(unmew11(src, offdiff, ssize, dsize, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, uselzma, ndesc)),1,(src,0));\n\t    break;\n\t}\n    }\n\n    if(epsize<168) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    if (found || upack) {\n\t/* Check EP for UPX vs. FSG vs. Upack */\n\n\t/* Upack 0.39 produces 2 types of executables\n\t * 3 sections:           | 2 sections (one empty, I don't chech found if !upack, since it's in OR above):\n\t *   mov esi, value      |   pusha\n\t *   lodsd               |   call $+0x9\n\t *   push eax            |\n\t *\n\t * Upack 1.1/1.2 Beta produces [based on 2 samples (sUx) provided by aCaB]:\n\t * 2 sections\n\t *   mov esi, value\n\t *   loads\n\t *   mov edi, eax\n\t *\n\t * Upack unknown [sample 0297729]\n\t * 3 sections\n\t *   mov esi, value\n\t *   push [esi]\n\t *   jmp\n\t * \n\t */\n\t/* upack 0.39-3s + sample 0151477*/\n \twhile(((upack && nsections == 3) && /* 3 sections */\n\t    ((\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x50' /* lodsd; push eax */\n\t     )\n\t    || \n\t    /* based on 0297729 sample from aCaB */\n\t    (epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xff' && epbuff[6] == '\\x36' /* push [esi] */\n\t     )\n\t   )) \n\t   ||\n\t   ((!upack && nsections == 2) && /* 2 sections */\n\t    (( /* upack 0.39-2s */\n\t     epbuff[0] == '\\x60' && epbuff[1] == '\\xe8' && cli_readint32(epbuff+2) == 0x9 /* pusha; call+9 */\n\t     )\n\t    ||\n\t    ( /* upack 1.1/1.2, based on 2 samples */\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase) < min &&  /* mov esi */\n\t     cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > 0 &&\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x8b' && epbuff[7] == '\\xf8' /* loads;  mov edi, eax */\n\t     )\n\t   ))\n\t   ) { \n\t    uint32_t vma, off;\n\t    int a,b,c;\n\n\t    cli_dbgmsg(\"Upack characteristics found.\\n\");\n\t    a = exe_sections[0].vsz;\n\t    b = exe_sections[1].vsz;\n\t    if (upack) {\n\t        cli_dbgmsg(\"Upack: var set\\n\");\n\t\tc = exe_sections[2].vsz;\n\t\tssize = exe_sections[0].ursz + exe_sections[0].uraw;\n\t\toff = exe_sections[0].rva;\n\t\tvma = EC32(optional_hdr32.ImageBase) + exe_sections[0].rva;\n\t    } else {\n\t        cli_dbgmsg(\"Upack: var NOT set\\n\");\n\t\tc = exe_sections[1].rva;\n\t\tssize = exe_sections[1].uraw;\n\t\toff = 0;\n\t\tvma = exe_sections[1].rva - exe_sections[1].uraw;\n\t    }\n\n\t    dsize = a+b+c;\n\n\t    CLI_UNPSIZELIMITS(\"Upack\", MAX(MAX(dsize, ssize), exe_sections[1].ursz));\n\n\t    if (!CLI_ISCONTAINED(0, dsize, exe_sections[1].rva - off, exe_sections[1].ursz) || (upack && !CLI_ISCONTAINED(0, dsize, exe_sections[2].rva - exe_sections[0].rva, ssize)) || ssize > dsize) {\n\t        cli_dbgmsg(\"Upack: probably malformed pe-header, skipping to next unpacker\\n\");\n\t\tbreak;\n\t    }\n\t\t\t\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((unsigned int)fmap_readn(map, dest, 0, ssize) != ssize) {\n\t        cli_dbgmsg(\"Upack: Can't read raw data of section 0\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n\t    if(upack) memmove(dest + exe_sections[2].rva - exe_sections[0].rva, dest, ssize);\n\n\t    if((unsigned int)fmap_readn(map, dest + exe_sections[1].rva - off, exe_sections[1].uraw, exe_sections[1].ursz) != exe_sections[1].ursz) {\n\t\tcli_dbgmsg(\"Upack: Can't read raw data of section 1\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Upack\");\n#endif\n\n\t    CLI_UNPTEMP(\"Upack\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Upack\",(unupack(upack, dest, dsize, epbuff, vma, ep, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, ndesc)),1,(dest,0));\n\t    break;\n\t}\n    }\n\n    \n    while(found  && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\x87' && epbuff[1] == '\\x25') {\n\tconst char *dst;\n\n\t/* FSG v2.0 support - thanks to aCaB ! */\n\n\tuint32_t newesi, newedi, newebx, newedx;\n\t\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\t\n\tnewedx = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: xchg out of bounds (%x), giving up\\n\", newedx);\n\t    break;\n\t}\n\t\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i + 1);\n\t    free(exe_sections);\n\t    return CL_ESEEK;\n\t}\n\n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(newedx < exe_sections[i + 1].rva || !CLI_ISCONTAINED(src, ssize, dst, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP (%x) is wrong\\n\", newedx);\n\t    break;\n\t}\n \n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(!CLI_ISCONTAINED(src, ssize, dst, 32)) {\n\t    cli_dbgmsg(\"FSG: New stack out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedi = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tnewesi = cli_readint32(dst + 4) - EC32(optional_hdr32.ImageBase);\n\tnewebx = cli_readint32(dst + 16) - EC32(optional_hdr32.ImageBase);\n\tnewedx = cli_readint32(dst + 20);\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination buffer (edi is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newebx, 16)) {\n\t    cli_dbgmsg(\"FSG: Array of functions out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx=cli_readint32(newebx + 12 - exe_sections[i + 1].rva + src) - EC32(optional_hdr32.ImageBase);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\",newedx);\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,exe_sections,0));\n\tCLI_UNPRESULTSFSG2(\"FSG\",(unfsg_200(newesi - exe_sections[i + 1].rva + src, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, newedi, EC32(optional_hdr32.ImageBase), newedx, ndesc)),1,(dest,0));\n\tbreak;\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min) {\n\n\t/* FSG support - v. 1.33 (thx trog for the many samples) */\n\n\tint sectcnt = 0;\n\tconst char *support;\n\tuint32_t newesi, newedi, oldep, gp, t;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!(t = cli_rawaddr(cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size)) && err ) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp);\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* newebx = cli_readint32(support) - EC32(optional_hdr32.ImageBase);  Unused */\n\tnewedi = cli_readint32(support + 4) - EC32(optional_hdr32.ImageBase); /* 1st dest */\n\tnewesi = cli_readint32(support + 8) - EC32(optional_hdr32.ImageBase); /* Source */\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 12; t < gp - 4; t += 4) {\n\t    uint32_t rva = cli_readint32(support+t);\n\n\t    if(!rva)\n\t\tbreak;\n\n\t    rva -= EC32(optional_hdr32.ImageBase)+1;\n\t    sectcnt++;\n\n\t    if(rva % 0x1000) cli_dbgmsg(\"FSG: Original section %d is misaligned\\n\", sectcnt);\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp - 4 || cli_readint32(support + t)) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 1; t <= (uint32_t)sectcnt; t++)\n\t    sections[t].rva = cli_readint32(support + 8 + t * 4) - 1 - EC32(optional_hdr32.ImageBase);\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\toldep = vep + 161 + 6 + cli_readint32(epbuff+163);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.33 */\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbb' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min && epbuff[5] == '\\xbf' && epbuff[10] == '\\xbe' && vep >= exe_sections[i + 1].rva && vep - exe_sections[i + 1].rva > exe_sections[i + 1].rva - 0xe0 ) {\n\n\t/* FSG support - v. 1.31 */\n\n\tint sectcnt = 0;\n\tuint32_t gp, t = cli_rawaddr(cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size);\n\tconst char *support;\n\tuint32_t newesi = cli_readint32(epbuff+11) - EC32(optional_hdr32.ImageBase);\n\tuint32_t newedi = cli_readint32(epbuff+6) - EC32(optional_hdr32.ImageBase);\n\tuint32_t oldep = vep - exe_sections[i + 1].rva;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tif(err) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].raw) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp)\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 0; t < gp - 2; t += 2) {\n\t    uint32_t rva = support[t]|(support[t+1]<<8);\n\n\t    if (rva == 2 || rva == 1)\n\t\tbreak;\n\n\t    rva = ((rva-2)<<12) - EC32(optional_hdr32.ImageBase);\n\t    sectcnt++;\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp-10 || cli_readint32(support + t + 6) != 2) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 0; t <= (uint32_t)sectcnt - 1; t++) {\n\t    sections[t+1].rva = (((support[t*2]|(support[t*2+1]<<8))-2)<<12)-EC32(optional_hdr32.ImageBase);\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"FSG: Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\tgp = 0xda + 6*(epbuff[16]=='\\xe8');\n\toldep = vep + gp + 6 + cli_readint32(src+gp+2+oldep);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.31 */\n    }\n\n\n    if(found && (DCONF & PE_CONF_UPX)) {\n\n\t/* UPX support */\n\n\t/* we assume (i + 1) is UPX1 */\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz + exe_sections[i + 1].vsz;\n\n        /* cli_dbgmsg(\"UPX: ssize %u dsize %u\\n\", ssize, dsize); */\n\n\tCLI_UNPSIZELIMITS(\"UPX\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) {\n\t    cli_dbgmsg(\"UPX: Size mismatch or dsize too big (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"UPX: Can't read raw data of section %d\\n\", i+1);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize + 8192, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\t/* try to detect UPX code */\n\tif(cli_memstr(UPX_NRV2B, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2B, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2B decompression routine\\n\");\n\t    upxfn = upx_inflate2b;\n\t} else if(cli_memstr(UPX_NRV2D, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2D, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2D decompression routine\\n\");\n\t    upxfn = upx_inflate2d;\n\t} else if(cli_memstr(UPX_NRV2E, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2E, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2E decompression routine\\n\");\n\t    upxfn = upx_inflate2e;\n\t}\n\n\tif(upxfn) {\n\t    int skew = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase) - exe_sections[i + 1].rva;\n\n\t    if(epbuff[1] != '\\xbe' || skew <= 0 || skew > 0xfff) { /* FIXME: legit skews?? */\n\t\tskew = 0; \n\t    } else if ((unsigned int)skew > ssize) {\n\t\t/* Ignore suggested skew larger than section size */\n\t\tskew = 0;\n\t    } else {\n\t\tcli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);\n\t    }\n\n\t    /* Try skewed first (skew may be zero) */\n\t    if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0) {\n\t\tupx_success = 1;\n\t    }\n\t    /* If skew not successful and non-zero, try no skew */\n\t    else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {\n\t\tupx_success = 1;\n\t    }\n\n\t    if(upx_success)\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed\\n\");\n\t    else\n\t\tcli_dbgmsg(\"UPX: Preferred decompressor failed\\n\");\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2b) {\n\t    if(upx_inflate2b(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2b(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2B decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2B\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2d) {\n\t    if(upx_inflate2d(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2d(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2D decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2D\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2e) {\n\t    if(upx_inflate2e(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2e(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\t\tcli_dbgmsg(\"UPX: NRV2E decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2E\\n\");\n\t    }\n\t}\n\n\tif(cli_memstr(UPX_LZMA2, 20, epbuff + 0x2f, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x21), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t} else if (cli_memstr(UPX_LZMA1, 20, epbuff + 0x39, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x2b), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t}\n\n\tif(!upx_success) {\n\t    cli_dbgmsg(\"UPX: All decompressors failed\\n\");\n\t    free(dest);\n\t}\n    }\n\n    if(upx_success) {\n\tfree(exe_sections);\n\n\tCLI_UNPTEMP(\"UPX/FSG\",(dest,0));\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"UPX\");\n#endif\n\n\tif((unsigned int) write(ndesc, dest, dsize) != dsize) {\n\t    cli_dbgmsg(\"UPX/FSG: Can't write %d bytes\\n\", dsize);\n\t    free(tempfile);\n\t    free(dest);\n\t    close(ndesc);\n\t    return CL_EWRITE;\n\t}\n\n\tfree(dest);\n\tif (lseek(ndesc, 0, SEEK_SET) == -1) {\n        cli_dbgmsg(\"UPX/FSG: lseek() failed\\n\");\n        close(ndesc);\n        CLI_TMPUNLK();\n        free(tempfile);\n        SHA_RESET;\n        return CL_ESEEK;\n    }\n\n\tif(ctx->engine->keeptmp)\n\t    cli_dbgmsg(\"UPX/FSG: Decompressed data saved in %s\\n\", tempfile);\n\n\tcli_dbgmsg(\"***** Scanning decompressed file *****\\n\");\n\tSHA_OFF;\n\tif((ret = cli_magic_scandesc(ndesc, ctx)) == CL_VIRUS) {\n\t    close(ndesc);\n\t    CLI_TMPUNLK();\n\t    free(tempfile);\n\t    SHA_RESET;\n\t    return CL_VIRUS;\n\t}\n\n\tSHA_RESET;\n\tclose(ndesc);\n\tCLI_TMPUNLK();\n\tfree(tempfile);\n\treturn ret;\n    }\n\n\n    /* Petite */\n\n    if(epsize<200) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    found = 2;\n\n    if(epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 1].rva + EC32(optional_hdr32.ImageBase)) {\n\tif(nsections < 2 || epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 2].rva + EC32(optional_hdr32.ImageBase))\n\t    found = 0;\n\telse\n\t    found = 1;\n    }\n\n    if(found && (DCONF & PE_CONF_PETITE)) {\n\tcli_dbgmsg(\"Petite: v2.%d compression detected\\n\", found);\n\n\tif(cli_readint32(epbuff + 0x80) == 0x163c988d) {\n\t    cli_dbgmsg(\"Petite: level zero compression is not supported yet\\n\");\n\t} else {\n\t    dsize = max - min;\n\n\t    CLI_UNPSIZELIMITS(\"Petite\", dsize);\n\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t\tcli_dbgmsg(\"Petite: Can't allocate %d bytes\\n\", dsize);\n\t\tfree(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    for(i = 0 ; i < nsections; i++) {\n\t\tif(exe_sections[i].raw) {\n\t\t    if(!exe_sections[i].rsz || (unsigned int)fmap_readn(map, dest + exe_sections[i].rva - min, exe_sections[i].raw, exe_sections[i].ursz) != exe_sections[i].ursz) {\n\t\t\tfree(exe_sections);\n\t\t\tfree(dest);\n\t\t\treturn CL_CLEAN;\n\t\t    }\n\t\t}\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Petite\");\n#endif\n\n\t    CLI_UNPTEMP(\"Petite\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Petite\",(petite_inflate2x_1to9(dest, min, max - min, exe_sections, nsections - (found == 1 ? 1 : 0), EC32(optional_hdr32.ImageBase),vep, ndesc, found, EC32(optional_hdr32.DataDirectory[2].VirtualAddress),EC32(optional_hdr32.DataDirectory[2].Size))),0,(dest,0));\n\t}\n    }\n\n    /* PESpin 1.1 */\n\n    if((DCONF & PE_CONF_PESPIN) && nsections > 1 &&\n       vep >= exe_sections[nsections - 1].rva &&\n       vep < exe_sections[nsections - 1].rva + exe_sections[nsections - 1].rsz - 0x3217 - 4 &&\n       memcmp(epbuff+4, \"\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3\", 10) == 0)  {\n\n\tchar *spinned;\n\n\tCLI_UNPSIZELIMITS(\"PEspin\", fsize);\n\n\tif((spinned = (char *) cli_malloc(fsize)) == NULL) {\n        cli_errmsg(\"PESping: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tif((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t    cli_dbgmsg(\"PESpin: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t    free(spinned);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"PEspin\");\n#endif\n\n\tCLI_UNPTEMP(\"PESpin\",(spinned,exe_sections,0));\n\tCLI_UNPRESULTS_(\"PEspin\",SPINCASE(),(unspin(spinned, fsize, exe_sections, nsections - 1, vep, ndesc, ctx)),0,(spinned,0));\n    }\n\n\n    /* yC 1.3 & variants */\n    if((DCONF & PE_CONF_YC) && nsections > 1 &&\n       (EC32(optional_hdr32.AddressOfEntryPoint) == exe_sections[nsections - 1].rva + 0x60)) {\n\n\tuint32_t ecx = 0;\n\tint16_t offset;\n\n\t/* yC 1.3 */\n\tif (!memcmp(epbuff, \"\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED\", 15) &&\n\t    !memcmp(epbuff+0x26, \"\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC\", 13) &&\n\t    ((uint8_t)epbuff[0x13] == 0xB9) &&\n\t    ((uint16_t)(cli_readint16(epbuff+0x18)) == 0xE981) &&\n\t    !memcmp(epbuff+0x1e,\"\\x8B\\xD5\\x81\\xC2\", 4)) {\n\n\t    offset = 0;\n\t    if (0x6c - cli_readint32(epbuff+0xf) + cli_readint32(epbuff+0x22) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x14) - cli_readint32(epbuff+0x1a);\n\t}\n\n\t/* yC 1.3 variant */\n\tif (!ecx && !memcmp(epbuff, \"\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57\", 9) &&\n\t    !memcmp(epbuff+0x17, \"\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\", 8) &&\n\t    ((uint8_t)epbuff[0x23] == 0xB9)) {\n\n\t    offset = 0x10;\n\t    if (0x6c - cli_readint32(epbuff+0x1f) + cli_readint32(epbuff+0x32) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x24) - cli_readint32(epbuff+0x2a);\n\t}\n\n\t/* yC 1.x/modified */\n\tif (!ecx && !memcmp(epbuff, \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\",9) &&\n\t    ((uint8_t)epbuff[0xd] == 0xb9) &&\n\t    ((uint16_t)cli_readint16(epbuff + 0x12)== 0xbd8d) &&\n\t    !memcmp(epbuff+0x18, \"\\x8b\\xf7\\xac\", 3)) {\n\n\t    offset = -0x18;\n\t    if (0x66 - cli_readint32(epbuff+0x9) + cli_readint32(epbuff+0x14) == 0xae)\n\t\tecx = cli_readint32(epbuff+0xe);\n\t}\n\n\tif (ecx > 0x800 && ecx < 0x2000 &&\n\t    !memcmp(epbuff+0x63+offset, \"\\xaa\\xe2\\xcc\", 3) &&\n\t    (fsize >= exe_sections[nsections-1].raw + 0xC6 + ecx + offset)) {\n\n\t    char *spinned;\n\n\t    if((spinned = (char *) cli_malloc(fsize)) == NULL) {\n            cli_errmsg(\"yC: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t      free(exe_sections);\n\t      return CL_EMEM;\n\t    }\n\n\t    if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t      cli_dbgmsg(\"yC: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t      free(spinned);\n\t      free(exe_sections);\n\t      return CL_EREAD;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"yC\");\n#endif\n\n\t    cli_dbgmsg(\"%d,%d,%d,%d\\n\", nsections-1, e_lfanew, ecx, offset);\n\t    CLI_UNPTEMP(\"yC\",(spinned,exe_sections,0));\n\t    CLI_UNPRESULTS(\"yC\",(yc_decrypt(spinned, fsize, exe_sections, nsections-1, e_lfanew, ndesc, ecx, offset)),0,(spinned,0));\n\t}\n    }\n\n    /* WWPack */\n\n    while ((DCONF & PE_CONF_WWPACK) && nsections > 1 &&\n       vep == exe_sections[nsections - 1].rva &&\n       memcmp(epbuff, \"\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb\", 7) == 0 &&\n       memcmp(epbuff+0x68, \"\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50\", 19) == 0)  {\n\tuint32_t head = exe_sections[nsections - 1].raw;\n        uint8_t *packer;\n\tchar *src;\n\n\tssize = 0;\n\tfor(i=0 ; ; i++) {\n\t    if(exe_sections[i].raw<head)\n\t        head=exe_sections[i].raw;\n\t    if(i+1==nsections) break;\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\t}\n\tif(!head || !ssize || head>ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"WWPack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif((size_t) fmap_readn(map, src, 0, head) != head) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from headers\\n\", head);\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections-1; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i+1!=nsections) {\n            cli_dbgmsg(\"WWpack: Probably hacked/damaged file.\\n\");\n            free(src);\n            break;\n        }\n\tif((packer = (uint8_t *) cli_calloc(exe_sections[nsections - 1].rsz, sizeof(char))) == NULL) {\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif(!exe_sections[nsections - 1].rsz || (size_t) fmap_readn(map, packer, exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz) != exe_sections[nsections - 1].rsz) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from wwpack sect\\n\", exe_sections[nsections - 1].rsz);\n\t    free(src);\n\t    free(packer);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"WWPack\");\n#endif\n\n\tCLI_UNPTEMP(\"WWPack\",(src,packer,exe_sections,0));\n\tCLI_UNPRESULTS(\"WWPack\",(wwunpack((uint8_t *)src, ssize, packer, exe_sections, nsections-1, e_lfanew, ndesc)),0,(src,packer,0));\n\tbreak;\n    }\n\n\n    /* ASPACK support */\n    while((DCONF & PE_CONF_ASPACK) && ep+58+0x70e < fsize && !memcmp(epbuff,\"\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb\",8)) {\n\tchar *src;\n\n        if(epsize<0x3bf || memcmp(epbuff+0x3b9, \"\\x68\\x00\\x00\\x00\\x00\\xc3\",6)) break;\n\tssize = 0;\n\tfor(i=0 ; i< nsections ; i++)\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\tif(!ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"Aspack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i!=nsections) {\n            cli_dbgmsg(\"Aspack: Probably hacked/damaged Aspack file.\\n\");\n            free(src);\n            break;\n        }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Aspack\");\n#endif\n\n\tCLI_UNPTEMP(\"Aspack\",(src,exe_sections,0));\n\tCLI_UNPRESULTS(\"Aspack\",(unaspack212((uint8_t *)src, ssize, exe_sections, nsections, vep-1, EC32(optional_hdr32.ImageBase), ndesc)),1,(src,0));\n\tbreak;\n    }\n\n    /* NsPack */\n\n    while (DCONF & PE_CONF_NSPACK) {\n\tuint32_t eprva = vep;\n\tuint32_t start_of_stuff, rep = ep;\n\tunsigned int nowinldr;\n\tconst char *nbuff;\n\n\tsrc=epbuff;\n\tif (*epbuff=='\\xe9') { /* bitched headers */\n\t    eprva = cli_readint32(epbuff+1)+vep+5;\n\t    if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) break;\n\t    if (!(nbuff = fmap_need_off_once(map, rep, 24))) break;\n\t    src = nbuff;\n\t}\n\n\tif (memcmp(src, \"\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00\", 13)) break;\n\n\tnowinldr = 0x54-cli_readint32(src+17);\n\tcli_dbgmsg(\"NsPack: Found *start_of_stuff @delta-%x\\n\", nowinldr);\n\n\tif(!(nbuff = fmap_need_off_once(map, rep-nowinldr, 4))) break;\n\tstart_of_stuff=rep+cli_readint32(nbuff);\n\tif(!(nbuff = fmap_need_off_once(map, start_of_stuff, 20))) break;\n\tsrc = nbuff;\n\tif (!cli_readint32(nbuff)) {\n\t    start_of_stuff+=4; /* FIXME: more to do */\n\t    src+=4;\n\t}\n\n\tssize = cli_readint32(src+5)|0xff;\n\tdsize = cli_readint32(src+9);\n\n\tCLI_UNPSIZELIMITS(\"NsPack\", MAX(ssize,dsize));\n\n\tif (!ssize || !dsize || dsize != exe_sections[0].vsz) break;\n\tif (!(dest=cli_malloc(dsize))) {\n        cli_errmsg(\"NsPack: Unable to allocate memory for dest %u\\n\", dsize);\n        break;\n    }\n\t/* memset(dest, 0xfc, dsize); */\n\n\tif(!(src = fmap_need_off(map, start_of_stuff, ssize))) {\n\t    free(dest);\n\t    break;\n\t}\n\t/* memset(src, 0x00, ssize); */\n\n\teprva+=0x27a;\n\tif (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\t  free(dest);\n\t  break;\n\t}\n\tif(!(nbuff = fmap_need_off_once(map, rep, 5))) {\n\t  free(dest);\n\t  break;\n\t}\n\tfmap_unneed_off(map, start_of_stuff, ssize);\n\teprva=eprva+5+cli_readint32(nbuff+1);\n\tcli_dbgmsg(\"NsPack: OEP = %08x\\n\", eprva);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"NsPack\");\n#endif\n\n\tCLI_UNPTEMP(\"NsPack\",(dest,exe_sections,0));\n\tCLI_UNPRESULTS(\"NsPack\",(unspack(src, dest, ctx, exe_sections[0].rva, EC32(optional_hdr32.ImageBase), eprva, ndesc)),0,(dest,0));\n\tbreak;\n    }\n\n    /* to be continued ... */\n\n\n\n\n    /* !!!!!!!!!!!!!!    PACKERS END HERE    !!!!!!!!!!!!!! */\n    ctx->corrupted_input = corrupted_cur;\n\n    /* Bytecode BC_PE_UNPACKER hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_UNPACKER, map);\n    switch (ret) {\n\tcase CL_VIRUS:\n\t    free(exe_sections);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    return CL_VIRUS;\n\tcase CL_SUCCESS:\n\t    ndesc = cli_bytecode_context_getresult_file(bc_ctx, &tempfile);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    if (ndesc != -1 && tempfile) {\n\t\tCLI_UNPRESULTS(\"bytecode PE hook\", 1, 1, (0));\n\t    }\n\t    break;\n\tdefault:\n\t    cli_bytecode_context_destroy(bc_ctx);\n    }\n\n    free(exe_sections);\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n    if (SCAN_ALL && viruses_found)\n\treturn CL_VIRUS;\n    return CL_CLEAN;",
    "label": "True",
    "variable_definitions": {
      "j": "uint32_t valign, falign, hdr_size, j;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 740,
    "line_new": 740,
    "critical_vars": [
      "upx_success"
    ],
    "function": "cli_scanpe",
    "filename": "clamav/CVE-2014-9050/CVE-2014-9050_CWE-119_fc3794a54d2affe5770c1f876484a871c783e91e_pe.c.diff",
    "function_code": "\nint cli_scanpe(cli_ctx *ctx)\n{\n\tuint16_t e_magic; /* DOS signature (\"MZ\") */\n\tuint16_t nsections;\n\tuint32_t e_lfanew; /* address of new exe header */\n\tuint32_t ep, vep; /* entry point (raw, virtual) */\n\tuint8_t polipos = 0;\n\ttime_t timestamp;\n\tstruct pe_image_file_hdr file_hdr;\n\tunion {\n\t    struct pe_image_optional_hdr64 opt64;\n\t    struct pe_image_optional_hdr32 opt32;\n\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\tstruct cli_pe_hook_data pedata;\n#ifdef HAVE__INTERNAL__SHA_COLLECT\n\tint sha_collect = ctx->sha_collect;\n#endif\n    const char *archtype=NULL, *subsystem=NULL;\n\tuint32_t viruses_found = 0;\n#if HAVE_JSON\n        int toval = 0;\n        struct json_object *pe_json=NULL;\n        char jsonbuf[128];\n#endif\n\n    if(!ctx) {\n\tcli_errmsg(\"cli_scanpe: ctx == NULL\\n\");\n\treturn CL_ENULLARG;\n    }\n\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        pe_json = get_pe_property(ctx);\n    }\n#endif\n    map = *ctx->fmap;\n    if(fmap_readn(map, &e_magic, 0, sizeof(e_magic)) != sizeof(e_magic)) {\n\tcli_dbgmsg(\"Can't read DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE && EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE_OLD) {\n\tcli_dbgmsg(\"Invalid DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &e_lfanew, 58 + sizeof(e_magic), sizeof(e_lfanew)) != sizeof(e_lfanew)) {\n\tcli_dbgmsg(\"Can't read new header address\\n\");\n\t/* truncated header? */\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    e_lfanew = EC32(e_lfanew);\n    cli_dbgmsg(\"e_lfanew == %d\\n\", e_lfanew);\n    if(!e_lfanew) {\n\tcli_dbgmsg(\"Not a PE file\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &file_hdr, e_lfanew, sizeof(struct pe_image_file_hdr)) != sizeof(struct pe_image_file_hdr)) {\n\t/* bad information in e_lfanew - probably not a PE file */\n\tcli_dbgmsg(\"Can't read file header\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC32(file_hdr.Magic) != PE_IMAGE_NT_SIGNATURE) {\n\tcli_dbgmsg(\"Invalid PE signature (probably NE file)\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(file_hdr.Characteristics) & 0x2000) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"DLL\");\n#endif\n\tcli_dbgmsg(\"File type: DLL\\n\");\n\tdll = 1;\n    } else if(EC16(file_hdr.Characteristics) & 0x01) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"EXE\");\n#endif\n\tcli_dbgmsg(\"File type: Executable\\n\");\n    }\n\n    switch(EC16(file_hdr.Machine)) {\n\tcase 0x0:\n        archtype = \"Unknown\";\n\t    break;\n\tcase 0x14c:\n        archtype = \"80386\";\n\t    break;\n\tcase 0x14d:\n        archtype = \"80486\";\n\t    break;\n\tcase 0x14e:\n        archtype = \"80586\";\n\t    break;\n\tcase 0x160:\n        archtype = \"R30000 (big-endian)\";\n\t    break;\n\tcase 0x162:\n        archtype = \"R3000\";\n\t    break;\n\tcase 0x166:\n        archtype = \"R4000\";\n\t    break;\n\tcase 0x168:\n        archtype = \"R10000\";\n\t    break;\n\tcase 0x184:\n        archtype = \"DEC Alpha AXP\";\n\t    break;\n\tcase 0x284:\n        archtype = \"DEC Alpha AXP 64bit\";\n\t    break;\n\tcase 0x1f0:\n        archtype = \"PowerPC\";\n\t    break;\n\tcase 0x200:\n        archtype = \"IA64\";\n\t    break;\n\tcase 0x268:\n        archtype = \"M68k\";\n\t    break;\n\tcase 0x266:\n        archtype = \"MIPS16\";\n\t    break;\n\tcase 0x366:\n        archtype = \"MIPS+FPU\";\n\t    break;\n\tcase 0x466:\n        archtype = \"MIPS16+FPU\";\n\t    break;\n\tcase 0x1a2:\n        archtype = \"Hitachi SH3\";\n\t    break;\n\tcase 0x1a3:\n        archtype = \"Hitachi SH3-DSP\";\n\t    break;\n\tcase 0x1a4:\n        archtype = \"Hitachi SH3-E\";\n\t    break;\n\tcase 0x1a6:\n        archtype = \"Hitachi SH4\";\n\t    break;\n\tcase 0x1a8:\n        archtype = \"Hitachi SH5\";\n\t    break;\n\tcase 0x1c0:\n        archtype = \"ARM\";\n\t    break;\n\tcase 0x1c2:\n        archtype = \"THUMB\";\n\t    break;\n\tcase 0x1d3:\n        archtype = \"AM33\";\n\t    break;\n\tcase 0x520:\n        archtype = \"Infineon TriCore\";\n\t    break;\n\tcase 0xcef:\n        archtype = \"CEF\";\n\t    break;\n\tcase 0xebc:\n        archtype = \"EFI Byte Code\";\n\t    break;\n\tcase 0x9041:\n        archtype = \"M32R\";\n\t    break;\n\tcase 0xc0ee:\n        archtype = \"CEEE\";\n\t    break;\n\tcase 0x8664:\n        archtype = \"AMD64\";\n\t    break;\n\tdefault:\n        archtype = \"Unknown\";\n    }\n\n    if ((archtype)) {\n        cli_dbgmsg(\"Machine type: %s\\n\", archtype);\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"ArchType\", archtype);\n#endif\n    }\n\n    nsections = EC16(file_hdr.NumberOfSections);\n    if(nsections < 1 || nsections > 96) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadNumberOfSections\");\n#endif\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\tif(!ctx->corrupted_input) {\n\t    if(nsections)\n\t\tcli_warnmsg(\"PE file contains %d sections\\n\", nsections);\n\t    else\n\t\tcli_warnmsg(\"PE file contains no sections\\n\");\n\t}\n\treturn CL_CLEAN;\n    }\n    cli_dbgmsg(\"NumberOfSections: %d\\n\", nsections);\n\n    timestamp = (time_t) EC32(file_hdr.TimeDateStamp);\n    cli_dbgmsg(\"TimeDateStamp: %s\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"TimeDateStamp\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n#endif\n\n    cli_dbgmsg(\"SizeOfOptionalHeader: %x\\n\", EC16(file_hdr.SizeOfOptionalHeader));\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"SizeOfOptionalHeader\", EC16(file_hdr.SizeOfOptionalHeader));\n#endif\n\n    if (EC16(file_hdr.SizeOfOptionalHeader) < sizeof(struct pe_image_optional_hdr32)) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSize\");\n#endif\n        cli_dbgmsg(\"SizeOfOptionalHeader too small\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    at = e_lfanew + sizeof(struct pe_image_file_hdr);\n    if(fmap_readn(map, &optional_hdr32, at, sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr32)) {\n        cli_dbgmsg(\"Can't read optional file header\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_optional_hdr32);\n\n    /* This will be a chicken and egg problem until we drop 9x */\n    if(EC16(optional_hdr64.Magic)==PE32P_SIGNATURE) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSizePE32Plus\");\n#endif\n        if(EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr64)) {\n\t    /* FIXME: need to play around a bit more with xp64 */\n\t    cli_dbgmsg(\"Incorrect SizeOfOptionalHeader for PE32+\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tpe_plus = 1;\n    }\n\n    if(!pe_plus) { /* PE */\n\tif (EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr32)) {\n\t    /* Seek to the end of the long header */\n\t    at += EC16(file_hdr.SizeOfOptionalHeader)-sizeof(struct pe_image_optional_hdr32);\n\t}\n\n\tif(DCONF & PE_CONF_UPACK)\n\t    upack = (EC16(file_hdr.SizeOfOptionalHeader)==0x148);\n\n\tvep = EC32(optional_hdr32.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr32.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr32.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr32.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr32.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr32.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr32.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr32.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr32.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n\tdirs = optional_hdr32.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr32.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr32.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr32.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr32.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr32.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr32.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr32.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n\n    } else { /* PE+ */\n        /* read the remaining part of the header */\n        if(fmap_readn(map, &optional_hdr32 + 1, at, sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) {\n\t    cli_dbgmsg(\"Can't read optional file header\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tat += sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32);\n\tvep = EC32(optional_hdr64.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr64.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE32+\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr64.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr64.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr64.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr64.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr64.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr64.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr64.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n\tdirs = optional_hdr64.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr64.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr64.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr64.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr64.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr64.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr64.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr64.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n    }\n\n#if HAVE_JSON\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", vep);\n        cli_jsonstr(pe_json, \"EntryPoint\", jsonbuf);\n    }\n#endif\n\n\n    switch(pe_plus ? EC16(optional_hdr64.Subsystem) : EC16(optional_hdr32.Subsystem)) {\n\tcase 0:\n        subsystem = \"Unknown\";\n\t    break;\n\tcase 1:\n        subsystem = \"Native (svc)\";\n\t    native = 1;\n\t    break;\n\tcase 2:\n        subsystem = \"Win32 GUI\";\n\t    break;\n\tcase 3:\n        subsystem = \"Win32 console\";\n\t    break;\n\tcase 5:\n        subsystem = \"OS/2 console\";\n\t    break;\n\tcase 7:\n        subsystem = \"POSIX console\";\n\t    break;\n\tcase 8:\n        subsystem = \"Native Win9x driver\";\n\t    break;\n\tcase 9:\n        subsystem = \"WinCE GUI\";\n\t    break;\n\tcase 10:\n        subsystem = \"EFI application\";\n\t    break;\n\tcase 11:\n        subsystem = \"EFI driver\";\n\t    break;\n\tcase 12:\n        subsystem = \"EFI runtime driver\";\n\t    break;\n\tcase 13:\n        subsystem = \"EFI ROM image\";\n\t    break;\n\tcase 14:\n        subsystem = \"Xbox\";\n\t    break;\n\tcase 16:\n        subsystem = \"Boot application\";\n\t    break;\n\tdefault:\n        subsystem = \"Unknown\";\n    }\n\n    cli_dbgmsg(\"Subsystem: %s\\n\", subsystem);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Subsystem\", subsystem);\n#endif\n\n    cli_dbgmsg(\"------------------------------------\\n\");\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment)) || (pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment))%0x1000)) {\n        cli_dbgmsg(\"Bad virtual alignemnt\\n\");\n\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment)) || (pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment))%0x200)) {\n        cli_dbgmsg(\"Bad file alignemnt\\n\");\n\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    fsize = map->len;\n\n    section_hdr = (struct pe_image_section_hdr *) cli_calloc(nsections, sizeof(struct pe_image_section_hdr));\n\n    if(!section_hdr) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\treturn CL_EMEM;\n    }\n\n    exe_sections = (struct cli_exe_section *) cli_calloc(nsections, sizeof(struct cli_exe_section));\n    \n    if(!exe_sections) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\tfree(section_hdr);\n\treturn CL_EMEM;\n    }\n\n    valign = (pe_plus)?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment);\n    falign = (pe_plus)?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment);\n\n    if(fmap_readn(map, section_hdr, at, sizeof(struct pe_image_section_hdr)*nsections) != (int)(nsections*sizeof(struct pe_image_section_hdr))) {\n        cli_dbgmsg(\"Can't read section header\\n\");\n\tcli_dbgmsg(\"Possibly broken PE file\\n\");\n\tfree(section_hdr);\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_section_hdr)*nsections;\n\n    for(i = 0; falign!=0x200 && i<nsections; i++) {\n\t/* file alignment fallback mode - blah */\n\tif (falign && section_hdr[i].SizeOfRawData && EC32(section_hdr[i].PointerToRawData)%falign && !(EC32(section_hdr[i].PointerToRawData)%0x200)) {\n\t    cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");\n\t    falign = 0x200;\n\t}\n    }\n\n    hdr_size = PESALIGN(hdr_size, valign); /* Aligned headers virtual size */\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    while (rescan==1) {\n        rescan=0;\n        for (i=0; i < nsections; i++) {\n            exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n            exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n            exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n            exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n            exe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n            exe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */\n            exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n            exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n            exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n            if (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n                if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)\n                    || exe_sections[i].raw >= fsize) {\n                    cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n                    if (nsections == 1) {\n                        free(section_hdr);\n                        free(exe_sections);\n\n                        if(DETECT_BROKEN_PE) {\n                            cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n                            return CL_VIRUS;\n                        }\n\n                        return CL_CLEAN; /* no ninjas to see here! move along! */\n                    }\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));\n\n                    nsections--;\n                    rescan=1;\n                    break;\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < nsections; i++) {\n        strncpy(sname, (char *) section_hdr[i].Name, 8);\n        sname[8] = 0;\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n            free(section_hdr);\n            free(exe_sections);\n            return CL_ETIMEOUT;\n        }\n#endif\n\n\tif (!exe_sections[i].vsz && exe_sections[i].rsz)\n\t    exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);\n\n\tif (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))\n\t    exe_sections[i].rsz = fsize - exe_sections[i].raw;\n\t\n\tcli_dbgmsg(\"Section %d\\n\", i);\n\tcli_dbgmsg(\"Section name: %s\\n\", sname);\n\tcli_dbgmsg(\"Section data (from headers - in memory)\\n\");\n\tcli_dbgmsg(\"VirtualSize: 0x%x 0x%x\\n\", exe_sections[i].uvsz, exe_sections[i].vsz);\n\tcli_dbgmsg(\"VirtualAddress: 0x%x 0x%x\\n\", exe_sections[i].urva, exe_sections[i].rva);\n\tcli_dbgmsg(\"SizeOfRawData: 0x%x 0x%x\\n\", exe_sections[i].ursz, exe_sections[i].rsz);\n\tcli_dbgmsg(\"PointerToRawData: 0x%x 0x%x\\n\", exe_sections[i].uraw, exe_sections[i].raw);\n\n\tif(exe_sections[i].chr & 0x20) {\n\t    cli_dbgmsg(\"Section contains executable code\\n\");\n\n\t    if(exe_sections[i].vsz < exe_sections[i].rsz) {\n\t\tcli_dbgmsg(\"Section contains free space\\n\");\n\t\t/*\n\t\tcli_dbgmsg(\"Dumping %d bytes\\n\", section_hdr.SizeOfRawData - section_hdr.VirtualSize);\n\t\tddump(desc, section_hdr.PointerToRawData + section_hdr.VirtualSize, section_hdr.SizeOfRawData - section_hdr.VirtualSize, cli_gentemp(NULL));\n\t\t*/\n\n\t    }\n\t}\n\n\tif(exe_sections[i].chr & 0x20000000)\n\t    cli_dbgmsg(\"Section's memory is executable\\n\");\n\n\tif(exe_sections[i].chr & 0x80000000)\n\t    cli_dbgmsg(\"Section's memory is writeable\\n\");\n\n\tif (DETECT_BROKEN_PE && (!valign || (exe_sections[i].urva % valign))) { /* Bad virtual alignment */\n\t    cli_dbgmsg(\"VirtualAddress is misaligned\\n\");\n\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    /* check hash section sigs */\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);\n\t        if (ret != CL_CLEAN) {\n\t            if (ret != CL_VIRUS)\n\t                cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));\n\t\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t            free(section_hdr);\n\t            free(exe_sections);\n\t            return ret;\n\t        }\n\t    }\n\t}\n\tcli_dbgmsg(\"------------------------------------\\n\");\n\n\tif (exe_sections[i].urva>>31 || exe_sections[i].uvsz>>31 || (exe_sections[i].rsz && exe_sections[i].uraw>>31) || exe_sections[i].ursz>>31) {\n\t    cli_dbgmsg(\"Found PE values with sign bit set\\n\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\n\tif(!i) {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva!=hdr_size) { /* Bad first section RVA */\n\t        cli_dbgmsg(\"First section is in the wrong place\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    min = exe_sections[i].rva;\n\t    max = exe_sections[i].rva + exe_sections[i].rsz;\n\t} else {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva - exe_sections[i-1].urva != exe_sections[i-1].vsz) { /* No holes, no overlapping, no virtual disorder */\n\t        cli_dbgmsg(\"Virtually misplaced section (wrong order, overlapping, non contiguous)\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    if(exe_sections[i].rva < min)\n\t        min = exe_sections[i].rva;\n\n\t    if(exe_sections[i].rva + exe_sections[i].rsz > max) {\n\t        max = exe_sections[i].rva + exe_sections[i].rsz;\n\t\toverlays = exe_sections[i].raw + exe_sections[i].rsz;\n\t    }\n\t}\n    }\n\n    free(section_hdr);\n\n    if(!(ep = cli_rawaddr(vep, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\tcli_dbgmsg(\"EntryPoint out of file\\n\");\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"EntryPointOffset\", ep);\n\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n\n    cli_dbgmsg(\"EntryPoint offset: 0x%x (%d)\\n\", ep, ep);\n\n    if(pe_plus) { /* Do not continue for PE32+ files */\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    epsize = fmap_readn(map, epbuff, ep, 4096);\n\n\n    /* Disasm scan disabled since it's now handled by the bytecode */\n\n    /* CLI_UNPTEMP(\"DISASM\",(exe_sections,0)); */\n    /* if(disasmbuf((unsigned char*)epbuff, epsize, ndesc)) */\n    /* \tret = cli_scandesc(ndesc, ctx, CL_TYPE_PE_DISASM, 1, NULL, AC_SCAN_VIR); */\n    /* close(ndesc); */\n    /* CLI_TMPUNLK(); */\n    /* free(tempfile); */\n    /* if(ret == CL_VIRUS) { */\n    /* \tfree(exe_sections); */\n    /* \treturn ret; */\n    /* } */\n\n    if(overlays) {\n\tint overlays_sz = fsize - overlays;\n\tif(overlays_sz > 0) {\n\t    ret = cli_scanishield(ctx, overlays, overlays_sz);\n\t    if(ret != CL_CLEAN) {\n\t\tfree(exe_sections);\n\t\treturn ret;\n\t    }\n\t}\n    }\n\n    pedata.nsections = nsections;\n    pedata.ep = ep;\n    pedata.offset = 0;\n    memcpy(&pedata.file_hdr, &file_hdr, sizeof(file_hdr));\n    memcpy(&pedata.opt32, &pe_opt.opt32, sizeof(pe_opt.opt32));\n    memcpy(&pedata.opt64, &pe_opt.opt64, sizeof(pe_opt.opt64));\n    memcpy(&pedata.dirs, dirs, sizeof(pedata.dirs));\n    pedata.e_lfanew = e_lfanew;\n    pedata.overlays = overlays;\n    pedata.overlays_sz = fsize - overlays;\n    pedata.hdr_size = hdr_size;\n\n    /* Bytecode BC_PE_ALL hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\tfree(exe_sections);\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_ALL, map);\n    switch (ret) {\n        case CL_ENULLARG:\n            cli_warnmsg(\"cli_scanpe: NULL argument supplied\\n\");\n            break;\n        case CL_VIRUS:\n        case CL_BREAK:\n            free(exe_sections);\n            cli_bytecode_context_destroy(bc_ctx);\n            return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN;\n    }\n    cli_bytecode_context_destroy(bc_ctx);\n    /* Attempt to detect some popular polymorphic viruses */\n\n    /* W32.Parite.B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_PARITE) && !dll && epsize == 4096 && ep == exe_sections[nsections - 1].raw) {\n        const char *pt = cli_memstr(epbuff, 4040, \"\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00\", 15);\n\tif(pt) {\n\t    pt += 15;\n\t    if((((uint32_t)cli_readint32(pt) ^ (uint32_t)cli_readint32(pt + 4)) == 0x505a4f) && (((uint32_t)cli_readint32(pt + 8) ^ (uint32_t)cli_readint32(pt + 12)) == 0xffffb) && (((uint32_t)cli_readint32(pt + 16) ^ (uint32_t)cli_readint32(pt + 20)) == 0xb8)) {\n\t        cli_append_virus(ctx,\"Heuristics.W32.Parite.B\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n    }\n\n    /* Kriz */\n    if(SCAN_ALGO && (DCONF & PE_CONF_KRIZ) && epsize >= 200 && CLI_ISCONTAINED(exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz, ep, 0x0fd2) && epbuff[1]=='\\x9c' && epbuff[2]=='\\x60') {\n\tenum {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSXORPRFX,KZSXOR,KZSDDELTA,KZSLOOP,KZSTOP};\n\tuint8_t kzs[] = {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSTRASH,KZSXORPRFX,KZSXOR,KZSTRASH,KZSDDELTA,KZSTRASH,KZSLOOP,KZSTOP};\n\tuint8_t *kzstate = kzs;\n\tuint8_t *kzcode = (uint8_t *)epbuff + 3;\n\tuint8_t kzdptr=0xff, kzdsize=0xff;\n\tint kzlen = 197, kzinitlen=0xffff, kzxorlen=-1;\n\tcli_dbgmsg(\"in kriz\\n\");\n\n\twhile(*kzstate!=KZSTOP) {\n\t    uint8_t op;\n\t    if(kzlen<=6) break;\n\t    op = *kzcode++;\n\t    kzlen--;\n\t    switch (*kzstate) {\n\t    case KZSTRASH: case KZSGETSIZE: {\n\t\tint opsz=0;\n\t\tswitch(op) {\n\t\tcase 0x81:\n\t\t    kzcode+=5;\n\t\t    kzlen-=5;\n\t\t    break;\n\t\tcase 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbd: case 0xbe: case 0xbf:\n\t\t    if(*kzstate==KZSGETSIZE && cli_readint32(kzcode)==0x0fd2) {\n\t\t\tkzinitlen = kzlen-5;\n\t\t\tkzdsize=op-0xb8;\n\t\t\tkzstate++;\n\t\t\top=4; /* fake the register to avoid breaking out */\n\t\t\tcli_dbgmsg(\"kriz: using #%d as size counter\\n\", kzdsize);\n\t\t    }\n\t\t    opsz=4;\n\t\tcase 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4d: case 0x4e: case 0x4f:\n\t\t    op&=7;\n\t\t    if(op!=kzdptr && op!=kzdsize) {\n\t\t\tkzcode+=opsz;\n\t\t\tkzlen-=opsz;\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t    kzcode--;\n\t\t    kzlen++;\n\t\t    kzstate++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    case KZSCDELTA:\n\t\tif(op==0xe8 && (uint32_t)cli_readint32(kzcode) < 0xff) {\n\t\t    kzlen-=*kzcode+4;\n\t\t    kzcode+=*kzcode+4;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSPDELTA:\n\t\tif((op&0xf8)==0x58 && (kzdptr=op-0x58)!=4) {\n\t\t    kzstate++;\n\t\t    cli_dbgmsg(\"kriz: using #%d as pointer\\n\", kzdptr);\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSXORPRFX:\n\t\tkzstate++;\n\t\tif(op==0x3e) break;\n\t    case KZSXOR:\n\t\tif (op==0x80 && *kzcode==kzdptr+0xb0) {\n\t\t    kzxorlen=kzlen;\n\t\t    kzcode+=+6;\n\t\t    kzlen-=+6;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSDDELTA:\n\t\tif (op==kzdptr+0x48) kzstate++;\n\t\telse *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSLOOP:\n\t\tif (op==kzdsize+0x48 && *kzcode==0x75 && kzlen-(int8_t)kzcode[1]-3<=kzinitlen && kzlen-(int8_t)kzcode[1]>=kzxorlen) {\n\t\t    cli_append_virus(ctx,\"Heuristics.W32.Kriz\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t\tcli_dbgmsg(\"kriz: loop out of bounds, corrupted sample?\\n\");\n\t\tkzstate++;\n\t    }\n\t}\n    }\n\n    /* W32.Magistr.A/B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_MAGISTR) && !dll && (nsections>1) && (exe_sections[nsections - 1].chr & 0x80000000)) {\n        uint32_t rsize, vsize, dam = 0;\n\n\tvsize = exe_sections[nsections - 1].uvsz;\n\trsize = exe_sections[nsections - 1].rsz;\n\tif(rsize < exe_sections[nsections - 1].ursz) {\n\t    rsize = exe_sections[nsections - 1].ursz;\n\t    dam = 1;\n\t}\n\n\tif(vsize >= 0x612c && rsize >= 0x612c && ((vsize & 0xff) == 0xec)) {\n\t\tint bw = rsize < 0x7000 ? rsize : 0x7000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x2c\\x61\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx, dam ? \"Heuristics.W32.Magistr.A.dam\" : \"Heuristics.W32.Magistr.A\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t    }\n\n\t} else if(rsize >= 0x7000 && vsize >= 0x7000 && ((vsize & 0xff) == 0xed)) {\n\t\tint bw = rsize < 0x8000 ? rsize : 0x8000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x04\\x72\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx,dam ? \"Heuristics.W32.Magistr.B.dam\" : \"Heuristics.W32.Magistr.B\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t} \n\t    }\n\t}\n    }\n\n    /* W32.Polipos.A */\n    while(polipos && !dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && (EC16(optional_hdr32.Subsystem) == 2 || EC16(optional_hdr32.Subsystem) == 3) && EC16(file_hdr.Machine) == 0x14c && optional_hdr32.SizeOfStackReserve >= 0x80000) {\n\tuint32_t jump, jold, *jumps = NULL;\n\tconst uint8_t *code;\n\tunsigned int xsjs = 0;\n\n\tif(exe_sections[0].rsz > CLI_MAX_ALLOCATION) break;\n\n\tif(!exe_sections[0].rsz) break;\n\tif(!(code=fmap_need_off_once(map, exe_sections[0].raw, exe_sections[0].rsz))) break;\n\tfor(i=0; i<exe_sections[0].rsz - 5; i++) {\n\t    if((uint8_t)(code[i]-0xe8) > 1) continue;\n\t    jump = cli_rawaddr(exe_sections[0].rva+i+5+cli_readint32(&code[i+1]), exe_sections, nsections, &err, fsize, hdr_size);\n\t    if(err || !CLI_ISCONTAINED(exe_sections[polipos].raw, exe_sections[polipos].rsz, jump, 9)) continue;\n\t    if(xsjs % 128 == 0) {\n\t\tif(xsjs == 1280) break;\n\t\tif(!(jumps=(uint32_t *)cli_realloc2(jumps, (xsjs+128)*sizeof(uint32_t)))) {\n\t\t    free(exe_sections);\n\t\t    return CL_EMEM;\n\t\t}\n\t    }\n\t    j=0;\n\t    for(; j<xsjs; j++) {\n\t\tif(jumps[j]<jump) continue;\n\t\tif(jumps[j]==jump) {\n\t\t    xsjs--;\n\t\t    break;\n\t\t}\n\t\tjold=jumps[j];\n\t\tjumps[j]=jump;\n\t\tjump=jold;\n\t    }\n\t    jumps[j]=jump;\n\t    xsjs++;\n\t}\n\tif(!xsjs) break;\n\tcli_dbgmsg(\"Polipos: Checking %d xsect jump(s)\\n\", xsjs);\n\tfor(i=0;i<xsjs;i++) {\n\t    if(!(code = fmap_need_off_once(map, jumps[i], 9))) continue;\n\t    if((jump=cli_readint32(code))==0x60ec8b55 || (code[4]==0x0ec && ((jump==0x83ec8b55 && code[6]==0x60) || (jump==0x81ec8b55 && !code[7] && !code[8])))) {\n\t\tcli_append_virus(ctx,\"Heuristics.W32.Polipos.A\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(jumps);\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n\tfree(jumps);\n\tbreak;\n    }\n\n    /* Trojan.Swizzor.Gen */\n    if (SCAN_ALGO && (DCONF & PE_CONF_SWIZZOR) && nsections > 1 && fsize > 64*1024 && fsize < 4*1024*1024) {\n\t    if(dirs[2].Size) {\n\t\t    struct swizz_stats *stats = cli_calloc(1, sizeof(*stats));\n\t\t    unsigned int m = 1000;\n\t\t    ret = CL_CLEAN;\n\n\t\t    if (!stats)\n\t\t\t    ret = CL_EMEM;\n\t\t    else {\n\t\t\t    cli_parseres_special(EC32(dirs[2].VirtualAddress), EC32(dirs[2].VirtualAddress), map, exe_sections, nsections, fsize, hdr_size, 0, 0, &m, stats);\n\t\t\t    if ((ret = cli_detect_swizz(stats)) == CL_VIRUS) {\n\t\t\t\tcli_append_virus(ctx,\"Heuristics.Trojan.Swizzor.Gen\");\n\t\t\t    }\n\t\t\t    free(stats);\n\t\t    }\n\t\t    if (ret != CL_CLEAN) {\n\t\t\tif (!(ret == CL_VIRUS && SCAN_ALL)) {\n\t\t\t    free(exe_sections);\n\t\t\t    return ret;\n\t\t\t}\n\t\t\tviruses_found++;\n\t\t    }\n\t    }\n    }\n\n\n    /* !!!!!!!!!!!!!!    PACKERS START HERE    !!!!!!!!!!!!!! */\n    corrupted_cur = ctx->corrupted_input;\n    ctx->corrupted_input = 2; /* caller will reset on return */\n\n\n    /* UPX, FSG, MEW support */\n\n    /* try to find the first section with physical size == 0 */\n    found = 0;\n    if(DCONF & (PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW)) {\n\tfor(i = 0; i < (unsigned int) nsections - 1; i++) {\n\t    if(!exe_sections[i].rsz && exe_sections[i].vsz && exe_sections[i + 1].rsz && exe_sections[i + 1].vsz) {\n\t\tfound = 1;\n\t\tcli_dbgmsg(\"UPX/FSG/MEW: empty section found - assuming compression\\n\");\n#if HAVE_JSON\n        cli_jsonbool(pe_json, \"HasEmptySection\", 1);\n#endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    /* MEW support */\n    if (found && (DCONF & PE_CONF_MEW) && epsize>=16 && epbuff[0]=='\\xe9') {\n\tuint32_t fileoffset;\n\tconst char *tbuff;\n\n\tfileoffset = (vep + cli_readint32(epbuff + 1) + 5);\n\twhile (fileoffset == 0x154 || fileoffset == 0x158) {\n\t    char *src;\n\t    uint32_t offdiff, uselzma;\n\n\t    cli_dbgmsg (\"MEW: found MEW characteristics %08X + %08X + 5 = %08X\\n\", \n\t\t\tcli_readint32(epbuff + 1), vep, cli_readint32(epbuff + 1) + vep + 5);\n\n\t    if(!(tbuff = fmap_need_off_once(map, fileoffset, 0xb0)))\n\t\tbreak;\n\t    if (fileoffset == 0x154) cli_dbgmsg(\"MEW: Win9x compatibility was set!\\n\");\n\t    else cli_dbgmsg(\"MEW: Win9x compatibility was NOT set!\\n\");\n\n\t    if((offdiff = cli_readint32(tbuff+1) - EC32(optional_hdr32.ImageBase)) <= exe_sections[i + 1].rva || offdiff >= exe_sections[i + 1].rva + exe_sections[i + 1].raw - 4) {\n\t        cli_dbgmsg(\"MEW: ESI is not in proper section\\n\");\n\t\tbreak;\n\t    }\n\t    offdiff -= exe_sections[i + 1].rva;\n\n\t    if(!exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: mew section is empty\\n\");\n\t\tbreak;\n\t    }\n\t    ssize = exe_sections[i + 1].vsz;\n\t    dsize = exe_sections[i].vsz;\n\n\t    cli_dbgmsg(\"MEW: ssize %08x dsize %08x offdiff: %08x\\n\", ssize, dsize, offdiff);\n\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize, dsize));\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize + dsize, exe_sections[i + 1].rsz));\n\n\t    if (exe_sections[i + 1].rsz < offdiff + 12 || exe_sections[i + 1].rsz > ssize) {\n\t        cli_dbgmsg(\"MEW: Size mismatch: %08x\\n\", exe_sections[i + 1].rsz);\n\t\tbreak;\n\t    }\n\n\t    /* allocate needed buffer */\n\t    if (!(src = cli_calloc (ssize + dsize, sizeof(char)))) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((bytes = fmap_readn(map, src + dsize, exe_sections[i + 1].raw, exe_sections[i + 1].rsz)) != exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: Can't read %d bytes [read: %lu]\\n\", exe_sections[i + 1].rsz, (unsigned long)bytes);\n\t\tfree(exe_sections);\n\t\tfree(src);\n\t\treturn CL_EREAD;\n\t    }\n\t    cli_dbgmsg(\"MEW: %u (%08x) bytes read\\n\", (unsigned int)bytes, (unsigned int)bytes);\n\n\t    /* count offset to lzma proc, if lzma used, 0xe8 -> call */\n\t    if (tbuff[0x7b] == '\\xe8') {\n\t        if (!CLI_ISCONTAINED(exe_sections[1].rva, exe_sections[1].vsz, cli_readint32(tbuff + 0x7c) + fileoffset + 0x80, 4)) {\n\t\t    cli_dbgmsg(\"MEW: lzma proc out of bounds!\\n\");\n\t\t    free(src);\n\t\t    break; /* to next unpacker in chain */\n\t\t}\n\t\tuselzma = cli_readint32(tbuff + 0x7c) - (exe_sections[0].rva - fileoffset - 0x80);\n\t    } else {\n\t        uselzma = 0;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"MEW\");\n#endif\n\n\t    CLI_UNPTEMP(\"MEW\",(src,exe_sections,0));\n\t    CLI_UNPRESULTS(\"MEW\",(unmew11(src, offdiff, ssize, dsize, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, uselzma, ndesc)),1,(src,0));\n\t    break;\n\t}\n    }\n\n    if(epsize<168) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    if (found || upack) {\n\t/* Check EP for UPX vs. FSG vs. Upack */\n\n\t/* Upack 0.39 produces 2 types of executables\n\t * 3 sections:           | 2 sections (one empty, I don't chech found if !upack, since it's in OR above):\n\t *   mov esi, value      |   pusha\n\t *   lodsd               |   call $+0x9\n\t *   push eax            |\n\t *\n\t * Upack 1.1/1.2 Beta produces [based on 2 samples (sUx) provided by aCaB]:\n\t * 2 sections\n\t *   mov esi, value\n\t *   loads\n\t *   mov edi, eax\n\t *\n\t * Upack unknown [sample 0297729]\n\t * 3 sections\n\t *   mov esi, value\n\t *   push [esi]\n\t *   jmp\n\t * \n\t */\n\t/* upack 0.39-3s + sample 0151477*/\n \twhile(((upack && nsections == 3) && /* 3 sections */\n\t    ((\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x50' /* lodsd; push eax */\n\t     )\n\t    || \n\t    /* based on 0297729 sample from aCaB */\n\t    (epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xff' && epbuff[6] == '\\x36' /* push [esi] */\n\t     )\n\t   )) \n\t   ||\n\t   ((!upack && nsections == 2) && /* 2 sections */\n\t    (( /* upack 0.39-2s */\n\t     epbuff[0] == '\\x60' && epbuff[1] == '\\xe8' && cli_readint32(epbuff+2) == 0x9 /* pusha; call+9 */\n\t     )\n\t    ||\n\t    ( /* upack 1.1/1.2, based on 2 samples */\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase) < min &&  /* mov esi */\n\t     cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > 0 &&\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x8b' && epbuff[7] == '\\xf8' /* loads;  mov edi, eax */\n\t     )\n\t   ))\n\t   ) { \n\t    uint32_t vma, off;\n\t    int a,b,c;\n\n\t    cli_dbgmsg(\"Upack characteristics found.\\n\");\n\t    a = exe_sections[0].vsz;\n\t    b = exe_sections[1].vsz;\n\t    if (upack) {\n\t        cli_dbgmsg(\"Upack: var set\\n\");\n\t\tc = exe_sections[2].vsz;\n\t\tssize = exe_sections[0].ursz + exe_sections[0].uraw;\n\t\toff = exe_sections[0].rva;\n\t\tvma = EC32(optional_hdr32.ImageBase) + exe_sections[0].rva;\n\t    } else {\n\t        cli_dbgmsg(\"Upack: var NOT set\\n\");\n\t\tc = exe_sections[1].rva;\n\t\tssize = exe_sections[1].uraw;\n\t\toff = 0;\n\t\tvma = exe_sections[1].rva - exe_sections[1].uraw;\n\t    }\n\n\t    dsize = a+b+c;\n\n\t    CLI_UNPSIZELIMITS(\"Upack\", MAX(MAX(dsize, ssize), exe_sections[1].ursz));\n\n\t    if (!CLI_ISCONTAINED(0, dsize, exe_sections[1].rva - off, exe_sections[1].ursz) || (upack && !CLI_ISCONTAINED(0, dsize, exe_sections[2].rva - exe_sections[0].rva, ssize)) || ssize > dsize) {\n\t        cli_dbgmsg(\"Upack: probably malformed pe-header, skipping to next unpacker\\n\");\n\t\tbreak;\n\t    }\n\t\t\t\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((unsigned int)fmap_readn(map, dest, 0, ssize) != ssize) {\n\t        cli_dbgmsg(\"Upack: Can't read raw data of section 0\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n\t    if(upack) memmove(dest + exe_sections[2].rva - exe_sections[0].rva, dest, ssize);\n\n\t    if((unsigned int)fmap_readn(map, dest + exe_sections[1].rva - off, exe_sections[1].uraw, exe_sections[1].ursz) != exe_sections[1].ursz) {\n\t\tcli_dbgmsg(\"Upack: Can't read raw data of section 1\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Upack\");\n#endif\n\n\t    CLI_UNPTEMP(\"Upack\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Upack\",(unupack(upack, dest, dsize, epbuff, vma, ep, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, ndesc)),1,(dest,0));\n\t    break;\n\t}\n    }\n\n    \n    while(found  && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\x87' && epbuff[1] == '\\x25') {\n\tconst char *dst;\n\n\t/* FSG v2.0 support - thanks to aCaB ! */\n\n\tuint32_t newesi, newedi, newebx, newedx;\n\t\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\t\n\tnewedx = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: xchg out of bounds (%x), giving up\\n\", newedx);\n\t    break;\n\t}\n\t\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i + 1);\n\t    free(exe_sections);\n\t    return CL_ESEEK;\n\t}\n\n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(newedx < exe_sections[i + 1].rva || !CLI_ISCONTAINED(src, ssize, dst, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP (%x) is wrong\\n\", newedx);\n\t    break;\n\t}\n \n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(!CLI_ISCONTAINED(src, ssize, dst, 32)) {\n\t    cli_dbgmsg(\"FSG: New stack out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedi = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tnewesi = cli_readint32(dst + 4) - EC32(optional_hdr32.ImageBase);\n\tnewebx = cli_readint32(dst + 16) - EC32(optional_hdr32.ImageBase);\n\tnewedx = cli_readint32(dst + 20);\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination buffer (edi is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newebx, 16)) {\n\t    cli_dbgmsg(\"FSG: Array of functions out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx=cli_readint32(newebx + 12 - exe_sections[i + 1].rva + src) - EC32(optional_hdr32.ImageBase);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\",newedx);\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,exe_sections,0));\n\tCLI_UNPRESULTSFSG2(\"FSG\",(unfsg_200(newesi - exe_sections[i + 1].rva + src, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, newedi, EC32(optional_hdr32.ImageBase), newedx, ndesc)),1,(dest,0));\n\tbreak;\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min) {\n\n\t/* FSG support - v. 1.33 (thx trog for the many samples) */\n\n\tint sectcnt = 0;\n\tconst char *support;\n\tuint32_t newesi, newedi, oldep, gp, t;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!(t = cli_rawaddr(cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size)) && err ) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp);\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* newebx = cli_readint32(support) - EC32(optional_hdr32.ImageBase);  Unused */\n\tnewedi = cli_readint32(support + 4) - EC32(optional_hdr32.ImageBase); /* 1st dest */\n\tnewesi = cli_readint32(support + 8) - EC32(optional_hdr32.ImageBase); /* Source */\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 12; t < gp - 4; t += 4) {\n\t    uint32_t rva = cli_readint32(support+t);\n\n\t    if(!rva)\n\t\tbreak;\n\n\t    rva -= EC32(optional_hdr32.ImageBase)+1;\n\t    sectcnt++;\n\n\t    if(rva % 0x1000) cli_dbgmsg(\"FSG: Original section %d is misaligned\\n\", sectcnt);\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp - 4 || cli_readint32(support + t)) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 1; t <= (uint32_t)sectcnt; t++)\n\t    sections[t].rva = cli_readint32(support + 8 + t * 4) - 1 - EC32(optional_hdr32.ImageBase);\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\toldep = vep + 161 + 6 + cli_readint32(epbuff+163);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.33 */\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbb' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min && epbuff[5] == '\\xbf' && epbuff[10] == '\\xbe' && vep >= exe_sections[i + 1].rva && vep - exe_sections[i + 1].rva > exe_sections[i + 1].rva - 0xe0 ) {\n\n\t/* FSG support - v. 1.31 */\n\n\tint sectcnt = 0;\n\tuint32_t gp, t = cli_rawaddr(cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size);\n\tconst char *support;\n\tuint32_t newesi = cli_readint32(epbuff+11) - EC32(optional_hdr32.ImageBase);\n\tuint32_t newedi = cli_readint32(epbuff+6) - EC32(optional_hdr32.ImageBase);\n\tuint32_t oldep = vep - exe_sections[i + 1].rva;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tif(err) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].raw) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp)\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 0; t < gp - 2; t += 2) {\n\t    uint32_t rva = support[t]|(support[t+1]<<8);\n\n\t    if (rva == 2 || rva == 1)\n\t\tbreak;\n\n\t    rva = ((rva-2)<<12) - EC32(optional_hdr32.ImageBase);\n\t    sectcnt++;\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp-10 || cli_readint32(support + t + 6) != 2) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 0; t <= (uint32_t)sectcnt - 1; t++) {\n\t    sections[t+1].rva = (((support[t*2]|(support[t*2+1]<<8))-2)<<12)-EC32(optional_hdr32.ImageBase);\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"FSG: Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\tgp = 0xda + 6*(epbuff[16]=='\\xe8');\n\toldep = vep + gp + 6 + cli_readint32(src+gp+2+oldep);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.31 */\n    }\n\n\n    if(found && (DCONF & PE_CONF_UPX)) {\n\n\t/* UPX support */\n\n\t/* we assume (i + 1) is UPX1 */\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz + exe_sections[i + 1].vsz;\n\n        /* cli_dbgmsg(\"UPX: ssize %u dsize %u\\n\", ssize, dsize); */\n\n\tCLI_UNPSIZELIMITS(\"UPX\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) {\n\t    cli_dbgmsg(\"UPX: Size mismatch or dsize too big (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"UPX: Can't read raw data of section %d\\n\", i+1);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize + 8192, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\t/* try to detect UPX code */\n\tif(cli_memstr(UPX_NRV2B, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2B, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2B decompression routine\\n\");\n\t    upxfn = upx_inflate2b;\n\t} else if(cli_memstr(UPX_NRV2D, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2D, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2D decompression routine\\n\");\n\t    upxfn = upx_inflate2d;\n\t} else if(cli_memstr(UPX_NRV2E, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2E, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2E decompression routine\\n\");\n\t    upxfn = upx_inflate2e;\n\t}\n\n\tif(upxfn) {\n\t    int skew = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase) - exe_sections[i + 1].rva;\n\n\t    if(epbuff[1] != '\\xbe' || skew <= 0 || skew > 0xfff) { /* FIXME: legit skews?? */\n\t\tskew = 0; \n\t    } else if ((unsigned int)skew > ssize) {\n\t\t/* Ignore suggested skew larger than section size */\n\t\tskew = 0;\n\t    } else {\n\t\tcli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);\n\t    }\n\n\t    /* Try skewed first (skew may be zero) */\n\t    if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0) {\n\t\tupx_success = 1;\n\t    }\n\t    /* If skew not successful and non-zero, try no skew */\n\t    else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {\n\t\tupx_success = 1;\n\t    }\n\n\t    if(upx_success)\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed\\n\");\n\t    else\n\t\tcli_dbgmsg(\"UPX: Preferred decompressor failed\\n\");\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2b) {\n\t    if(upx_inflate2b(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2b(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2B decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2B\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2d) {\n\t    if(upx_inflate2d(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2d(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2D decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2D\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2e) {\n\t    if(upx_inflate2e(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2e(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\t\tcli_dbgmsg(\"UPX: NRV2E decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2E\\n\");\n\t    }\n\t}\n\n\tif(cli_memstr(UPX_LZMA2, 20, epbuff + 0x2f, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x21), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t} else if (cli_memstr(UPX_LZMA1, 20, epbuff + 0x39, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x2b), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t}\n\n\tif(!upx_success) {\n\t    cli_dbgmsg(\"UPX: All decompressors failed\\n\");\n\t    free(dest);\n\t}\n    }\n\n    if(upx_success) {\n\tfree(exe_sections);\n\n\tCLI_UNPTEMP(\"UPX/FSG\",(dest,0));\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"UPX\");\n#endif\n\n\tif((unsigned int) write(ndesc, dest, dsize) != dsize) {\n\t    cli_dbgmsg(\"UPX/FSG: Can't write %d bytes\\n\", dsize);\n\t    free(tempfile);\n\t    free(dest);\n\t    close(ndesc);\n\t    return CL_EWRITE;\n\t}\n\n\tfree(dest);\n\tif (lseek(ndesc, 0, SEEK_SET) == -1) {\n        cli_dbgmsg(\"UPX/FSG: lseek() failed\\n\");\n        close(ndesc);\n        CLI_TMPUNLK();\n        free(tempfile);\n        SHA_RESET;\n        return CL_ESEEK;\n    }\n\n\tif(ctx->engine->keeptmp)\n\t    cli_dbgmsg(\"UPX/FSG: Decompressed data saved in %s\\n\", tempfile);\n\n\tcli_dbgmsg(\"***** Scanning decompressed file *****\\n\");\n\tSHA_OFF;\n\tif((ret = cli_magic_scandesc(ndesc, ctx)) == CL_VIRUS) {\n\t    close(ndesc);\n\t    CLI_TMPUNLK();\n\t    free(tempfile);\n\t    SHA_RESET;\n\t    return CL_VIRUS;\n\t}\n\n\tSHA_RESET;\n\tclose(ndesc);\n\tCLI_TMPUNLK();\n\tfree(tempfile);\n\treturn ret;\n    }\n\n\n    /* Petite */\n\n    if(epsize<200) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    found = 2;\n\n    if(epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 1].rva + EC32(optional_hdr32.ImageBase)) {\n\tif(nsections < 2 || epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 2].rva + EC32(optional_hdr32.ImageBase))\n\t    found = 0;\n\telse\n\t    found = 1;\n    }\n\n    if(found && (DCONF & PE_CONF_PETITE)) {\n\tcli_dbgmsg(\"Petite: v2.%d compression detected\\n\", found);\n\n\tif(cli_readint32(epbuff + 0x80) == 0x163c988d) {\n\t    cli_dbgmsg(\"Petite: level zero compression is not supported yet\\n\");\n\t} else {\n\t    dsize = max - min;\n\n\t    CLI_UNPSIZELIMITS(\"Petite\", dsize);\n\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t\tcli_dbgmsg(\"Petite: Can't allocate %d bytes\\n\", dsize);\n\t\tfree(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    for(i = 0 ; i < nsections; i++) {\n\t\tif(exe_sections[i].raw) {\n\t\t    if(!exe_sections[i].rsz || (unsigned int)fmap_readn(map, dest + exe_sections[i].rva - min, exe_sections[i].raw, exe_sections[i].ursz) != exe_sections[i].ursz) {\n\t\t\tfree(exe_sections);\n\t\t\tfree(dest);\n\t\t\treturn CL_CLEAN;\n\t\t    }\n\t\t}\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Petite\");\n#endif\n\n\t    CLI_UNPTEMP(\"Petite\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Petite\",(petite_inflate2x_1to9(dest, min, max - min, exe_sections, nsections - (found == 1 ? 1 : 0), EC32(optional_hdr32.ImageBase),vep, ndesc, found, EC32(optional_hdr32.DataDirectory[2].VirtualAddress),EC32(optional_hdr32.DataDirectory[2].Size))),0,(dest,0));\n\t}\n    }\n\n    /* PESpin 1.1 */\n\n    if((DCONF & PE_CONF_PESPIN) && nsections > 1 &&\n       vep >= exe_sections[nsections - 1].rva &&\n       vep < exe_sections[nsections - 1].rva + exe_sections[nsections - 1].rsz - 0x3217 - 4 &&\n       memcmp(epbuff+4, \"\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3\", 10) == 0)  {\n\n\tchar *spinned;\n\n\tCLI_UNPSIZELIMITS(\"PEspin\", fsize);\n\n\tif((spinned = (char *) cli_malloc(fsize)) == NULL) {\n        cli_errmsg(\"PESping: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tif((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t    cli_dbgmsg(\"PESpin: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t    free(spinned);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"PEspin\");\n#endif\n\n\tCLI_UNPTEMP(\"PESpin\",(spinned,exe_sections,0));\n\tCLI_UNPRESULTS_(\"PEspin\",SPINCASE(),(unspin(spinned, fsize, exe_sections, nsections - 1, vep, ndesc, ctx)),0,(spinned,0));\n    }\n\n\n    /* yC 1.3 & variants */\n    if((DCONF & PE_CONF_YC) && nsections > 1 &&\n       (EC32(optional_hdr32.AddressOfEntryPoint) == exe_sections[nsections - 1].rva + 0x60)) {\n\n\tuint32_t ecx = 0;\n\tint16_t offset;\n\n\t/* yC 1.3 */\n\tif (!memcmp(epbuff, \"\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED\", 15) &&\n\t    !memcmp(epbuff+0x26, \"\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC\", 13) &&\n\t    ((uint8_t)epbuff[0x13] == 0xB9) &&\n\t    ((uint16_t)(cli_readint16(epbuff+0x18)) == 0xE981) &&\n\t    !memcmp(epbuff+0x1e,\"\\x8B\\xD5\\x81\\xC2\", 4)) {\n\n\t    offset = 0;\n\t    if (0x6c - cli_readint32(epbuff+0xf) + cli_readint32(epbuff+0x22) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x14) - cli_readint32(epbuff+0x1a);\n\t}\n\n\t/* yC 1.3 variant */\n\tif (!ecx && !memcmp(epbuff, \"\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57\", 9) &&\n\t    !memcmp(epbuff+0x17, \"\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\", 8) &&\n\t    ((uint8_t)epbuff[0x23] == 0xB9)) {\n\n\t    offset = 0x10;\n\t    if (0x6c - cli_readint32(epbuff+0x1f) + cli_readint32(epbuff+0x32) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x24) - cli_readint32(epbuff+0x2a);\n\t}\n\n\t/* yC 1.x/modified */\n\tif (!ecx && !memcmp(epbuff, \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\",9) &&\n\t    ((uint8_t)epbuff[0xd] == 0xb9) &&\n\t    ((uint16_t)cli_readint16(epbuff + 0x12)== 0xbd8d) &&\n\t    !memcmp(epbuff+0x18, \"\\x8b\\xf7\\xac\", 3)) {\n\n\t    offset = -0x18;\n\t    if (0x66 - cli_readint32(epbuff+0x9) + cli_readint32(epbuff+0x14) == 0xae)\n\t\tecx = cli_readint32(epbuff+0xe);\n\t}\n\n\tif (ecx > 0x800 && ecx < 0x2000 &&\n\t    !memcmp(epbuff+0x63+offset, \"\\xaa\\xe2\\xcc\", 3) &&\n\t    (fsize >= exe_sections[nsections-1].raw + 0xC6 + ecx + offset)) {\n\n\t    char *spinned;\n\n\t    if((spinned = (char *) cli_malloc(fsize)) == NULL) {\n            cli_errmsg(\"yC: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t      free(exe_sections);\n\t      return CL_EMEM;\n\t    }\n\n\t    if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t      cli_dbgmsg(\"yC: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t      free(spinned);\n\t      free(exe_sections);\n\t      return CL_EREAD;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"yC\");\n#endif\n\n\t    cli_dbgmsg(\"%d,%d,%d,%d\\n\", nsections-1, e_lfanew, ecx, offset);\n\t    CLI_UNPTEMP(\"yC\",(spinned,exe_sections,0));\n\t    CLI_UNPRESULTS(\"yC\",(yc_decrypt(spinned, fsize, exe_sections, nsections-1, e_lfanew, ndesc, ecx, offset)),0,(spinned,0));\n\t}\n    }\n\n    /* WWPack */\n\n    while ((DCONF & PE_CONF_WWPACK) && nsections > 1 &&\n       vep == exe_sections[nsections - 1].rva &&\n       memcmp(epbuff, \"\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb\", 7) == 0 &&\n       memcmp(epbuff+0x68, \"\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50\", 19) == 0)  {\n\tuint32_t head = exe_sections[nsections - 1].raw;\n        uint8_t *packer;\n\tchar *src;\n\n\tssize = 0;\n\tfor(i=0 ; ; i++) {\n\t    if(exe_sections[i].raw<head)\n\t        head=exe_sections[i].raw;\n\t    if(i+1==nsections) break;\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\t}\n\tif(!head || !ssize || head>ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"WWPack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif((size_t) fmap_readn(map, src, 0, head) != head) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from headers\\n\", head);\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections-1; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i+1!=nsections) {\n            cli_dbgmsg(\"WWpack: Probably hacked/damaged file.\\n\");\n            free(src);\n            break;\n        }\n\tif((packer = (uint8_t *) cli_calloc(exe_sections[nsections - 1].rsz, sizeof(char))) == NULL) {\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif(!exe_sections[nsections - 1].rsz || (size_t) fmap_readn(map, packer, exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz) != exe_sections[nsections - 1].rsz) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from wwpack sect\\n\", exe_sections[nsections - 1].rsz);\n\t    free(src);\n\t    free(packer);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"WWPack\");\n#endif\n\n\tCLI_UNPTEMP(\"WWPack\",(src,packer,exe_sections,0));\n\tCLI_UNPRESULTS(\"WWPack\",(wwunpack((uint8_t *)src, ssize, packer, exe_sections, nsections-1, e_lfanew, ndesc)),0,(src,packer,0));\n\tbreak;\n    }\n\n\n    /* ASPACK support */\n    while((DCONF & PE_CONF_ASPACK) && ep+58+0x70e < fsize && !memcmp(epbuff,\"\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb\",8)) {\n\tchar *src;\n\n        if(epsize<0x3bf || memcmp(epbuff+0x3b9, \"\\x68\\x00\\x00\\x00\\x00\\xc3\",6)) break;\n\tssize = 0;\n\tfor(i=0 ; i< nsections ; i++)\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\tif(!ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"Aspack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i!=nsections) {\n            cli_dbgmsg(\"Aspack: Probably hacked/damaged Aspack file.\\n\");\n            free(src);\n            break;\n        }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Aspack\");\n#endif\n\n\tCLI_UNPTEMP(\"Aspack\",(src,exe_sections,0));\n\tCLI_UNPRESULTS(\"Aspack\",(unaspack212((uint8_t *)src, ssize, exe_sections, nsections, vep-1, EC32(optional_hdr32.ImageBase), ndesc)),1,(src,0));\n\tbreak;\n    }\n\n    /* NsPack */\n\n    while (DCONF & PE_CONF_NSPACK) {\n\tuint32_t eprva = vep;\n\tuint32_t start_of_stuff, rep = ep;\n\tunsigned int nowinldr;\n\tconst char *nbuff;\n\n\tsrc=epbuff;\n\tif (*epbuff=='\\xe9') { /* bitched headers */\n\t    eprva = cli_readint32(epbuff+1)+vep+5;\n\t    if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) break;\n\t    if (!(nbuff = fmap_need_off_once(map, rep, 24))) break;\n\t    src = nbuff;\n\t}\n\n\tif (memcmp(src, \"\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00\", 13)) break;\n\n\tnowinldr = 0x54-cli_readint32(src+17);\n\tcli_dbgmsg(\"NsPack: Found *start_of_stuff @delta-%x\\n\", nowinldr);\n\n\tif(!(nbuff = fmap_need_off_once(map, rep-nowinldr, 4))) break;\n\tstart_of_stuff=rep+cli_readint32(nbuff);\n\tif(!(nbuff = fmap_need_off_once(map, start_of_stuff, 20))) break;\n\tsrc = nbuff;\n\tif (!cli_readint32(nbuff)) {\n\t    start_of_stuff+=4; /* FIXME: more to do */\n\t    src+=4;\n\t}\n\n\tssize = cli_readint32(src+5)|0xff;\n\tdsize = cli_readint32(src+9);\n\n\tCLI_UNPSIZELIMITS(\"NsPack\", MAX(ssize,dsize));\n\n\tif (!ssize || !dsize || dsize != exe_sections[0].vsz) break;\n\tif (!(dest=cli_malloc(dsize))) {\n        cli_errmsg(\"NsPack: Unable to allocate memory for dest %u\\n\", dsize);\n        break;\n    }\n\t/* memset(dest, 0xfc, dsize); */\n\n\tif(!(src = fmap_need_off(map, start_of_stuff, ssize))) {\n\t    free(dest);\n\t    break;\n\t}\n\t/* memset(src, 0x00, ssize); */\n\n\teprva+=0x27a;\n\tif (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\t  free(dest);\n\t  break;\n\t}\n\tif(!(nbuff = fmap_need_off_once(map, rep, 5))) {\n\t  free(dest);\n\t  break;\n\t}\n\tfmap_unneed_off(map, start_of_stuff, ssize);\n\teprva=eprva+5+cli_readint32(nbuff+1);\n\tcli_dbgmsg(\"NsPack: OEP = %08x\\n\", eprva);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"NsPack\");\n#endif\n\n\tCLI_UNPTEMP(\"NsPack\",(dest,exe_sections,0));\n\tCLI_UNPRESULTS(\"NsPack\",(unspack(src, dest, ctx, exe_sections[0].rva, EC32(optional_hdr32.ImageBase), eprva, ndesc)),0,(dest,0));\n\tbreak;\n    }\n\n    /* to be continued ... */\n\n\n\n\n    /* !!!!!!!!!!!!!!    PACKERS END HERE    !!!!!!!!!!!!!! */\n    ctx->corrupted_input = corrupted_cur;\n\n    /* Bytecode BC_PE_UNPACKER hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_UNPACKER, map);\n    switch (ret) {\n\tcase CL_VIRUS:\n\t    free(exe_sections);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    return CL_VIRUS;\n\tcase CL_SUCCESS:\n\t    ndesc = cli_bytecode_context_getresult_file(bc_ctx, &tempfile);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    if (ndesc != -1 && tempfile) {\n\t\tCLI_UNPRESULTS(\"bytecode PE hook\", 1, 1, (0));\n\t    }\n\t    break;\n\tdefault:\n\t    cli_bytecode_context_destroy(bc_ctx);\n    }\n\n    free(exe_sections);\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n    if (SCAN_ALL && viruses_found)\n\treturn CL_VIRUS;\n    return CL_CLEAN;",
    "label": "False",
    "variable_definitions": {
      "upx_success": "unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 170,
    "critical_vars": [
      "ld->bytes_left"
    ],
    "function": "faad_resetbits",
    "filename": "faad2/CVE-2019-15296/CVE-2019-15296_CWE-119_942c3e0aee748ea6fe97cb2c1aa5893225316174_bits.c.diff",
    "function_code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}",
    "label": "True",
    "variable_definitions": {
      "ld->bytes_left": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 170,
    "critical_vars": [
      "ld->buffer_size"
    ],
    "function": "faad_resetbits",
    "filename": "faad2/CVE-2019-15296/CVE-2019-15296_CWE-119_942c3e0aee748ea6fe97cb2c1aa5893225316174_bits.c.diff",
    "function_code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    if (ld->buffer_size < words * 4)\n        ld->bytes_left = 0;\n    else\n        ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}",
    "label": "False",
    "variable_definitions": {
      "ld->buffer_size": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 318,
    "critical_vars": [
      "value"
    ],
    "function": "SQLSetDescField",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescField.c.diff",
    "function_code": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n    \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT\n        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "True",
    "variable_definitions": {
      "value": "SQLPOINTER value,"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 309,
    "critical_vars": [
      "intptr_t"
    ],
    "function": "SQLSetDescField",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescField.c.diff",
    "function_code": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n    \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT\n        && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&\n        (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "False",
    "variable_definitions": {
      "intptr_t": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 300,
    "critical_vars": [
      "value"
    ],
    "function": "SQLSetDescFieldW",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescFieldW.c.diff",
    "function_code": "SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n#ifdef WITH_HANDLE_REDIRECT\n\t\t{\n\t\t\tDMHDESC parent_desc;\n\n\t\t\tparent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC );\n\n\t\t\tif ( parent_desc ) {\n        \t\tdm_log_write( __FILE__, \n                \t__LINE__, \n                    \tLOG_INFO, \n                    \tLOG_INFO, \n                    \t\"Info: found parent handle\" );\n\n\t\t\t\tif ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection ))\n\t\t\t\t{\n        \t\t\tdm_log_write( __FILE__, \n                \t\t__LINE__, \n                   \t\t \tLOG_INFO, \n                   \t\t \tLOG_INFO, \n                   \t\t \t\"Info: calling redirected driver function\" );\n\n                \treturn  SQLSETDESCFIELDW( parent_desc -> connection,\n\t\t\t\t\t\t\tdescriptor,\n\t\t\t\t\t\t\trec_number,\n\t\t\t\t\t\t\tfield_identifier,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tbuffer_length );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT\n        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( descriptor -> connection -> unicode_driver ||\n\t\t    CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n\t{\n    \tif ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n    \tret = SQLSETDESCFIELDW( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\t}\n\telse\n\t{\n\t\tSQLCHAR *ascii_str = NULL;\n\n    \tif ( !CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n\t\t/*\n\t\t * is it a char arg...\n\t\t */\n\n\t\tswitch ( field_identifier )\n\t\t{\n\t\t\tcase SQL_DESC_NAME:\t\t/* This is the only R/W SQLCHAR* type */\n        \t\tascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL );\n\t\t\t\tvalue = ascii_str;\n\t\t\t\tbuffer_length = strlen((char*) ascii_str );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n    \tret = SQLSETDESCFIELD( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\n\t\tif ( ascii_str ) \n\t\t{\n\t\t\tfree( ascii_str );\n\t\t}\n\t}\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "True",
    "variable_definitions": {
      "value": "SQLPOINTER value,"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 291,
    "critical_vars": [
      "intptr_t"
    ],
    "function": "SQLSetDescFieldW",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescFieldW.c.diff",
    "function_code": "SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n#ifdef WITH_HANDLE_REDIRECT\n\t\t{\n\t\t\tDMHDESC parent_desc;\n\n\t\t\tparent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC );\n\n\t\t\tif ( parent_desc ) {\n        \t\tdm_log_write( __FILE__, \n                \t__LINE__, \n                    \tLOG_INFO, \n                    \tLOG_INFO, \n                    \t\"Info: found parent handle\" );\n\n\t\t\t\tif ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection ))\n\t\t\t\t{\n        \t\t\tdm_log_write( __FILE__, \n                \t\t__LINE__, \n                   \t\t \tLOG_INFO, \n                   \t\t \tLOG_INFO, \n                   \t\t \t\"Info: calling redirected driver function\" );\n\n                \treturn  SQLSETDESCFIELDW( parent_desc -> connection,\n\t\t\t\t\t\t\tdescriptor,\n\t\t\t\t\t\t\trec_number,\n\t\t\t\t\t\t\tfield_identifier,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tbuffer_length );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT\n        && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&\n        (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( descriptor -> connection -> unicode_driver ||\n\t\t    CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n\t{\n    \tif ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n    \tret = SQLSETDESCFIELDW( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\t}\n\telse\n\t{\n\t\tSQLCHAR *ascii_str = NULL;\n\n    \tif ( !CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n\t\t/*\n\t\t * is it a char arg...\n\t\t */\n\n\t\tswitch ( field_identifier )\n\t\t{\n\t\t\tcase SQL_DESC_NAME:\t\t/* This is the only R/W SQLCHAR* type */\n        \t\tascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL );\n\t\t\t\tvalue = ascii_str;\n\t\t\t\tbuffer_length = strlen((char*) ascii_str );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n    \tret = SQLSETDESCFIELD( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\n\t\tif ( ascii_str ) \n\t\t{\n\t\t\tfree( ascii_str );\n\t\t}\n\t}\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "False",
    "variable_definitions": {
      "intptr_t": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 333,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horAcc8",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n\tassert((cc%stride)==0);\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcc -= 3;\n\t\t\t\tcp += 3;\n\t\t\t}\n\t\t} else if (stride == 4)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tunsigned int ca = cp[3];\n\t\t\tcc -= 4;\n\t\t\tcp += 4;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcp[3] = (unsigned char) ((ca += cp[3]) & 0xff);\n\t\t\t\tcc -= 4;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n}",
    "label": "True",
    "variable_definitions": {
      "tif": "TIFF* tif",
      "cp0": "uint8* cp0",
      "cc": "tmsize_t cc"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 350,
    "critical_vars": [
      "stride"
    ],
    "function": "horAcc8",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n    if((cc%stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n                     \"%s\", \"(cc%stride)!=0\");\n        return 0;\n    }\n\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcc -= 3;\n\t\t\t\tcp += 3;\n\t\t\t}\n\t\t} else if (stride == 4)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tunsigned int ca = cp[3];\n\t\t\tcc -= 4;\n\t\t\tcp += 4;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcp[3] = (unsigned char) ((ca += cp[3]) & 0xff);\n\t\t\t\tcc -= 4;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n\treturn 1;\n}",
    "label": "False",
    "variable_definitions": {
      "stride": "tmsize_t stride = PredictorState(tif)->stride;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 361,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horAcc16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "label": "True",
    "variable_definitions": {
      "tif": "TIFF* tif",
      "cp0": "uint8* cp0",
      "cc": "tmsize_t cc"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 384,
    "critical_vars": [
      "stride"
    ],
    "function": "horAcc16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",\n                     \"%s\", \"cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "label": "False",
    "variable_definitions": {
      "stride": "tmsize_t stride = PredictorState(tif)->stride;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 414,
    "critical_vars": [
      "stride",
      "bps"
    ],
    "function": "fpAcc",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}",
    "label": "False",
    "variable_definitions": {
      "stride": "tmsize_t stride = PredictorState(tif)->stride;",
      "bps": "uint32 bps = tif->tif_dir.td_bitspersample / 8;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 462,
    "critical_vars": [
      "op0",
      "rowsize"
    ],
    "function": "PredictorDecodeTile",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp->rowsize;\n\t\tassert(rowsize > 0);\n\t\tassert((occ0%rowsize)==0);\n\t\tassert(sp->decodepfunc != NULL);\n\t\twhile (occ0 > 0) {\n\t\t\t(*sp->decodepfunc)(tif, op0, rowsize);\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "op0": "uint8* op0",
      "rowsize": "tmsize_t rowsize = sp->rowsize;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 483,
    "critical_vars": [
      "occ0%rowsize"
    ],
    "function": "PredictorDecodeTile",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp->rowsize;\n\t\tassert(rowsize > 0);\n\t\tif((occ0%rowsize) !=0)\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"PredictorDecodeTile\",\n                         \"%s\", \"occ0%rowsize != 0\");\n            return 0;\n        }\n\t\tassert(sp->decodepfunc != NULL);\n\t\twhile (occ0 > 0) {\n\t\t\tif( !(*sp->decodepfunc)(tif, op0, rowsize) )\n                return 0;\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "occ0%rowsize": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 544,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horDiff16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "label": "True",
    "variable_definitions": {
      "tif": "TIFF* tif",
      "cp0": "uint8* cp0",
      "cc": "tmsize_t cc"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 562,
    "critical_vars": [
      "stride"
    ],
    "function": "horDiff16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n                     \"%s\", \"(cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "label": "False",
    "variable_definitions": {
      "stride": "tmsize_t stride = sp->stride;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 575,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horDiff32",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n\tassert((cc%(4*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "label": "True",
    "variable_definitions": {
      "tif": "TIFF* tif",
      "cp0": "uint8* cp0",
      "cc": "tmsize_t cc"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 601,
    "critical_vars": [
      "stride"
    ],
    "function": "horDiff32",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n    if((cc%(4*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff32\",\n                     \"%s\", \"(cc%(4*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "label": "False",
    "variable_definitions": {
      "stride": "tmsize_t stride = sp->stride;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 645,
    "critical_vars": [
      "stride",
      "bps"
    ],
    "function": "fpDiff",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if((cc%(bps*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                     \"%s\", \"(cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}",
    "label": "False",
    "variable_definitions": {
      "stride": "tmsize_t stride = PredictorState(tif)->stride;",
      "bps": "uint32 bps = tif->tif_dir.td_bitspersample / 8;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1351,
    "critical_vars": [
      "colb",
      "tilew"
    ],
    "function": "DECLAREreadFunc",
    "filename": "libtiff/CVE-2016-10093/CVE-2016-10093_CWE-119_787c0ee906430b772f33ca50b97b8b5ca070faec_tiffcp.c.diff",
    "function_code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}",
    "label": "True",
    "variable_definitions": {
      "colb": "uint32 colb = 0;",
      "tilew": "uint32 tilew  = TIFFTileRowSize(in);"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1341,
    "critical_vars": [
      "colb"
    ],
    "function": "DECLAREreadFunc",
    "filename": "libtiff/CVE-2016-9540/CVE-2016-9540_CWE-119_5ad9d8016fbb60109302d558f7edb2cb2a3bb8e3_tiffcp.c.diff",
    "function_code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}",
    "label": "False",
    "variable_definitions": {
      "colb": "uint32 colb = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 986,
    "critical_vars": [
      "ip"
    ],
    "function": "horizontalDifferenceF",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t/* point to last one */\n\t    wp += n - 1;\t/* point to last one */\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}",
    "label": "True",
    "variable_definitions": {
      "ip": "float *ip"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 988,
    "critical_vars": [
      "n"
    ],
    "function": "horizontalDifferenceF",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "n": "int n"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1039,
    "critical_vars": [
      "ip"
    ],
    "function": "horizontalDifference16",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n/* assumption is unsigned pixel values */\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t/* point to last one */\n\t    wp += n - 1;\t/* point to last one */\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}",
    "label": "True",
    "variable_definitions": {
      "ip": "unsigned short *ip"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1036,
    "critical_vars": [
      "ip",
      "stride",
      "wp"
    ],
    "function": "horizontalDifference16",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n/* assumption is unsigned pixel values */\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n\t    n -= stride;\n\t    while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "ip": "unsigned short *ip",
      "stride": "int stride",
      "wp": "unsigned short *wp"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1092,
    "critical_vars": [
      "wp"
    ],
    "function": "horizontalDifference8",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t/* point to last one */\n\t    ip += n + stride - 1;\t/* point to last one */\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}",
    "label": "True",
    "variable_definitions": {
      "wp": "unsigned short *wp"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 1088,
    "critical_vars": [
      "n"
    ],
    "function": "horizontalDifference8",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n    }\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "n": "int n"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 594,
    "critical_vars": [
      "samplesperpixel"
    ],
    "function": "pickCopyFunc",
    "filename": "libtiff/CVE-2017-5225/CVE-2017-5225_CWE-119_5c080298d59efa53264d7248bbe3a04660db6ef7_tiffcp.c.diff",
    "function_code": "pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;\n\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n\t\t/* if biased, force decoded copying to allow image subtraction */\n\t\tbychunk = !bias && (rowsperstrip == irps);\n\t}else{  /* either in or out is tiled */\n\t\tif (bias) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\n\t\t\tTIFFFileName(in));\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (TIFFIsTiled(out)) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\n\t\t\t\ttw = w;\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\n\t\t\t\ttl = l;\n\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\n\t\t} else {  /* out's not, so in must be tiled */\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t\t\tbychunk = (tw == w && tl == rowsperstrip);\n\t\t}\n\t}\n#define\tT 1\n#define\tF 0\n#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\n\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\n\t\t/* Strips -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpContigStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpContigStrips2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpSeparateStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpSeparateStrips2SeparateTiles;\n\t\t/* Tiles -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpContigTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpContigTiles2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpSeparateTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpSeparateTiles2SeparateTiles;\n\t\t/* Tiles -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpContigTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpContigTiles2SeparateStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpSeparateTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpSeparateTiles2SeparateStrips;\n\t\t/* Strips -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\n\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpDecodedStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\n\t\t\treturn cpContig2SeparateByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpSeparate2ContigByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\n\t\t\treturn cpSeparate2SeparateByRow;\n\t}\n#undef pack\n#undef F\n#undef T\n\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\n\t    TIFFFileName(in));\n\treturn (NULL);\n}",
    "label": "True",
    "variable_definitions": {
      "samplesperpixel": "uint16 samplesperpixel"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 594,
    "critical_vars": [
      "bitspersample"
    ],
    "function": "pickCopyFunc",
    "filename": "libtiff/CVE-2017-5225/CVE-2017-5225_CWE-119_5c080298d59efa53264d7248bbe3a04660db6ef7_tiffcp.c.diff",
    "function_code": "pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;\n\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n\t\t/* if biased, force decoded copying to allow image subtraction */\n\t\tbychunk = !bias && (rowsperstrip == irps);\n\t}else{  /* either in or out is tiled */\n\t\tif (bias) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\n\t\t\tTIFFFileName(in));\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (TIFFIsTiled(out)) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\n\t\t\t\ttw = w;\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\n\t\t\t\ttl = l;\n\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\n\t\t} else {  /* out's not, so in must be tiled */\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t\t\tbychunk = (tw == w && tl == rowsperstrip);\n\t\t}\n\t}\n#define\tT 1\n#define\tF 0\n#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\n\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\n\t\t/* Strips -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpContigStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpContigStrips2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpSeparateStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpSeparateStrips2SeparateTiles;\n\t\t/* Tiles -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpContigTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpContigTiles2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpSeparateTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpSeparateTiles2SeparateTiles;\n\t\t/* Tiles -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpContigTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpContigTiles2SeparateStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpSeparateTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpSeparateTiles2SeparateStrips;\n\t\t/* Strips -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\n\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpDecodedStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\n\t\t\treturn cpContig2SeparateByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpSeparate2ContigByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\n\t\t\treturn cpSeparate2SeparateByRow;\n\t}\n#undef pack\n#undef F\n#undef T\n\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\n\t    TIFFFileName(in));\n\treturn (NULL);\n}",
    "label": "False",
    "variable_definitions": {
      "bitspersample": "uint16 bitspersample"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 542,
    "critical_vars": [
      "buflen"
    ],
    "function": "bittok2str_internal",
    "filename": "tcpdump/CVE-2017-13011/CVE-2017-13011_CWE-119_9f0730bee3eb65d07b49fd468bc2f269173352fe_util-print.c.diff",
    "function_code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; /* our stringbuffer */\n        int buflen=0;\n        register u_int rotbit; /* this is the bit we rotate through all bitpositions */\n        register u_int tokval;\n        const char * sepstr = \"\";\n\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   /* load our first value */\n            rotbit=1;\n            while (rotbit != 0) {\n                /*\n                 * lets AND the rotating bit with our token value\n                 * and see if we have got a match\n                 */\n\t\tif (tokval == (v&rotbit)) {\n                    /* ok we have found something */\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; /* no match - lets shift and try again */\n            }\n            lp++;\n\t}\n\n        if (buflen == 0)\n            /* bummer - lets print the \"unknown\" message as advised in the fmt string if we got one */\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}",
    "label": "True",
    "variable_definitions": {
      "buflen": "int buflen=0;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 543,
    "critical_vars": [
      "space_left"
    ],
    "function": "bittok2str_internal",
    "filename": "tcpdump/CVE-2017-13011/CVE-2017-13011_CWE-119_9f0730bee3eb65d07b49fd468bc2f269173352fe_util-print.c.diff",
    "function_code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[1024+1]; /* our string buffer */\n        char *bufp = buf;\n        size_t space_left = sizeof(buf), string_size;\n        register u_int rotbit; /* this is the bit we rotate through all bitpositions */\n        register u_int tokval;\n        const char * sepstr = \"\";\n\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   /* load our first value */\n            rotbit=1;\n            while (rotbit != 0) {\n                /*\n                 * lets AND the rotating bit with our token value\n                 * and see if we have got a match\n                 */\n\t\tif (tokval == (v&rotbit)) {\n                    /* ok we have found something */\n                    if (space_left <= 1)\n                        return (buf); /* only enough room left for NUL, if that */\n                    string_size = strlcpy(bufp, sepstr, space_left);\n                    if (string_size >= space_left)\n                        return (buf);    /* we ran out of room */\n                    bufp += string_size;\n                    space_left -= string_size;\n                    if (space_left <= 1)\n                        return (buf); /* only enough room left for NUL, if that */\n                    string_size = strlcpy(bufp, lp->s, space_left);\n                    if (string_size >= space_left)\n                        return (buf);    /* we ran out of room */\n                    bufp += string_size;\n                    space_left -= string_size;\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; /* no match - lets shift and try again */\n            }\n            lp++;\n\t}\n\n        if (bufp == buf)\n            /* bummer - lets print the \"unknown\" message as advised in the fmt string if we got one */\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}",
    "label": "False",
    "variable_definitions": {
      "space_left": "size_t space_left = sizeof(buf), string_size;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1373,
    "critical_vars": [
      "i"
    ],
    "function": "ppp_hdlc",
    "filename": "tcpdump/CVE-2014-9140/CVE-2014-9140_CWE-119_0f95d441e4b5d7512cc5c326c8668a120e048eda_print-ppp.c.diff",
    "function_code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *s, *t, c;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (uint8_t *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
    "label": "True",
    "variable_definitions": {
      "i": "int i, proto;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1371,
    "critical_vars": [
      "s"
    ],
    "function": "ppp_hdlc",
    "filename": "tcpdump/CVE-2014-9140/CVE-2014-9140_CWE-119_0f95d441e4b5d7512cc5c326c8668a120e048eda_print-ppp.c.diff",
    "function_code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1 || !ND_TTEST(*s))\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
    "label": "False",
    "variable_definitions": {
      "s": "const u_char *s;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 81,
    "critical_vars": [
      "xWantedSize"
    ],
    "function": "pvPortMalloc",
    "filename": "FreeRTOS-Kernel/CVE-2021-32020/CVE-2021-32020_CWE-119_c7a9a01c94987082b223d3e59969ede64363da63_heap_1.c.diff",
    "function_code": "void * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    void * pvReturn = NULL;\r\n\r\n    /* The heap must be initialised before the first call to\r\n     * prvPortMalloc(). */\r\n    configASSERT( pxEnd );\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* Check the requested block size is not so large that the top bit is\r\n         * set.  The top bit of the block size member of the BlockLink_t structure\r\n         * is used to determine who owns the block - the application or the\r\n         * kernel, so it must be free. */\r\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n        {\r\n            /* The wanted size is increased so it can contain a BlockLink_t\r\n             * structure in addition to the requested amount of bytes. */\r\n            if( xWantedSize > 0 )\r\n            {\r\n                xWantedSize += xHeapStructSize;\r\n\r\n                /* Ensure that blocks are always aligned to the required number\r\n                 * of bytes. */\r\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                {\r\n                    /* Byte alignment required. */\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n            {\r\n                /* Traverse the list from the start\t(lowest address) block until\r\n                 * one\tof adequate size is found. */\r\n                pxPreviousBlock = &xStart;\r\n                pxBlock = xStart.pxNextFreeBlock;\r\n\r\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n                {\r\n                    pxPreviousBlock = pxBlock;\r\n                    pxBlock = pxBlock->pxNextFreeBlock;\r\n                }\r\n\r\n                /* If the end marker was reached then a block of adequate size\r\n                 * was\tnot found. */\r\n                if( pxBlock != pxEnd )\r\n                {\r\n                    /* Return the memory space pointed to - jumping over the\r\n                     * BlockLink_t structure at its start. */\r\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\r\n\r\n                    /* This block is being returned for use so must be taken out\r\n                     * of the list of free blocks. */\r\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                    /* If the block is larger than required it can be split into\r\n                     * two. */\r\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                    {\r\n                        /* This block is to be split into two.  Create a new\r\n                         * block following the number of bytes requested. The void\r\n                         * cast is used to prevent byte alignment warnings from the\r\n                         * compiler. */\r\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n\r\n                        /* Calculate the sizes of two blocks split from the\r\n                         * single block. */\r\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                        pxBlock->xBlockSize = xWantedSize;\r\n\r\n                        /* Insert the new block into the list of free blocks. */\r\n                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n\r\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\r\n                    {\r\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    /* The block is being returned - it is allocated and owned\r\n                     * by the application and has no \"next\" block. */\r\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\r\n                    pxBlock->pxNextFreeBlock = NULL;\r\n                    xNumberOfSuccessfulAllocations++;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\r\n\r\n    return pvReturn;\r\n}\r",
    "label": "True",
    "variable_definitions": {
      "xWantedSize": "size_t xWantedSize"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 80,
    "critical_vars": [
      "portBYTE_ALIGNMENT_MASK",
      "xWantedSize",
      "portBYTE_ALIGNMENT"
    ],
    "function": "pvPortMalloc",
    "filename": "FreeRTOS-Kernel/CVE-2021-32020/CVE-2021-32020_CWE-119_c7a9a01c94987082b223d3e59969ede64363da63_heap_1.c.diff",
    "function_code": "void * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    void * pvReturn = NULL;\r\n    static uint8_t * pucAlignedHeap = NULL;\r\n\r\n    /* Ensure that blocks are always aligned. */\r\n    #if ( portBYTE_ALIGNMENT != 1 )\r\n        {\r\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\r\n            {\r\n                /* Byte alignment required. Check for overflow. */\r\n                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )\r\n                {\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                } \r\n                else \r\n                {\r\n                    xWantedSize = 0;\r\n                }\r\n            }\r\n        }\r\n    #endif\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        if( pucAlignedHeap == NULL )\r\n        {\r\n            /* Ensure the heap starts on a correctly aligned boundary. */\r\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n        }\r\n\r\n        /* Check there is enough room left for the allocation and. */\r\n        if( ( xWantedSize > 0 ) && /* valid size */\r\n            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\r\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\r\n        {\r\n            /* Return the next free byte then increment the index past this\r\n             * block. */\r\n            pvReturn = pucAlignedHeap + xNextFreeByte;\r\n            xNextFreeByte += xWantedSize;\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n        }\r\n    #endif\r\n\r\n    return pvReturn;\r\n}\r",
    "label": "False",
    "variable_definitions": {
      "portBYTE_ALIGNMENT_MASK": "Definition not found",
      "xWantedSize": "size_t xWantedSize",
      "portBYTE_ALIGNMENT": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 734,
    "critical_vars": [
      "source_node_id"
    ],
    "function": "fwnet_receive_broadcast",
    "filename": "linux/CVE-2016-8633/CVE-2016-8633_CWE-119_667121ace9dbafb368618dbabcf07901c962ddac_net.c.diff",
    "function_code": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n#endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n\t\t\t\t      context->card->generation, true);\n\t}\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
    "label": "True",
    "variable_definitions": {
      "source_node_id": "u16 source_node_id;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 777,
    "critical_vars": [
      "length",
      "buf_ptr"
    ],
    "function": "fwnet_receive_broadcast",
    "filename": "linux/CVE-2016-8633/CVE-2016-8633_CWE-119_667121ace9dbafb368618dbabcf07901c962ddac_net.c.diff",
    "function_code": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (length > IEEE1394_GASP_HDR_SIZE &&\n\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n\t    ))\n\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n\t\t\t\t      gasp_source_id(buf_ptr),\n\t\t\t\t      context->card->generation, true);\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
    "label": "False",
    "variable_definitions": {
      "length": "u32 length;",
      "buf_ptr": "__be32 *buf_ptr;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 845,
    "critical_vars": [
      "hdr.flags"
    ],
    "function": "vfio_pci_ioctl",
    "filename": "linux/CVE-2016-9083/CVE-2016-9083_CWE-119_05692d7005a364add85c6e25a6c4447ce08f913a_vfio_pci.c.diff",
    "function_code": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
    "label": "True",
    "variable_definitions": {
      "hdr.flags": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 832,
    "critical_vars": [
      "size"
    ],
    "function": "vfio_pci_ioctl",
    "filename": "linux/CVE-2016-9083/CVE-2016-9083_CWE-119_05692d7005a364add85c6e25a6c4447ce08f913a_vfio_pci.c.diff",
    "function_code": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
    "label": "False",
    "variable_definitions": {
      "size": "size_t size;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 78,
    "critical_vars": [
      "ret"
    ],
    "function": "ceph_x_decrypt",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_decrypt(struct ceph_crypto_key *secret,\n\t\t\t  void **p, void *end, void *obuf, size_t olen)\n{\n\tstruct ceph_x_encrypt_header head;\n\tsize_t head_len = sizeof(head);\n\tint len, ret;\n\n\tlen = ceph_decode_32(p);\n\tif (*p + len > end)\n\t\treturn -EINVAL;\n\n\tdout(\"ceph_x_decrypt len %d\\n\", len);\n\tret = ceph_decrypt2(secret, &head, &head_len, obuf, &olen,\n\t\t\t    *p, len);\n\tif (ret)\n\t\treturn ret;\n\tif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\n\t\treturn -EPERM;\n\t*p += len;\n\treturn olen;\n}",
    "label": "True",
    "variable_definitions": {
      "ret": "int len, ret;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 76,
    "critical_vars": [
      "obuf"
    ],
    "function": "ceph_x_decrypt",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_decrypt(struct ceph_crypto_key *secret,\n\t\t\t  void **p, void *end, void **obuf, size_t olen)\n{\n\tstruct ceph_x_encrypt_header head;\n\tsize_t head_len = sizeof(head);\n\tint len, ret;\n\n\tlen = ceph_decode_32(p);\n\tif (*p + len > end)\n\t\treturn -EINVAL;\n\n\tdout(\"ceph_x_decrypt len %d\\n\", len);\n\tif (*obuf == NULL) {\n\t\t*obuf = kmalloc(len, GFP_NOFS);\n\t\tif (!*obuf)\n\t\t\treturn -ENOMEM;\n\t\tolen = len;\n\t}\n\n\tret = ceph_decrypt2(secret, &head, &head_len, *obuf, &olen, *p, len);\n\tif (ret)\n\t\treturn ret;\n\tif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\n\t\treturn -EPERM;\n\t*p += len;\n\treturn olen;\n}",
    "label": "False",
    "variable_definitions": {
      "obuf": "void **obuf"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 198,
    "critical_vars": [
      "tp"
    ],
    "function": "process_one_ticket",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int process_one_ticket(struct ceph_auth_client *ac,\n\t\t\t      struct ceph_crypto_key *secret,\n\t\t\t      void **p, void *end,\n\t\t\t      void *dbuf, void *ticket_buf)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint type;\n\tu8 tkt_struct_v, blob_struct_v;\n\tstruct ceph_x_ticket_handler *th;\n\tvoid *dp, *dend;\n\tint dlen;\n\tchar is_enc;\n\tstruct timespec validity;\n\tstruct ceph_crypto_key old_key;\n\tvoid *tp, *tpend;\n\tstruct ceph_timespec new_validity;\n\tstruct ceph_crypto_key new_session_key;\n\tstruct ceph_buffer *new_ticket_blob;\n\tunsigned long new_expires, new_renew_after;\n\tu64 new_secret_id;\n\tint ret;\n\n\tceph_decode_need(p, end, sizeof(u32) + 1, bad);\n\n\ttype = ceph_decode_32(p);\n\tdout(\" ticket type %d %s\\n\", type, ceph_entity_type_name(type));\n\n\ttkt_struct_v = ceph_decode_8(p);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tth = get_ticket_handler(ac, type);\n\tif (IS_ERR(th)) {\n\t\tret = PTR_ERR(th);\n\t\tgoto out;\n\t}\n\n\t/* blob for me */\n\tdlen = ceph_x_decrypt(secret, p, end, dbuf,\n\t\t\t      TEMP_TICKET_BUF_LEN);\n\tif (dlen <= 0) {\n\t\tret = dlen;\n\t\tgoto out;\n\t}\n\tdout(\" decrypted %d bytes\\n\", dlen);\n\tdp = dbuf;\n\tdend = dp + dlen;\n\n\ttkt_struct_v = ceph_decode_8(&dp);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tmemcpy(&old_key, &th->session_key, sizeof(old_key));\n\tret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\n\tif (ret)\n\t\tgoto out;\n\n\tceph_decode_copy(&dp, &new_validity, sizeof(new_validity));\n\tceph_decode_timespec(&validity, &new_validity);\n\tnew_expires = get_seconds() + validity.tv_sec;\n\tnew_renew_after = new_expires - (validity.tv_sec / 4);\n\tdout(\" expires=%lu renew_after=%lu\\n\", new_expires,\n\t     new_renew_after);\n\n\t/* ticket blob for service */\n\tceph_decode_8_safe(p, end, is_enc, bad);\n\ttp = ticket_buf;\n\tif (is_enc) {\n\t\t/* encrypted */\n\t\tdout(\" encrypted ticket\\n\");\n\t\tdlen = ceph_x_decrypt(&old_key, p, end, ticket_buf,\n\t\t\t\t      TEMP_TICKET_BUF_LEN);\n\t\tif (dlen < 0) {\n\t\t\tret = dlen;\n\t\t\tgoto out;\n\t\t}\n\t\tdlen = ceph_decode_32(&tp);\n\t} else {\n\t\t/* unencrypted */\n\t\tceph_decode_32_safe(p, end, dlen, bad);\n\t\tceph_decode_need(p, end, dlen, bad);\n\t\tceph_decode_copy(p, ticket_buf, dlen);\n\t}\n\ttpend = tp + dlen;\n\tdout(\" ticket blob is %d bytes\\n\", dlen);\n\tceph_decode_need(&tp, tpend, 1 + sizeof(u64), bad);\n\tblob_struct_v = ceph_decode_8(&tp);\n\tnew_secret_id = ceph_decode_64(&tp);\n\tret = ceph_decode_buffer(&new_ticket_blob, &tp, tpend);\n\tif (ret)\n\t\tgoto out;\n\n\t/* all is well, update our ticket */\n\tceph_crypto_key_destroy(&th->session_key);\n\tif (th->ticket_blob)\n\t\tceph_buffer_put(th->ticket_blob);\n\tth->session_key = new_session_key;\n\tth->ticket_blob = new_ticket_blob;\n\tth->validity = new_validity;\n\tth->secret_id = new_secret_id;\n\tth->expires = new_expires;\n\tth->renew_after = new_renew_after;\n\tdout(\" got ticket service %d (%s) secret_id %lld len %d\\n\",\n\t     type, ceph_entity_type_name(type), th->secret_id,\n\t     (int)th->ticket_blob->vec.iov_len);\n\txi->have_keys |= th->service;\n\nout:\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
    "label": "True",
    "variable_definitions": {
      "tp": "void *tp, *tpend;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 170,
    "line_new": 175,
    "critical_vars": [
      "dlen"
    ],
    "function": "process_one_ticket",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int process_one_ticket(struct ceph_auth_client *ac,\n\t\t\t      struct ceph_crypto_key *secret,\n\t\t\t      void **p, void *end)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint type;\n\tu8 tkt_struct_v, blob_struct_v;\n\tstruct ceph_x_ticket_handler *th;\n\tvoid *dbuf = NULL;\n\tvoid *dp, *dend;\n\tint dlen;\n\tchar is_enc;\n\tstruct timespec validity;\n\tstruct ceph_crypto_key old_key;\n\tvoid *ticket_buf = NULL;\n\tvoid *tp, *tpend;\n\tstruct ceph_timespec new_validity;\n\tstruct ceph_crypto_key new_session_key;\n\tstruct ceph_buffer *new_ticket_blob;\n\tunsigned long new_expires, new_renew_after;\n\tu64 new_secret_id;\n\tint ret;\n\n\tceph_decode_need(p, end, sizeof(u32) + 1, bad);\n\n\ttype = ceph_decode_32(p);\n\tdout(\" ticket type %d %s\\n\", type, ceph_entity_type_name(type));\n\n\ttkt_struct_v = ceph_decode_8(p);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tth = get_ticket_handler(ac, type);\n\tif (IS_ERR(th)) {\n\t\tret = PTR_ERR(th);\n\t\tgoto out;\n\t}\n\n\t/* blob for me */\n\tdlen = ceph_x_decrypt(secret, p, end, &dbuf, 0);\n\tif (dlen <= 0) {\n\t\tret = dlen;\n\t\tgoto out;\n\t}\n\tdout(\" decrypted %d bytes\\n\", dlen);\n\tdp = dbuf;\n\tdend = dp + dlen;\n\n\ttkt_struct_v = ceph_decode_8(&dp);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tmemcpy(&old_key, &th->session_key, sizeof(old_key));\n\tret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\n\tif (ret)\n\t\tgoto out;\n\n\tceph_decode_copy(&dp, &new_validity, sizeof(new_validity));\n\tceph_decode_timespec(&validity, &new_validity);\n\tnew_expires = get_seconds() + validity.tv_sec;\n\tnew_renew_after = new_expires - (validity.tv_sec / 4);\n\tdout(\" expires=%lu renew_after=%lu\\n\", new_expires,\n\t     new_renew_after);\n\n\t/* ticket blob for service */\n\tceph_decode_8_safe(p, end, is_enc, bad);\n\tif (is_enc) {\n\t\t/* encrypted */\n\t\tdout(\" encrypted ticket\\n\");\n\t\tdlen = ceph_x_decrypt(&old_key, p, end, &ticket_buf, 0);\n\t\tif (dlen < 0) {\n\t\t\tret = dlen;\n\t\t\tgoto out;\n\t\t}\n\t\ttp = ticket_buf;\n\t\tdlen = ceph_decode_32(&tp);\n\t} else {\n\t\t/* unencrypted */\n\t\tceph_decode_32_safe(p, end, dlen, bad);\n\t\tticket_buf = kmalloc(dlen, GFP_NOFS);\n\t\tif (!ticket_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttp = ticket_buf;\n\t\tceph_decode_need(p, end, dlen, bad);\n\t\tceph_decode_copy(p, ticket_buf, dlen);\n\t}\n\ttpend = tp + dlen;\n\tdout(\" ticket blob is %d bytes\\n\", dlen);\n\tceph_decode_need(&tp, tpend, 1 + sizeof(u64), bad);\n\tblob_struct_v = ceph_decode_8(&tp);\n\tnew_secret_id = ceph_decode_64(&tp);\n\tret = ceph_decode_buffer(&new_ticket_blob, &tp, tpend);\n\tif (ret)\n\t\tgoto out;\n\n\t/* all is well, update our ticket */\n\tceph_crypto_key_destroy(&th->session_key);\n\tif (th->ticket_blob)\n\t\tceph_buffer_put(th->ticket_blob);\n\tth->session_key = new_session_key;\n\tth->ticket_blob = new_ticket_blob;\n\tth->validity = new_validity;\n\tth->secret_id = new_secret_id;\n\tth->expires = new_expires;\n\tth->renew_after = new_renew_after;\n\tdout(\" got ticket service %d (%s) secret_id %lld len %d\\n\",\n\t     type, ceph_entity_type_name(type), th->secret_id,\n\t     (int)th->ticket_blob->vec.iov_len);\n\txi->have_keys |= th->service;\n\nout:\n\tkfree(ticket_buf);\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
    "label": "False",
    "variable_definitions": {
      "dlen": "int dlen;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 275,
    "line_new": 275,
    "critical_vars": [
      "ret"
    ],
    "function": "ceph_x_proc_ticket_reply",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}",
    "label": "False",
    "variable_definitions": {
      "ret": "int ret;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 664,
    "critical_vars": [
      "obuf",
      "ibuf"
    ],
    "function": "su3000_i2c_transfer",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 obuf[0x40], ibuf[0x40];\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tobuf[0] = msg[0].buf[0] + 0x36;\n\t\t\tobuf[1] = 3;\n\t\t\tobuf[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tobuf[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = ibuf[0];\n\t\t\tmsg[0].buf[0] = ibuf[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tobuf[0] = 0x08;\n\t\t\tobuf[1] = msg[0].addr;\n\t\t\tobuf[2] = msg[0].len;\n\n\t\t\tmemcpy(&obuf[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\n\t\t\t\t\t\tibuf, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tobuf[0] = 0x09;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[1].len;\n\t\tobuf[3] = msg[0].addr;\n\t\tmemcpy(&obuf[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\n\t\t\t\t\tibuf, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}",
    "label": "True",
    "variable_definitions": {
      "obuf": "u8 obuf[0x40], ibuf[0x40];",
      "ibuf": "u8 obuf[0x40], ibuf[0x40];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 151,
    "critical_vars": [
      "data"
    ],
    "function": "k90_backlight_get",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}",
    "label": "True",
    "variable_definitions": {
      "data": "char data[8];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 256,
    "critical_vars": [
      "data"
    ],
    "function": "k90_show_macro_mode",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}",
    "label": "True",
    "variable_definitions": {
      "data": "char data[8];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 323,
    "critical_vars": [
      "data"
    ],
    "function": "k90_show_current_profile",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}",
    "label": "True",
    "variable_definitions": {
      "data": "char data[8];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1539,
    "critical_vars": [
      "len"
    ],
    "function": "dma_rx",
    "filename": "linux/CVE-2011-3359/CVE-2011-3359_CWE-119_c85ce65ecac078ab1a1835c87c4a6319cf74660a_dma.c.diff",
    "function_code": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n\t\tdmaaddr = meta->dmaaddr;\n\t\tgoto drop_recycle_buffer;\n\t}\n\tif (unlikely(len > ring->rx_buffersize)) {\n\t\t/* The data did not fit into one descriptor buffer\n\t\t * and is split over multiple buffers.\n\t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}",
    "label": "True",
    "variable_definitions": {
      "len": "u16 len;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1539,
    "critical_vars": [
      "ring->frameoffset",
      "len"
    ],
    "function": "dma_rx",
    "filename": "linux/CVE-2011-3359/CVE-2011-3359_CWE-119_c85ce65ecac078ab1a1835c87c4a6319cf74660a_dma.c.diff",
    "function_code": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n\t\tdmaaddr = meta->dmaaddr;\n\t\tgoto drop_recycle_buffer;\n\t}\n\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n\t\t/* The data did not fit into one descriptor buffer\n\t\t * and is split over multiple buffers.\n\t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}",
    "label": "False",
    "variable_definitions": {
      "ring->frameoffset": "Definition not found",
      "len": "u16 len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2447,
    "critical_vars": [
      "copied"
    ],
    "function": "cifs_iovec_write",
    "filename": "linux/CVE-2014-0069/CVE-2014-0069_CWE-119_5d81de8e8667da7135d3a32a964087c0faf5483f_file.c.diff",
    "function_code": "cifs_iovec_write(struct file *file, const struct iovec *iov,\n\t\t unsigned long nr_segs, loff_t *poffset)\n{\n\tunsigned long nr_pages, i;\n\tsize_t copied, len, cur_len;\n\tssize_t total_written = 0;\n\tloff_t offset;\n\tstruct iov_iter it;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tint rc;\n\tpid_t pid;\n\n\tlen = iov_length(iov, nr_segs);\n\tif (!len)\n\t\treturn 0;\n\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\toffset = *poffset;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tiov_iter_init(&it, iov, nr_segs, len, 0);\n\tdo {\n\t\tsize_t save_len;\n\n\t\tnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tbreak;\n\t\t}\n\n\t\tsave_len = cur_len;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tcopied = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n\t\t\t\t\t\t\t 0, copied);\n\t\t\tcur_len -= copied;\n\t\t\tiov_iter_advance(&it, copied);\n\t\t}\n\t\tcur_len = save_len - cur_len;\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\trc = cifs_uncached_retry_writev(wdata);\n\t\tif (rc) {\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, &wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = cifs_uncached_retry_writev(wdata);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}",
    "label": "True",
    "variable_definitions": {
      "copied": "size_t copied, len, cur_len;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2392,
    "critical_vars": [
      "bytes"
    ],
    "function": "cifs_iovec_write",
    "filename": "linux/CVE-2014-0069/CVE-2014-0069_CWE-119_5d81de8e8667da7135d3a32a964087c0faf5483f_file.c.diff",
    "function_code": "cifs_iovec_write(struct file *file, const struct iovec *iov,\n\t\t unsigned long nr_segs, loff_t *poffset)\n{\n\tunsigned long nr_pages, i;\n\tsize_t bytes, copied, len, cur_len;\n\tssize_t total_written = 0;\n\tloff_t offset;\n\tstruct iov_iter it;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tint rc;\n\tpid_t pid;\n\n\tlen = iov_length(iov, nr_segs);\n\tif (!len)\n\t\treturn 0;\n\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\toffset = *poffset;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tiov_iter_init(&it, iov, nr_segs, len, 0);\n\tdo {\n\t\tsize_t save_len;\n\n\t\tnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tbreak;\n\t\t}\n\n\t\tsave_len = cur_len;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n\t\t\t\t\t\t\t 0, bytes);\n\t\t\tcur_len -= copied;\n\t\t\tiov_iter_advance(&it, copied);\n\t\t\t/*\n\t\t\t * If we didn't copy as much as we expected, then that\n\t\t\t * may mean we trod into an unmapped area. Stop copying\n\t\t\t * at that point. On the next pass through the big\n\t\t\t * loop, we'll likely end up getting a zero-length\n\t\t\t * write and bailing out of it.\n\t\t\t */\n\t\t\tif (copied < bytes)\n\t\t\t\tbreak;\n\t\t}\n\t\tcur_len = save_len - cur_len;\n\n\t\t/*\n\t\t * If we have no data to send, then that probably means that\n\t\t * the copy above failed altogether. That's most likely because\n\t\t * the address in the iovec was bogus. Set the rc to -EFAULT,\n\t\t * free anything we allocated and bail out.\n\t\t */\n\t\tif (!cur_len) {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(wdata->pages[i]);\n\t\t\tkfree(wdata);\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * i + 1 now represents the number of pages we actually used in\n\t\t * the copy phase above. Bring nr_pages down to that, and free\n\t\t * any pages that we didn't use.\n\t\t */\n\t\tfor ( ; nr_pages > i + 1; nr_pages--)\n\t\t\tput_page(wdata->pages[nr_pages - 1]);\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\trc = cifs_uncached_retry_writev(wdata);\n\t\tif (rc) {\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, &wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = cifs_uncached_retry_writev(wdata);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}",
    "label": "False",
    "variable_definitions": {
      "bytes": "size_t bytes, copied, len, cur_len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 70,
    "critical_vars": [
      "reset"
    ],
    "function": "usb_cypress_load_firmware",
    "filename": "linux/CVE-2017-8061/CVE-2017-8061_CWE-119_67b0503db9c29b04eadfeede6bebbfe5ddad94ef_dvb-usb-firmware.c.diff",
    "function_code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\n\t/* stop the CPU */\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(hx);\n\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "reset": "u8 reset;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 64,
    "line_new": 66,
    "critical_vars": [
      "hx",
      "buf"
    ],
    "function": "usb_cypress_load_firmware",
    "filename": "linux/CVE-2017-8061/CVE-2017-8061_CWE-119_67b0503db9c29b04eadfeede6bebbfe5ddad94ef_dvb-usb-firmware.c.diff",
    "function_code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 *buf;\n\tint ret, pos = 0;\n\tu16 cpu_cs_register = cypress[type].cpu_cs_register;\n\n\tbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\thx = (struct hexline *)buf;\n\n\t/* stop the CPU */\n\tbuf[0] = 1;\n\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\tbuf[0] = 0;\n\t\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "hx": "struct hexline *hx;",
      "buf": "u8 *buf;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 45,
    "critical_vars": [
      "buffer",
      "count",
      "buf"
    ],
    "function": "exitcode_proc_write",
    "filename": "linux/CVE-2013-4512/CVE-2013-4512_CWE-119_201f99f170df14ba52ea4c52847779042b7a623b_exitcode.c.diff",
    "function_code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}",
    "label": "True",
    "variable_definitions": {
      "buffer": "const char __user *buffer",
      "count": "size_t count",
      "buf": "char *end, buf[sizeof(\"nnnnn\\0\")];"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 43,
    "critical_vars": [
      "size"
    ],
    "function": "exitcode_proc_write",
    "filename": "linux/CVE-2013-4512/CVE-2013-4512_CWE-119_201f99f170df14ba52ea4c52847779042b7a623b_exitcode.c.diff",
    "function_code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tsize_t size;\n\tint tmp;\n\n\tsize = min(count, sizeof(buf));\n\tif (copy_from_user(buf, buffer, size))\n\t\treturn -EFAULT;\n\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}",
    "label": "False",
    "variable_definitions": {
      "size": "size_t size;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1203,
    "critical_vars": [
      "regs[value_regno].var_off"
    ],
    "function": "check_mem_access",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* ctx accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t */\n\t\tif (reg->off) {\n\t\t\tverbose(env,\n\t\t\t\t\"dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\\n\",\n\t\t\t\tregno, reg->off, off - reg->off);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env,\n\t\t\t\t\"variable ctx access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\telse\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\tregs[value_regno].id = 0;\n\t\t\tregs[value_regno].off = 0;\n\t\t\tregs[value_regno].range = 0;\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* stack accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t * See check_stack_read().\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\toff += reg->var_off.value;\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off,\n\t\t\t\tsize);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (env->prog->aux->stack_depth < -off)\n\t\t\tenv->prog->aux->stack_depth = -off;\n\n\t\tif (t == BPF_WRITE)\n\t\t\terr = check_stack_write(env, state, off, size,\n\t\t\t\t\t\tvalue_regno);\n\t\telse\n\t\t\terr = check_stack_read(env, state, off, size,\n\t\t\t\t\t       value_regno);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tregs[value_regno].var_off =\n\t\t\ttnum_cast(regs[value_regno].var_off, size);\n\t\t__update_reg_bounds(&regs[value_regno]);\n\t}\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "regs[value_regno].var_off": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2020,
    "critical_vars": [
      "dst_reg"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift, so make the appropriate casts */\n\t\tif (dst_reg->smin_value < 0) {\n\t\t\tif (umin_val) {\n\t\t\t\t/* Sign bit will be cleared */\n\t\t\t\tdst_reg->smin_value = 0;\n\t\t\t} else {\n\t\t\t\t/* Lost sign bit information */\n\t\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t\t}\n\t\t} else {\n\t\t\tdst_reg->smin_value =\n\t\t\t\t(u64)(dst_reg->smin_value) >> umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "dst_reg": "struct bpf_reg_state *dst_reg,"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2033,
    "critical_vars": [
      "dst_reg"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "dst_reg": "struct bpf_reg_state *dst_reg,"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2402,
    "critical_vars": [
      "regs[insn->dst_reg].var_off"
    ],
    "function": "check_alu_op",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "regs[insn->dst_reg].var_off": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 533,
    "critical_vars": [
      "num_pages"
    ],
    "function": "zerocopy_sg_from_iovec",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\n\t/* Skip over from offset */\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\n\t/* copy up to skb headlen */\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\n\tif (len == offset1)\n\t\treturn 0;\n\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\t/* increase sk_wmem_alloc */\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "num_pages": "int num_pages;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 532,
    "critical_vars": [
      "size",
      "i"
    ],
    "function": "zerocopy_sg_from_iovec",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\n\t/* Skip over from offset */\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\n\t/* copy up to skb headlen */\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\n\tif (len == offset1)\n\t\treturn 0;\n\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tif (i + size > MAX_SKB_FRAGS)\n\t\t\treturn -EMSGSIZE;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif (num_pages != size) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\t/* increase sk_wmem_alloc */\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "size": "int size, offset1 = 0;",
      "i": "int i = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 654,
    "critical_vars": [
      "copylen"
    ],
    "function": "macvtap_get_user",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n\t\t\t\tconst struct iovec *iv, unsigned long total_len,\n\t\t\t\tsize_t count, int noblock)\n{\n\tstruct sk_buff *skb;\n\tstruct macvlan_dev *vlan;\n\tunsigned long len = total_len;\n\tint err;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint vnet_hdr_len = 0;\n\tint copylen;\n\tbool zerocopy = false;\n\n\tif (q->flags & IFF_VNET_HDR) {\n\t\tvnet_hdr_len = q->vnet_hdr_sz;\n\n\t\terr = -EINVAL;\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto err;\n\t\tlen -= vnet_hdr_len;\n\n\t\terr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\n\t\t\t\t\t   sizeof(vnet_hdr));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\tif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t     vnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\n\t\t\t\t\t\t\tvnet_hdr.hdr_len)\n\t\t\tvnet_hdr.hdr_len = vnet_hdr.csum_start +\n\t\t\t\t\t\tvnet_hdr.csum_offset + 2;\n\t\terr = -EINVAL;\n\t\tif (vnet_hdr.hdr_len > len)\n\t\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (unlikely(len < ETH_HLEN))\n\t\tgoto err;\n\n\tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n\t\tzerocopy = true;\n\n\tif (zerocopy) {\n\t\t/* There are 256 bytes to be copied in skb, so there is enough\n\t\t * room for skb expand head in case it is used.\n\t\t * The rest buffer is mapped from userspace.\n\t\t */\n\t\tcopylen = vnet_hdr.hdr_len;\n\t\tif (!copylen)\n\t\t\tcopylen = GOODCOPY_LEN;\n\t} else\n\t\tcopylen = len;\n\n\tskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\n\t\t\t\tvnet_hdr.hdr_len, noblock, &err);\n\tif (!skb)\n\t\tgoto err;\n\n\tif (zerocopy)\n\t\terr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\n\telse\n\t\terr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\n\t\t\t\t\t\t   len);\n\tif (err)\n\t\tgoto err_kfree;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\tif (vnet_hdr_len) {\n\t\terr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto err_kfree;\n\t}\n\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\t/* copy skb_ubuf_info for callback when skb has no error */\n\tif (zerocopy) {\n\t\tskb_shinfo(skb)->destructor_arg = m->msg_control;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\t}\n\tif (vlan)\n\t\tmacvlan_start_xmit(skb, vlan->dev);\n\telse\n\t\tkfree_skb(skb);\n\trcu_read_unlock_bh();\n\n\treturn total_len;\n\nerr_kfree:\n\tkfree_skb(skb);\n\nerr:\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\tif (vlan)\n\t\tvlan->dev->stats.tx_dropped++;\n\trcu_read_unlock_bh();\n\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "copylen": "int copylen;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 655,
    "critical_vars": [
      "copylen"
    ],
    "function": "macvtap_get_user",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n\t\t\t\tconst struct iovec *iv, unsigned long total_len,\n\t\t\t\tsize_t count, int noblock)\n{\n\tstruct sk_buff *skb;\n\tstruct macvlan_dev *vlan;\n\tunsigned long len = total_len;\n\tint err;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint vnet_hdr_len = 0;\n\tint copylen = 0;\n\tbool zerocopy = false;\n\n\tif (q->flags & IFF_VNET_HDR) {\n\t\tvnet_hdr_len = q->vnet_hdr_sz;\n\n\t\terr = -EINVAL;\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto err;\n\t\tlen -= vnet_hdr_len;\n\n\t\terr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\n\t\t\t\t\t   sizeof(vnet_hdr));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\tif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t     vnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\n\t\t\t\t\t\t\tvnet_hdr.hdr_len)\n\t\t\tvnet_hdr.hdr_len = vnet_hdr.csum_start +\n\t\t\t\t\t\tvnet_hdr.csum_offset + 2;\n\t\terr = -EINVAL;\n\t\tif (vnet_hdr.hdr_len > len)\n\t\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (unlikely(len < ETH_HLEN))\n\t\tgoto err;\n\n\terr = -EMSGSIZE;\n\tif (unlikely(count > UIO_MAXIOV))\n\t\tgoto err;\n\n\tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n\t\tzerocopy = true;\n\n\tif (zerocopy) {\n\t\t/* Userspace may produce vectors with count greater than\n\t\t * MAX_SKB_FRAGS, so we need to linearize parts of the skb\n\t\t * to let the rest of data to be fit in the frags.\n\t\t */\n\t\tif (count > MAX_SKB_FRAGS) {\n\t\t\tcopylen = iov_length(iv, count - MAX_SKB_FRAGS);\n\t\t\tif (copylen < vnet_hdr_len)\n\t\t\t\tcopylen = 0;\n\t\t\telse\n\t\t\t\tcopylen -= vnet_hdr_len;\n\t\t}\n\t\t/* There are 256 bytes to be copied in skb, so there is enough\n\t\t * room for skb expand head in case it is used.\n\t\t * The rest buffer is mapped from userspace.\n\t\t */\n\t\tif (copylen < vnet_hdr.hdr_len)\n\t\t\tcopylen = vnet_hdr.hdr_len;\n\t\tif (!copylen)\n\t\t\tcopylen = GOODCOPY_LEN;\n\t} else\n\t\tcopylen = len;\n\n\tskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\n\t\t\t\tvnet_hdr.hdr_len, noblock, &err);\n\tif (!skb)\n\t\tgoto err;\n\n\tif (zerocopy)\n\t\terr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\n\telse\n\t\terr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\n\t\t\t\t\t\t   len);\n\tif (err)\n\t\tgoto err_kfree;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\tif (vnet_hdr_len) {\n\t\terr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto err_kfree;\n\t}\n\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\t/* copy skb_ubuf_info for callback when skb has no error */\n\tif (zerocopy) {\n\t\tskb_shinfo(skb)->destructor_arg = m->msg_control;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\t}\n\tif (vlan)\n\t\tmacvlan_start_xmit(skb, vlan->dev);\n\telse\n\t\tkfree_skb(skb);\n\trcu_read_unlock_bh();\n\n\treturn total_len;\n\nerr_kfree:\n\tkfree_skb(skb);\n\nerr:\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\tif (vlan)\n\t\tvlan->dev->stats.tx_dropped++;\n\trcu_read_unlock_bh();\n\n\treturn err;\n}",
    "label": "False",
    "variable_definitions": {
      "copylen": "int copylen = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2365,
    "critical_vars": [
      "cmd"
    ],
    "function": "do_ip_vs_get_ctl",
    "filename": "linux/CVE-2013-4588/CVE-2013-4588_CWE-119_04bcef2a83f40c6db24222b27a52892cba39dffb_ip_vs_ctl.c.diff",
    "function_code": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "cmd": "int cmd"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2359,
    "critical_vars": [
      "copylen"
    ],
    "function": "do_ip_vs_get_ctl",
    "filename": "linux/CVE-2013-4588/CVE-2013-4588_CWE-119_04bcef2a83f40c6db24222b27a52892cba39dffb_ip_vs_ctl.c.diff",
    "function_code": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "copylen": "unsigned int copylen;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2301,
    "critical_vars": [
      "po->has_vnet_hdr"
    ],
    "function": "tpacket_rcv",
    "filename": "linux/CVE-2017-14497/CVE-2017-14497_CWE-119_edbd58be15a957f6a760c4a514cd475217eb97fd_af_packet.c.diff",
    "function_code": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr)\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0)\n\t\t\t\tsnaplen = 0;\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tif (po->has_vnet_hdr) {\n\t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}",
    "label": "True",
    "variable_definitions": {
      "po->has_vnet_hdr": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2194,
    "critical_vars": [
      "do_vnet"
    ],
    "function": "tpacket_rcv",
    "filename": "linux/CVE-2017-14497/CVE-2017-14497_CWE-119_edbd58be15a957f6a760c4a514cd475217eb97fd_af_packet.c.diff",
    "function_code": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\tbool do_vnet = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\t\tdo_vnet = true;\n\t\t}\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0) {\n\t\t\t\tsnaplen = 0;\n\t\t\t\tdo_vnet = false;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t\tdo_vnet = false;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tif (do_vnet) {\n\t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}",
    "label": "False",
    "variable_definitions": {
      "do_vnet": "bool do_vnet = false;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 186,
    "critical_vars": [
      "odata"
    ],
    "function": "crypto_ccm_auth",
    "filename": "linux/CVE-2017-8065/CVE-2017-8065_CWE-119_3b30460c5b0ed762be75a004e924ec3f8711e032_ccm.c.diff",
    "function_code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\n\t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "odata": "u8 odata[16];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 2391,
    "critical_vars": [
      "cnt2end"
    ],
    "function": "arcmsr_iop_message_xfer",
    "filename": "linux/CVE-2016-7425/CVE-2016-7425_CWE-119_7bc2b55a5c030685b399bb65b6baa9ccc3d1f167_arcmsr_hba.c.diff",
    "function_code": "static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tint32_t user_len, cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}",
    "label": "True",
    "variable_definitions": {
      "cnt2end": "int32_t user_len, cnt2end;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2392,
    "critical_vars": [
      "cnt2end"
    ],
    "function": "arcmsr_iop_message_xfer",
    "filename": "linux/CVE-2016-7425/CVE-2016-7425_CWE-119_7bc2b55a5c030685b399bb65b6baa9ccc3d1f167_arcmsr_hba.c.diff",
    "function_code": "static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint32_t user_len;\n\t\tint32_t cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tif (user_len > ARCMSR_API_DATA_BUFLEN) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tkfree(ver_addr);\n\t\t\tgoto message_out;\n\t\t}\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}",
    "label": "False",
    "variable_definitions": {
      "cnt2end": "int32_t cnt2end;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 4082,
    "critical_vars": [
      "name_len"
    ],
    "function": "CIFSFindNext",
    "filename": "linux/CVE-2011-3191/CVE-2011-3191_CWE-119_9438fabb73eb48055b58b89fc51e0bc4db22fabd_cifssmb.c.diff",
    "function_code": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned, name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
    "label": "True",
    "variable_definitions": {
      "name_len": "int bytes_returned, name_len;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 4083,
    "critical_vars": [
      "name_len"
    ],
    "function": "CIFSFindNext",
    "filename": "linux/CVE-2011-3191/CVE-2011-3191_CWE-119_9438fabb73eb48055b58b89fc51e0bc4db22fabd_cifssmb.c.diff",
    "function_code": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
    "label": "False",
    "variable_definitions": {
      "name_len": "unsigned int name_len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 83,
    "critical_vars": [
      "err"
    ],
    "function": "udf_symlink_filler",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_a1d47b262952a45aae62bd49cfaf33dd76c11a2c_symlink.c.diff",
    "function_code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tsymlink = bh->b_data;\n\t}\n\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "err": "int err = -EIO;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 83,
    "critical_vars": [
      "err"
    ],
    "function": "udf_symlink_filler",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_a1d47b262952a45aae62bd49cfaf33dd76c11a2c_symlink.c.diff",
    "function_code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\n\t/* We don't support symlinks longer than one block */\n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unmap;\n\t}\n\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\n\t\tsymlink = bh->b_data;\n\t}\n\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nout_unlock_inode:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\nout_unmap:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "label": "False",
    "variable_definitions": {
      "err": "int err;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 88,
    "critical_vars": [
      "elen"
    ],
    "function": "udf_pc_to_char",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_e237ec37ec154564f8690c5bd1795339955eeef9_symlink.c.diff",
    "function_code": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "elen": "int elen = 0;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 45,
    "critical_vars": [
      "elen"
    ],
    "function": "udf_pc_to_char",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_e237ec37ec154564f8690c5bd1795339955eeef9_symlink.c.diff",
    "function_code": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\telen += sizeof(struct pathComponent);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0) {\n\t\t\t\telen += pc->lengthComponentIdent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\telen += pc->lengthComponentIdent;\n\t\t\tif (elen > fromlen)\n\t\t\t\treturn -EIO;\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "elen": "int elen = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 62,
    "critical_vars": [
      "wo"
    ],
    "function": "cxusb_ctrl_msg",
    "filename": "linux/CVE-2017-8063/CVE-2017-8063_CWE-119_3f190e3aec212fc8c61e202c51400afa7384d4bc_cxusb.c.diff",
    "function_code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); /* write-only */\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "wo": "int ret, wo;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 69,
    "critical_vars": [
      "rlen"
    ],
    "function": "cxusb_ctrl_msg",
    "filename": "linux/CVE-2017-8063/CVE-2017-8063_CWE-119_3f190e3aec212fc8c61e202c51400afa7384d4bc_cxusb.c.diff",
    "function_code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c rd: len=%d is too big!\\n\", rlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen, st->data, rlen, 0);\n\tif (!ret && rbuf && rlen)\n\t\tmemcpy(rbuf, st->data, rlen);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "rlen": "int rlen"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 80,
    "critical_vars": [
      "priv",
      "sta_id"
    ],
    "function": "iwl_process_add_sta_resp",
    "filename": "linux/CVE-2012-6712/CVE-2012-6712_CWE-119_2da424b0773cea3db47e1e81db71eeebde8269d4_iwl-agn-sta.c.diff",
    "function_code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "priv": "struct iwl_priv *priv,",
      "sta_id": "u8 sta_id = addsta->sta.sta_id;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 84,
    "critical_vars": [
      "ret"
    ],
    "function": "iwl_process_add_sta_resp",
    "filename": "linux/CVE-2012-6712/CVE-2012-6712_CWE-119_2da424b0773cea3db47e1e81db71eeebde8269d4_iwl-agn-sta.c.diff",
    "function_code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tret = iwl_sta_ucode_activate(priv, sta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "ret": "int ret = -EIO;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1026,
    "critical_vars": [
      "devname",
      "drvname"
    ],
    "function": "dvb_usbv2_disconnect",
    "filename": "linux/CVE-2017-8064/CVE-2017-8064_CWE-119_005145378c9ad7575a01b6ce1ba118fb427f583a_dvb_usb_core.c.diff",
    "function_code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\n\tconst char *drvname = d->name;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tpr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\n\t\tKBUILD_MODNAME, drvname, devname);\n\tkfree(devname);\n}",
    "label": "False",
    "variable_definitions": {
      "devname": "const char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);",
      "drvname": "const char *drvname = d->name;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 779,
    "critical_vars": [
      "i"
    ],
    "function": "catc_probe",
    "filename": "linux/CVE-2017-8070/CVE-2017-8070_CWE-119_2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478_catc.c.diff",
    "function_code": "static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint i, pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\tinit_timer(&catc->timer);\n\tcatc->timer.data = (long) catc;\n\tcatc->timer.function = catc_stats_timer;\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) || \n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */\n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 && \n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\t\t\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\t\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\ti = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, &i, 4);\n\t\ti = 0x87654321;\t\n\t\tcatc_write_mem(catc, 0xfa80, &i, 4);\n\t\tcatc_read_mem(catc, 0x7a80, &i, 4);\n\t  \n\t\tswitch (i) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\t  \n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\t\t\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\t\t\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\t\t\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\t\t\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "i": "int i, pktsz, ret;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 139,
    "critical_vars": [
      "error"
    ],
    "function": "bat_socket_read",
    "filename": "linux/CVE-2011-4604/CVE-2011-4604_CWE-119_b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c_icmp_socket.c.diff",
    "function_code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
    "label": "True",
    "variable_definitions": {
      "error": "int error;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 139,
    "critical_vars": [
      "packet_len"
    ],
    "function": "bat_socket_read",
    "filename": "linux/CVE-2011-4604/CVE-2011-4604_CWE-119_b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c_icmp_socket.c.diff",
    "function_code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\tpacket_len = min(count, socket_packet->icmp_len);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\n\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
    "label": "False",
    "variable_definitions": {
      "packet_len": "size_t packet_len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 393,
    "critical_vars": [
      "data_len"
    ],
    "function": "oz_usb_rx",
    "filename": "linux/CVE-2015-4002/CVE-2015-4002_CWE-119_d114b9fe78c8d6fc6e70808c2092aa307c36dc8e_ozusbsvc1.c.diff",
    "function_code": "void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)\n{\n\tstruct oz_usb_hdr *usb_hdr = (struct oz_usb_hdr *)(elt + 1);\n\tstruct oz_usb_ctx *usb_ctx;\n\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tusb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB];\n\tif (usb_ctx)\n\t\toz_usb_get(usb_ctx);\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tif (usb_ctx == NULL)\n\t\treturn; /* Context has gone so nothing to do. */\n\tif (usb_ctx->stopped)\n\t\tgoto done;\n\t/* If sequence number is non-zero then check it is not a duplicate.\n\t * Zero sequence numbers are always accepted.\n\t */\n\tif (usb_hdr->elt_seq_num != 0) {\n\t\tif (((usb_ctx->rx_seq_num - usb_hdr->elt_seq_num) & 0x80) == 0)\n\t\t\t/* Reject duplicate element. */\n\t\t\tgoto done;\n\t}\n\tusb_ctx->rx_seq_num = usb_hdr->elt_seq_num;\n\tswitch (usb_hdr->type) {\n\tcase OZ_GET_DESC_RSP: {\n\t\t\tstruct oz_get_desc_rsp *body =\n\t\t\t\t(struct oz_get_desc_rsp *)usb_hdr;\n\t\t\tint data_len = elt->length -\n\t\t\t\t\tsizeof(struct oz_get_desc_rsp) + 1;\n\t\t\tu16 offs = le16_to_cpu(get_unaligned(&body->offset));\n\t\t\tu16 total_size =\n\t\t\t\tle16_to_cpu(get_unaligned(&body->total_size));\n\t\t\toz_dbg(ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\n\");\n\t\t\toz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\t\tbody->rcode, body->data,\n\t\t\t\t\tdata_len, offs, total_size);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_CONFIG_RSP: {\n\t\t\tstruct oz_set_config_rsp *body =\n\t\t\t\t(struct oz_set_config_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_INTERFACE_RSP: {\n\t\t\tstruct oz_set_interface_rsp *body =\n\t\t\t\t(struct oz_set_interface_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport,\n\t\t\t\tbody->req_id, body->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_VENDOR_CLASS_RSP: {\n\t\t\tstruct oz_vendor_class_rsp *body =\n\t\t\t\t(struct oz_vendor_class_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, body->data, elt->length-\n\t\t\t\tsizeof(struct oz_vendor_class_rsp)+1);\n\t\t}\n\t\tbreak;\n\tcase OZ_USB_ENDPOINT_DATA:\n\t\toz_usb_handle_ep_data(usb_ctx, usb_hdr, elt->length);\n\t\tbreak;\n\t}\ndone:\n\toz_usb_put(usb_ctx);\n}",
    "label": "True",
    "variable_definitions": {
      "data_len": "int data_len = elt->length - sizeof(struct oz_get_desc_rsp) + 1;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 393,
    "critical_vars": [
      "total_size",
      "offs"
    ],
    "function": "oz_usb_rx",
    "filename": "linux/CVE-2015-4002/CVE-2015-4002_CWE-119_d114b9fe78c8d6fc6e70808c2092aa307c36dc8e_ozusbsvc1.c.diff",
    "function_code": "void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)\n{\n\tstruct oz_usb_hdr *usb_hdr = (struct oz_usb_hdr *)(elt + 1);\n\tstruct oz_usb_ctx *usb_ctx;\n\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tusb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB];\n\tif (usb_ctx)\n\t\toz_usb_get(usb_ctx);\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tif (usb_ctx == NULL)\n\t\treturn; /* Context has gone so nothing to do. */\n\tif (usb_ctx->stopped)\n\t\tgoto done;\n\t/* If sequence number is non-zero then check it is not a duplicate.\n\t * Zero sequence numbers are always accepted.\n\t */\n\tif (usb_hdr->elt_seq_num != 0) {\n\t\tif (((usb_ctx->rx_seq_num - usb_hdr->elt_seq_num) & 0x80) == 0)\n\t\t\t/* Reject duplicate element. */\n\t\t\tgoto done;\n\t}\n\tusb_ctx->rx_seq_num = usb_hdr->elt_seq_num;\n\tswitch (usb_hdr->type) {\n\tcase OZ_GET_DESC_RSP: {\n\t\t\tstruct oz_get_desc_rsp *body =\n\t\t\t\t(struct oz_get_desc_rsp *)usb_hdr;\n\t\t\tu16 offs, total_size;\n\t\t\tu8 data_len;\n\n\t\t\tif (elt->length < sizeof(struct oz_get_desc_rsp) - 1)\n\t\t\t\tbreak;\n\t\t\tdata_len = elt->length -\n\t\t\t\t\t(sizeof(struct oz_get_desc_rsp) - 1);\n\t\t\toffs = le16_to_cpu(get_unaligned(&body->offset));\n\t\t\ttotal_size =\n\t\t\t\tle16_to_cpu(get_unaligned(&body->total_size));\n\t\t\toz_dbg(ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\n\");\n\t\t\toz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\t\tbody->rcode, body->data,\n\t\t\t\t\tdata_len, offs, total_size);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_CONFIG_RSP: {\n\t\t\tstruct oz_set_config_rsp *body =\n\t\t\t\t(struct oz_set_config_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_INTERFACE_RSP: {\n\t\t\tstruct oz_set_interface_rsp *body =\n\t\t\t\t(struct oz_set_interface_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport,\n\t\t\t\tbody->req_id, body->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_VENDOR_CLASS_RSP: {\n\t\t\tstruct oz_vendor_class_rsp *body =\n\t\t\t\t(struct oz_vendor_class_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, body->data, elt->length-\n\t\t\t\tsizeof(struct oz_vendor_class_rsp)+1);\n\t\t}\n\t\tbreak;\n\tcase OZ_USB_ENDPOINT_DATA:\n\t\toz_usb_handle_ep_data(usb_ctx, usb_hdr, elt->length);\n\t\tbreak;\n\t}\ndone:\n\toz_usb_put(usb_ctx);\n}",
    "label": "False",
    "variable_definitions": {
      "total_size": "u16 offs, total_size;",
      "offs": "u16 offs, total_size;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 520,
    "critical_vars": [
      "uref->usage_index",
      "cmd",
      "uref_multi->num_values"
    ],
    "function": "hiddev_ioctl_usage",
    "filename": "linux/CVE-2016-5829/CVE-2016-5829_CWE-119_93a2001bdfd5376c3dc2158653034c20392d15c5_hiddev.c.diff",
    "function_code": "static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_usage_ref_multi *uref_multi = NULL;\n\tstruct hiddev_usage_ref *uref;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\n\turef_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\n\tif (!uref_multi)\n\t\treturn -ENOMEM;\n\turef = &uref_multi->uref;\n\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\tif (copy_from_user(uref_multi, user_arg,\n\t\t\t\t   sizeof(*uref_multi)))\n\t\t\tgoto fault;\n\t} else {\n\t\tif (copy_from_user(uref, user_arg, sizeof(*uref)))\n\t\t\tgoto fault;\n\t}\n\n\tswitch (cmd) {\n\tcase HIDIOCGUCODE:\n\t\trinfo.report_type = uref->report_type;\n\t\trinfo.report_id = uref->report_id;\n\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\tgoto inval;\n\n\t\tif (uref->field_index >= report->maxfield)\n\t\t\tgoto inval;\n\n\t\tfield = report->field[uref->field_index];\n\t\tif (uref->usage_index >= field->maxusage)\n\t\t\tgoto inval;\n\n\t\turef->usage_code = field->usage[uref->usage_index].hid;\n\n\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\tgoto fault;\n\n\t\tgoto goodreturn;\n\n\tdefault:\n\t\tif (cmd != HIDIOCGUSAGE &&\n\t\t    cmd != HIDIOCGUSAGES &&\n\t\t    uref->report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tgoto inval;\n\n\t\tif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\n\t\t\tfield = hiddev_lookup_usage(hid, uref);\n\t\t\tif (field == NULL)\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\trinfo.report_type = uref->report_type;\n\t\t\trinfo.report_id = uref->report_id;\n\t\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\t\tgoto inval;\n\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\n\t\t\telse if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t\t\t (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t\t\t  uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCGCOLLECTIONINDEX:\n\t\t\ti = field->usage[uref->usage_index].collection_index;\n\t\t\tkfree(uref_multi);\n\t\t\treturn i;\n\t\tcase HIDIOCGUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\turef_multi->values[i] =\n\t\t\t\t    field->value[uref->usage_index + i];\n\t\t\tif (copy_to_user(user_arg, uref_multi,\n\t\t\t\t\t sizeof(*uref_multi)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\tfield->value[uref->usage_index + i] =\n\t\t\t\t    uref_multi->values[i];\n\t\t\tgoto goodreturn;\n\t\t}\n\ngoodreturn:\n\t\tkfree(uref_multi);\n\t\treturn 0;\nfault:\n\t\tkfree(uref_multi);\n\t\treturn -EFAULT;\ninval:\n\t\tkfree(uref_multi);\n\t\treturn -EINVAL;\n\t}\n}",
    "label": "True",
    "variable_definitions": {
      "uref->usage_index": "Definition not found",
      "cmd": "unsigned int cmd",
      "uref_multi->num_values": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 521,
    "critical_vars": [
      "uref->usage_index",
      "cmd",
      "uref_multi->num_values"
    ],
    "function": "hiddev_ioctl_usage",
    "filename": "linux/CVE-2016-5829/CVE-2016-5829_CWE-119_93a2001bdfd5376c3dc2158653034c20392d15c5_hiddev.c.diff",
    "function_code": "static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_usage_ref_multi *uref_multi = NULL;\n\tstruct hiddev_usage_ref *uref;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\n\turef_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\n\tif (!uref_multi)\n\t\treturn -ENOMEM;\n\turef = &uref_multi->uref;\n\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\tif (copy_from_user(uref_multi, user_arg,\n\t\t\t\t   sizeof(*uref_multi)))\n\t\t\tgoto fault;\n\t} else {\n\t\tif (copy_from_user(uref, user_arg, sizeof(*uref)))\n\t\t\tgoto fault;\n\t}\n\n\tswitch (cmd) {\n\tcase HIDIOCGUCODE:\n\t\trinfo.report_type = uref->report_type;\n\t\trinfo.report_id = uref->report_id;\n\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\tgoto inval;\n\n\t\tif (uref->field_index >= report->maxfield)\n\t\t\tgoto inval;\n\n\t\tfield = report->field[uref->field_index];\n\t\tif (uref->usage_index >= field->maxusage)\n\t\t\tgoto inval;\n\n\t\turef->usage_code = field->usage[uref->usage_index].hid;\n\n\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\tgoto fault;\n\n\t\tgoto goodreturn;\n\n\tdefault:\n\t\tif (cmd != HIDIOCGUSAGE &&\n\t\t    cmd != HIDIOCGUSAGES &&\n\t\t    uref->report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tgoto inval;\n\n\t\tif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\n\t\t\tfield = hiddev_lookup_usage(hid, uref);\n\t\t\tif (field == NULL)\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\trinfo.report_type = uref->report_type;\n\t\t\trinfo.report_id = uref->report_id;\n\t\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\t\tgoto inval;\n\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tif ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t     uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\tgoto inval;\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCGCOLLECTIONINDEX:\n\t\t\ti = field->usage[uref->usage_index].collection_index;\n\t\t\tkfree(uref_multi);\n\t\t\treturn i;\n\t\tcase HIDIOCGUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\turef_multi->values[i] =\n\t\t\t\t    field->value[uref->usage_index + i];\n\t\t\tif (copy_to_user(user_arg, uref_multi,\n\t\t\t\t\t sizeof(*uref_multi)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\tfield->value[uref->usage_index + i] =\n\t\t\t\t    uref_multi->values[i];\n\t\t\tgoto goodreturn;\n\t\t}\n\ngoodreturn:\n\t\tkfree(uref_multi);\n\t\treturn 0;\nfault:\n\t\tkfree(uref_multi);\n\t\treturn -EFAULT;\ninval:\n\t\tkfree(uref_multi);\n\t\treturn -EINVAL;\n\t}\n}",
    "label": "False",
    "variable_definitions": {
      "uref->usage_index": "Definition not found",
      "cmd": "unsigned int cmd",
      "uref_multi->num_values": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 648,
    "critical_vars": [
      "vma->vm_ops"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-6763/CVE-2013-6763_CWE-119_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "True",
    "variable_definitions": {
      "vma->vm_ops": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 137,
    "critical_vars": [
      "iter"
    ],
    "function": "netlbl_cipsov4_add_common",
    "filename": "linux/CVE-2007-6762/CVE-2007-6762_CWE-119_2a2f11c227bdf292b3a2900ad04139d301b56ac4_netlabel_cipso_v4.c.diff",
    "function_code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "iter": "u32 iter = 0;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 133,
    "line_new": 133,
    "critical_vars": [
      "iter"
    ],
    "function": "netlbl_cipsov4_add_common",
    "filename": "linux/CVE-2007-6762/CVE-2007-6762_CWE-119_2a2f11c227bdf292b3a2900ad04139d301b56ac4_netlabel_cipso_v4.c.diff",
    "function_code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "iter": "u32 iter = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1041,
    "critical_vars": [
      "err"
    ],
    "function": "ip6_ufo_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "err": "int err;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1018,
    "critical_vars": [
      "fhdr"
    ],
    "function": "ip6_ufo_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "label": "False",
    "variable_definitions": {
      "fhdr": "struct frag_hdr fhdr;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1230,
    "critical_vars": [
      "cork->length"
    ],
    "function": "ip6_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "cork->length": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1221,
    "critical_vars": [
      "dontfrag",
      "sk->sk_protocol",
      "length"
    ],
    "function": "ip6_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tif ((length > mtu) && dontfrag && (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t\t\t   sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tskb = skb_peek_tail(&sk->sk_write_queue);\n\tcork->length += length;\n\tif (((length > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}",
    "label": "False",
    "variable_definitions": {
      "dontfrag": "int dontfrag",
      "sk->sk_protocol": "Definition not found",
      "length": "int length"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 188,
    "critical_vars": [
      "desc->reslength"
    ],
    "function": "wdm_in_callback",
    "filename": "linux/CVE-2013-1860/CVE-2013-1860_CWE-119_c0f5ecee4e741667b2493c742b60b6218d40b3aa_cdc-wdm.c.diff",
    "function_code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "label": "True",
    "variable_definitions": {
      "desc->reslength": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 159,
    "critical_vars": [
      "length"
    ],
    "function": "wdm_in_callback",
    "filename": "linux/CVE-2013-1860/CVE-2013-1860_CWE-119_c0f5ecee4e741667b2493c742b60b6218d40b3aa_cdc-wdm.c.diff",
    "function_code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "label": "False",
    "variable_definitions": {
      "length": "int length = urb->actual_length;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 810,
    "critical_vars": [
      "curr"
    ],
    "function": "fallocate_chunk",
    "filename": "linux/CVE-2011-4098/CVE-2011-4098_CWE-119_64dd153c83743af81f20924c6343652d731eeecb_file.c.diff",
    "function_code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\n\tmark_inode_dirty(inode);\n\n\tbrelse(dibh);\n\nout:\n\treturn error;\n}",
    "label": "True",
    "variable_definitions": {
      "curr": "pgoff_t curr;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 693,
    "critical_vars": [
      "len"
    ],
    "function": "fallocate_chunk",
    "filename": "linux/CVE-2011-4098/CVE-2011-4098_CWE-119_64dd153c83743af81f20924c6343652d731eeecb_file.c.diff",
    "function_code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))\n\t\ti_size_write(inode, offset + len);\n\n\tmark_inode_dirty(inode);\n\nout:\n\tbrelse(dibh);\n\treturn error;\n}",
    "label": "False",
    "variable_definitions": {
      "len": "loff_t len,"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3414,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_trigger_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;",
    "label": "True",
    "variable_definitions": {
      "request->ssids[i].ssid_len": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3409,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_trigger_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;",
    "label": "False",
    "variable_definitions": {
      "request->ssids[i].ssid_len": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3582,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_start_sched_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;",
    "label": "True",
    "variable_definitions": {
      "request->ssids[i].ssid_len": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3575,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_start_sched_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;",
    "label": "False",
    "variable_definitions": {
      "request->ssids[i].ssid_len": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1075,
    "critical_vars": [
      "fork_nctx"
    ],
    "function": "userfaultfd_ctx_read",
    "filename": "linux/CVE-2017-15126/CVE-2017-15126_CWE-119_384632e67e0829deb8015ee6ad916b180049d252_userfaultfd.c.diff",
    "function_code": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "fork_nctx": "struct userfaultfd_ctx *fork_nctx = NULL;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 232,
    "critical_vars": [
      "s->target_offset"
    ],
    "function": "get_chainname_rulenum",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "s->target_offset": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 233,
    "critical_vars": [
      "s"
    ],
    "function": "get_chainname_rulenum",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "s": "const struct ip6t_entry *s"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 479,
    "critical_vars": [
      "e->target_offset"
    ],
    "function": "mark_source_chains",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||\n\t\t\t    visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
    "label": "True",
    "variable_definitions": {
      "e->target_offset": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 479,
    "critical_vars": [
      "e"
    ],
    "function": "mark_source_chains",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
    "label": "False",
    "variable_definitions": {
      "e": "struct arpt_entry *e = (struct arpt_entry *)(entry0 + pos);"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 717,
    "critical_vars": [
      "e"
    ],
    "function": "check_underflow",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
    "label": "False",
    "variable_definitions": {
      "e": "const struct arpt_entry *e"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 580,
    "critical_vars": [
      "val"
    ],
    "function": "sock_setsockopt",
    "filename": "linux/CVE-2012-6704/CVE-2012-6704_CWE-119_82981930125abfd39d7c8378a9cfdf5e1be2002b_sock.c.diff",
    "function_code": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "val": "int val;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 718,
    "line_new": 718,
    "critical_vars": [
      "sk->sk_sndbuf"
    ],
    "function": "sock_setsockopt",
    "filename": "linux/CVE-2016-9793/CVE-2016-9793_CWE-119_b98b0bc8c431e3ceb4b26b0dfc8db509518fb290_sock.c.diff",
    "function_code": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "sk->sk_sndbuf": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 651,
    "critical_vars": [
      "buffer"
    ],
    "function": "atusb_get_and_show_revision",
    "filename": "linux/CVE-2017-5548/CVE-2017-5548_CWE-119_05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655_atusb.c.diff",
    "function_code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "buffer": "unsigned char *buffer;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 690,
    "critical_vars": [
      "len"
    ],
    "function": "wvlan_uil_put_info",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */",
    "label": "False",
    "variable_definitions": {
      "len": "size_t\t\t\tlen;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1797,
    "critical_vars": [
      "extra",
      "wrqu->data.length",
      "lp->StationName"
    ],
    "function": "wvlan_set_station_nickname",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */",
    "label": "True",
    "variable_definitions": {
      "extra": "char *extra",
      "wrqu->data.length": "Definition not found",
      "lp->StationName": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1788,
    "critical_vars": [
      "len"
    ],
    "function": "wvlan_set_station_nickname",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tsize_t len;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\n\tstrlcpy(lp->StationName, extra, len);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */",
    "label": "False",
    "variable_definitions": {
      "len": "size_t len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 1610,
    "critical_vars": [
      "resp"
    ],
    "function": "create_qp_common",
    "filename": "linux/CVE-2018-20855/CVE-2018-20855_CWE-119_0625b4ba1a5d4703c7fb01c497bd6c156908af00_qp.c.diff",
    "function_code": "static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_create_qp_resp resp;\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&qp->mutex);\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr->create_flags &\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n\t\t    (init_attr->qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd && pd->uobject) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\t\t&ucmd, udata->inlen, &uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\n\t\tqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp->tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr->qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev->mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp->underlay_qpn = init_attr->source_qpn;\n\t\t}\n\t} else {\n\t\tqp->wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\n\t\t\t  qp, (pd && pd->uobject) ? &ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd->uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, \"invalid rq params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count > max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr->create_flags &\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n\t\t\t\t\t     &resp, &inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp->flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"create qp failed\\n\");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}",
    "label": "True",
    "variable_definitions": {
      "resp": "struct mlx5_ib_create_qp_resp resp;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1610,
    "critical_vars": [
      "resp"
    ],
    "function": "create_qp_common",
    "filename": "linux/CVE-2018-20855/CVE-2018-20855_CWE-119_0625b4ba1a5d4703c7fb01c497bd6c156908af00_qp.c.diff",
    "function_code": "static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_create_qp_resp resp = {};\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&qp->mutex);\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr->create_flags &\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n\t\t    (init_attr->qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd && pd->uobject) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\t\t&ucmd, udata->inlen, &uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\n\t\tqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp->tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr->qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev->mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp->underlay_qpn = init_attr->source_qpn;\n\t\t}\n\t} else {\n\t\tqp->wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\n\t\t\t  qp, (pd && pd->uobject) ? &ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd->uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, \"invalid rq params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count > max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr->create_flags &\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n\t\t\t\t\t     &resp, &inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp->flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"create qp failed\\n\");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}",
    "label": "False",
    "variable_definitions": {
      "resp": "struct mlx5_ib_create_qp_resp resp = {};"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1545,
    "critical_vars": [
      "unix_sock_count"
    ],
    "function": "unix_attach_fds",
    "filename": "linux/CVE-2013-4312/CVE-2013-4312_CWE-119_712f4aad406bb1ed67f3f98d04c044191f0ff593_af_unix.c.diff",
    "function_code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t/*\n\t * Need to duplicate file references for the sake of garbage\n\t * collection.  Otherwise a socket in the fps might become a\n\t * candidate for GC while the skb is not yet queued.\n\t */\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tif (unix_sock_count) {\n\t\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\t\tunix_inflight(scm->fp->fp[i]);\n\t}\n\treturn max_level;\n}",
    "label": "True",
    "variable_definitions": {
      "unix_sock_count": "int unix_sock_count = 0;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1539,
    "critical_vars": [
      "current"
    ],
    "function": "unix_attach_fds",
    "filename": "linux/CVE-2013-4312/CVE-2013-4312_CWE-119_712f4aad406bb1ed67f3f98d04c044191f0ff593_af_unix.c.diff",
    "function_code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t/*\n\t * Need to duplicate file references for the sake of garbage\n\t * collection.  Otherwise a socket in the fps might become a\n\t * candidate for GC while the skb is not yet queued.\n\t */\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n\treturn max_level;\n}",
    "label": "False",
    "variable_definitions": {
      "current": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 761,
    "critical_vars": [
      "key",
      "extra_response->key"
    ],
    "function": "iscsi_add_notunderstood_response",
    "filename": "linux/CVE-2013-2850/CVE-2013-2850_CWE-119_cea4dcfdad926a27a18e188720efe0f2c9403456_iscsi_target_parameters.c.diff",
    "function_code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "key": "char *key,",
      "extra_response->key": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 761,
    "critical_vars": [
      "key",
      "extra_response->key"
    ],
    "function": "iscsi_add_notunderstood_response",
    "filename": "linux/CVE-2013-2850/CVE-2013-2850_CWE-119_cea4dcfdad926a27a18e188720efe0f2c9403456_iscsi_target_parameters.c.diff",
    "function_code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "key": "char *key,",
      "extra_response->key": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 14607,
    "critical_vars": [
      "len"
    ],
    "function": "tg3_read_vpd",
    "filename": "linux/CVE-2013-1929/CVE-2013-1929_CWE-119_715230a44310a8cf66fbfb5a46f9a62a9b2de424_tg3.c.diff",
    "function_code": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end)\n\t\t\tgoto partno;\n\n\t\tif (len >= sizeof(tp->fw_ver))\n\t\t\tlen = sizeof(tp->fw_ver) - 1;\n\t\tmemset(tp->fw_ver, 0, sizeof(tp->fw_ver));\n\t\tsnprintf(tp->fw_ver, sizeof(tp->fw_ver), \"%.*s bc \", len,\n\t\t\t &vpd_data[j]);\n\t}\n\npartno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}",
    "label": "False",
    "variable_definitions": {
      "len": "unsigned int block_end, rosize, len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 471,
    "critical_vars": [
      "ret"
    ],
    "function": "GetCode_",
    "filename": "visit_repo_url/CVE-2014-9709/CVE-2014-9709_CWE-119_47eb44b2e90ca88a08dca9f9a1aa9041e9587f43_gd_gif_in.c.diff",
    "function_code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t\t/* Oh well */\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t}\n\n\tscd->curbit += code_size;\n\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "ret": "int i, j, ret;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 473,
    "critical_vars": [
      "i"
    ],
    "function": "GetCode_",
    "filename": "visit_repo_url/CVE-2014-9709/CVE-2014-9709_CWE-119_47eb44b2e90ca88a08dca9f9a1aa9041e9587f43_gd_gif_in.c.diff",
    "function_code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t\t/* Oh well */\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tif (i < CSD_BUF_SIZE * 8) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tscd->curbit += code_size;\n\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "i": "int i, j, ret;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 485,
    "critical_vars": [
      "buf"
    ],
    "function": "read_attribute",
    "filename": "visit_repo_url/CVE-2017-5337/CVE-2017-5337_CWE-119_94fcf1645ea17223237aaf8d19132e004afddc1a_read-packet.c.diff",
    "function_code": "read_attribute(cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr,\n\t       int name_size)\n{\n\tconst byte *p;\n\tbyte *buf;\n\tsize_t len, nread;\n\tcdk_error_t rc;\n\n\tif (!inp || !attr || !pktlen)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_attribute: %d octets\\n\",\n\t\t\t\t  (int) pktlen);\n\n\t_gnutls_str_cpy(attr->name, name_size, ATTRIBUTE);\n\tattr->len = MIN(name_size, sizeof(ATTRIBUTE) - 1);\n\n\tbuf = cdk_calloc(1, pktlen);\n\tif (!buf)\n\t\treturn CDK_Out_Of_Core;\n\trc = stream_read(inp, buf, pktlen, &nread);\n\tif (rc) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp = buf;\n\tlen = *p++;\n\tpktlen--;\n\tif (len == 255) {\n\t\tlen = _cdk_buftou32(p);\n\t\tp += 4;\n\t\tpktlen -= 4;\n\t} else if (len >= 192) {\n\t\tif (pktlen < 2) {\n\t\t\tcdk_free(buf);\n\t\t\treturn CDK_Inv_Packet;\n\t\t}\n\t\tlen = ((len - 192) << 8) + *p + 192;\n\t\tp++;\n\t\tpktlen--;\n\t}\n\n\tif (*p != 1) {\t\t/* Currently only 1, meaning an image, is defined. */\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp++;\n\tlen--;\n\n\tif (len >= pktlen) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tattr->attrib_img = cdk_calloc(1, len);\n\tif (!attr->attrib_img) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Out_Of_Core;\n\t}\n\tattr->attrib_len = len;\n\tmemcpy(attr->attrib_img, p, len);\n\tcdk_free(buf);\n\treturn rc;\n}",
    "label": "True",
    "variable_definitions": {
      "buf": "byte *buf;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 486,
    "critical_vars": [
      "rc"
    ],
    "function": "read_attribute",
    "filename": "visit_repo_url/CVE-2017-5337/CVE-2017-5337_CWE-119_94fcf1645ea17223237aaf8d19132e004afddc1a_read-packet.c.diff",
    "function_code": "read_attribute(cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr,\n\t       int name_size)\n{\n\tconst byte *p;\n\tbyte *buf;\n\tsize_t len, nread;\n\tcdk_error_t rc;\n\n\tif (!inp || !attr || !pktlen)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_attribute: %d octets\\n\",\n\t\t\t\t  (int) pktlen);\n\n\t_gnutls_str_cpy(attr->name, name_size, ATTRIBUTE);\n\tattr->len = MIN(name_size, sizeof(ATTRIBUTE) - 1);\n\n\tbuf = cdk_calloc(1, pktlen);\n\tif (!buf)\n\t\treturn CDK_Out_Of_Core;\n\trc = stream_read(inp, buf, pktlen, &nread);\n\tif (rc) {\n\t\tgnutls_assert();\n\t\trc = CDK_Inv_Packet;\n\t\tgoto error;\n\t}\n\n\tp = buf;\n\tlen = *p++;\n\tpktlen--;\n\n\tif (len == 255) {\n\t\tif (pktlen < 4) {\n\t\t\tgnutls_assert();\n\t\t\trc = CDK_Inv_Packet;\n\t\t\tgoto error;\n\t\t}\n\n\t\tlen = _cdk_buftou32(p);\n\t\tp += 4;\n\t\tpktlen -= 4;\n\t} else if (len >= 192) {\n\t\tif (pktlen < 2) {\n\t\t\tgnutls_assert();\n\t\t\trc = CDK_Inv_Packet;\n\t\t\tgoto error;\n\t\t}\n\n\t\tlen = ((len - 192) << 8) + *p + 192;\n\t\tp++;\n\t\tpktlen--;\n\t}\n\n\tif (!len || *p != 1) {\t\t/* Currently only 1, meaning an image, is defined. */\n\t\trc = CDK_Inv_Packet;\n\t\tgoto error;\n\t}\n\n\tp++;\n\tlen--;\n\n\tif (len >= pktlen) {\n\t\trc = CDK_Inv_Packet;\n\t\tgoto error;\n\t}\n\n\tattr->attrib_img = cdk_calloc(1, len);\n\tif (!attr->attrib_img) {\n\t\trc = CDK_Out_Of_Core;\n\t\tgoto error;\n\t}\n\n\tattr->attrib_len = len;\n\tmemcpy(attr->attrib_img, p, len);\n\tcdk_free(buf);\n\treturn rc;\n\n error:\n\tcdk_free(buf);\n\treturn rc;\n}",
    "label": "False",
    "variable_definitions": {
      "rc": "cdk_error_t rc;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 521,
    "critical_vars": [
      "rc"
    ],
    "function": "cdk_pk_get_keyid",
    "filename": "visit_repo_url/CVE-2017-5336/CVE-2017-5336_CWE-119_5140422e0d7319a8e2fe07f02cbcafc4d6538732_pubkey.c.diff",
    "function_code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tint rc;\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\trc = _gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tif (rc < 0 || n < 8) {\n\t\t\t\tkeyid[0] = keyid[1] = (u32)-1;\n\t\t\t\treturn (u32)-1;\n\t\t\t}\n\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\n\treturn lowbits;\n}",
    "label": "False",
    "variable_definitions": {
      "rc": "int rc;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 4786,
    "critical_vars": [
      "err_msg"
    ],
    "function": "dbd_bind_ph",
    "filename": "DBD-mysql/CVE-2016-1246/CVE-2016-1246_CWE-119_7c164a0c86cec6ee95df1d141e67b0e85dfdefd2_dbdimp.c.diff",
    "function_code": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char err_msg[64];\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n  IV tmp;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upon binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      sprintf(err_msg,\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n\n          tmp = SvIV(imp_sth->params[idx].value);\n          if (tmp > INT32_MAX)\n\t        croak(\"Could not bind %ld: Integer too large for MYSQL_TYPE_LONG\", tmp);\n          imp_sth->fbind[idx].numeric_val.lval= tmp;\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%\"PRId32\"<- IS A INT NUMBER\\n\",\n                          (int) sql_type, *(int32_t *)buffer);\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%f<- IS A FLOAT NUMBER\\n\",\n                          (int) sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %d, buffertype=%d\\n\", (int) sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %d ->length %d<- IS A STRING or BLOB\\n\",\n                        (int) sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      /* Note: this looks like being another bug:\n       * if type of parameter N changes, then a bind is triggered\n       * with an only partially filled bind structure ??\n       */\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%d\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, (int) sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has not been called */\n    if (imp_sth->has_been_bound == 0)\n    {\n      imp_sth->bind[idx].buffer_type= buffer_type;\n      imp_sth->bind[idx].buffer= buffer;\n      imp_sth->bind[idx].buffer_length= buffer_length;\n    }\n    else /* prepare has been called */\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}",
    "label": "True",
    "variable_definitions": {
      "err_msg": "char err_msg[64];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 790,
    "critical_vars": [
      "entry"
    ],
    "function": "SPL_METHOD",
    "filename": "php-src/CVE-2016-7480/CVE-2016-7480_CWE-119_61cdd1255d5b9c8453be71aacbbf682796ac77d4_spl_observer.c.diff",
    "function_code": "SPL_METHOD(SplObjectStorage, unserialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tchar *buf;\n\tsize_t buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval entry, inf;\n\tzval *pcount, *pmembers;\n\tspl_SplObjectStorageElement *element;\n\tzend_long count;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpcount = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\t--p; /* for ';' */\n\tcount = Z_LVAL_P(pcount);\n\n\twhile (count-- > 0) {\n\t\tspl_SplObjectStorageElement *pelement;\n\t\tzend_string *hash;\n\n\t\tif (*p != ';') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t++p;\n\t\tif(*p != 'O' && *p != 'C' && *p != 'r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t/* store reference to allow cross-references between different elements */\n\t\tif (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (Z_TYPE(entry) != IS_OBJECT) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (*p == ',') { /* new version has inf */\n\t\t\t++p;\n\t\t\tif (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) {\n\t\t\t\tzval_ptr_dtor(&entry);\n\t\t\t\tgoto outexcept;\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_UNDEF(&inf);\n\t\t}\n\n\t\thash = spl_object_storage_get_hash(intern, getThis(), &entry);\n\t\tif (!hash) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tpelement = spl_object_storage_get(intern, hash);\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\tif (pelement) {\n\t\t\tif (!Z_ISUNDEF(pelement->inf)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->inf);\n\t\t\t}\n\t\t\tif (!Z_ISUNDEF(pelement->obj)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->obj);\n\t\t\t}\n\t\t}\n\t\telement = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf);\n\t\tvar_replace(&var_hash, &entry, &element->obj);\n\t\tvar_replace(&var_hash, &inf, &element->inf);\n\t\tzval_ptr_dtor(&entry);\n\t\tZVAL_UNDEF(&entry);\n\t\tzval_ptr_dtor(&inf);\n\t\tZVAL_UNDEF(&inf);\n\t}\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpmembers = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tgoto outexcept;\n\t}\n\n\t/* copy members */\n\tobject_properties_load(&intern->std, Z_ARRVAL_P(pmembers));\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Error at offset %pd of %d bytes\", (zend_long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */",
    "label": "True",
    "variable_definitions": {
      "entry": "zval entry, inf;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 509,
    "critical_vars": [
      "ll"
    ],
    "function": "*php_parserr",
    "filename": "php-src/CVE-2014-3597/CVE-2014-3597_CWE-119_2fefae47716d501aec41c1102f3fd4531f070b05_dns.c.diff",
    "function_code": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n\t\t\t\t\n\t\t\t\twhile (ll < dlen) {\n\t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (ll + 1);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n\t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n\t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}",
    "label": "True",
    "variable_definitions": {
      "ll": "int ll = 0;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 428,
    "line_new": 434,
    "critical_vars": [
      "n"
    ],
    "function": "*php_parserr",
    "filename": "php-src/CVE-2014-3597/CVE-2014-3597_CWE-119_2fefae47716d501aec41c1102f3fd4531f070b05_dns.c.diff",
    "function_code": "static u_char *php_parserr(u_char *cp, u_char *end, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, end, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tCHECKCP(10);\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tCHECKCP(dlen);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tCHECKCP(4);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tCHECKCP(2);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tCHECKCP(1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tCHECKCP(1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint l1 = 0, l2 = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n\t\t\t\t\n\t\t\t\twhile (l1 < dlen) {\n\t\t\t\t\tn = cp[l1];\n\t\t\t\t\tif ((l1 + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (l1 + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (n) {\n\t\t\t\t\t\tmemcpy(tp + l2 , cp + l1 + 1, n);\n\t\t\t\t\t\tadd_next_index_stringl(entries, cp + l1 + 1, n, 1);\n\t\t\t\t\t}\n\t\t\t\t\tl1 = l1 + n + 1;\n\t\t\t\t\tl2 = l2 + n;\n\t\t\t\t}\n\t\t\t\ttp[l2] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, l2, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tCHECKCP(5*4);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tCHECKCP(8*2);\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tCHECKCP(1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tCHECKCP(2);\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tCHECKCP(3*2);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tCHECKCP(2*2);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\n\t\t\tCHECKCP(1);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}",
    "label": "False",
    "variable_definitions": {
      "n": "long n, i;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 300,
    "critical_vars": [
      "pkt->cnt"
    ],
    "function": "dumpppp",
    "filename": "ppp/CVE-2022-4603/CVE-2022-4603_CWE-119_a75fb7b198eed50d769c80c36629f38346882cbf_pppdump.c.diff",
    "function_code": "dumpppp(f)\n    FILE *f;\n{\n    int c, n, k;\n    int nb, nl, dn, proto, rv;\n    char *dir, *q;\n    unsigned char *p, *r, *endp;\n    unsigned char *d;\n    unsigned short fcs;\n    struct pkt *pkt;\n\n    spkt.cnt = rpkt.cnt = 0;\n    spkt.esc = rpkt.esc = 0;\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    dir = c==1? \"sent\": \"rcvd\";\n\t    pkt = c==1? &spkt: &rpkt;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tswitch (c) {\n\t\tcase EOF:\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    if (spkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete send packet]\\n\",\n\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tif (pkt->cnt >= sizeof(pkt->buf)) {\n\t\t\t    printf(\"%s over-long packet truncated:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    printf(\"\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tfcs = PPP_INITFCS;\n\t\t\tfor (k = 0; k < nb; ++k)\n\t\t\t    fcs = PPP_FCS(fcs, p[k]);\n\t\t\tfcs &= 0xFFFF;\n\t\t\tnb -= 2;\n\t\t\tendp = p + nb;\n\t\t\tr = p;\n\t\t\tif (r[0] == 0xff && r[1] == 3)\n\t\t\t    r += 2;\n\t\t\tif ((r[0] & 1) == 0)\n\t\t\t    ++r;\n\t\t\t++r;\n\t\t\tif (endp - r > mru)\n\t\t\t    printf(\"     ERROR: length (%zd) > MRU (%d)\\n\",\n\t\t\t\t   endp - r, mru);\n\t\t\tif (decompress && fcs == PPP_GOODFCS) {\n\t\t\t    /* See if this is a CCP or compressed packet */\n\t\t\t    d = dbuf;\n\t\t\t    r = p;\n\t\t\t    if (r[0] == 0xff && r[1] == 3) {\n\t\t\t\t*d++ = *r++;\n\t\t\t\t*d++ = *r++;\n\t\t\t    }\n\t\t\t    proto = r[0];\n\t\t\t    if ((proto & 1) == 0)\n\t\t\t\tproto = (proto << 8) + r[1];\n\t\t\t    if (proto == PPP_CCP) {\n\t\t\t\thandle_ccp(pkt, r + 2, endp - r - 2);\n\t\t\t    } else if (proto == PPP_COMP) {\n\t\t\t\tif ((pkt->flags & CCP_ISUP)\n\t\t\t\t    && (pkt->flags & CCP_DECOMP_RUN)\n\t\t\t\t    && pkt->state\n\t\t\t\t    && (pkt->flags & CCP_ERR) == 0) {\n\t\t\t\t    rv = pkt->comp->decompress(pkt->state, r,\n\t\t\t\t\t\t\tendp - r, d, &dn);\n\t\t\t\t    switch (rv) {\n\t\t\t\t    case DECOMP_OK:\n\t\t\t\t\tp = dbuf;\n\t\t\t\t\tnb = d + dn - p;\n\t\t\t\t\tif ((d[0] & 1) == 0)\n\t\t\t\t\t    --dn;\n\t\t\t\t\t--dn;\n\t\t\t\t\tif (dn > mru)\n\t\t\t\t\t    printf(\"     ERROR: decompressed length (%d) > MRU (%d)\\n\", dn, mru);\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_ERROR:\n\t\t\t\t\tprintf(\"     DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_FATALERROR:\n\t\t\t\t\tprintf(\"     FATAL DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_FATALERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } else if (pkt->state\n\t\t\t\t       && (pkt->flags & CCP_DECOMP_RUN)) {\n\t\t\t\tpkt->comp->incomp(pkt->state, r, endp - r);\n\t\t\t    }\n\t\t\t}\n\t\t\tdo {\n\t\t\t    nl = nb < 16? nb: 16;\n\t\t\t    printf(\"%s \", q);\n\t\t\t    for (k = 0; k < nl; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    for (; k < 16; ++k)\n\t\t\t\tprintf(\"   \");\n\t\t\t    printf(\"  \");\n\t\t\t    for (k = 0; k < nl; ++k) {\n\t\t\t\tc = p[k];\n\t\t\t\tputchar((' ' <= c && c <= '~')? c: '.');\n\t\t\t    }\n\t\t\t    printf(\"\\n\");\n\t\t\t    q = \"    \";\n\t\t\t    p += nl;\n\t\t\t    nb -= nl;\n\t\t\t} while (nb > 0);\n\t\t\tif (fcs != PPP_GOODFCS)\n\t\t\t    printf(\"     BAD FCS: (residue = %x)\\n\", fcs);\n\t\t    }\n\t\t    break;\n\t\tcase '}':\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    if (pkt->cnt < sizeof(pkt->buf))\n\t\t\tpkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;\n\t    printf(\"end %s\", dir);\n\t    if (pkt->cnt > 0)\n\t\tprintf(\"  [%d bytes in incomplete packet]\", pkt->cnt);\n\t    printf(\"\\n\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "pkt->cnt": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 781,
    "critical_vars": [
      "s->str",
      "outbuffer"
    ],
    "function": "xmlrpc_char_encode",
    "filename": "atheme/CVE-2016-4478/CVE-2016-4478_CWE-119_87580d767868360d2fed503980129504da84b63e_xmlrpclib.c.diff",
    "function_code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
    "label": "True",
    "variable_definitions": {
      "s->str": "Definition not found",
      "outbuffer": "char *outbuffer"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 780,
    "critical_vars": [
      "s"
    ],
    "function": "xmlrpc_char_encode",
    "filename": "atheme/CVE-2016-4478/CVE-2016-4478_CWE-119_87580d767868360d2fed503980129504da84b63e_xmlrpclib.c.diff",
    "function_code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\ts->append_char(s, 0);\n\n\tstrncpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
    "label": "False",
    "variable_definitions": {
      "s": "mowgli_string_t *s = mowgli_string_create();"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 370,
    "critical_vars": [
      "httpinf.method",
      "username",
      "clientip",
      "sgfpw",
      "httpinf.url"
    ],
    "function": "squidclamav_check_preview_handler",
    "filename": "squidclamav/CVE-2012-3501/CVE-2012-3501_CWE-119_80f74451f628264d1d9a1f1c0bbcebc932ba5e00_squidclamav.c.diff",
    "function_code": "int squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req)\n{\n     ci_headers_list_t *req_header;\n     struct http_info httpinf;\n     av_req_data_t *data = ci_service_data(req); \n     char *clientip;\n     struct hostent *clientname;\n     unsigned long ip;\n     char *username;\n     char *content_type;\n     ci_off_t content_length;\n     char *chain_ret = NULL;\n     char *ret = NULL;\n     int chkipdone = 0;\n\n     ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: processing preview header.\\n\");\n\n     if (preview_data_len)\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\n\", preview_data_len);\n\n     /* Extract the HTTP header from the request */\n     if ((req_header = ci_http_request_headers(req)) == NULL) {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_ERROR;\n     }\n\n     /* Get the Authenticated user */\n     if ((username = ci_headers_value(req->request_header, \"X-Authenticated-User\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\n\", username);\n        /* if a TRUSTUSER match => no squidguard and no virus scan */\n        if (simple_pattern_compare(username, TRUSTUSER) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\n\", username);\n\t   return CI_MOD_ALLOW204;\n        }\n     } else {\n\t/* set null client to - */\n\tusername = (char *)malloc(sizeof(char)*2);\n\tstrcpy(username, \"-\");\n     }\n\n     /* Check client Ip against SquidClamav trustclient */\n     if ((clientip = ci_headers_value(req->request_header, \"X-Client-IP\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\n\", clientip);\n\tip = inet_addr(clientip);\n\tchkipdone = 0;\n\tif (dnslookup == 1) {\n\t\tif ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) {\n\t\t\tif (clientname->h_name != NULL) {\n\t\t\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\t\t\tif (client_pattern_compare(clientip, clientname->h_name) > 0) {\n\t\t\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\\n\", clientname->h_name, clientip);\n\t\t\t\t   return CI_MOD_ALLOW204;\n\t\t\t\t}\n\t\t\t\tchkipdone = 1;\n\t\t\t}\n\t\t  }\n\t}\n\tif (chkipdone == 0) {\n\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\tif (client_pattern_compare(clientip, NULL) > 0) {\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\\n\", clientip);\n\t\t   return CI_MOD_ALLOW204;\n\t\t}\n\t}\n     } else {\n\t/* set null client to - */\n\tclientip = (char *)malloc(sizeof(char)*2);\n\tstrcpy(clientip, \"-\");\n     }\n     \n     /* Get the requested URL */\n     if (!extract_http_info(req, req_header, &httpinf)) {\n\t/* Something wrong in the header or unknow method */\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",httpinf.url,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;\n\t\tgenerate_redirect_page(strtok(chain_ret, \" \"), req, data);\n\t        xfree(chain_ret);\n\t        chain_ret = NULL;\n\t        return CI_MOD_CONTINUE;\n\t   }\n\t   xfree(chain_ret);\n\t   chain_ret = NULL;\n\t}\n     }\n\n     /* CONNECT method (https) can not be scanned so abort */\n     if (strcmp(httpinf.method, \"CONNECT\") == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\\n\", httpinf.method);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Check the URL against SquidClamav abort */\n     if (simple_pattern_compare(httpinf.url, ABORT) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     /* Get the content length header */\n     content_length = ci_http_content_length(req);\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Length: %d\\n\", (int)content_length);\n\n     if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\\n\", content_length, (int)maxsize);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Get the content type header */\n     if ((content_type = http_content_type(req)) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Type: %s\\n\", content_type);\n        /* Check the Content-Type against SquidClamav abortcontent */\n        if (simple_pattern_compare(content_type, ABORTCONTENT)) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\\n\", content_type);\n\t   return CI_MOD_ALLOW204;\n        }\n     }\n\n     /* No data, so nothing to scan */\n     if (!data || !ci_req_hasbody(req)) {\n\t ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No body data, allow 204\\n\");\n          return CI_MOD_ALLOW204;\n     }\n\n     if (preview_data_len == 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     data->url = ci_buffer_alloc(strlen(httpinf.url)+1);\n     strcpy(data->url, httpinf.url);\n     if (username != NULL) {\n\t     data->user = ci_buffer_alloc(strlen(username)+1);\n\t     strcpy(data->user, username);\n     } else {\n\tdata->user = NULL;\n     }\n     if (clientip != NULL) {\n\tdata->clientip = ci_buffer_alloc(strlen(clientip)+1);\n\tstrcpy(data->clientip, clientip);\n     } else {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\\n\");\n\tdata->clientip = NULL;\n     }\n\n     data->body = ci_simple_file_new(0);\n     if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) {\n\tci_req_unlock_data(req);\n\tci_simple_file_lock_all(data->body);\n     }\n     if (!data->body)\n\treturn CI_ERROR;\n\n     if (preview_data_len) {\n\tif (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR)\n\t\treturn CI_ERROR;\n     }\n\n     return CI_MOD_CONTINUE;\n}",
    "label": "True",
    "variable_definitions": {
      "httpinf.method": "Definition not found",
      "username": "char *username;",
      "clientip": "char *clientip;",
      "sgfpw": "Definition not found",
      "httpinf.url": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 144,
    "critical_vars": [
      "code_length"
    ],
    "function": "mobi_decompress_huffman_internal",
    "filename": "libmobi/CVE-2021-3889/CVE-2021-3889_CWE-119_bec783e6212439a335ba6e8df7ab8ed610ca9a21_compression.c.diff",
    "function_code": "static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}",
    "label": "True",
    "variable_definitions": {
      "code_length": "uint8_t code_length = 0;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 144,
    "critical_vars": [
      "code_length"
    ],
    "function": "mobi_decompress_huffman_internal",
    "filename": "libmobi/CVE-2021-3889/CVE-2021-3889_CWE-119_bec783e6212439a335ba6e8df7ab8ed610ca9a21_compression.c.diff",
    "function_code": "static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                if (++code_length >= HUFF_CODETABLE_SIZE) {\n                    debug_print(\"Wrong offset to mincode table: %hhu\\n\", code_length);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}",
    "label": "False",
    "variable_definitions": {
      "code_length": "uint8_t code_length = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 656,
    "critical_vars": [
      "token->end"
    ],
    "function": "cssp_read_tsrequest",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_cssp.c.diff",
    "function_code": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\t// peek at first 4 bytes to get full message length\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}",
    "label": "True",
    "variable_definitions": {
      "token->end": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 598,
    "critical_vars": [
      "packet"
    ],
    "function": "cssp_read_tsrequest",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_cssp.c.diff",
    "function_code": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\tstruct stream packet;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\t// peek at first 4 bytes to get full message length\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\tpacket = *s;\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n\t\t\t\t    &packet);\n\t}\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tif (!s_check_rem(s, length))\n\t\t{\n\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n\t\t\t\t\t   &packet);\n\t\t}\n\n\t\ts_realloc(token, length);\n\t\ts_reset(token);\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}",
    "label": "False",
    "variable_definitions": {
      "packet": "struct stream packet;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 486,
    "critical_vars": [
      "name",
      "name_len",
      "content_name"
    ],
    "function": "chmd_read_headers",
    "filename": "libmspack/CVE-2019-1010305/CVE-2019-1010305_CWE-119_2f084136cfe0d05e5bf5703f3e83c6d955234b4d_chmd.c.diff",
    "function_code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n                             struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n        ((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n        if ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n        sys->message(fh, \"invalid section number '%u'.\", section);\n        continue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n        sys->free(chunk);\n        return MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n                                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        /* system file */\n        if (name_len == 40 && memcmp(name, content_name, 40) == 0) {\n          chm->sec1.content = fi;\n        }\n        else if (name_len == 44 && memcmp(name, control_name, 44) == 0) {\n          chm->sec1.control = fi;\n        }\n        else if (name_len == 41 && memcmp(name, spaninfo_name, 41) == 0) {\n          chm->sec1.spaninfo = fi;\n        }\n        else if (name_len == 105 && memcmp(name, rtable_name, 105) == 0) {\n          chm->sec1.rtable = fi;\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {\n        /* normal file */\n        if (link) link->next = fi; else chm->files = fi;\n        link = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
    "label": "False",
    "variable_definitions": {
      "name": "unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;",
      "name_len": "unsigned int section, name_len, x, errors, num_chunks;",
      "content_name": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1378,
    "critical_vars": [
      "url_address",
      "url_len",
      "url_begin"
    ],
    "function": "extract_sockaddr",
    "filename": "cgminer/CVE-2014-4502/CVE-2014-4502_CWE-119_e1c5050734123973b99d181c45e74b2cbb00272e_util.c.diff",
    "function_code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}",
    "label": "True",
    "variable_definitions": {
      "url_address": "char url_address[256], port[6];",
      "url_len": "int url_len, port_len = 0;",
      "url_begin": "char *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1223,
    "critical_vars": [
      "url_len"
    ],
    "function": "extract_sockaddr",
    "filename": "sgminer/CVE-2014-4501/CVE-2014-4501_CWE-119_b65574bef233474e915fdf18614aa211e31cc6c2_util.c.diff",
    "function_code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\t\n\tif (url_len >= sizeof(url_address))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",\n\t\t       __func__, url_len, url_begin);\n\t\turl_len = sizeof(url_address) - 1;\n\t}\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}",
    "label": "False",
    "variable_definitions": {
      "url_len": "int url_len, port_len = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1738,
    "critical_vars": [
      "port",
      "address",
      "url"
    ],
    "function": "parse_reconnect",
    "filename": "sgminer/CVE-2014-4501/CVE-2014-4501_CWE-119_78cc408369bdbbd440196c93574098d1482efbce_util.c.diff",
    "function_code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect forbidden, aborting.\");\n\t\treturn false;\n\t}\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsprintf(address, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "label": "True",
    "variable_definitions": {
      "port": "char *url, *port, address[256];",
      "address": "char *url, *port, address[256];",
      "url": "char *url, *port, address[256];"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1737,
    "critical_vars": [
      "port",
      "address",
      "url"
    ],
    "function": "parse_reconnect",
    "filename": "sgminer/CVE-2014-4501/CVE-2014-4501_CWE-119_78cc408369bdbbd440196c93574098d1482efbce_util.c.diff",
    "function_code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect received but is disabled, not reconnecting.\");\n\t\treturn false;\n\t}\n\n\tchar *url, *port, address[256];\n\tchar *sockaddr_url, *stratum_port, *tmp; /* Tempvars. */\n\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, sizeof(address), \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "label": "False",
    "variable_definitions": {
      "port": "char *url, *port, address[256];",
      "address": "char *url, *port, address[256];",
      "url": "char *url, *port, address[256];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1426,
    "critical_vars": [
      "status"
    ],
    "function": "*ReadWPGImage",
    "filename": "ImageMagick/CVE-2016-5688/CVE-2016-5688_CWE-119_fc43974d34318c834fbf78570ca1a3764ed8c7d7_wpg.c.diff",
    "function_code": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp <= 16))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     ReplaceImageInList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}",
    "label": "True",
    "variable_definitions": {
      "status": "unsigned int"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1115,
    "critical_vars": [
      "status"
    ],
    "function": "*ReadWPGImage",
    "filename": "ImageMagick/CVE-2016-5688/CVE-2016-5688_CWE-119_fc43974d34318c834fbf78570ca1a3764ed8c7d7_wpg.c.diff",
    "function_code": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2)/3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              if (WPG_Palette.StartIndex > WPG_Palette.NumOfEntries)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp <= 16))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     ReplaceImageInList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}",
    "label": "False",
    "variable_definitions": {
      "status": "unsigned int status;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 485,
    "critical_vars": [
      "imbuf"
    ],
    "function": "sixel_decode",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_sixel.c.diff",
    "function_code": "MagickBooleanType sixel_decode(unsigned char              /* in */  *p,         /* sixel bytes */\n                               unsigned char              /* out */ **pixels,   /* decoded pixels */\n                               size_t                     /* out */ *pwidth,    /* image width */\n                               size_t                     /* out */ *pheight,   /* image height */\n                               unsigned char              /* out */ **palette,  /* ARGB palette */\n                               size_t                     /* out */ *ncolors    /* palette size (<= 256) */)\n{\n    int n, i, r, g, b, sixel_vertical_mask, c;\n    int posision_x, posision_y;\n    int max_x, max_y;\n    int attributed_pan, attributed_pad;\n    int attributed_ph, attributed_pv;\n    int repeat_count, color_index, max_color_index = 2, background_color_index;\n    int param[10];\n    int sixel_palet[SIXEL_PALETTE_MAX];\n    unsigned char *imbuf, *dmbuf;\n    int imsx, imsy;\n    int dmsx, dmsy;\n    int y;\n\n    posision_x = posision_y = 0;\n    max_x = max_y = 0;\n    attributed_pan = 2;\n    attributed_pad = 1;\n    attributed_ph = attributed_pv = 0;\n    repeat_count = 1;\n    color_index = 0;\n    background_color_index = 0;\n\n    imsx = 2048;\n    imsy = 2048;\n    imbuf = (unsigned char *) AcquireQuantumMemory(imsx * imsy,1);\n\n    if (imbuf == NULL) {\n        return(MagickFalse);\n    }\n\n    for (n = 0; n < 16; n++) {\n        sixel_palet[n] = sixel_default_color_table[n];\n    }\n\n    /* colors 16-231 are a 6x6x6 color cube */\n    for (r = 0; r < 6; r++) {\n        for (g = 0; g < 6; g++) {\n            for (b = 0; b < 6; b++) {\n                sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);\n            }\n        }\n    }\n    /* colors 232-255 are a grayscale ramp, intentionally leaving out */\n    for (i = 0; i < 24; i++) {\n        sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);\n    }\n\n    for (; n < SIXEL_PALETTE_MAX; n++) {\n        sixel_palet[n] = SIXEL_RGB(255, 255, 255);\n    }\n\n    (void) ResetMagickMemory(imbuf, background_color_index, imsx * imsy);\n\n    while (*p != '\\0') {\n        if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {\n            if (*p == '\\033') {\n                p++;\n            }\n\n            p = get_params(++p, param, &n);\n\n            if (*p == 'q') {\n                p++;\n\n                if (n > 0) {        /* Pn1 */\n                    switch(param[0]) {\n                    case 0:\n                    case 1:\n                        attributed_pad = 2;\n                        break;\n                    case 2:\n                        attributed_pad = 5;\n                        break;\n                    case 3:\n                        attributed_pad = 4;\n                        break;\n                    case 4:\n                        attributed_pad = 4;\n                        break;\n                    case 5:\n                        attributed_pad = 3;\n                        break;\n                    case 6:\n                        attributed_pad = 3;\n                        break;\n                    case 7:\n                        attributed_pad = 2;\n                        break;\n                    case 8:\n                        attributed_pad = 2;\n                        break;\n                    case 9:\n                        attributed_pad = 1;\n                        break;\n                    }\n                }\n\n                if (n > 2) {        /* Pn3 */\n                    if (param[2] == 0) {\n                        param[2] = 10;\n                    }\n                    attributed_pan = attributed_pan * param[2] / 10;\n                    attributed_pad = attributed_pad * param[2] / 10;\n                    if (attributed_pan <= 0) attributed_pan = 1;\n                    if (attributed_pad <= 0) attributed_pad = 1;\n                }\n            }\n\n        } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {\n            break;\n        } else if (*p == '\"') {\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) attributed_pad = param[0];\n            if (n > 1) attributed_pan = param[1];\n            if (n > 2 && param[2] > 0) attributed_ph = param[2];\n            if (n > 3 && param[3] > 0) attributed_pv = param[3];\n\n            if (attributed_pan <= 0) attributed_pan = 1;\n            if (attributed_pad <= 0) attributed_pad = 1;\n\n            if (imsx < attributed_ph || imsy < attributed_pv) {\n                dmsx = imsx > attributed_ph ? imsx : attributed_ph;\n                dmsy = imsy > attributed_pv ? imsy : attributed_pv;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n        } else if (*p == '!') {\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                repeat_count = param[0];\n            }\n\n        } else if (*p == '#') {\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                if ((color_index = param[0]) < 0) {\n                    color_index = 0;\n                } else if (color_index >= SIXEL_PALETTE_MAX) {\n                    color_index = SIXEL_PALETTE_MAX - 1;\n                }\n            }\n\n            if (n > 4) {\n                if (param[1] == 1) {            /* HLS */\n                    if (param[2] > 360) param[2] = 360;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);\n                } else if (param[1] == 2) {    /* RGB */\n                    if (param[2] > 100) param[2] = 100;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);\n                }\n            }\n\n        } else if (*p == '$') {\n            /* DECGCR Graphics Carriage Return */\n            p++;\n            posision_x = 0;\n            repeat_count = 1;\n\n        } else if (*p == '-') {\n            /* DECGNL Graphics Next Line */\n            p++;\n            posision_x  = 0;\n            posision_y += 6;\n            repeat_count = 1;\n\n        } else if (*p >= '?' && *p <= '\\177') {\n            if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {\n                int nx = imsx * 2;\n                int ny = imsy * 2;\n\n                while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {\n                    nx *= 2;\n                    ny *= 2;\n                }\n\n                dmsx = nx;\n                dmsy = ny;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n            if (color_index > max_color_index) {\n                max_color_index = color_index;\n            }\n            if ((b = *(p++) - '?') == 0) {\n                posision_x += repeat_count;\n\n            } else {\n                sixel_vertical_mask = 0x01;\n\n                if (repeat_count <= 1) {\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            imbuf[imsx * (posision_y + i) + posision_x] = color_index;\n                            if (max_x < posision_x) {\n                                max_x = posision_x;\n                            }\n                            if (max_y < (posision_y + i)) {\n                                max_y = posision_y + i;\n                            }\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += 1;\n\n                } else { /* repeat_count > 1 */\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            c = sixel_vertical_mask << 1;\n                            for (n = 1; (i + n) < 6; n++) {\n                                if ((b & c) == 0) {\n                                    break;\n                                }\n                                c <<= 1;\n                            }\n                            for (y = posision_y + i; y < posision_y + i + n; ++y) {\n                                (void) ResetMagickMemory(imbuf + imsx * y + posision_x, color_index, repeat_count);\n                            }\n                            if (max_x < (posision_x + repeat_count - 1)) {\n                                max_x = posision_x + repeat_count - 1;\n                            }\n                            if (max_y < (posision_y + i + n - 1)) {\n                                max_y = posision_y + i + n - 1;\n                            }\n\n                            i += (n - 1);\n                            sixel_vertical_mask <<= (n - 1);\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += repeat_count;\n                }\n            }\n            repeat_count = 1;\n        } else {\n            p++;\n        }\n    }\n\n    if (++max_x < attributed_ph) {\n        max_x = attributed_ph;\n    }\n    if (++max_y < attributed_pv) {\n        max_y = attributed_pv;\n    }\n\n    if (imsx > max_x || imsy > max_y) {\n        dmsx = max_x;\n        dmsy = max_y;\n        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1)) == NULL) {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n        }\n        for (y = 0; y < dmsy; ++y) {\n            (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);\n        }\n        imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n        imsx = dmsx;\n        imsy = dmsy;\n        imbuf = dmbuf;\n    }\n\n    *pixels = imbuf;\n    *pwidth = imsx;\n    *pheight = imsy;\n    *ncolors = max_color_index + 1;\n    *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);\n    for (n = 0; n < (ssize_t) *ncolors; ++n) {\n        (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;\n        (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;\n        (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;\n        (*palette)[n * 4 + 3] = 0xff;\n    }\n    return(MagickTrue);\n}",
    "label": "True",
    "variable_definitions": {
      "imbuf": "unsigned char *imbuf, *dmbuf;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 260,
    "line_new": 260,
    "critical_vars": [
      "imbuf"
    ],
    "function": "sixel_decode",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_sixel.c.diff",
    "function_code": "MagickBooleanType sixel_decode(unsigned char              /* in */  *p,         /* sixel bytes */\n                               unsigned char              /* out */ **pixels,   /* decoded pixels */\n                               size_t                     /* out */ *pwidth,    /* image width */\n                               size_t                     /* out */ *pheight,   /* image height */\n                               unsigned char              /* out */ **palette,  /* ARGB palette */\n                               size_t                     /* out */ *ncolors    /* palette size (<= 256) */)\n{\n    int n, i, r, g, b, sixel_vertical_mask, c;\n    int posision_x, posision_y;\n    int max_x, max_y;\n    int attributed_pan, attributed_pad;\n    int attributed_ph, attributed_pv;\n    int repeat_count, color_index, max_color_index = 2, background_color_index;\n    int param[10];\n    int sixel_palet[SIXEL_PALETTE_MAX];\n    unsigned char *imbuf, *dmbuf;\n    int imsx, imsy;\n    int dmsx, dmsy;\n    int y;\n\n    posision_x = posision_y = 0;\n    max_x = max_y = 0;\n    attributed_pan = 2;\n    attributed_pad = 1;\n    attributed_ph = attributed_pv = 0;\n    repeat_count = 1;\n    color_index = 0;\n    background_color_index = 0;\n\n    imsx = 2048;\n    imsy = 2048;\n    imbuf = (unsigned char *) AcquireQuantumMemory(imsx , imsy);\n\n    if (imbuf == NULL) {\n        return(MagickFalse);\n    }\n\n    for (n = 0; n < 16; n++) {\n        sixel_palet[n] = sixel_default_color_table[n];\n    }\n\n    /* colors 16-231 are a 6x6x6 color cube */\n    for (r = 0; r < 6; r++) {\n        for (g = 0; g < 6; g++) {\n            for (b = 0; b < 6; b++) {\n                sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);\n            }\n        }\n    }\n    /* colors 232-255 are a grayscale ramp, intentionally leaving out */\n    for (i = 0; i < 24; i++) {\n        sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);\n    }\n\n    for (; n < SIXEL_PALETTE_MAX; n++) {\n        sixel_palet[n] = SIXEL_RGB(255, 255, 255);\n    }\n\n    (void) ResetMagickMemory(imbuf, background_color_index, (size_t) imsx * imsy);\n\n    while (*p != '\\0') {\n        if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {\n            if (*p == '\\033') {\n                p++;\n            }\n\n            p = get_params(++p, param, &n);\n\n            if (*p == 'q') {\n                p++;\n\n                if (n > 0) {        /* Pn1 */\n                    switch(param[0]) {\n                    case 0:\n                    case 1:\n                        attributed_pad = 2;\n                        break;\n                    case 2:\n                        attributed_pad = 5;\n                        break;\n                    case 3:\n                        attributed_pad = 4;\n                        break;\n                    case 4:\n                        attributed_pad = 4;\n                        break;\n                    case 5:\n                        attributed_pad = 3;\n                        break;\n                    case 6:\n                        attributed_pad = 3;\n                        break;\n                    case 7:\n                        attributed_pad = 2;\n                        break;\n                    case 8:\n                        attributed_pad = 2;\n                        break;\n                    case 9:\n                        attributed_pad = 1;\n                        break;\n                    }\n                }\n\n                if (n > 2) {        /* Pn3 */\n                    if (param[2] == 0) {\n                        param[2] = 10;\n                    }\n                    attributed_pan = attributed_pan * param[2] / 10;\n                    attributed_pad = attributed_pad * param[2] / 10;\n                    if (attributed_pan <= 0) attributed_pan = 1;\n                    if (attributed_pad <= 0) attributed_pad = 1;\n                }\n            }\n\n        } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {\n            break;\n        } else if (*p == '\"') {\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) attributed_pad = param[0];\n            if (n > 1) attributed_pan = param[1];\n            if (n > 2 && param[2] > 0) attributed_ph = param[2];\n            if (n > 3 && param[3] > 0) attributed_pv = param[3];\n\n            if (attributed_pan <= 0) attributed_pan = 1;\n            if (attributed_pad <= 0) attributed_pad = 1;\n\n            if (imsx < attributed_ph || imsy < attributed_pv) {\n                dmsx = imsx > attributed_ph ? imsx : attributed_ph;\n                dmsy = imsy > attributed_pv ? imsy : attributed_pv;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n        } else if (*p == '!') {\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                repeat_count = param[0];\n            }\n\n        } else if (*p == '#') {\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                if ((color_index = param[0]) < 0) {\n                    color_index = 0;\n                } else if (color_index >= SIXEL_PALETTE_MAX) {\n                    color_index = SIXEL_PALETTE_MAX - 1;\n                }\n            }\n\n            if (n > 4) {\n                if (param[1] == 1) {            /* HLS */\n                    if (param[2] > 360) param[2] = 360;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);\n                } else if (param[1] == 2) {    /* RGB */\n                    if (param[2] > 100) param[2] = 100;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);\n                }\n            }\n\n        } else if (*p == '$') {\n            /* DECGCR Graphics Carriage Return */\n            p++;\n            posision_x = 0;\n            repeat_count = 1;\n\n        } else if (*p == '-') {\n            /* DECGNL Graphics Next Line */\n            p++;\n            posision_x  = 0;\n            posision_y += 6;\n            repeat_count = 1;\n\n        } else if (*p >= '?' && *p <= '\\177') {\n            if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {\n                int nx = imsx * 2;\n                int ny = imsy * 2;\n\n                while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {\n                    nx *= 2;\n                    ny *= 2;\n                }\n\n                dmsx = nx;\n                dmsy = ny;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n            if (color_index > max_color_index) {\n                max_color_index = color_index;\n            }\n            if ((b = *(p++) - '?') == 0) {\n                posision_x += repeat_count;\n\n            } else {\n                sixel_vertical_mask = 0x01;\n\n                if (repeat_count <= 1) {\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            imbuf[imsx * (posision_y + i) + posision_x] = color_index;\n                            if (max_x < posision_x) {\n                                max_x = posision_x;\n                            }\n                            if (max_y < (posision_y + i)) {\n                                max_y = posision_y + i;\n                            }\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += 1;\n\n                } else { /* repeat_count > 1 */\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            c = sixel_vertical_mask << 1;\n                            for (n = 1; (i + n) < 6; n++) {\n                                if ((b & c) == 0) {\n                                    break;\n                                }\n                                c <<= 1;\n                            }\n                            for (y = posision_y + i; y < posision_y + i + n; ++y) {\n                                (void) ResetMagickMemory(imbuf + (size_t) imsx * y + posision_x, color_index, repeat_count);\n                            }\n                            if (max_x < (posision_x + repeat_count - 1)) {\n                                max_x = posision_x + repeat_count - 1;\n                            }\n                            if (max_y < (posision_y + i + n - 1)) {\n                                max_y = posision_y + i + n - 1;\n                            }\n\n                            i += (n - 1);\n                            sixel_vertical_mask <<= (n - 1);\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += repeat_count;\n                }\n            }\n            repeat_count = 1;\n        } else {\n            p++;\n        }\n    }\n\n    if (++max_x < attributed_ph) {\n        max_x = attributed_ph;\n    }\n    if (++max_y < attributed_pv) {\n        max_y = attributed_pv;\n    }\n\n    if (imsx > max_x || imsy > max_y) {\n        dmsx = max_x;\n        dmsy = max_y;\n        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy)) == NULL) {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n        }\n        for (y = 0; y < dmsy; ++y) {\n            (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);\n        }\n        imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n        imsx = dmsx;\n        imsy = dmsy;\n        imbuf = dmbuf;\n    }\n\n    *pixels = imbuf;\n    *pwidth = imsx;\n    *pheight = imsy;\n    *ncolors = max_color_index + 1;\n    *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);\n    for (n = 0; n < (ssize_t) *ncolors; ++n) {\n        (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;\n        (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;\n        (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;\n        (*palette)[n * 4 + 3] = 0xff;\n    }\n    return(MagickTrue);\n}",
    "label": "False",
    "variable_definitions": {
      "imbuf": "unsigned char *imbuf, *dmbuf;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2496,
    "critical_vars": [
      "image",
      "exception",
      "BilevelType"
    ],
    "function": "WriteGROUP4Image",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_tiff.c.diff",
    "function_code": "static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}",
    "label": "True",
    "variable_definitions": {
      "image": "Image *image",
      "exception": "ExceptionInfo *exception",
      "BilevelType": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2497,
    "critical_vars": [
      "image",
      "exception",
      "BilevelType"
    ],
    "function": "WriteGROUP4Image",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_tiff.c.diff",
    "function_code": "static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}",
    "label": "False",
    "variable_definitions": {
      "image": "Image *image",
      "exception": "ExceptionInfo *exception",
      "BilevelType": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 377,
    "critical_vars": [
      "hstartcol"
    ],
    "function": "jpc_qmfb_split_col",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "True",
    "variable_definitions": {
      "hstartcol": "int hstartcol;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 377,
    "critical_vars": [
      "hstartrow"
    ],
    "function": "jpc_qmfb_split_col",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartrow;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartrow = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);\n\t\tm = numrows - hstartrow;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartrow * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "False",
    "variable_definitions": {
      "hstartrow": "int hstartrow;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 442,
    "critical_vars": [
      "hstartcol"
    ],
    "function": "jpc_qmfb_split_colgrp",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "True",
    "variable_definitions": {
      "hstartcol": "int hstartcol;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 442,
    "critical_vars": [
      "hstartrow"
    ],
    "function": "jpc_qmfb_split_colgrp",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartrow;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartrow = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);\n\t\tm = numrows - hstartrow;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartrow * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "False",
    "variable_definitions": {
      "hstartrow": "int hstartrow;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 529,
    "critical_vars": [
      "buf",
      "bufsize",
      "jpc_fix_t"
    ],
    "function": "jpc_qmfb_split_colres",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "True",
    "variable_definitions": {
      "buf": "jpc_fix_t *buf = splitbuf;",
      "bufsize": "int bufsize = JPC_CEILDIVPOW2(numrows, 1);",
      "jpc_fix_t": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 530,
    "critical_vars": [
      "buf",
      "bufsize",
      "jpc_fix_t",
      "numcols"
    ],
    "function": "jpc_qmfb_split_colres",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "False",
    "variable_definitions": {
      "buf": "jpc_fix_t *buf = splitbuf;",
      "bufsize": "int bufsize = JPC_CEILDIVPOW2(numrows, 1);",
      "jpc_fix_t": "Definition not found",
      "numcols": "int numcols"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 27,
    "critical_vars": [
      "cb_data",
      "obj",
      "name",
      "path"
    ],
    "function": "process_blob",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}",
    "label": "True",
    "variable_definitions": {
      "cb_data": "void *cb_data)",
      "obj": "struct object *obj = &blob->object;",
      "name": "const char *name,",
      "path": "struct strbuf *path,"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 19,
    "critical_vars": [
      "pathlen"
    ],
    "function": "process_blob",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tsize_t pathlen;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\n\tpathlen = path->len;\n\tstrbuf_addstr(path, name);\n\tshow(obj, path->buf, cb_data);\n\tstrbuf_setlen(path, pathlen);\n}",
    "label": "False",
    "variable_definitions": {
      "pathlen": "size_t pathlen;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 89,
    "critical_vars": [
      "base",
      "cb_data",
      "obj",
      "name"
    ],
    "function": "process_tree",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}",
    "label": "True",
    "variable_definitions": {
      "base": "struct strbuf *base,",
      "cb_data": "void *cb_data)",
      "obj": "struct object *obj = &tree->object;",
      "name": "const char *name,"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 95,
    "critical_vars": [
      "cb_data",
      "obj",
      "base->buf"
    ],
    "function": "process_tree",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\n\tobj->flags |= SEEN;\n\tstrbuf_addstr(base, name);\n\tshow(obj, base->buf, cb_data);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}",
    "label": "False",
    "variable_definitions": {
      "cb_data": "void *cb_data",
      "obj": "struct object *obj = &tree->object;",
      "base->buf": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 107,
    "critical_vars": [
      "data->l_head"
    ],
    "function": "ParseNameValue",
    "filename": "miniupnp/CVE-2017-1000494/CVE-2017-1000494_CWE-119_7aeb624b44f86d335841242ff427433190e7168a_upnpreplyparse.c.diff",
    "function_code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}",
    "label": "True",
    "variable_definitions": {
      "data->l_head": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 108,
    "critical_vars": [
      "NameValueParserData",
      "data"
    ],
    "function": "ParseNameValue",
    "filename": "miniupnp/CVE-2017-1000494/CVE-2017-1000494_CWE-119_7aeb624b44f86d335841242ff427433190e7168a_upnpreplyparse.c.diff",
    "function_code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tmemset(data, 0, sizeof(struct NameValueParserData));\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}",
    "label": "False",
    "variable_definitions": {
      "NameValueParserData": "Definition not found",
      "data": "struct NameValueParserData * data"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 171,
    "critical_vars": [
      "l_row"
    ],
    "function": "libxsmm_sparse_csc_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_generator_spgemm_csc_reader.c.diff",
    "function_code": "void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data structure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          /* init column idx */\n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    /* let's handle empty columns */\n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_column_idx_id );\n  }\n}",
    "label": "True",
    "variable_definitions": {
      "l_row": "unsigned int l_row = 0, l_column = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 132,
    "critical_vars": [
      "l_row"
    ],
    "function": "libxsmm_sparse_csr_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_generator_spgemm_csr_reader.c.diff",
    "function_code": "void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let's handle empty rows */\n    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}",
    "label": "True",
    "variable_definitions": {
      "l_row": "unsigned int l_row = 0, l_column = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 160,
    "critical_vars": [
      "ptr",
      "length",
      "conn_status->password"
    ],
    "function": "FUNC_DECODER",
    "filename": "ettercap/CVE-2014-6396/CVE-2014-6396_CWE-119_e3abe7d7585ecc420a7cab73313216613aadad5a_ec_postgresql.c.diff",
    "function_code": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n               int length;\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n               GET_ULONG_BE(length, ptr, 1);\n               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n               conn_status->password[length - 4] = 0;\n               DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}",
    "label": "True",
    "variable_definitions": {
      "ptr": "DECLARE_DISP_PTR(ptr);",
      "length": "int length;",
      "conn_status->password": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 160,
    "critical_vars": [
      "length"
    ],
    "function": "FUNC_DECODER",
    "filename": "ettercap/CVE-2014-6396/CVE-2014-6396_CWE-119_e3abe7d7585ecc420a7cab73313216613aadad5a_ec_postgresql.c.diff",
    "function_code": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n               int length;\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n               GET_ULONG_BE(length, ptr, 1);\n               length -= 4;\n               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {\n                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n                   return NULL;\n               }\n               snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));\n               DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}",
    "label": "False",
    "variable_definitions": {
      "length": "int length;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 311,
    "critical_vars": [
      "ptr",
      "len",
      "result"
    ],
    "function": "*fstrndup",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}",
    "label": "True",
    "variable_definitions": {
      "ptr": "const char *ptr",
      "len": "unsigned long len",
      "result": "char *result;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 311,
    "critical_vars": [
      "ptr",
      "len",
      "result"
    ],
    "function": "*fstrndup",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memcpy(result, ptr, len);\n  return result;\n}",
    "label": "False",
    "variable_definitions": {
      "ptr": "const char *ptr",
      "len": "unsigned long len",
      "result": "char *result;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 111,
    "critical_vars": [
      "msg->maxsize",
      "msg->cursize"
    ],
    "function": "MSG_WriteBits",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_msg.c.diff",
    "function_code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\t// this isn't an exact overflow check, but close enough\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "label": "True",
    "variable_definitions": {
      "msg->maxsize": "Definition not found",
      "msg->cursize": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 110,
    "critical_vars": [
      "msg->overflowed"
    ],
    "function": "MSG_WriteBits",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_msg.c.diff",
    "function_code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\tif ( msg->overflowed ) {\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {\n\t\t\tmsg->overflowed = qtrue;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tif ( msg->bit + nbits > msg->maxsize << 3 ) {\n\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );\n\t\t\t\tvalue = (value >> 8);\n\n\t\t\t\tif ( msg->bit > msg->maxsize << 3 ) {\n\t\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "label": "False",
    "variable_definitions": {
      "msg->overflowed": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 184,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_read_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}",
    "label": "True",
    "variable_definitions": {
      "n": "uint32_t n;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 194,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_read_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    n = scsi_init_iovec(r);\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "n": "uint32_t n;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 242,
    "critical_vars": [
      "len"
    ],
    "function": "scsi_write_complete",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
    "label": "True",
    "variable_definitions": {
      "len": "uint32_t len;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 256,
    "line_new": 256,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_write_complete",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        scsi_init_iovec(r);\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, r->qiov.size);\n        scsi_req_data(&r->req, r->qiov.size);\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "n": "uint32_t n;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 287,
    "line_new": 283,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_write_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->qiov.size / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                       scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Called for the first time.  Ask the driver to send us more data.  */\n        scsi_write_complete(r, 0);\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "n": "uint32_t n;"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1031,
    "line_new": 1056,
    "critical_vars": [
      "rc"
    ],
    "function": "scsi_send_command",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_7285477ab11831b1cf56e45878a89170dd06d9b9_scsi-disk.c.diff",
    "function_code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    int rc;\n\n    command = buf[0];\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}",
    "label": "False",
    "variable_definitions": {
      "rc": "int rc;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 637,
    "critical_vars": [
      "signature"
    ],
    "function": "key_verify",
    "filename": "pam_p11/CVE-2019-16058/CVE-2019-16058_CWE-119_d150b60e1e14c261b113f55681419ad1dfa8a76c_pam_p11.c.diff",
    "function_code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}",
    "label": "True",
    "variable_definitions": {
      "signature": "unsigned char signature[256];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 810,
    "critical_vars": [
      "update",
      "s"
    ],
    "function": "update_recv",
    "filename": "FreeRDP/CVE-2020-11046/CVE-2020-11046_CWE-119_ed53cd148f43cbab905eaa0f5308c2bf3c48cc37_update.c.diff",
    "function_code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "True",
    "variable_definitions": {
      "update": "rdpUpdate* update",
      "s": "wStream* s"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 810,
    "critical_vars": [
      "update",
      "s"
    ],
    "function": "update_recv",
    "filename": "FreeRDP/CVE-2020-11046/CVE-2020-11046_CWE-119_ed53cd148f43cbab905eaa0f5308c2bf3c48cc37_update.c.diff",
    "function_code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "False",
    "variable_definitions": {
      "update": "rdpUpdate* update",
      "s": "wStream* s"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1690,
    "critical_vars": [
      "job_id"
    ],
    "function": "parse_notify",
    "filename": "cgminer/CVE-2014-4502/CVE-2014-4502_CWE-119_e1c5050734123973b99d181c45e74b2cbb00272e_util.c.diff",
    "function_code": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n\tntime = __json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}",
    "label": "True",
    "variable_definitions": {
      "job_id": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1688,
    "line_new": 1716,
    "critical_vars": [
      "bbversion",
      "prev_hash",
      "job_id",
      "ntime",
      "coinbase1",
      "coinbase2",
      "nbit"
    ],
    "function": "parse_notify",
    "filename": "cgminer/CVE-2014-4502/CVE-2014-4502_CWE-119_e1c5050734123973b99d181c45e74b2cbb00272e_util.c.diff",
    "function_code": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n\tntime = __json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!valid_hex(job_id) || !valid_hex(prev_hash) || !valid_hex(coinbase1) ||\n\t    !valid_hex(coinbase2) || !valid_hex(bbversion) || !valid_hex(nbit) ||\n\t    !valid_hex(ntime)) {\n\t\t/* Annoying but we must not leak memory */\n\t\tfree(job_id);\n\t\tfree(coinbase1);\n\t\tfree(coinbase2);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}",
    "label": "False",
    "variable_definitions": {
      "bbversion": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];",
      "prev_hash": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];",
      "job_id": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];",
      "ntime": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];",
      "coinbase1": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];",
      "coinbase2": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];",
      "nbit": "char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit, *ntime, header[228];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 329,
    "critical_vars": [
      "psf",
      "calloc",
      "sizeof"
    ],
    "function": "sf_open",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */",
    "label": "True",
    "variable_definitions": {
      "psf": "SF_PRIVATE \t*psf ;",
      "calloc": "Definition not found",
      "sizeof": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 329,
    "critical_vars": [
      "psf_allocate",
      "psf"
    ],
    "function": "sf_open",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */",
    "label": "False",
    "variable_definitions": {
      "psf_allocate": "Definition not found",
      "psf": "SF_PRIVATE \t*psf ;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 361,
    "critical_vars": [
      "psf",
      "calloc",
      "sizeof"
    ],
    "function": "sf_open_fd",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_fd */",
    "label": "True",
    "variable_definitions": {
      "psf": "SF_PRIVATE \t*psf ;",
      "calloc": "Definition not found",
      "sizeof": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 361,
    "critical_vars": [
      "psf_allocate",
      "psf"
    ],
    "function": "sf_open_fd",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_fd */",
    "label": "False",
    "variable_definitions": {
      "psf_allocate": "Definition not found",
      "psf": "SF_PRIVATE \t*psf ;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1179,
    "critical_vars": [
      "target_end",
      "s->chunksize"
    ],
    "function": "http_buf_read",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
    "label": "True",
    "variable_definitions": {
      "target_end": "int64_t target_end = s->end_off ? s->end_off : s->filesize;",
      "s->chunksize": "Definition not found"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1178,
    "line_new": 1179,
    "critical_vars": [
      "target_end"
    ],
    "function": "http_buf_read",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        uint64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
    "label": "False",
    "variable_definitions": {
      "target_end": "uint64_t target_end = s->end_off ? s->end_off : s->filesize;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1341,
    "critical_vars": [
      "remaining"
    ],
    "function": "store_icy",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    /* until next metadata packet */\n    int remaining = s->icy_metaint - s->icy_data_read;\n\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n\n    if (!remaining) {\n        /* The metadata packet is variable sized. It has a 1 byte header\n         * which sets the length of the packet (divided by 16). If it's 0,\n         * the metadata doesn't change. After the packet, icy_metaint bytes\n         * of normal data follows. */\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n\n    return FFMIN(size, remaining);\n}",
    "label": "True",
    "variable_definitions": {
      "remaining": "int remaining = s->icy_metaint - s->icy_data_read;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1346,
    "critical_vars": [
      "remaining"
    ],
    "function": "store_icy",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    /* until next metadata packet */\n    uint64_t remaining;\n\n    if (s->icy_metaint < s->icy_data_read)\n        return AVERROR_INVALIDDATA;\n    remaining = s->icy_metaint - s->icy_data_read;\n\n    if (!remaining) {\n        /* The metadata packet is variable sized. It has a 1 byte header\n         * which sets the length of the packet (divided by 16). If it's 0,\n         * the metadata doesn't change. After the packet, icy_metaint bytes\n         * of normal data follows. */\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n\n    return FFMIN(size, remaining);\n}",
    "label": "False",
    "variable_definitions": {
      "remaining": "uint64_t remaining;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 600,
    "critical_vars": [
      "f->chroma_planes"
    ],
    "function": "read_header",
    "filename": "FFmpeg/CVE-2013-7011/CVE-2013-7011_CWE-119_547d690d676064069d44703a1917e0dab7e33445_ffv1dec.c.diff",
    "function_code": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}",
    "label": "True",
    "variable_definitions": {
      "f->chroma_planes": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 583,
    "critical_vars": [
      "chroma_h_shift",
      "chroma_planes",
      "transparency",
      "chroma_v_shift"
    ],
    "function": "read_header",
    "filename": "FFmpeg/CVE-2013-7011/CVE-2013-7011_CWE-119_547d690d676064069d44703a1917e0dab7e33445_ffv1dec.c.diff",
    "function_code": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        colorspace     = get_symbol(c, state, 0); //YUV cs type\n        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   colorspace    != f->colorspace\n                || bits_per_raw_sample != f->avctx->bits_per_raw_sample\n                || chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->colorspace     = colorspace;\n        f->avctx->bits_per_raw_sample = bits_per_raw_sample;\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}",
    "label": "False",
    "variable_definitions": {
      "chroma_h_shift": "int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;",
      "chroma_planes": "int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;",
      "transparency": "int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;",
      "chroma_v_shift": "int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 392,
    "critical_vars": [
      "src_end",
      "src"
    ],
    "function": "kempf_decode_tile",
    "filename": "FFmpeg/CVE-2013-4264/CVE-2013-4264_CWE-119_2960576378d17d71cc8dccc926352ce568b5eec1_g2meet.c.diff",
    "function_code": "static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n                             const uint8_t *src, int src_size)\n{\n    int width, height;\n    int hdr, zsize, npal, tidx = -1, ret;\n    int i, j;\n    const uint8_t *src_end = src + src_size;\n    uint8_t pal[768], transp[3];\n    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n    int sub_type;\n    int nblocks, cblocks, bstride;\n    int bits, bitbuf, coded;\n    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n                   tile_y * c->tile_height * c->framebuf_stride;\n\n    if (src_size < 2)\n        return AVERROR_INVALIDDATA;\n\n    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n\n    hdr = *src++;\n    sub_type = hdr >> 5;\n    if (sub_type == 0) {\n        int j;\n        memcpy(transp, src, 3);\n        src += 3;\n        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n            for (i = 0; i < width; i++)\n                memcpy(dst + i * 3, transp, 3);\n        return 0;\n    } else if (sub_type == 1) {\n        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n    }\n\n    if (sub_type != 2) {\n        memcpy(transp, src, 3);\n        src += 3;\n    }\n    npal = *src++ + 1;\n    memcpy(pal, src, npal * 3); src += npal * 3;\n    if (sub_type != 2) {\n        for (i = 0; i < npal; i++) {\n            if (!memcmp(pal + i * 3, transp, 3)) {\n               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize)\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;\n        }\n    }\n\n    memset(c->jpeg_tile, 0, c->tile_stride * height);\n    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                    c->jpeg_tile, c->tile_stride,\n                    c->kempf_flags, bstride, nblocks, 0);\n\n    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                      c->jpeg_tile, c->tile_stride,\n                      width, height, pal, npal, tidx);\n\n    return 0;\n}",
    "label": "True",
    "variable_definitions": {
      "src_end": "const uint8_t *src_end = src + src_size;",
      "src": "const uint8_t *src"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 392,
    "critical_vars": [
      "src_end",
      "zsize",
      "src",
      "sub_type"
    ],
    "function": "kempf_decode_tile",
    "filename": "FFmpeg/CVE-2013-4264/CVE-2013-4264_CWE-119_2960576378d17d71cc8dccc926352ce568b5eec1_g2meet.c.diff",
    "function_code": "static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n                             const uint8_t *src, int src_size)\n{\n    int width, height;\n    int hdr, zsize, npal, tidx = -1, ret;\n    int i, j;\n    const uint8_t *src_end = src + src_size;\n    uint8_t pal[768], transp[3];\n    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n    int sub_type;\n    int nblocks, cblocks, bstride;\n    int bits, bitbuf, coded;\n    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n                   tile_y * c->tile_height * c->framebuf_stride;\n\n    if (src_size < 2)\n        return AVERROR_INVALIDDATA;\n\n    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n\n    hdr = *src++;\n    sub_type = hdr >> 5;\n    if (sub_type == 0) {\n        int j;\n        memcpy(transp, src, 3);\n        src += 3;\n        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n            for (i = 0; i < width; i++)\n                memcpy(dst + i * 3, transp, 3);\n        return 0;\n    } else if (sub_type == 1) {\n        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n    }\n\n    if (sub_type != 2) {\n        memcpy(transp, src, 3);\n        src += 3;\n    }\n    npal = *src++ + 1;\n    memcpy(pal, src, npal * 3); src += npal * 3;\n    if (sub_type != 2) {\n        for (i = 0; i < npal; i++) {\n            if (!memcmp(pal + i * 3, transp, 3)) {\n               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;\n        }\n    }\n\n    memset(c->jpeg_tile, 0, c->tile_stride * height);\n    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                    c->jpeg_tile, c->tile_stride,\n                    c->kempf_flags, bstride, nblocks, 0);\n\n    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                      c->jpeg_tile, c->tile_stride,\n                      width, height, pal, npal, tidx);\n\n    return 0;\n}",
    "label": "False",
    "variable_definitions": {
      "src_end": "const uint8_t *src_end = src + src_size;",
      "zsize": "int hdr, zsize, npal, tidx = -1, ret;",
      "src": "const uint8_t *src",
      "sub_type": "int sub_type;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1337,
    "critical_vars": [
      "s->has_alpha"
    ],
    "function": "vp8_lossy_decode_frame",
    "filename": "FFmpeg/CVE-2017-9994/CVE-2017-9994_CWE-119_6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef_webp.c.diff",
    "function_code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}",
    "label": "True",
    "variable_definitions": {
      "s->has_alpha": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1338,
    "critical_vars": [
      "avctx->pix_fmt"
    ],
    "function": "vp8_lossy_decode_frame",
    "filename": "FFmpeg/CVE-2017-9994/CVE-2017-9994_CWE-119_6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef_webp.c.diff",
    "function_code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n    }\n    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}",
    "label": "False",
    "variable_definitions": {
      "avctx->pix_fmt": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 913,
    "critical_vars": [
      "the_url",
      "evt->navigate.to_url"
    ],
    "function": "GPAC_EventProc",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "Bool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrcpy(the_url, evt->navigate.to_url);\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "the_url": "Definition not found",
      "evt->navigate.to_url": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 913,
    "critical_vars": [
      "the_url",
      "evt->navigate.to_url"
    ],
    "function": "GPAC_EventProc",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "Bool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "the_url": "Definition not found",
      "evt->navigate.to_url": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1683,
    "critical_vars": [
      "the_url",
      "url_arg"
    ],
    "function": "mp4client_main",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tstrcpy(the_url, url_arg);\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) strcpy(the_url, gf_dm_sess_get_cache_name(sess));\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrcpy(the_url, \"MP4Client \"GPAC_FULL_VERSION);\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}",
    "label": "True",
    "variable_definitions": {
      "the_url": "Definition not found",
      "url_arg": "char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1697,
    "critical_vars": [
      "url_arg"
    ],
    "function": "mp4client_main",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}",
    "label": "False",
    "variable_definitions": {
      "url_arg": "char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 405,
    "critical_vars": [
      "esd"
    ],
    "function": "*gf_hinter_track_new",
    "filename": "gpac/CVE-2021-31261/CVE-2021-31261_CWE-119_cd3738dea038dbd12e603ad48cd7373ae0440f65_isom_hinter.c.diff",
    "function_code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}",
    "label": "True",
    "variable_definitions": {
      "esd": "GF_ESD *esd;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 406,
    "critical_vars": [
      "esd"
    ],
    "function": "*gf_hinter_track_new",
    "filename": "gpac/CVE-2021-31261/CVE-2021-31261_CWE-119_cd3738dea038dbd12e603ad48cd7373ae0440f65_isom_hinter.c.diff",
    "function_code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esd)\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}",
    "label": "False",
    "variable_definitions": {
      "esd": "GF_ESD *esd;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1388,
    "critical_vars": [
      "argc"
    ],
    "function": "parse_device",
    "filename": "libarchive/CVE-2016-4301/CVE-2016-4301_CWE-119_a550daeecf6bc689ade371349892ea17b5b97c77_archive_read_support_format_mtree.c.diff",
    "function_code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tif (argc >= MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
    "label": "False",
    "variable_definitions": {
      "argc": "int argc;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 72,
    "critical_vars": [
      "next_len"
    ],
    "function": "cac_cac1_get_certificate",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* get the size */\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* in the old CAC-1, 0x63 means 'more data' in addition to 'pin failed' */\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\t/* we've either finished reading, or hit an error, break */\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}",
    "label": "True",
    "variable_definitions": {
      "next_len": "size_t len, next_len;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 80,
    "critical_vars": [
      "len"
    ],
    "function": "cac_cac1_get_certificate",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* get the size */\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tlen = MIN(left, 100);\n\tfor (; left > 0;) { /* Increments for readability in the end of the function */\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* in the old CAC-1, 0x63 means 'more data' in addition to 'pin failed' */\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\t/* we've either finished reading, or hit an error, break */\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\t/* Adjust the lengths */\n\t\tleft -= len;\n\t\tout_ptr += len;\n\t\tlen = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}",
    "label": "False",
    "variable_definitions": {
      "len": "size_t len;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 131,
    "critical_vars": [
      "val_len"
    ],
    "function": "cac_read_binary",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *val = NULL;\n\tu8 *cert_ptr;\n\tsize_t val_len;\n\tsize_t len, cert_len;\n\tu8 cert_type;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_log(card->ctx, \n\t\t\t\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\tidx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\tidx, count);\n\tfree(priv->cache_buf);\n\tpriv->cache_buf = NULL;\n\tpriv->cache_buf_len = 0;\n\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\tif (val_len < 1) {\n\t\tr = SC_ERROR_INVALID_DATA;\n\t\tgoto done;\n\t}\n\n\tcert_type = val[0];\n\tcert_ptr = val + 1;\n\tcert_len = val_len - 1;\n\n\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\tif (r)\n\t\t\tgoto done;\n\t} else if (cert_len > 0) {\n\t\tpriv->cache_buf = malloc(cert_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = cert_len;\n\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tif (len && priv->cache_buf)\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (val)\n\t\tfree(val);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}",
    "label": "True",
    "variable_definitions": {
      "val_len": "size_t val_len;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 133,
    "critical_vars": [
      "val_len"
    ],
    "function": "cac_read_binary",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *val = NULL;\n\tu8 *cert_ptr;\n\tsize_t val_len = 0;\n\tsize_t len, cert_len;\n\tu8 cert_type;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_log(card->ctx, \n\t\t\t\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\tidx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\tidx, count);\n\tfree(priv->cache_buf);\n\tpriv->cache_buf = NULL;\n\tpriv->cache_buf_len = 0;\n\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\tif (val_len < 1) {\n\t\tr = SC_ERROR_INVALID_DATA;\n\t\tgoto done;\n\t}\n\n\tcert_type = val[0];\n\tcert_ptr = val + 1;\n\tcert_len = val_len - 1;\n\n\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\tif (r)\n\t\t\tgoto done;\n\t} else if (cert_len > 0) {\n\t\tpriv->cache_buf = malloc(cert_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = cert_len;\n\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tif (len && priv->cache_buf)\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (val)\n\t\tfree(val);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}",
    "label": "False",
    "variable_definitions": {
      "val_len": "size_t val_len = 0;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 435,
    "critical_vars": [
      "file->name",
      "d",
      "len"
    ],
    "function": "tcos_select_file",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-tcos.c.diff",
    "function_code": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
    "label": "True",
    "variable_definitions": {
      "file->name": "Definition not found",
      "d": "unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;",
      "len": "int j, len=apdu.resp[i+1];"
    }
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 411,
    "line_new": 411,
    "critical_vars": [
      "len"
    ],
    "function": "tcos_select_file",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-tcos.c.diff",
    "function_code": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
    "label": "False",
    "variable_definitions": {
      "len": "size_t j, len=apdu.resp[i+1];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 342,
    "critical_vars": [
      "buf",
      "line"
    ],
    "function": "util_acl_to_str",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_util.c.diff",
    "function_code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
    "label": "True",
    "variable_definitions": {
      "buf": "static char line[80], buf[20];",
      "line": "static char line[80], buf[20];"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 342,
    "critical_vars": [
      "buf",
      "sizeof",
      "line"
    ],
    "function": "util_acl_to_str",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_util.c.diff",
    "function_code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
    "label": "False",
    "variable_definitions": {
      "buf": "static char line[80], buf[20];",
      "sizeof": "Definition not found",
      "line": "static char line[80], buf[20];"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 573,
    "critical_vars": [
      "zero_bits"
    ],
    "function": "decode_bit_string",
    "filename": "OpenSC/CVE-2019-15945/CVE-2019-15945_CWE-119_412a6142c27a5973c61ba540e33cdc22d5608e68_asn1.c.diff",
    "function_code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\t/* 1st octet of input:  ABCDEFGH, where A is the MSB */\n\t\t/* 1st octet of output: HGFEDCBA, where A is the LSB */\n\t\t/* first bit in bit string is the LSB in first resulting octet */\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}",
    "label": "True",
    "variable_definitions": {
      "zero_bits": "int zero_bits = *in & 0x07;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 574,
    "critical_vars": [
      "zero_bits"
    ],
    "function": "decode_bit_string",
    "filename": "OpenSC/CVE-2019-15945/CVE-2019-15945_CWE-119_412a6142c27a5973c61ba540e33cdc22d5608e68_asn1.c.diff",
    "function_code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint i, count = 0;\n\tint zero_bits;\n\tsize_t octets_left;\n\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\n\tzero_bits = *in & 0x07;\n\toctets_left = inlen - 1;\n\tin++;\n\tmemset(outbuf, 0, outlen);\n\n\twhile (octets_left) {\n\t\t/* 1st octet of input:  ABCDEFGH, where A is the MSB */\n\t\t/* 1st octet of output: HGFEDCBA, where A is the LSB */\n\t\t/* first bit in bit string is the LSB in first resulting octet */\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}",
    "label": "False",
    "variable_definitions": {
      "zero_bits": "int zero_bits;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 858,
    "critical_vars": [
      "image->numcomps"
    ],
    "function": "color_cmyk_to_rgb",
    "filename": "openjpeg/CVE-2016-4796/CVE-2016-4796_CWE-119_162f6199c0cd3ec1c6c6dc65e41b2faab92b2d91_color.c.diff",
    "function_code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif(image->numcomps < 4) return;\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -> RGB : RGB results from 0 to 255 */\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */",
    "label": "True",
    "variable_definitions": {
      "image->numcomps": "Definition not found"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 858,
    "critical_vars": [
      "image->comps[0].dx",
      "image->numcomps",
      "image->comps[0].dy"
    ],
    "function": "color_cmyk_to_rgb",
    "filename": "openjpeg/CVE-2016-4796/CVE-2016-4796_CWE-119_162f6199c0cd3ec1c6c6dc65e41b2faab92b2d91_color.c.diff",
    "function_code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif (\n\t\t\t(image->numcomps < 4)\n\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx) || (image->comps[0].dx != image->comps[3].dx)\n\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy) || (image->comps[0].dy != image->comps[3].dy)\n\t\t\t) {\n\t\tfprintf(stderr,\"%s:%d:color_cmyk_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n\t}\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -> RGB : RGB results from 0 to 255 */\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */",
    "label": "False",
    "variable_definitions": {
      "image->comps[0].dx": "Definition not found",
      "image->numcomps": "Definition not found",
      "image->comps[0].dy": "Definition not found"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 5097,
    "critical_vars": [
      "buf"
    ],
    "function": "get_matching_data",
    "filename": "krb5/CVE-2017-15088/CVE-2017-15088_CWE-119_fbb687db1088ddd894d975996e5f6a4252b9a2b4_pkinit_crypto_openssl.c.diff",
    "function_code": "get_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    /* Get the subject name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->subject_dn = strdup(buf);\n    if (md->subject_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the issuer name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->issuer_dn = strdup(buf);\n    if (md->issuer_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}",
    "label": "True",
    "variable_definitions": {
      "buf": "char buf[DN_BUF_LEN];"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 5100,
    "critical_vars": [
      "ret"
    ],
    "function": "get_matching_data",
    "filename": "krb5/CVE-2017-15088/CVE-2017-15088_CWE-119_fbb687db1088ddd894d975996e5f6a4252b9a2b4_pkinit_crypto_openssl.c.diff",
    "function_code": "get_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n    if (ret)\n        goto cleanup;\n    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n    if (ret)\n        goto cleanup;\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}",
    "label": "False",
    "variable_definitions": {
      "ret": "krb5_error_code ret = ENOMEM;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1814,
    "critical_vars": [
      "i"
    ],
    "function": "X509_cmp_time",
    "filename": "openssl/CVE-2015-1789/CVE-2015-1789_CWE-119_f48b83b4fb7d6689584cf25f61ca63a4891f5b11_x509_vfy.c.diff",
    "function_code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        /* Skip any fractional seconds... */\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}",
    "label": "True",
    "variable_definitions": {
      "i": "int i, j;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1811,
    "critical_vars": [
      "remaining"
    ],
    "function": "X509_cmp_time",
    "filename": "openssl/CVE-2015-1789/CVE-2015-1789_CWE-119_f48b83b4fb7d6689584cf25f61ca63a4891f5b11_x509_vfy.c.diff",
    "function_code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j, remaining;\n\n    p = buff1;\n    remaining = ctm->length;\n    str = (char *)ctm->data;\n    /*\n     * Note that the following (historical) code allows much more slack in the\n     * time format than RFC5280. In RFC5280, the representation is fixed:\n     * UTCTime: YYMMDDHHMMSSZ\n     * GeneralizedTime: YYYYMMDDHHMMSSZ\n     */\n    if (ctm->type == V_ASN1_UTCTIME) {\n        /* YYMMDDHHMM[SS]Z or YYMMDDHHMM[SS](+-)hhmm */\n        int min_length = sizeof(\"YYMMDDHHMMZ\") - 1;\n        int max_length = sizeof(\"YYMMDDHHMMSS+hhmm\") - 1;\n        if (remaining < min_length || remaining > max_length)\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n        remaining -= 10;\n    } else {\n        /* YYYYMMDDHHMM[SS[.fff]]Z or YYYYMMDDHHMM[SS[.f[f[f]]]](+-)hhmm */\n        int min_length = sizeof(\"YYYYMMDDHHMMZ\") - 1;\n        int max_length = sizeof(\"YYYYMMDDHHMMSS.fff+hhmm\") - 1;\n        if (remaining < min_length || remaining > max_length)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n        remaining -= 12;\n    }\n\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        /* SS (seconds) */\n        if (remaining < 2)\n            return 0;\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        remaining -= 2;\n        /*\n         * Skip any (up to three) fractional seconds...\n         * TODO(emilia): in RFC5280, fractional seconds are forbidden.\n         * Can we just kill them altogether?\n         */\n        if (remaining && *str == '.') {\n            str++;\n            remaining--;\n            for (i = 0; i < 3 && remaining; i++, str++, remaining--) {\n                if (*str < '0' || *str > '9')\n                    break;\n            }\n        }\n\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n\n    /* We now need either a terminating 'Z' or an offset. */\n    if (!remaining)\n        return 0;\n    if (*str == 'Z') {\n        if (remaining != 1)\n            return 0;\n        offset = 0;\n    } else {\n        /* (+-)HHMM */\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        /* Historical behaviour: the (+-)hhmm offset is forbidden in RFC5280. */\n        if (remaining != 5)\n            return 0;\n        if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||\n            str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}",
    "label": "False",
    "variable_definitions": {
      "remaining": "int i, j, remaining;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 317,
    "critical_vars": [
      "s->s3->rrec.seq_num",
      "s->d1->processed_rcds",
      "s"
    ],
    "function": "dtls1_process_buffered_records",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n\n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
    "label": "True",
    "variable_definitions": {
      "s->s3->rrec.seq_num": "Definition not found",
      "s->d1->processed_rcds": "Definition not found",
      "s": "SSL *s"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 321,
    "critical_vars": [
      "s->s3->rrec.seq_num",
      "s->d1->processed_rcds",
      "s"
    ],
    "function": "dtls1_process_buffered_records",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                s->s3->rrec.seq_num)<0)\n                return -1;\n            }\n        }\n\n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
    "label": "False",
    "variable_definitions": {
      "s->s3->rrec.seq_num": "Definition not found",
      "s->d1->processed_rcds": "Definition not found",
      "s": "SSL *s"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 566,
    "critical_vars": [
      "s"
    ],
    "function": "dtls1_get_record",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n\treturn(1);\n\n\t}",
    "label": "True",
    "variable_definitions": {
      "s": "SSL *s"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 570,
    "critical_vars": [
      "s"
    ],
    "function": "dtls1_get_record",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tif(dtls1_process_buffered_records(s)<0)\n\t\treturn -1;\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tif(dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num)<0)\n\t\t\t\treturn -1;\n\t\t\tdtls1_record_bitmap_update(s, bitmap);/* Mark receipt of record. */\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\tdtls1_record_bitmap_update(s, bitmap);/* Mark receipt of record. */\n\n\treturn(1);\n\n\t}",
    "label": "False",
    "variable_definitions": {
      "s": "SSL *s"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 205,
    "critical_vars": [
      "frag"
    ],
    "function": "dtls1_clear_queues",
    "filename": "openssl/CVE-2014-8176/CVE-2014-8176_CWE-119_470990fee0182566d439ef7e82d1abf18b7085d7_d1_lib.c.diff",
    "function_code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}",
    "label": "True",
    "variable_definitions": {
      "frag": "hm_fragment *frag = NULL;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 205,
    "critical_vars": [
      "rdata"
    ],
    "function": "dtls1_clear_queues",
    "filename": "openssl/CVE-2014-8176/CVE-2014-8176_CWE-119_470990fee0182566d439ef7e82d1abf18b7085d7_d1_lib.c.diff",
    "function_code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n\t\tOPENSSL_free(item->data);\n\t\tpitem_free(item);\n\t\t}\n\t}",
    "label": "False",
    "variable_definitions": {
      "rdata": "DTLS1_RECORD_DATA *rdata;"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1226,
    "critical_vars": [
      "nbytes"
    ],
    "function": "mget",
    "filename": "file/CVE-2014-2270/CVE-2014-2270_CWE-119_447558595a3650db2886cd2f416ad0beba965801_softmagic.c.diff",
    "function_code": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (nbytes < offset || nbytes < (offset + 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t (p->hs[1]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t (p->hs[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t (p->hl[3]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t (p->hl[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t (p->hl[2]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (nbytes < (offset + 1)) /* should alway be true */\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (nbytes < (offset + 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (nbytes < (offset + 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (nbytes < (offset + 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (nbytes < (offset + m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(m->desc, \"%u\"), offset) == -1)\n\t\t\t\treturn -1;\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\treturn -1;\n\t\t\tfree(rbuf);\n\t\t}\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;",
    "label": "True",
    "variable_definitions": {
      "nbytes": "size_t nbytes"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1227,
    "critical_vars": [
      "offset",
      "nbytes"
    ],
    "function": "mget",
    "filename": "file/CVE-2014-2270/CVE-2014-2270_CWE-119_447558595a3650db2886cd2f416ad0beba965801_softmagic.c.diff",
    "function_code": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t (p->hs[1]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t (p->hs[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t (p->hl[3]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t (p->hl[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t (p->hl[2]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (OFFSET_OOB(nbytes, offset, 0))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (OFFSET_OOB(nbytes, offset, 0))\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(m->desc, \"%u\"), offset) == -1)\n\t\t\t\treturn -1;\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\treturn -1;\n\t\t\tfree(rbuf);\n\t\t}\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (OFFSET_OOB(nbytes, offset, 0))\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;",
    "label": "False",
    "variable_definitions": {
      "offset": "uint32_t soffset, offset = ms->offset;",
      "nbytes": "size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 967,
    "critical_vars": [
      "len"
    ],
    "function": "mconvert",
    "filename": "file/CVE-2014-9652/CVE-2014-9652_CWE-119_59e63838913eee47f5c120a6c53d4565af638158_softmagic.c.diff",
    "function_code": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s)) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t */ \n\t\t\tlen = sizeof(p->s) - sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;",
    "label": "True",
    "variable_definitions": {
      "len": "size_t len = file_pstring_get_length(m, ptr1);"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 967,
    "critical_vars": [
      "sz"
    ],
    "function": "mconvert",
    "filename": "file/CVE-2014-9652/CVE-2014-9652_CWE-119_59e63838913eee47f5c120a6c53d4565af638158_softmagic.c.diff",
    "function_code": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s)) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t */ \n\t\t\tlen = sizeof(p->s) - sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;",
    "label": "False",
    "variable_definitions": {
      "sz": "size_t sz = file_pstring_length_size(m);"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 355,
    "critical_vars": [
      "pos"
    ],
    "function": "cdf_read_short_sector",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_cdf.c.diff",
    "function_code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
    "label": "True",
    "variable_definitions": {
      "pos": "size_t pos = CDF_SHORT_SEC_POS(h, id);"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 355,
    "critical_vars": [
      "pos",
      "len"
    ],
    "function": "cdf_read_short_sector",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_cdf.c.diff",
    "function_code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
    "label": "False",
    "variable_definitions": {
      "pos": "size_t pos = CDF_SHORT_SEC_POS(h, id);",
      "len": "size_t len"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 239,
    "critical_vars": [
      "clsid"
    ],
    "function": "cdf_file_property_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const uint64_t clsid[2])\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms))\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_FLOAT:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_f) == -1)\n                                return -1;\n                        break;\n                case CDF_DOUBLE:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_d) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (str == NULL && info[i].pi_id ==\n\t\t\t\t    CDF_PROPERTY_NAME_OF_APPLICATION) {\n\t\t\t\t\tstr = cdf_app_to_mime(vbuf, app2mime);\n\t\t\t\t}\n\t\t\t}\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n\t\t\t\tchar tbuf[64];\n                                if (tp < 1000000000000000LL) {\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec, tbuf);\n                                        if (c != NULL &&\n\t\t\t\t\t    (ec = strchr(c, '\\n')) != NULL)\n\t\t\t\t\t\t*ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}",
    "label": "True",
    "variable_definitions": {
      "clsid": "const uint64_t clsid[2]"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 133,
    "critical_vars": [
      "root_storage"
    ],
    "function": "cdf_file_property_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const cdf_directory_t *root_storage)\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms) && root_storage)\n\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_FLOAT:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_f) == -1)\n                                return -1;\n                        break;\n                case CDF_DOUBLE:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_d) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (str == NULL && info[i].pi_id ==\n\t\t\t\t    CDF_PROPERTY_NAME_OF_APPLICATION) {\n\t\t\t\t\tstr = cdf_app_to_mime(vbuf, app2mime);\n\t\t\t\t}\n\t\t\t}\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n\t\t\t\tchar tbuf[64];\n                                if (tp < 1000000000000000LL) {\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec, tbuf);\n                                        if (c != NULL &&\n\t\t\t\t\t    (ec = strchr(c, '\\n')) != NULL)\n\t\t\t\t\t\t*ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}",
    "label": "False",
    "variable_definitions": {
      "root_storage": "const cdf_directory_t *root_storage"
    }
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 279,
    "critical_vars": [
      "str"
    ],
    "function": "cdf_file_summary_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const uint64_t clsid[2])\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);\n\t\tif (str)\n                        if (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\treturn -2;\n        }\n\n        m = cdf_file_property_info(ms, info, count, clsid);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}",
    "label": "True",
    "variable_definitions": {
      "str": "const char *str;"
    }
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 279,
    "critical_vars": [
      "root_storage"
    ],
    "function": "cdf_file_summary_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n        m = cdf_file_property_info(ms, info, count, root_storage);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}",
    "label": "False",
    "variable_definitions": {
      "root_storage": "const cdf_directory_t *root_storage"
    }
  }
]