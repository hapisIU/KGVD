[
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 769,
    "critical_vars": [
      "this_run",
      "window_posn"
    ],
    "function": "lzxd_decompress",
    "filename": "clamav/CVE-2017-6419/CVE-2017-6419_CWE-119_a83773682e856ad6529ba6db8d1792e6d515d7f1_lzxd.c.diff",
    "function_code": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n        if (window_posn + this_run > lzx->window_size) {\n                D((\"match ran over window boundary\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n        }\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 891,
    "critical_vars": [
      "lzx->inbuf"
    ],
    "function": "lzxd_free",
    "filename": "clamav/CVE-2017-6419/CVE-2017-6419_CWE-119_a83773682e856ad6529ba6db8d1792e6d515d7f1_lzxd.c.diff",
    "function_code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 896,
    "critical_vars": [
      "lzx->inbuf"
    ],
    "function": "lzxd_free",
    "filename": "clamav/CVE-2017-6419/CVE-2017-6419_CWE-119_a83773682e856ad6529ba6db8d1792e6d515d7f1_lzxd.c.diff",
    "function_code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    if(lzx->inbuf)\n        sys->free(lzx->inbuf);\n    if(lzx->window)\n        sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 740,
    "line_new": 740,
    "critical_vars": [
      "upx_success"
    ],
    "function": "cli_scanpe",
    "filename": "clamav/CVE-2014-9050/CVE-2014-9050_CWE-119_fc3794a54d2affe5770c1f876484a871c783e91e_pe.c.diff",
    "function_code": "\nint cli_scanpe(cli_ctx *ctx)\n{\n\tuint16_t e_magic; /* DOS signature (\"MZ\") */\n\tuint16_t nsections;\n\tuint32_t e_lfanew; /* address of new exe header */\n\tuint32_t ep, vep; /* entry point (raw, virtual) */\n\tuint8_t polipos = 0;\n\ttime_t timestamp;\n\tstruct pe_image_file_hdr file_hdr;\n\tunion {\n\t    struct pe_image_optional_hdr64 opt64;\n\t    struct pe_image_optional_hdr32 opt32;\n\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\tstruct cli_pe_hook_data pedata;\n#ifdef HAVE__INTERNAL__SHA_COLLECT\n\tint sha_collect = ctx->sha_collect;\n#endif\n    const char *archtype=NULL, *subsystem=NULL;\n\tuint32_t viruses_found = 0;\n#if HAVE_JSON\n        int toval = 0;\n        struct json_object *pe_json=NULL;\n        char jsonbuf[128];\n#endif\n\n    if(!ctx) {\n\tcli_errmsg(\"cli_scanpe: ctx == NULL\\n\");\n\treturn CL_ENULLARG;\n    }\n\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        pe_json = get_pe_property(ctx);\n    }\n#endif\n    map = *ctx->fmap;\n    if(fmap_readn(map, &e_magic, 0, sizeof(e_magic)) != sizeof(e_magic)) {\n\tcli_dbgmsg(\"Can't read DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE && EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE_OLD) {\n\tcli_dbgmsg(\"Invalid DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &e_lfanew, 58 + sizeof(e_magic), sizeof(e_lfanew)) != sizeof(e_lfanew)) {\n\tcli_dbgmsg(\"Can't read new header address\\n\");\n\t/* truncated header? */\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    e_lfanew = EC32(e_lfanew);\n    cli_dbgmsg(\"e_lfanew == %d\\n\", e_lfanew);\n    if(!e_lfanew) {\n\tcli_dbgmsg(\"Not a PE file\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &file_hdr, e_lfanew, sizeof(struct pe_image_file_hdr)) != sizeof(struct pe_image_file_hdr)) {\n\t/* bad information in e_lfanew - probably not a PE file */\n\tcli_dbgmsg(\"Can't read file header\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC32(file_hdr.Magic) != PE_IMAGE_NT_SIGNATURE) {\n\tcli_dbgmsg(\"Invalid PE signature (probably NE file)\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(file_hdr.Characteristics) & 0x2000) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"DLL\");\n#endif\n\tcli_dbgmsg(\"File type: DLL\\n\");\n\tdll = 1;\n    } else if(EC16(file_hdr.Characteristics) & 0x01) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"EXE\");\n#endif\n\tcli_dbgmsg(\"File type: Executable\\n\");\n    }\n\n    switch(EC16(file_hdr.Machine)) {\n\tcase 0x0:\n        archtype = \"Unknown\";\n\t    break;\n\tcase 0x14c:\n        archtype = \"80386\";\n\t    break;\n\tcase 0x14d:\n        archtype = \"80486\";\n\t    break;\n\tcase 0x14e:\n        archtype = \"80586\";\n\t    break;\n\tcase 0x160:\n        archtype = \"R30000 (big-endian)\";\n\t    break;\n\tcase 0x162:\n        archtype = \"R3000\";\n\t    break;\n\tcase 0x166:\n        archtype = \"R4000\";\n\t    break;\n\tcase 0x168:\n        archtype = \"R10000\";\n\t    break;\n\tcase 0x184:\n        archtype = \"DEC Alpha AXP\";\n\t    break;\n\tcase 0x284:\n        archtype = \"DEC Alpha AXP 64bit\";\n\t    break;\n\tcase 0x1f0:\n        archtype = \"PowerPC\";\n\t    break;\n\tcase 0x200:\n        archtype = \"IA64\";\n\t    break;\n\tcase 0x268:\n        archtype = \"M68k\";\n\t    break;\n\tcase 0x266:\n        archtype = \"MIPS16\";\n\t    break;\n\tcase 0x366:\n        archtype = \"MIPS+FPU\";\n\t    break;\n\tcase 0x466:\n        archtype = \"MIPS16+FPU\";\n\t    break;\n\tcase 0x1a2:\n        archtype = \"Hitachi SH3\";\n\t    break;\n\tcase 0x1a3:\n        archtype = \"Hitachi SH3-DSP\";\n\t    break;\n\tcase 0x1a4:\n        archtype = \"Hitachi SH3-E\";\n\t    break;\n\tcase 0x1a6:\n        archtype = \"Hitachi SH4\";\n\t    break;\n\tcase 0x1a8:\n        archtype = \"Hitachi SH5\";\n\t    break;\n\tcase 0x1c0:\n        archtype = \"ARM\";\n\t    break;\n\tcase 0x1c2:\n        archtype = \"THUMB\";\n\t    break;\n\tcase 0x1d3:\n        archtype = \"AM33\";\n\t    break;\n\tcase 0x520:\n        archtype = \"Infineon TriCore\";\n\t    break;\n\tcase 0xcef:\n        archtype = \"CEF\";\n\t    break;\n\tcase 0xebc:\n        archtype = \"EFI Byte Code\";\n\t    break;\n\tcase 0x9041:\n        archtype = \"M32R\";\n\t    break;\n\tcase 0xc0ee:\n        archtype = \"CEEE\";\n\t    break;\n\tcase 0x8664:\n        archtype = \"AMD64\";\n\t    break;\n\tdefault:\n        archtype = \"Unknown\";\n    }\n\n    if ((archtype)) {\n        cli_dbgmsg(\"Machine type: %s\\n\", archtype);\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"ArchType\", archtype);\n#endif\n    }\n\n    nsections = EC16(file_hdr.NumberOfSections);\n    if(nsections < 1 || nsections > 96) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadNumberOfSections\");\n#endif\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\tif(!ctx->corrupted_input) {\n\t    if(nsections)\n\t\tcli_warnmsg(\"PE file contains %d sections\\n\", nsections);\n\t    else\n\t\tcli_warnmsg(\"PE file contains no sections\\n\");\n\t}\n\treturn CL_CLEAN;\n    }\n    cli_dbgmsg(\"NumberOfSections: %d\\n\", nsections);\n\n    timestamp = (time_t) EC32(file_hdr.TimeDateStamp);\n    cli_dbgmsg(\"TimeDateStamp: %s\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"TimeDateStamp\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n#endif\n\n    cli_dbgmsg(\"SizeOfOptionalHeader: %x\\n\", EC16(file_hdr.SizeOfOptionalHeader));\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"SizeOfOptionalHeader\", EC16(file_hdr.SizeOfOptionalHeader));\n#endif\n\n    if (EC16(file_hdr.SizeOfOptionalHeader) < sizeof(struct pe_image_optional_hdr32)) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSize\");\n#endif\n        cli_dbgmsg(\"SizeOfOptionalHeader too small\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    at = e_lfanew + sizeof(struct pe_image_file_hdr);\n    if(fmap_readn(map, &optional_hdr32, at, sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr32)) {\n        cli_dbgmsg(\"Can't read optional file header\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_optional_hdr32);\n\n    /* This will be a chicken and egg problem until we drop 9x */\n    if(EC16(optional_hdr64.Magic)==PE32P_SIGNATURE) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSizePE32Plus\");\n#endif\n        if(EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr64)) {\n\t    /* FIXME: need to play around a bit more with xp64 */\n\t    cli_dbgmsg(\"Incorrect SizeOfOptionalHeader for PE32+\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tpe_plus = 1;\n    }\n\n    if(!pe_plus) { /* PE */\n\tif (EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr32)) {\n\t    /* Seek to the end of the long header */\n\t    at += EC16(file_hdr.SizeOfOptionalHeader)-sizeof(struct pe_image_optional_hdr32);\n\t}\n\n\tif(DCONF & PE_CONF_UPACK)\n\t    upack = (EC16(file_hdr.SizeOfOptionalHeader)==0x148);\n\n\tvep = EC32(optional_hdr32.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr32.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr32.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr32.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr32.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr32.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr32.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr32.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr32.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n\tdirs = optional_hdr32.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr32.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr32.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr32.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr32.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr32.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr32.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr32.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n\n    } else { /* PE+ */\n        /* read the remaining part of the header */\n        if(fmap_readn(map, &optional_hdr32 + 1, at, sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) {\n\t    cli_dbgmsg(\"Can't read optional file header\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tat += sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32);\n\tvep = EC32(optional_hdr64.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr64.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE32+\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr64.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr64.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr64.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr64.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr64.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr64.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr64.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n\tdirs = optional_hdr64.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr64.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr64.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr64.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr64.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr64.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr64.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr64.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n    }\n\n#if HAVE_JSON\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", vep);\n        cli_jsonstr(pe_json, \"EntryPoint\", jsonbuf);\n    }\n#endif\n\n\n    switch(pe_plus ? EC16(optional_hdr64.Subsystem) : EC16(optional_hdr32.Subsystem)) {\n\tcase 0:\n        subsystem = \"Unknown\";\n\t    break;\n\tcase 1:\n        subsystem = \"Native (svc)\";\n\t    native = 1;\n\t    break;\n\tcase 2:\n        subsystem = \"Win32 GUI\";\n\t    break;\n\tcase 3:\n        subsystem = \"Win32 console\";\n\t    break;\n\tcase 5:\n        subsystem = \"OS/2 console\";\n\t    break;\n\tcase 7:\n        subsystem = \"POSIX console\";\n\t    break;\n\tcase 8:\n        subsystem = \"Native Win9x driver\";\n\t    break;\n\tcase 9:\n        subsystem = \"WinCE GUI\";\n\t    break;\n\tcase 10:\n        subsystem = \"EFI application\";\n\t    break;\n\tcase 11:\n        subsystem = \"EFI driver\";\n\t    break;\n\tcase 12:\n        subsystem = \"EFI runtime driver\";\n\t    break;\n\tcase 13:\n        subsystem = \"EFI ROM image\";\n\t    break;\n\tcase 14:\n        subsystem = \"Xbox\";\n\t    break;\n\tcase 16:\n        subsystem = \"Boot application\";\n\t    break;\n\tdefault:\n        subsystem = \"Unknown\";\n    }\n\n    cli_dbgmsg(\"Subsystem: %s\\n\", subsystem);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Subsystem\", subsystem);\n#endif\n\n    cli_dbgmsg(\"------------------------------------\\n\");\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment)) || (pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment))%0x1000)) {\n        cli_dbgmsg(\"Bad virtual alignemnt\\n\");\n\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment)) || (pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment))%0x200)) {\n        cli_dbgmsg(\"Bad file alignemnt\\n\");\n\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    fsize = map->len;\n\n    section_hdr = (struct pe_image_section_hdr *) cli_calloc(nsections, sizeof(struct pe_image_section_hdr));\n\n    if(!section_hdr) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\treturn CL_EMEM;\n    }\n\n    exe_sections = (struct cli_exe_section *) cli_calloc(nsections, sizeof(struct cli_exe_section));\n    \n    if(!exe_sections) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\tfree(section_hdr);\n\treturn CL_EMEM;\n    }\n\n    valign = (pe_plus)?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment);\n    falign = (pe_plus)?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment);\n\n    if(fmap_readn(map, section_hdr, at, sizeof(struct pe_image_section_hdr)*nsections) != (int)(nsections*sizeof(struct pe_image_section_hdr))) {\n        cli_dbgmsg(\"Can't read section header\\n\");\n\tcli_dbgmsg(\"Possibly broken PE file\\n\");\n\tfree(section_hdr);\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_section_hdr)*nsections;\n\n    for(i = 0; falign!=0x200 && i<nsections; i++) {\n\t/* file alignment fallback mode - blah */\n\tif (falign && section_hdr[i].SizeOfRawData && EC32(section_hdr[i].PointerToRawData)%falign && !(EC32(section_hdr[i].PointerToRawData)%0x200)) {\n\t    cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");\n\t    falign = 0x200;\n\t}\n    }\n\n    hdr_size = PESALIGN(hdr_size, valign); /* Aligned headers virtual size */\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    while (rescan==1) {\n        rescan=0;\n        for (i=0; i < nsections; i++) {\n            exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n            exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n            exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n            exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n            exe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n            exe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */\n            exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n            exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n            exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n            if (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n                if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)\n                    || exe_sections[i].raw >= fsize) {\n                    cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n                    if (nsections == 1) {\n                        free(section_hdr);\n                        free(exe_sections);\n\n                        if(DETECT_BROKEN_PE) {\n                            cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n                            return CL_VIRUS;\n                        }\n\n                        return CL_CLEAN; /* no ninjas to see here! move along! */\n                    }\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));\n\n                    nsections--;\n                    rescan=1;\n                    break;\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < nsections; i++) {\n        strncpy(sname, (char *) section_hdr[i].Name, 8);\n        sname[8] = 0;\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n            free(section_hdr);\n            free(exe_sections);\n            return CL_ETIMEOUT;\n        }\n#endif\n\n\tif (!exe_sections[i].vsz && exe_sections[i].rsz)\n\t    exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);\n\n\tif (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))\n\t    exe_sections[i].rsz = fsize - exe_sections[i].raw;\n\t\n\tcli_dbgmsg(\"Section %d\\n\", i);\n\tcli_dbgmsg(\"Section name: %s\\n\", sname);\n\tcli_dbgmsg(\"Section data (from headers - in memory)\\n\");\n\tcli_dbgmsg(\"VirtualSize: 0x%x 0x%x\\n\", exe_sections[i].uvsz, exe_sections[i].vsz);\n\tcli_dbgmsg(\"VirtualAddress: 0x%x 0x%x\\n\", exe_sections[i].urva, exe_sections[i].rva);\n\tcli_dbgmsg(\"SizeOfRawData: 0x%x 0x%x\\n\", exe_sections[i].ursz, exe_sections[i].rsz);\n\tcli_dbgmsg(\"PointerToRawData: 0x%x 0x%x\\n\", exe_sections[i].uraw, exe_sections[i].raw);\n\n\tif(exe_sections[i].chr & 0x20) {\n\t    cli_dbgmsg(\"Section contains executable code\\n\");\n\n\t    if(exe_sections[i].vsz < exe_sections[i].rsz) {\n\t\tcli_dbgmsg(\"Section contains free space\\n\");\n\t\t/*\n\t\tcli_dbgmsg(\"Dumping %d bytes\\n\", section_hdr.SizeOfRawData - section_hdr.VirtualSize);\n\t\tddump(desc, section_hdr.PointerToRawData + section_hdr.VirtualSize, section_hdr.SizeOfRawData - section_hdr.VirtualSize, cli_gentemp(NULL));\n\t\t*/\n\n\t    }\n\t}\n\n\tif(exe_sections[i].chr & 0x20000000)\n\t    cli_dbgmsg(\"Section's memory is executable\\n\");\n\n\tif(exe_sections[i].chr & 0x80000000)\n\t    cli_dbgmsg(\"Section's memory is writeable\\n\");\n\n\tif (DETECT_BROKEN_PE && (!valign || (exe_sections[i].urva % valign))) { /* Bad virtual alignment */\n\t    cli_dbgmsg(\"VirtualAddress is misaligned\\n\");\n\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    /* check hash section sigs */\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);\n\t        if (ret != CL_CLEAN) {\n\t            if (ret != CL_VIRUS)\n\t                cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));\n\t\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t            free(section_hdr);\n\t            free(exe_sections);\n\t            return ret;\n\t        }\n\t    }\n\t}\n\tcli_dbgmsg(\"------------------------------------\\n\");\n\n\tif (exe_sections[i].urva>>31 || exe_sections[i].uvsz>>31 || (exe_sections[i].rsz && exe_sections[i].uraw>>31) || exe_sections[i].ursz>>31) {\n\t    cli_dbgmsg(\"Found PE values with sign bit set\\n\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\n\tif(!i) {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva!=hdr_size) { /* Bad first section RVA */\n\t        cli_dbgmsg(\"First section is in the wrong place\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    min = exe_sections[i].rva;\n\t    max = exe_sections[i].rva + exe_sections[i].rsz;\n\t} else {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva - exe_sections[i-1].urva != exe_sections[i-1].vsz) { /* No holes, no overlapping, no virtual disorder */\n\t        cli_dbgmsg(\"Virtually misplaced section (wrong order, overlapping, non contiguous)\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    if(exe_sections[i].rva < min)\n\t        min = exe_sections[i].rva;\n\n\t    if(exe_sections[i].rva + exe_sections[i].rsz > max) {\n\t        max = exe_sections[i].rva + exe_sections[i].rsz;\n\t\toverlays = exe_sections[i].raw + exe_sections[i].rsz;\n\t    }\n\t}\n    }\n\n    free(section_hdr);\n\n    if(!(ep = cli_rawaddr(vep, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\tcli_dbgmsg(\"EntryPoint out of file\\n\");\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"EntryPointOffset\", ep);\n\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n\n    cli_dbgmsg(\"EntryPoint offset: 0x%x (%d)\\n\", ep, ep);\n\n    if(pe_plus) { /* Do not continue for PE32+ files */\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    epsize = fmap_readn(map, epbuff, ep, 4096);\n\n\n    /* Disasm scan disabled since it's now handled by the bytecode */\n\n    /* CLI_UNPTEMP(\"DISASM\",(exe_sections,0)); */\n    /* if(disasmbuf((unsigned char*)epbuff, epsize, ndesc)) */\n    /* \tret = cli_scandesc(ndesc, ctx, CL_TYPE_PE_DISASM, 1, NULL, AC_SCAN_VIR); */\n    /* close(ndesc); */\n    /* CLI_TMPUNLK(); */\n    /* free(tempfile); */\n    /* if(ret == CL_VIRUS) { */\n    /* \tfree(exe_sections); */\n    /* \treturn ret; */\n    /* } */\n\n    if(overlays) {\n\tint overlays_sz = fsize - overlays;\n\tif(overlays_sz > 0) {\n\t    ret = cli_scanishield(ctx, overlays, overlays_sz);\n\t    if(ret != CL_CLEAN) {\n\t\tfree(exe_sections);\n\t\treturn ret;\n\t    }\n\t}\n    }\n\n    pedata.nsections = nsections;\n    pedata.ep = ep;\n    pedata.offset = 0;\n    memcpy(&pedata.file_hdr, &file_hdr, sizeof(file_hdr));\n    memcpy(&pedata.opt32, &pe_opt.opt32, sizeof(pe_opt.opt32));\n    memcpy(&pedata.opt64, &pe_opt.opt64, sizeof(pe_opt.opt64));\n    memcpy(&pedata.dirs, dirs, sizeof(pedata.dirs));\n    pedata.e_lfanew = e_lfanew;\n    pedata.overlays = overlays;\n    pedata.overlays_sz = fsize - overlays;\n    pedata.hdr_size = hdr_size;\n\n    /* Bytecode BC_PE_ALL hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\tfree(exe_sections);\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_ALL, map);\n    switch (ret) {\n        case CL_ENULLARG:\n            cli_warnmsg(\"cli_scanpe: NULL argument supplied\\n\");\n            break;\n        case CL_VIRUS:\n        case CL_BREAK:\n            free(exe_sections);\n            cli_bytecode_context_destroy(bc_ctx);\n            return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN;\n    }\n    cli_bytecode_context_destroy(bc_ctx);\n    /* Attempt to detect some popular polymorphic viruses */\n\n    /* W32.Parite.B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_PARITE) && !dll && epsize == 4096 && ep == exe_sections[nsections - 1].raw) {\n        const char *pt = cli_memstr(epbuff, 4040, \"\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00\", 15);\n\tif(pt) {\n\t    pt += 15;\n\t    if((((uint32_t)cli_readint32(pt) ^ (uint32_t)cli_readint32(pt + 4)) == 0x505a4f) && (((uint32_t)cli_readint32(pt + 8) ^ (uint32_t)cli_readint32(pt + 12)) == 0xffffb) && (((uint32_t)cli_readint32(pt + 16) ^ (uint32_t)cli_readint32(pt + 20)) == 0xb8)) {\n\t        cli_append_virus(ctx,\"Heuristics.W32.Parite.B\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n    }\n\n    /* Kriz */\n    if(SCAN_ALGO && (DCONF & PE_CONF_KRIZ) && epsize >= 200 && CLI_ISCONTAINED(exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz, ep, 0x0fd2) && epbuff[1]=='\\x9c' && epbuff[2]=='\\x60') {\n\tenum {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSXORPRFX,KZSXOR,KZSDDELTA,KZSLOOP,KZSTOP};\n\tuint8_t kzs[] = {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSTRASH,KZSXORPRFX,KZSXOR,KZSTRASH,KZSDDELTA,KZSTRASH,KZSLOOP,KZSTOP};\n\tuint8_t *kzstate = kzs;\n\tuint8_t *kzcode = (uint8_t *)epbuff + 3;\n\tuint8_t kzdptr=0xff, kzdsize=0xff;\n\tint kzlen = 197, kzinitlen=0xffff, kzxorlen=-1;\n\tcli_dbgmsg(\"in kriz\\n\");\n\n\twhile(*kzstate!=KZSTOP) {\n\t    uint8_t op;\n\t    if(kzlen<=6) break;\n\t    op = *kzcode++;\n\t    kzlen--;\n\t    switch (*kzstate) {\n\t    case KZSTRASH: case KZSGETSIZE: {\n\t\tint opsz=0;\n\t\tswitch(op) {\n\t\tcase 0x81:\n\t\t    kzcode+=5;\n\t\t    kzlen-=5;\n\t\t    break;\n\t\tcase 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbd: case 0xbe: case 0xbf:\n\t\t    if(*kzstate==KZSGETSIZE && cli_readint32(kzcode)==0x0fd2) {\n\t\t\tkzinitlen = kzlen-5;\n\t\t\tkzdsize=op-0xb8;\n\t\t\tkzstate++;\n\t\t\top=4; /* fake the register to avoid breaking out */\n\t\t\tcli_dbgmsg(\"kriz: using #%d as size counter\\n\", kzdsize);\n\t\t    }\n\t\t    opsz=4;\n\t\tcase 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4d: case 0x4e: case 0x4f:\n\t\t    op&=7;\n\t\t    if(op!=kzdptr && op!=kzdsize) {\n\t\t\tkzcode+=opsz;\n\t\t\tkzlen-=opsz;\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t    kzcode--;\n\t\t    kzlen++;\n\t\t    kzstate++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    case KZSCDELTA:\n\t\tif(op==0xe8 && (uint32_t)cli_readint32(kzcode) < 0xff) {\n\t\t    kzlen-=*kzcode+4;\n\t\t    kzcode+=*kzcode+4;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSPDELTA:\n\t\tif((op&0xf8)==0x58 && (kzdptr=op-0x58)!=4) {\n\t\t    kzstate++;\n\t\t    cli_dbgmsg(\"kriz: using #%d as pointer\\n\", kzdptr);\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSXORPRFX:\n\t\tkzstate++;\n\t\tif(op==0x3e) break;\n\t    case KZSXOR:\n\t\tif (op==0x80 && *kzcode==kzdptr+0xb0) {\n\t\t    kzxorlen=kzlen;\n\t\t    kzcode+=+6;\n\t\t    kzlen-=+6;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSDDELTA:\n\t\tif (op==kzdptr+0x48) kzstate++;\n\t\telse *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSLOOP:\n\t\tif (op==kzdsize+0x48 && *kzcode==0x75 && kzlen-(int8_t)kzcode[1]-3<=kzinitlen && kzlen-(int8_t)kzcode[1]>=kzxorlen) {\n\t\t    cli_append_virus(ctx,\"Heuristics.W32.Kriz\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t\tcli_dbgmsg(\"kriz: loop out of bounds, corrupted sample?\\n\");\n\t\tkzstate++;\n\t    }\n\t}\n    }\n\n    /* W32.Magistr.A/B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_MAGISTR) && !dll && (nsections>1) && (exe_sections[nsections - 1].chr & 0x80000000)) {\n        uint32_t rsize, vsize, dam = 0;\n\n\tvsize = exe_sections[nsections - 1].uvsz;\n\trsize = exe_sections[nsections - 1].rsz;\n\tif(rsize < exe_sections[nsections - 1].ursz) {\n\t    rsize = exe_sections[nsections - 1].ursz;\n\t    dam = 1;\n\t}\n\n\tif(vsize >= 0x612c && rsize >= 0x612c && ((vsize & 0xff) == 0xec)) {\n\t\tint bw = rsize < 0x7000 ? rsize : 0x7000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x2c\\x61\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx, dam ? \"Heuristics.W32.Magistr.A.dam\" : \"Heuristics.W32.Magistr.A\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t    }\n\n\t} else if(rsize >= 0x7000 && vsize >= 0x7000 && ((vsize & 0xff) == 0xed)) {\n\t\tint bw = rsize < 0x8000 ? rsize : 0x8000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x04\\x72\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx,dam ? \"Heuristics.W32.Magistr.B.dam\" : \"Heuristics.W32.Magistr.B\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t} \n\t    }\n\t}\n    }\n\n    /* W32.Polipos.A */\n    while(polipos && !dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && (EC16(optional_hdr32.Subsystem) == 2 || EC16(optional_hdr32.Subsystem) == 3) && EC16(file_hdr.Machine) == 0x14c && optional_hdr32.SizeOfStackReserve >= 0x80000) {\n\tuint32_t jump, jold, *jumps = NULL;\n\tconst uint8_t *code;\n\tunsigned int xsjs = 0;\n\n\tif(exe_sections[0].rsz > CLI_MAX_ALLOCATION) break;\n\n\tif(!exe_sections[0].rsz) break;\n\tif(!(code=fmap_need_off_once(map, exe_sections[0].raw, exe_sections[0].rsz))) break;\n\tfor(i=0; i<exe_sections[0].rsz - 5; i++) {\n\t    if((uint8_t)(code[i]-0xe8) > 1) continue;\n\t    jump = cli_rawaddr(exe_sections[0].rva+i+5+cli_readint32(&code[i+1]), exe_sections, nsections, &err, fsize, hdr_size);\n\t    if(err || !CLI_ISCONTAINED(exe_sections[polipos].raw, exe_sections[polipos].rsz, jump, 9)) continue;\n\t    if(xsjs % 128 == 0) {\n\t\tif(xsjs == 1280) break;\n\t\tif(!(jumps=(uint32_t *)cli_realloc2(jumps, (xsjs+128)*sizeof(uint32_t)))) {\n\t\t    free(exe_sections);\n\t\t    return CL_EMEM;\n\t\t}\n\t    }\n\t    j=0;\n\t    for(; j<xsjs; j++) {\n\t\tif(jumps[j]<jump) continue;\n\t\tif(jumps[j]==jump) {\n\t\t    xsjs--;\n\t\t    break;\n\t\t}\n\t\tjold=jumps[j];\n\t\tjumps[j]=jump;\n\t\tjump=jold;\n\t    }\n\t    jumps[j]=jump;\n\t    xsjs++;\n\t}\n\tif(!xsjs) break;\n\tcli_dbgmsg(\"Polipos: Checking %d xsect jump(s)\\n\", xsjs);\n\tfor(i=0;i<xsjs;i++) {\n\t    if(!(code = fmap_need_off_once(map, jumps[i], 9))) continue;\n\t    if((jump=cli_readint32(code))==0x60ec8b55 || (code[4]==0x0ec && ((jump==0x83ec8b55 && code[6]==0x60) || (jump==0x81ec8b55 && !code[7] && !code[8])))) {\n\t\tcli_append_virus(ctx,\"Heuristics.W32.Polipos.A\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(jumps);\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n\tfree(jumps);\n\tbreak;\n    }\n\n    /* Trojan.Swizzor.Gen */\n    if (SCAN_ALGO && (DCONF & PE_CONF_SWIZZOR) && nsections > 1 && fsize > 64*1024 && fsize < 4*1024*1024) {\n\t    if(dirs[2].Size) {\n\t\t    struct swizz_stats *stats = cli_calloc(1, sizeof(*stats));\n\t\t    unsigned int m = 1000;\n\t\t    ret = CL_CLEAN;\n\n\t\t    if (!stats)\n\t\t\t    ret = CL_EMEM;\n\t\t    else {\n\t\t\t    cli_parseres_special(EC32(dirs[2].VirtualAddress), EC32(dirs[2].VirtualAddress), map, exe_sections, nsections, fsize, hdr_size, 0, 0, &m, stats);\n\t\t\t    if ((ret = cli_detect_swizz(stats)) == CL_VIRUS) {\n\t\t\t\tcli_append_virus(ctx,\"Heuristics.Trojan.Swizzor.Gen\");\n\t\t\t    }\n\t\t\t    free(stats);\n\t\t    }\n\t\t    if (ret != CL_CLEAN) {\n\t\t\tif (!(ret == CL_VIRUS && SCAN_ALL)) {\n\t\t\t    free(exe_sections);\n\t\t\t    return ret;\n\t\t\t}\n\t\t\tviruses_found++;\n\t\t    }\n\t    }\n    }\n\n\n    /* !!!!!!!!!!!!!!    PACKERS START HERE    !!!!!!!!!!!!!! */\n    corrupted_cur = ctx->corrupted_input;\n    ctx->corrupted_input = 2; /* caller will reset on return */\n\n\n    /* UPX, FSG, MEW support */\n\n    /* try to find the first section with physical size == 0 */\n    found = 0;\n    if(DCONF & (PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW)) {\n\tfor(i = 0; i < (unsigned int) nsections - 1; i++) {\n\t    if(!exe_sections[i].rsz && exe_sections[i].vsz && exe_sections[i + 1].rsz && exe_sections[i + 1].vsz) {\n\t\tfound = 1;\n\t\tcli_dbgmsg(\"UPX/FSG/MEW: empty section found - assuming compression\\n\");\n#if HAVE_JSON\n        cli_jsonbool(pe_json, \"HasEmptySection\", 1);\n#endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    /* MEW support */\n    if (found && (DCONF & PE_CONF_MEW) && epsize>=16 && epbuff[0]=='\\xe9') {\n\tuint32_t fileoffset;\n\tconst char *tbuff;\n\n\tfileoffset = (vep + cli_readint32(epbuff + 1) + 5);\n\twhile (fileoffset == 0x154 || fileoffset == 0x158) {\n\t    char *src;\n\t    uint32_t offdiff, uselzma;\n\n\t    cli_dbgmsg (\"MEW: found MEW characteristics %08X + %08X + 5 = %08X\\n\", \n\t\t\tcli_readint32(epbuff + 1), vep, cli_readint32(epbuff + 1) + vep + 5);\n\n\t    if(!(tbuff = fmap_need_off_once(map, fileoffset, 0xb0)))\n\t\tbreak;\n\t    if (fileoffset == 0x154) cli_dbgmsg(\"MEW: Win9x compatibility was set!\\n\");\n\t    else cli_dbgmsg(\"MEW: Win9x compatibility was NOT set!\\n\");\n\n\t    if((offdiff = cli_readint32(tbuff+1) - EC32(optional_hdr32.ImageBase)) <= exe_sections[i + 1].rva || offdiff >= exe_sections[i + 1].rva + exe_sections[i + 1].raw - 4) {\n\t        cli_dbgmsg(\"MEW: ESI is not in proper section\\n\");\n\t\tbreak;\n\t    }\n\t    offdiff -= exe_sections[i + 1].rva;\n\n\t    if(!exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: mew section is empty\\n\");\n\t\tbreak;\n\t    }\n\t    ssize = exe_sections[i + 1].vsz;\n\t    dsize = exe_sections[i].vsz;\n\n\t    cli_dbgmsg(\"MEW: ssize %08x dsize %08x offdiff: %08x\\n\", ssize, dsize, offdiff);\n\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize, dsize));\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize + dsize, exe_sections[i + 1].rsz));\n\n\t    if (exe_sections[i + 1].rsz < offdiff + 12 || exe_sections[i + 1].rsz > ssize) {\n\t        cli_dbgmsg(\"MEW: Size mismatch: %08x\\n\", exe_sections[i + 1].rsz);\n\t\tbreak;\n\t    }\n\n\t    /* allocate needed buffer */\n\t    if (!(src = cli_calloc (ssize + dsize, sizeof(char)))) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((bytes = fmap_readn(map, src + dsize, exe_sections[i + 1].raw, exe_sections[i + 1].rsz)) != exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: Can't read %d bytes [read: %lu]\\n\", exe_sections[i + 1].rsz, (unsigned long)bytes);\n\t\tfree(exe_sections);\n\t\tfree(src);\n\t\treturn CL_EREAD;\n\t    }\n\t    cli_dbgmsg(\"MEW: %u (%08x) bytes read\\n\", (unsigned int)bytes, (unsigned int)bytes);\n\n\t    /* count offset to lzma proc, if lzma used, 0xe8 -> call */\n\t    if (tbuff[0x7b] == '\\xe8') {\n\t        if (!CLI_ISCONTAINED(exe_sections[1].rva, exe_sections[1].vsz, cli_readint32(tbuff + 0x7c) + fileoffset + 0x80, 4)) {\n\t\t    cli_dbgmsg(\"MEW: lzma proc out of bounds!\\n\");\n\t\t    free(src);\n\t\t    break; /* to next unpacker in chain */\n\t\t}\n\t\tuselzma = cli_readint32(tbuff + 0x7c) - (exe_sections[0].rva - fileoffset - 0x80);\n\t    } else {\n\t        uselzma = 0;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"MEW\");\n#endif\n\n\t    CLI_UNPTEMP(\"MEW\",(src,exe_sections,0));\n\t    CLI_UNPRESULTS(\"MEW\",(unmew11(src, offdiff, ssize, dsize, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, uselzma, ndesc)),1,(src,0));\n\t    break;\n\t}\n    }\n\n    if(epsize<168) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    if (found || upack) {\n\t/* Check EP for UPX vs. FSG vs. Upack */\n\n\t/* Upack 0.39 produces 2 types of executables\n\t * 3 sections:           | 2 sections (one empty, I don't chech found if !upack, since it's in OR above):\n\t *   mov esi, value      |   pusha\n\t *   lodsd               |   call $+0x9\n\t *   push eax            |\n\t *\n\t * Upack 1.1/1.2 Beta produces [based on 2 samples (sUx) provided by aCaB]:\n\t * 2 sections\n\t *   mov esi, value\n\t *   loads\n\t *   mov edi, eax\n\t *\n\t * Upack unknown [sample 0297729]\n\t * 3 sections\n\t *   mov esi, value\n\t *   push [esi]\n\t *   jmp\n\t * \n\t */\n\t/* upack 0.39-3s + sample 0151477*/\n \twhile(((upack && nsections == 3) && /* 3 sections */\n\t    ((\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x50' /* lodsd; push eax */\n\t     )\n\t    || \n\t    /* based on 0297729 sample from aCaB */\n\t    (epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xff' && epbuff[6] == '\\x36' /* push [esi] */\n\t     )\n\t   )) \n\t   ||\n\t   ((!upack && nsections == 2) && /* 2 sections */\n\t    (( /* upack 0.39-2s */\n\t     epbuff[0] == '\\x60' && epbuff[1] == '\\xe8' && cli_readint32(epbuff+2) == 0x9 /* pusha; call+9 */\n\t     )\n\t    ||\n\t    ( /* upack 1.1/1.2, based on 2 samples */\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase) < min &&  /* mov esi */\n\t     cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > 0 &&\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x8b' && epbuff[7] == '\\xf8' /* loads;  mov edi, eax */\n\t     )\n\t   ))\n\t   ) { \n\t    uint32_t vma, off;\n\t    int a,b,c;\n\n\t    cli_dbgmsg(\"Upack characteristics found.\\n\");\n\t    a = exe_sections[0].vsz;\n\t    b = exe_sections[1].vsz;\n\t    if (upack) {\n\t        cli_dbgmsg(\"Upack: var set\\n\");\n\t\tc = exe_sections[2].vsz;\n\t\tssize = exe_sections[0].ursz + exe_sections[0].uraw;\n\t\toff = exe_sections[0].rva;\n\t\tvma = EC32(optional_hdr32.ImageBase) + exe_sections[0].rva;\n\t    } else {\n\t        cli_dbgmsg(\"Upack: var NOT set\\n\");\n\t\tc = exe_sections[1].rva;\n\t\tssize = exe_sections[1].uraw;\n\t\toff = 0;\n\t\tvma = exe_sections[1].rva - exe_sections[1].uraw;\n\t    }\n\n\t    dsize = a+b+c;\n\n\t    CLI_UNPSIZELIMITS(\"Upack\", MAX(MAX(dsize, ssize), exe_sections[1].ursz));\n\n\t    if (!CLI_ISCONTAINED(0, dsize, exe_sections[1].rva - off, exe_sections[1].ursz) || (upack && !CLI_ISCONTAINED(0, dsize, exe_sections[2].rva - exe_sections[0].rva, ssize)) || ssize > dsize) {\n\t        cli_dbgmsg(\"Upack: probably malformed pe-header, skipping to next unpacker\\n\");\n\t\tbreak;\n\t    }\n\t\t\t\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((unsigned int)fmap_readn(map, dest, 0, ssize) != ssize) {\n\t        cli_dbgmsg(\"Upack: Can't read raw data of section 0\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n\t    if(upack) memmove(dest + exe_sections[2].rva - exe_sections[0].rva, dest, ssize);\n\n\t    if((unsigned int)fmap_readn(map, dest + exe_sections[1].rva - off, exe_sections[1].uraw, exe_sections[1].ursz) != exe_sections[1].ursz) {\n\t\tcli_dbgmsg(\"Upack: Can't read raw data of section 1\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Upack\");\n#endif\n\n\t    CLI_UNPTEMP(\"Upack\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Upack\",(unupack(upack, dest, dsize, epbuff, vma, ep, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, ndesc)),1,(dest,0));\n\t    break;\n\t}\n    }\n\n    \n    while(found  && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\x87' && epbuff[1] == '\\x25') {\n\tconst char *dst;\n\n\t/* FSG v2.0 support - thanks to aCaB ! */\n\n\tuint32_t newesi, newedi, newebx, newedx;\n\t\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\t\n\tnewedx = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: xchg out of bounds (%x), giving up\\n\", newedx);\n\t    break;\n\t}\n\t\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i + 1);\n\t    free(exe_sections);\n\t    return CL_ESEEK;\n\t}\n\n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(newedx < exe_sections[i + 1].rva || !CLI_ISCONTAINED(src, ssize, dst, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP (%x) is wrong\\n\", newedx);\n\t    break;\n\t}\n \n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(!CLI_ISCONTAINED(src, ssize, dst, 32)) {\n\t    cli_dbgmsg(\"FSG: New stack out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedi = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tnewesi = cli_readint32(dst + 4) - EC32(optional_hdr32.ImageBase);\n\tnewebx = cli_readint32(dst + 16) - EC32(optional_hdr32.ImageBase);\n\tnewedx = cli_readint32(dst + 20);\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination buffer (edi is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newebx, 16)) {\n\t    cli_dbgmsg(\"FSG: Array of functions out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx=cli_readint32(newebx + 12 - exe_sections[i + 1].rva + src) - EC32(optional_hdr32.ImageBase);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\",newedx);\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,exe_sections,0));\n\tCLI_UNPRESULTSFSG2(\"FSG\",(unfsg_200(newesi - exe_sections[i + 1].rva + src, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, newedi, EC32(optional_hdr32.ImageBase), newedx, ndesc)),1,(dest,0));\n\tbreak;\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min) {\n\n\t/* FSG support - v. 1.33 (thx trog for the many samples) */\n\n\tint sectcnt = 0;\n\tconst char *support;\n\tuint32_t newesi, newedi, oldep, gp, t;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!(t = cli_rawaddr(cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size)) && err ) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp);\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* newebx = cli_readint32(support) - EC32(optional_hdr32.ImageBase);  Unused */\n\tnewedi = cli_readint32(support + 4) - EC32(optional_hdr32.ImageBase); /* 1st dest */\n\tnewesi = cli_readint32(support + 8) - EC32(optional_hdr32.ImageBase); /* Source */\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 12; t < gp - 4; t += 4) {\n\t    uint32_t rva = cli_readint32(support+t);\n\n\t    if(!rva)\n\t\tbreak;\n\n\t    rva -= EC32(optional_hdr32.ImageBase)+1;\n\t    sectcnt++;\n\n\t    if(rva % 0x1000) cli_dbgmsg(\"FSG: Original section %d is misaligned\\n\", sectcnt);\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp - 4 || cli_readint32(support + t)) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 1; t <= (uint32_t)sectcnt; t++)\n\t    sections[t].rva = cli_readint32(support + 8 + t * 4) - 1 - EC32(optional_hdr32.ImageBase);\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\toldep = vep + 161 + 6 + cli_readint32(epbuff+163);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.33 */\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbb' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min && epbuff[5] == '\\xbf' && epbuff[10] == '\\xbe' && vep >= exe_sections[i + 1].rva && vep - exe_sections[i + 1].rva > exe_sections[i + 1].rva - 0xe0 ) {\n\n\t/* FSG support - v. 1.31 */\n\n\tint sectcnt = 0;\n\tuint32_t gp, t = cli_rawaddr(cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size);\n\tconst char *support;\n\tuint32_t newesi = cli_readint32(epbuff+11) - EC32(optional_hdr32.ImageBase);\n\tuint32_t newedi = cli_readint32(epbuff+6) - EC32(optional_hdr32.ImageBase);\n\tuint32_t oldep = vep - exe_sections[i + 1].rva;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tif(err) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].raw) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp)\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 0; t < gp - 2; t += 2) {\n\t    uint32_t rva = support[t]|(support[t+1]<<8);\n\n\t    if (rva == 2 || rva == 1)\n\t\tbreak;\n\n\t    rva = ((rva-2)<<12) - EC32(optional_hdr32.ImageBase);\n\t    sectcnt++;\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp-10 || cli_readint32(support + t + 6) != 2) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 0; t <= (uint32_t)sectcnt - 1; t++) {\n\t    sections[t+1].rva = (((support[t*2]|(support[t*2+1]<<8))-2)<<12)-EC32(optional_hdr32.ImageBase);\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"FSG: Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\tgp = 0xda + 6*(epbuff[16]=='\\xe8');\n\toldep = vep + gp + 6 + cli_readint32(src+gp+2+oldep);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.31 */\n    }\n\n\n    if(found && (DCONF & PE_CONF_UPX)) {\n\n\t/* UPX support */\n\n\t/* we assume (i + 1) is UPX1 */\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz + exe_sections[i + 1].vsz;\n\n        /* cli_dbgmsg(\"UPX: ssize %u dsize %u\\n\", ssize, dsize); */\n\n\tCLI_UNPSIZELIMITS(\"UPX\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) {\n\t    cli_dbgmsg(\"UPX: Size mismatch or dsize too big (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"UPX: Can't read raw data of section %d\\n\", i+1);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize + 8192, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\t/* try to detect UPX code */\n\tif(cli_memstr(UPX_NRV2B, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2B, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2B decompression routine\\n\");\n\t    upxfn = upx_inflate2b;\n\t} else if(cli_memstr(UPX_NRV2D, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2D, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2D decompression routine\\n\");\n\t    upxfn = upx_inflate2d;\n\t} else if(cli_memstr(UPX_NRV2E, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2E, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2E decompression routine\\n\");\n\t    upxfn = upx_inflate2e;\n\t}\n\n\tif(upxfn) {\n\t    int skew = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase) - exe_sections[i + 1].rva;\n\n\t    if(epbuff[1] != '\\xbe' || skew <= 0 || skew > 0xfff) { /* FIXME: legit skews?? */\n\t\tskew = 0; \n\t    } else if ((unsigned int)skew > ssize) {\n\t\t/* Ignore suggested skew larger than section size */\n\t\tskew = 0;\n\t    } else {\n\t\tcli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);\n\t    }\n\n\t    /* Try skewed first (skew may be zero) */\n\t    if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0) {\n\t\tupx_success = 1;\n\t    }\n\t    /* If skew not successful and non-zero, try no skew */\n\t    else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {\n\t\tupx_success = 1;\n\t    }\n\n\t    if(upx_success)\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed\\n\");\n\t    else\n\t\tcli_dbgmsg(\"UPX: Preferred decompressor failed\\n\");\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2b) {\n\t    if(upx_inflate2b(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2b(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2B decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2B\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2d) {\n\t    if(upx_inflate2d(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2d(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2D decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2D\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2e) {\n\t    if(upx_inflate2e(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2e(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\t\tcli_dbgmsg(\"UPX: NRV2E decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2E\\n\");\n\t    }\n\t}\n\n\tif(cli_memstr(UPX_LZMA2, 20, epbuff + 0x2f, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x21), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t} else if (cli_memstr(UPX_LZMA1, 20, epbuff + 0x39, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x2b), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t}\n\n\tif(!upx_success) {\n\t    cli_dbgmsg(\"UPX: All decompressors failed\\n\");\n\t    free(dest);\n\t}\n    }\n\n    if(upx_success) {\n\tfree(exe_sections);\n\n\tCLI_UNPTEMP(\"UPX/FSG\",(dest,0));\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"UPX\");\n#endif\n\n\tif((unsigned int) write(ndesc, dest, dsize) != dsize) {\n\t    cli_dbgmsg(\"UPX/FSG: Can't write %d bytes\\n\", dsize);\n\t    free(tempfile);\n\t    free(dest);\n\t    close(ndesc);\n\t    return CL_EWRITE;\n\t}\n\n\tfree(dest);\n\tif (lseek(ndesc, 0, SEEK_SET) == -1) {\n        cli_dbgmsg(\"UPX/FSG: lseek() failed\\n\");\n        close(ndesc);\n        CLI_TMPUNLK();\n        free(tempfile);\n        SHA_RESET;\n        return CL_ESEEK;\n    }\n\n\tif(ctx->engine->keeptmp)\n\t    cli_dbgmsg(\"UPX/FSG: Decompressed data saved in %s\\n\", tempfile);\n\n\tcli_dbgmsg(\"***** Scanning decompressed file *****\\n\");\n\tSHA_OFF;\n\tif((ret = cli_magic_scandesc(ndesc, ctx)) == CL_VIRUS) {\n\t    close(ndesc);\n\t    CLI_TMPUNLK();\n\t    free(tempfile);\n\t    SHA_RESET;\n\t    return CL_VIRUS;\n\t}\n\n\tSHA_RESET;\n\tclose(ndesc);\n\tCLI_TMPUNLK();\n\tfree(tempfile);\n\treturn ret;\n    }\n\n\n    /* Petite */\n\n    if(epsize<200) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    found = 2;\n\n    if(epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 1].rva + EC32(optional_hdr32.ImageBase)) {\n\tif(nsections < 2 || epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 2].rva + EC32(optional_hdr32.ImageBase))\n\t    found = 0;\n\telse\n\t    found = 1;\n    }\n\n    if(found && (DCONF & PE_CONF_PETITE)) {\n\tcli_dbgmsg(\"Petite: v2.%d compression detected\\n\", found);\n\n\tif(cli_readint32(epbuff + 0x80) == 0x163c988d) {\n\t    cli_dbgmsg(\"Petite: level zero compression is not supported yet\\n\");\n\t} else {\n\t    dsize = max - min;\n\n\t    CLI_UNPSIZELIMITS(\"Petite\", dsize);\n\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t\tcli_dbgmsg(\"Petite: Can't allocate %d bytes\\n\", dsize);\n\t\tfree(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    for(i = 0 ; i < nsections; i++) {\n\t\tif(exe_sections[i].raw) {\n\t\t    if(!exe_sections[i].rsz || (unsigned int)fmap_readn(map, dest + exe_sections[i].rva - min, exe_sections[i].raw, exe_sections[i].ursz) != exe_sections[i].ursz) {\n\t\t\tfree(exe_sections);\n\t\t\tfree(dest);\n\t\t\treturn CL_CLEAN;\n\t\t    }\n\t\t}\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Petite\");\n#endif\n\n\t    CLI_UNPTEMP(\"Petite\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Petite\",(petite_inflate2x_1to9(dest, min, max - min, exe_sections, nsections - (found == 1 ? 1 : 0), EC32(optional_hdr32.ImageBase),vep, ndesc, found, EC32(optional_hdr32.DataDirectory[2].VirtualAddress),EC32(optional_hdr32.DataDirectory[2].Size))),0,(dest,0));\n\t}\n    }\n\n    /* PESpin 1.1 */\n\n    if((DCONF & PE_CONF_PESPIN) && nsections > 1 &&\n       vep >= exe_sections[nsections - 1].rva &&\n       vep < exe_sections[nsections - 1].rva + exe_sections[nsections - 1].rsz - 0x3217 - 4 &&\n       memcmp(epbuff+4, \"\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3\", 10) == 0)  {\n\n\tchar *spinned;\n\n\tCLI_UNPSIZELIMITS(\"PEspin\", fsize);\n\n\tif((spinned = (char *) cli_malloc(fsize)) == NULL) {\n        cli_errmsg(\"PESping: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tif((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t    cli_dbgmsg(\"PESpin: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t    free(spinned);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"PEspin\");\n#endif\n\n\tCLI_UNPTEMP(\"PESpin\",(spinned,exe_sections,0));\n\tCLI_UNPRESULTS_(\"PEspin\",SPINCASE(),(unspin(spinned, fsize, exe_sections, nsections - 1, vep, ndesc, ctx)),0,(spinned,0));\n    }\n\n\n    /* yC 1.3 & variants */\n    if((DCONF & PE_CONF_YC) && nsections > 1 &&\n       (EC32(optional_hdr32.AddressOfEntryPoint) == exe_sections[nsections - 1].rva + 0x60)) {\n\n\tuint32_t ecx = 0;\n\tint16_t offset;\n\n\t/* yC 1.3 */\n\tif (!memcmp(epbuff, \"\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED\", 15) &&\n\t    !memcmp(epbuff+0x26, \"\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC\", 13) &&\n\t    ((uint8_t)epbuff[0x13] == 0xB9) &&\n\t    ((uint16_t)(cli_readint16(epbuff+0x18)) == 0xE981) &&\n\t    !memcmp(epbuff+0x1e,\"\\x8B\\xD5\\x81\\xC2\", 4)) {\n\n\t    offset = 0;\n\t    if (0x6c - cli_readint32(epbuff+0xf) + cli_readint32(epbuff+0x22) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x14) - cli_readint32(epbuff+0x1a);\n\t}\n\n\t/* yC 1.3 variant */\n\tif (!ecx && !memcmp(epbuff, \"\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57\", 9) &&\n\t    !memcmp(epbuff+0x17, \"\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\", 8) &&\n\t    ((uint8_t)epbuff[0x23] == 0xB9)) {\n\n\t    offset = 0x10;\n\t    if (0x6c - cli_readint32(epbuff+0x1f) + cli_readint32(epbuff+0x32) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x24) - cli_readint32(epbuff+0x2a);\n\t}\n\n\t/* yC 1.x/modified */\n\tif (!ecx && !memcmp(epbuff, \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\",9) &&\n\t    ((uint8_t)epbuff[0xd] == 0xb9) &&\n\t    ((uint16_t)cli_readint16(epbuff + 0x12)== 0xbd8d) &&\n\t    !memcmp(epbuff+0x18, \"\\x8b\\xf7\\xac\", 3)) {\n\n\t    offset = -0x18;\n\t    if (0x66 - cli_readint32(epbuff+0x9) + cli_readint32(epbuff+0x14) == 0xae)\n\t\tecx = cli_readint32(epbuff+0xe);\n\t}\n\n\tif (ecx > 0x800 && ecx < 0x2000 &&\n\t    !memcmp(epbuff+0x63+offset, \"\\xaa\\xe2\\xcc\", 3) &&\n\t    (fsize >= exe_sections[nsections-1].raw + 0xC6 + ecx + offset)) {\n\n\t    char *spinned;\n\n\t    if((spinned = (char *) cli_malloc(fsize)) == NULL) {\n            cli_errmsg(\"yC: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t      free(exe_sections);\n\t      return CL_EMEM;\n\t    }\n\n\t    if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t      cli_dbgmsg(\"yC: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t      free(spinned);\n\t      free(exe_sections);\n\t      return CL_EREAD;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"yC\");\n#endif\n\n\t    cli_dbgmsg(\"%d,%d,%d,%d\\n\", nsections-1, e_lfanew, ecx, offset);\n\t    CLI_UNPTEMP(\"yC\",(spinned,exe_sections,0));\n\t    CLI_UNPRESULTS(\"yC\",(yc_decrypt(spinned, fsize, exe_sections, nsections-1, e_lfanew, ndesc, ecx, offset)),0,(spinned,0));\n\t}\n    }\n\n    /* WWPack */\n\n    while ((DCONF & PE_CONF_WWPACK) && nsections > 1 &&\n       vep == exe_sections[nsections - 1].rva &&\n       memcmp(epbuff, \"\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb\", 7) == 0 &&\n       memcmp(epbuff+0x68, \"\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50\", 19) == 0)  {\n\tuint32_t head = exe_sections[nsections - 1].raw;\n        uint8_t *packer;\n\tchar *src;\n\n\tssize = 0;\n\tfor(i=0 ; ; i++) {\n\t    if(exe_sections[i].raw<head)\n\t        head=exe_sections[i].raw;\n\t    if(i+1==nsections) break;\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\t}\n\tif(!head || !ssize || head>ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"WWPack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif((size_t) fmap_readn(map, src, 0, head) != head) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from headers\\n\", head);\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections-1; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i+1!=nsections) {\n            cli_dbgmsg(\"WWpack: Probably hacked/damaged file.\\n\");\n            free(src);\n            break;\n        }\n\tif((packer = (uint8_t *) cli_calloc(exe_sections[nsections - 1].rsz, sizeof(char))) == NULL) {\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif(!exe_sections[nsections - 1].rsz || (size_t) fmap_readn(map, packer, exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz) != exe_sections[nsections - 1].rsz) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from wwpack sect\\n\", exe_sections[nsections - 1].rsz);\n\t    free(src);\n\t    free(packer);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"WWPack\");\n#endif\n\n\tCLI_UNPTEMP(\"WWPack\",(src,packer,exe_sections,0));\n\tCLI_UNPRESULTS(\"WWPack\",(wwunpack((uint8_t *)src, ssize, packer, exe_sections, nsections-1, e_lfanew, ndesc)),0,(src,packer,0));\n\tbreak;\n    }\n\n\n    /* ASPACK support */\n    while((DCONF & PE_CONF_ASPACK) && ep+58+0x70e < fsize && !memcmp(epbuff,\"\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb\",8)) {\n\tchar *src;\n\n        if(epsize<0x3bf || memcmp(epbuff+0x3b9, \"\\x68\\x00\\x00\\x00\\x00\\xc3\",6)) break;\n\tssize = 0;\n\tfor(i=0 ; i< nsections ; i++)\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\tif(!ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"Aspack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i!=nsections) {\n            cli_dbgmsg(\"Aspack: Probably hacked/damaged Aspack file.\\n\");\n            free(src);\n            break;\n        }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Aspack\");\n#endif\n\n\tCLI_UNPTEMP(\"Aspack\",(src,exe_sections,0));\n\tCLI_UNPRESULTS(\"Aspack\",(unaspack212((uint8_t *)src, ssize, exe_sections, nsections, vep-1, EC32(optional_hdr32.ImageBase), ndesc)),1,(src,0));\n\tbreak;\n    }\n\n    /* NsPack */\n\n    while (DCONF & PE_CONF_NSPACK) {\n\tuint32_t eprva = vep;\n\tuint32_t start_of_stuff, rep = ep;\n\tunsigned int nowinldr;\n\tconst char *nbuff;\n\n\tsrc=epbuff;\n\tif (*epbuff=='\\xe9') { /* bitched headers */\n\t    eprva = cli_readint32(epbuff+1)+vep+5;\n\t    if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) break;\n\t    if (!(nbuff = fmap_need_off_once(map, rep, 24))) break;\n\t    src = nbuff;\n\t}\n\n\tif (memcmp(src, \"\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00\", 13)) break;\n\n\tnowinldr = 0x54-cli_readint32(src+17);\n\tcli_dbgmsg(\"NsPack: Found *start_of_stuff @delta-%x\\n\", nowinldr);\n\n\tif(!(nbuff = fmap_need_off_once(map, rep-nowinldr, 4))) break;\n\tstart_of_stuff=rep+cli_readint32(nbuff);\n\tif(!(nbuff = fmap_need_off_once(map, start_of_stuff, 20))) break;\n\tsrc = nbuff;\n\tif (!cli_readint32(nbuff)) {\n\t    start_of_stuff+=4; /* FIXME: more to do */\n\t    src+=4;\n\t}\n\n\tssize = cli_readint32(src+5)|0xff;\n\tdsize = cli_readint32(src+9);\n\n\tCLI_UNPSIZELIMITS(\"NsPack\", MAX(ssize,dsize));\n\n\tif (!ssize || !dsize || dsize != exe_sections[0].vsz) break;\n\tif (!(dest=cli_malloc(dsize))) {\n        cli_errmsg(\"NsPack: Unable to allocate memory for dest %u\\n\", dsize);\n        break;\n    }\n\t/* memset(dest, 0xfc, dsize); */\n\n\tif(!(src = fmap_need_off(map, start_of_stuff, ssize))) {\n\t    free(dest);\n\t    break;\n\t}\n\t/* memset(src, 0x00, ssize); */\n\n\teprva+=0x27a;\n\tif (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\t  free(dest);\n\t  break;\n\t}\n\tif(!(nbuff = fmap_need_off_once(map, rep, 5))) {\n\t  free(dest);\n\t  break;\n\t}\n\tfmap_unneed_off(map, start_of_stuff, ssize);\n\teprva=eprva+5+cli_readint32(nbuff+1);\n\tcli_dbgmsg(\"NsPack: OEP = %08x\\n\", eprva);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"NsPack\");\n#endif\n\n\tCLI_UNPTEMP(\"NsPack\",(dest,exe_sections,0));\n\tCLI_UNPRESULTS(\"NsPack\",(unspack(src, dest, ctx, exe_sections[0].rva, EC32(optional_hdr32.ImageBase), eprva, ndesc)),0,(dest,0));\n\tbreak;\n    }\n\n    /* to be continued ... */\n\n\n\n\n    /* !!!!!!!!!!!!!!    PACKERS END HERE    !!!!!!!!!!!!!! */\n    ctx->corrupted_input = corrupted_cur;\n\n    /* Bytecode BC_PE_UNPACKER hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_UNPACKER, map);\n    switch (ret) {\n\tcase CL_VIRUS:\n\t    free(exe_sections);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    return CL_VIRUS;\n\tcase CL_SUCCESS:\n\t    ndesc = cli_bytecode_context_getresult_file(bc_ctx, &tempfile);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    if (ndesc != -1 && tempfile) {\n\t\tCLI_UNPRESULTS(\"bytecode PE hook\", 1, 1, (0));\n\t    }\n\t    break;\n\tdefault:\n\t    cli_bytecode_context_destroy(bc_ctx);\n    }\n\n    free(exe_sections);\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n    if (SCAN_ALL && viruses_found)\n\treturn CL_VIRUS;\n    return CL_CLEAN;",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 747,
    "critical_vars": [
      "j"
    ],
    "function": "cli_scanpe",
    "filename": "clamav/CVE-2014-9050/CVE-2014-9050_CWE-119_fc3794a54d2affe5770c1f876484a871c783e91e_pe.c.diff",
    "function_code": "\nint cli_scanpe(cli_ctx *ctx)\n{\n\tuint16_t e_magic; /* DOS signature (\"MZ\") */\n\tuint16_t nsections;\n\tuint32_t e_lfanew; /* address of new exe header */\n\tuint32_t ep, vep; /* entry point (raw, virtual) */\n\tuint8_t polipos = 0;\n\ttime_t timestamp;\n\tstruct pe_image_file_hdr file_hdr;\n\tunion {\n\t    struct pe_image_optional_hdr64 opt64;\n\t    struct pe_image_optional_hdr32 opt32;\n\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size, j;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\tstruct cli_pe_hook_data pedata;\n#ifdef HAVE__INTERNAL__SHA_COLLECT\n\tint sha_collect = ctx->sha_collect;\n#endif\n    const char *archtype=NULL, *subsystem=NULL;\n\tuint32_t viruses_found = 0;\n#if HAVE_JSON\n        int toval = 0;\n        struct json_object *pe_json=NULL;\n        char jsonbuf[128];\n#endif\n\n    if(!ctx) {\n\tcli_errmsg(\"cli_scanpe: ctx == NULL\\n\");\n\treturn CL_ENULLARG;\n    }\n\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        pe_json = get_pe_property(ctx);\n    }\n#endif\n    map = *ctx->fmap;\n    if(fmap_readn(map, &e_magic, 0, sizeof(e_magic)) != sizeof(e_magic)) {\n\tcli_dbgmsg(\"Can't read DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE && EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE_OLD) {\n\tcli_dbgmsg(\"Invalid DOS signature\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &e_lfanew, 58 + sizeof(e_magic), sizeof(e_lfanew)) != sizeof(e_lfanew)) {\n\tcli_dbgmsg(\"Can't read new header address\\n\");\n\t/* truncated header? */\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    e_lfanew = EC32(e_lfanew);\n    cli_dbgmsg(\"e_lfanew == %d\\n\", e_lfanew);\n    if(!e_lfanew) {\n\tcli_dbgmsg(\"Not a PE file\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(fmap_readn(map, &file_hdr, e_lfanew, sizeof(struct pe_image_file_hdr)) != sizeof(struct pe_image_file_hdr)) {\n\t/* bad information in e_lfanew - probably not a PE file */\n\tcli_dbgmsg(\"Can't read file header\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC32(file_hdr.Magic) != PE_IMAGE_NT_SIGNATURE) {\n\tcli_dbgmsg(\"Invalid PE signature (probably NE file)\\n\");\n\treturn CL_CLEAN;\n    }\n\n    if(EC16(file_hdr.Characteristics) & 0x2000) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"DLL\");\n#endif\n\tcli_dbgmsg(\"File type: DLL\\n\");\n\tdll = 1;\n    } else if(EC16(file_hdr.Characteristics) & 0x01) {\n#if HAVE_JSON\n        if ((pe_json))\n            cli_jsonstr(pe_json, \"Type\", \"EXE\");\n#endif\n\tcli_dbgmsg(\"File type: Executable\\n\");\n    }\n\n    switch(EC16(file_hdr.Machine)) {\n\tcase 0x0:\n        archtype = \"Unknown\";\n\t    break;\n\tcase 0x14c:\n        archtype = \"80386\";\n\t    break;\n\tcase 0x14d:\n        archtype = \"80486\";\n\t    break;\n\tcase 0x14e:\n        archtype = \"80586\";\n\t    break;\n\tcase 0x160:\n        archtype = \"R30000 (big-endian)\";\n\t    break;\n\tcase 0x162:\n        archtype = \"R3000\";\n\t    break;\n\tcase 0x166:\n        archtype = \"R4000\";\n\t    break;\n\tcase 0x168:\n        archtype = \"R10000\";\n\t    break;\n\tcase 0x184:\n        archtype = \"DEC Alpha AXP\";\n\t    break;\n\tcase 0x284:\n        archtype = \"DEC Alpha AXP 64bit\";\n\t    break;\n\tcase 0x1f0:\n        archtype = \"PowerPC\";\n\t    break;\n\tcase 0x200:\n        archtype = \"IA64\";\n\t    break;\n\tcase 0x268:\n        archtype = \"M68k\";\n\t    break;\n\tcase 0x266:\n        archtype = \"MIPS16\";\n\t    break;\n\tcase 0x366:\n        archtype = \"MIPS+FPU\";\n\t    break;\n\tcase 0x466:\n        archtype = \"MIPS16+FPU\";\n\t    break;\n\tcase 0x1a2:\n        archtype = \"Hitachi SH3\";\n\t    break;\n\tcase 0x1a3:\n        archtype = \"Hitachi SH3-DSP\";\n\t    break;\n\tcase 0x1a4:\n        archtype = \"Hitachi SH3-E\";\n\t    break;\n\tcase 0x1a6:\n        archtype = \"Hitachi SH4\";\n\t    break;\n\tcase 0x1a8:\n        archtype = \"Hitachi SH5\";\n\t    break;\n\tcase 0x1c0:\n        archtype = \"ARM\";\n\t    break;\n\tcase 0x1c2:\n        archtype = \"THUMB\";\n\t    break;\n\tcase 0x1d3:\n        archtype = \"AM33\";\n\t    break;\n\tcase 0x520:\n        archtype = \"Infineon TriCore\";\n\t    break;\n\tcase 0xcef:\n        archtype = \"CEF\";\n\t    break;\n\tcase 0xebc:\n        archtype = \"EFI Byte Code\";\n\t    break;\n\tcase 0x9041:\n        archtype = \"M32R\";\n\t    break;\n\tcase 0xc0ee:\n        archtype = \"CEEE\";\n\t    break;\n\tcase 0x8664:\n        archtype = \"AMD64\";\n\t    break;\n\tdefault:\n        archtype = \"Unknown\";\n    }\n\n    if ((archtype)) {\n        cli_dbgmsg(\"Machine type: %s\\n\", archtype);\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"ArchType\", archtype);\n#endif\n    }\n\n    nsections = EC16(file_hdr.NumberOfSections);\n    if(nsections < 1 || nsections > 96) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadNumberOfSections\");\n#endif\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\tif(!ctx->corrupted_input) {\n\t    if(nsections)\n\t\tcli_warnmsg(\"PE file contains %d sections\\n\", nsections);\n\t    else\n\t\tcli_warnmsg(\"PE file contains no sections\\n\");\n\t}\n\treturn CL_CLEAN;\n    }\n    cli_dbgmsg(\"NumberOfSections: %d\\n\", nsections);\n\n    timestamp = (time_t) EC32(file_hdr.TimeDateStamp);\n    cli_dbgmsg(\"TimeDateStamp: %s\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"TimeDateStamp\", cli_ctime(&timestamp, timestr, sizeof(timestr)));\n#endif\n\n    cli_dbgmsg(\"SizeOfOptionalHeader: %x\\n\", EC16(file_hdr.SizeOfOptionalHeader));\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"SizeOfOptionalHeader\", EC16(file_hdr.SizeOfOptionalHeader));\n#endif\n\n    if (EC16(file_hdr.SizeOfOptionalHeader) < sizeof(struct pe_image_optional_hdr32)) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSize\");\n#endif\n        cli_dbgmsg(\"SizeOfOptionalHeader too small\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n    at = e_lfanew + sizeof(struct pe_image_file_hdr);\n    if(fmap_readn(map, &optional_hdr32, at, sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr32)) {\n        cli_dbgmsg(\"Can't read optional file header\\n\");\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_optional_hdr32);\n\n    /* This will be a chicken and egg problem until we drop 9x */\n    if(EC16(optional_hdr64.Magic)==PE32P_SIGNATURE) {\n#if HAVE_JSON\n        pe_add_heuristic_property(ctx, \"BadOptionalHeaderSizePE32Plus\");\n#endif\n        if(EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr64)) {\n\t    /* FIXME: need to play around a bit more with xp64 */\n\t    cli_dbgmsg(\"Incorrect SizeOfOptionalHeader for PE32+\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tpe_plus = 1;\n    }\n\n    if(!pe_plus) { /* PE */\n\tif (EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr32)) {\n\t    /* Seek to the end of the long header */\n\t    at += EC16(file_hdr.SizeOfOptionalHeader)-sizeof(struct pe_image_optional_hdr32);\n\t}\n\n\tif(DCONF & PE_CONF_UPACK)\n\t    upack = (EC16(file_hdr.SizeOfOptionalHeader)==0x148);\n\n\tvep = EC32(optional_hdr32.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr32.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr32.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr32.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr32.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr32.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr32.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr32.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr32.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n\tdirs = optional_hdr32.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr32.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr32.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr32.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr32.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr32.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr32.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr32.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr32.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n\n    } else { /* PE+ */\n        /* read the remaining part of the header */\n        if(fmap_readn(map, &optional_hdr32 + 1, at, sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) {\n\t    cli_dbgmsg(\"Can't read optional file header\\n\");\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\tat += sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32);\n\tvep = EC32(optional_hdr64.AddressOfEntryPoint);\n\thdr_size = EC32(optional_hdr64.SizeOfHeaders);\n\tcli_dbgmsg(\"File format: PE32+\\n\");\n\n\tcli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr64.MajorLinkerVersion);\n\tcli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr64.MinorLinkerVersion);\n\tcli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr64.SizeOfCode));\n\tcli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfInitializedData));\n\tcli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfUninitializedData));\n\tcli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);\n\tcli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr64.BaseOfCode));\n\tcli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr64.SectionAlignment));\n\tcli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr64.FileAlignment));\n\tcli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MajorSubsystemVersion));\n\tcli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MinorSubsystemVersion));\n\tcli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr64.SizeOfImage));\n\tcli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);\n\tcli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n\tdirs = optional_hdr64.DataDirectory;\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr64.MajorLinkerVersion);\n    cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr64.MinorLinkerVersion);\n    cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr64.SizeOfCode));\n    cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr64.SizeOfInitializedData));\n    cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr64.SizeOfUninitializedData));\n    cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr64.NumberOfRvaAndSizes));\n    cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr64.MajorSubsystemVersion));\n    cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr64.MinorSubsystemVersion));\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.BaseOfCode));\n    cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SectionAlignment));\n    cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.FileAlignment));\n    cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SizeOfImage));\n    cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);\n\n    snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);\n    cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);\n#endif\n    }\n\n#if HAVE_JSON\n    if (ctx->options & CL_SCAN_FILE_PROPERTIES) {\n        snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", vep);\n        cli_jsonstr(pe_json, \"EntryPoint\", jsonbuf);\n    }\n#endif\n\n\n    switch(pe_plus ? EC16(optional_hdr64.Subsystem) : EC16(optional_hdr32.Subsystem)) {\n\tcase 0:\n        subsystem = \"Unknown\";\n\t    break;\n\tcase 1:\n        subsystem = \"Native (svc)\";\n\t    native = 1;\n\t    break;\n\tcase 2:\n        subsystem = \"Win32 GUI\";\n\t    break;\n\tcase 3:\n        subsystem = \"Win32 console\";\n\t    break;\n\tcase 5:\n        subsystem = \"OS/2 console\";\n\t    break;\n\tcase 7:\n        subsystem = \"POSIX console\";\n\t    break;\n\tcase 8:\n        subsystem = \"Native Win9x driver\";\n\t    break;\n\tcase 9:\n        subsystem = \"WinCE GUI\";\n\t    break;\n\tcase 10:\n        subsystem = \"EFI application\";\n\t    break;\n\tcase 11:\n        subsystem = \"EFI driver\";\n\t    break;\n\tcase 12:\n        subsystem = \"EFI runtime driver\";\n\t    break;\n\tcase 13:\n        subsystem = \"EFI ROM image\";\n\t    break;\n\tcase 14:\n        subsystem = \"Xbox\";\n\t    break;\n\tcase 16:\n        subsystem = \"Boot application\";\n\t    break;\n\tdefault:\n        subsystem = \"Unknown\";\n    }\n\n    cli_dbgmsg(\"Subsystem: %s\\n\", subsystem);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Subsystem\", subsystem);\n#endif\n\n    cli_dbgmsg(\"------------------------------------\\n\");\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment)) || (pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment))%0x1000)) {\n        cli_dbgmsg(\"Bad virtual alignemnt\\n\");\n\tcli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment)) || (pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment))%0x200)) {\n        cli_dbgmsg(\"Bad file alignemnt\\n\");\n\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\treturn CL_VIRUS;\n    }\n\n    fsize = map->len;\n\n    section_hdr = (struct pe_image_section_hdr *) cli_calloc(nsections, sizeof(struct pe_image_section_hdr));\n\n    if(!section_hdr) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\treturn CL_EMEM;\n    }\n\n    exe_sections = (struct cli_exe_section *) cli_calloc(nsections, sizeof(struct cli_exe_section));\n    \n    if(!exe_sections) {\n\tcli_dbgmsg(\"Can't allocate memory for section headers\\n\");\n\tfree(section_hdr);\n\treturn CL_EMEM;\n    }\n\n    valign = (pe_plus)?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment);\n    falign = (pe_plus)?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment);\n\n    if(fmap_readn(map, section_hdr, at, sizeof(struct pe_image_section_hdr)*nsections) != (int)(nsections*sizeof(struct pe_image_section_hdr))) {\n        cli_dbgmsg(\"Can't read section header\\n\");\n\tcli_dbgmsg(\"Possibly broken PE file\\n\");\n\tfree(section_hdr);\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n    at += sizeof(struct pe_image_section_hdr)*nsections;\n\n    for(i = 0; falign!=0x200 && i<nsections; i++) {\n\t/* file alignment fallback mode - blah */\n\tif (falign && section_hdr[i].SizeOfRawData && EC32(section_hdr[i].PointerToRawData)%falign && !(EC32(section_hdr[i].PointerToRawData)%0x200)) {\n\t    cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");\n\t    falign = 0x200;\n\t}\n    }\n\n    hdr_size = PESALIGN(hdr_size, valign); /* Aligned headers virtual size */\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    for(i = 0; i < nsections; i++) {\n\tstrncpy(sname, (char *) section_hdr[i].Name, 8);\n\tsname[8] = 0;\n\texe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n\texe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n\texe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n\texe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n\texe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n\texe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */\n\texe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n\texe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n\texe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n            free(section_hdr);\n            free(exe_sections);\n            return CL_ETIMEOUT;\n        }\n#endif\n\n\tif (!exe_sections[i].vsz && exe_sections[i].rsz)\n\t    exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);\n\n\tif (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))\n\t    exe_sections[i].rsz = fsize - exe_sections[i].raw;\n\t\n\tcli_dbgmsg(\"Section %d\\n\", i);\n\tcli_dbgmsg(\"Section name: %s\\n\", sname);\n\tcli_dbgmsg(\"Section data (from headers - in memory)\\n\");\n\tcli_dbgmsg(\"VirtualSize: 0x%x 0x%x\\n\", exe_sections[i].uvsz, exe_sections[i].vsz);\n\tcli_dbgmsg(\"VirtualAddress: 0x%x 0x%x\\n\", exe_sections[i].urva, exe_sections[i].rva);\n\tcli_dbgmsg(\"SizeOfRawData: 0x%x 0x%x\\n\", exe_sections[i].ursz, exe_sections[i].rsz);\n\tcli_dbgmsg(\"PointerToRawData: 0x%x 0x%x\\n\", exe_sections[i].uraw, exe_sections[i].raw);\n\n\tif(exe_sections[i].chr & 0x20) {\n\t    cli_dbgmsg(\"Section contains executable code\\n\");\n\n\t    if(exe_sections[i].vsz < exe_sections[i].rsz) {\n\t\tcli_dbgmsg(\"Section contains free space\\n\");\n\t\t/*\n\t\tcli_dbgmsg(\"Dumping %d bytes\\n\", section_hdr.SizeOfRawData - section_hdr.VirtualSize);\n\t\tddump(desc, section_hdr.PointerToRawData + section_hdr.VirtualSize, section_hdr.SizeOfRawData - section_hdr.VirtualSize, cli_gentemp(NULL));\n\t\t*/\n\n\t    }\n\t}\n\n\tif(exe_sections[i].chr & 0x20000000)\n\t    cli_dbgmsg(\"Section's memory is executable\\n\");\n\n\tif(exe_sections[i].chr & 0x80000000)\n\t    cli_dbgmsg(\"Section's memory is writeable\\n\");\n\n\tif (DETECT_BROKEN_PE && (!valign || (exe_sections[i].urva % valign))) { /* Bad virtual alignment */\n\t    cli_dbgmsg(\"VirtualAddress is misaligned\\n\");\n\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n\t    if (exe_sections[i].raw >= fsize) { /* really broken */\n\t      cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n\t      cli_dbgmsg(\"------------------------------------\\n\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\tif(DETECT_BROKEN_PE) {\n\t\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\t    return CL_VIRUS;\n\t\t}\n\t\treturn CL_CLEAN; /* no ninjas to see here! move along! */\n\t    }\n\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    /* check hash section sigs */\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);\n\t        if (ret != CL_CLEAN) {\n\t            if (ret != CL_VIRUS)\n\t                cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));\n\t\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t            free(section_hdr);\n\t            free(exe_sections);\n\t            return ret;\n\t        }\n\t    }\n\t}\n\tcli_dbgmsg(\"------------------------------------\\n\");\n\n\tif (exe_sections[i].urva>>31 || exe_sections[i].uvsz>>31 || (exe_sections[i].rsz && exe_sections[i].uraw>>31) || exe_sections[i].ursz>>31) {\n\t    cli_dbgmsg(\"Found PE values with sign bit set\\n\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    if(DETECT_BROKEN_PE) {\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\treturn CL_VIRUS;\n\t    }\n\t    return CL_CLEAN;\n\t}\n\n\tif(!i) {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva!=hdr_size) { /* Bad first section RVA */\n\t        cli_dbgmsg(\"First section is in the wrong place\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    min = exe_sections[i].rva;\n\t    max = exe_sections[i].rva + exe_sections[i].rsz;\n\t} else {\n\t    if (DETECT_BROKEN_PE && exe_sections[i].urva - exe_sections[i-1].urva != exe_sections[i-1].vsz) { /* No holes, no overlapping, no virtual disorder */\n\t        cli_dbgmsg(\"Virtually misplaced section (wrong order, overlapping, non contiguous)\\n\");\n\t\tcli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\treturn CL_VIRUS;\n\t    }\n\t    if(exe_sections[i].rva < min)\n\t        min = exe_sections[i].rva;\n\n\t    if(exe_sections[i].rva + exe_sections[i].rsz > max) {\n\t        max = exe_sections[i].rva + exe_sections[i].rsz;\n\t\toverlays = exe_sections[i].raw + exe_sections[i].rsz;\n\t    }\n\t}\n    }\n\n    free(section_hdr);\n\n    if(!(ep = cli_rawaddr(vep, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\tcli_dbgmsg(\"EntryPoint out of file\\n\");\n\tfree(exe_sections);\n\tif(DETECT_BROKEN_PE) {\n\t    cli_append_virus(ctx,\"Heuristics.Broken.Executable\");\n\t    return CL_VIRUS;\n\t}\n\treturn CL_CLEAN;\n    }\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"EntryPointOffset\", ep);\n\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n\n    cli_dbgmsg(\"EntryPoint offset: 0x%x (%d)\\n\", ep, ep);\n\n    if(pe_plus) { /* Do not continue for PE32+ files */\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    epsize = fmap_readn(map, epbuff, ep, 4096);\n\n\n    /* Disasm scan disabled since it's now handled by the bytecode */\n\n    /* CLI_UNPTEMP(\"DISASM\",(exe_sections,0)); */\n    /* if(disasmbuf((unsigned char*)epbuff, epsize, ndesc)) */\n    /* \tret = cli_scandesc(ndesc, ctx, CL_TYPE_PE_DISASM, 1, NULL, AC_SCAN_VIR); */\n    /* close(ndesc); */\n    /* CLI_TMPUNLK(); */\n    /* free(tempfile); */\n    /* if(ret == CL_VIRUS) { */\n    /* \tfree(exe_sections); */\n    /* \treturn ret; */\n    /* } */\n\n    if(overlays) {\n\tint overlays_sz = fsize - overlays;\n\tif(overlays_sz > 0) {\n\t    ret = cli_scanishield(ctx, overlays, overlays_sz);\n\t    if(ret != CL_CLEAN) {\n\t\tfree(exe_sections);\n\t\treturn ret;\n\t    }\n\t}\n    }\n\n    pedata.nsections = nsections;\n    pedata.ep = ep;\n    pedata.offset = 0;\n    memcpy(&pedata.file_hdr, &file_hdr, sizeof(file_hdr));\n    memcpy(&pedata.opt32, &pe_opt.opt32, sizeof(pe_opt.opt32));\n    memcpy(&pedata.opt64, &pe_opt.opt64, sizeof(pe_opt.opt64));\n    memcpy(&pedata.dirs, dirs, sizeof(pedata.dirs));\n    pedata.e_lfanew = e_lfanew;\n    pedata.overlays = overlays;\n    pedata.overlays_sz = fsize - overlays;\n    pedata.hdr_size = hdr_size;\n\n    /* Bytecode BC_PE_ALL hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\tfree(exe_sections);\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_ALL, map);\n    switch (ret) {\n        case CL_ENULLARG:\n            cli_warnmsg(\"cli_scanpe: NULL argument supplied\\n\");\n            break;\n        case CL_VIRUS:\n        case CL_BREAK:\n            free(exe_sections);\n            cli_bytecode_context_destroy(bc_ctx);\n            return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN;\n    }\n    cli_bytecode_context_destroy(bc_ctx);\n    /* Attempt to detect some popular polymorphic viruses */\n\n    /* W32.Parite.B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_PARITE) && !dll && epsize == 4096 && ep == exe_sections[nsections - 1].raw) {\n        const char *pt = cli_memstr(epbuff, 4040, \"\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00\", 15);\n\tif(pt) {\n\t    pt += 15;\n\t    if((((uint32_t)cli_readint32(pt) ^ (uint32_t)cli_readint32(pt + 4)) == 0x505a4f) && (((uint32_t)cli_readint32(pt + 8) ^ (uint32_t)cli_readint32(pt + 12)) == 0xffffb) && (((uint32_t)cli_readint32(pt + 16) ^ (uint32_t)cli_readint32(pt + 20)) == 0xb8)) {\n\t        cli_append_virus(ctx,\"Heuristics.W32.Parite.B\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n    }\n\n    /* Kriz */\n    if(SCAN_ALGO && (DCONF & PE_CONF_KRIZ) && epsize >= 200 && CLI_ISCONTAINED(exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz, ep, 0x0fd2) && epbuff[1]=='\\x9c' && epbuff[2]=='\\x60') {\n\tenum {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSXORPRFX,KZSXOR,KZSDDELTA,KZSLOOP,KZSTOP};\n\tuint8_t kzs[] = {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSTRASH,KZSXORPRFX,KZSXOR,KZSTRASH,KZSDDELTA,KZSTRASH,KZSLOOP,KZSTOP};\n\tuint8_t *kzstate = kzs;\n\tuint8_t *kzcode = (uint8_t *)epbuff + 3;\n\tuint8_t kzdptr=0xff, kzdsize=0xff;\n\tint kzlen = 197, kzinitlen=0xffff, kzxorlen=-1;\n\tcli_dbgmsg(\"in kriz\\n\");\n\n\twhile(*kzstate!=KZSTOP) {\n\t    uint8_t op;\n\t    if(kzlen<=6) break;\n\t    op = *kzcode++;\n\t    kzlen--;\n\t    switch (*kzstate) {\n\t    case KZSTRASH: case KZSGETSIZE: {\n\t\tint opsz=0;\n\t\tswitch(op) {\n\t\tcase 0x81:\n\t\t    kzcode+=5;\n\t\t    kzlen-=5;\n\t\t    break;\n\t\tcase 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbd: case 0xbe: case 0xbf:\n\t\t    if(*kzstate==KZSGETSIZE && cli_readint32(kzcode)==0x0fd2) {\n\t\t\tkzinitlen = kzlen-5;\n\t\t\tkzdsize=op-0xb8;\n\t\t\tkzstate++;\n\t\t\top=4; /* fake the register to avoid breaking out */\n\t\t\tcli_dbgmsg(\"kriz: using #%d as size counter\\n\", kzdsize);\n\t\t    }\n\t\t    opsz=4;\n\t\tcase 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4d: case 0x4e: case 0x4f:\n\t\t    op&=7;\n\t\t    if(op!=kzdptr && op!=kzdsize) {\n\t\t\tkzcode+=opsz;\n\t\t\tkzlen-=opsz;\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t    kzcode--;\n\t\t    kzlen++;\n\t\t    kzstate++;\n\t\t}\n\t\tbreak;\n\t    }\n\t    case KZSCDELTA:\n\t\tif(op==0xe8 && (uint32_t)cli_readint32(kzcode) < 0xff) {\n\t\t    kzlen-=*kzcode+4;\n\t\t    kzcode+=*kzcode+4;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSPDELTA:\n\t\tif((op&0xf8)==0x58 && (kzdptr=op-0x58)!=4) {\n\t\t    kzstate++;\n\t\t    cli_dbgmsg(\"kriz: using #%d as pointer\\n\", kzdptr);\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSXORPRFX:\n\t\tkzstate++;\n\t\tif(op==0x3e) break;\n\t    case KZSXOR:\n\t\tif (op==0x80 && *kzcode==kzdptr+0xb0) {\n\t\t    kzxorlen=kzlen;\n\t\t    kzcode+=+6;\n\t\t    kzlen-=+6;\n\t\t    kzstate++;\n\t\t} else *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSDDELTA:\n\t\tif (op==kzdptr+0x48) kzstate++;\n\t\telse *kzstate=KZSTOP;\n\t\tbreak;\n\t    case KZSLOOP:\n\t\tif (op==kzdsize+0x48 && *kzcode==0x75 && kzlen-(int8_t)kzcode[1]-3<=kzinitlen && kzlen-(int8_t)kzcode[1]>=kzxorlen) {\n\t\t    cli_append_virus(ctx,\"Heuristics.W32.Kriz\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t\tcli_dbgmsg(\"kriz: loop out of bounds, corrupted sample?\\n\");\n\t\tkzstate++;\n\t    }\n\t}\n    }\n\n    /* W32.Magistr.A/B */\n    if(SCAN_ALGO && (DCONF & PE_CONF_MAGISTR) && !dll && (nsections>1) && (exe_sections[nsections - 1].chr & 0x80000000)) {\n        uint32_t rsize, vsize, dam = 0;\n\n\tvsize = exe_sections[nsections - 1].uvsz;\n\trsize = exe_sections[nsections - 1].rsz;\n\tif(rsize < exe_sections[nsections - 1].ursz) {\n\t    rsize = exe_sections[nsections - 1].ursz;\n\t    dam = 1;\n\t}\n\n\tif(vsize >= 0x612c && rsize >= 0x612c && ((vsize & 0xff) == 0xec)) {\n\t\tint bw = rsize < 0x7000 ? rsize : 0x7000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x2c\\x61\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx, dam ? \"Heuristics.W32.Magistr.A.dam\" : \"Heuristics.W32.Magistr.A\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t}\n\t    }\n\n\t} else if(rsize >= 0x7000 && vsize >= 0x7000 && ((vsize & 0xff) == 0xed)) {\n\t\tint bw = rsize < 0x8000 ? rsize : 0x8000;\n\t\tconst char *tbuff;\n\n\t    if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {\n\t\tif(cli_memstr(tbuff, 4091, \"\\xe8\\x04\\x72\\x00\\x00\", 5)) {\n\t\t    cli_append_virus(ctx,dam ? \"Heuristics.W32.Magistr.B.dam\" : \"Heuristics.W32.Magistr.B\");\n\t\t    if (!SCAN_ALL) {\n\t\t        free(exe_sections);\n\t\t\treturn CL_VIRUS;\n\t\t    }\n\t\t    viruses_found++;\n\t\t} \n\t    }\n\t}\n    }\n\n    /* W32.Polipos.A */\n    while(polipos && !dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && (EC16(optional_hdr32.Subsystem) == 2 || EC16(optional_hdr32.Subsystem) == 3) && EC16(file_hdr.Machine) == 0x14c && optional_hdr32.SizeOfStackReserve >= 0x80000) {\n\tuint32_t jump, jold, *jumps = NULL;\n\tconst uint8_t *code;\n\tunsigned int xsjs = 0;\n\n\tif(exe_sections[0].rsz > CLI_MAX_ALLOCATION) break;\n\n\tif(!exe_sections[0].rsz) break;\n\tif(!(code=fmap_need_off_once(map, exe_sections[0].raw, exe_sections[0].rsz))) break;\n\tfor(i=0; i<exe_sections[0].rsz - 5; i++) {\n\t    if((uint8_t)(code[i]-0xe8) > 1) continue;\n\t    jump = cli_rawaddr(exe_sections[0].rva+i+5+cli_readint32(&code[i+1]), exe_sections, nsections, &err, fsize, hdr_size);\n\t    if(err || !CLI_ISCONTAINED(exe_sections[polipos].raw, exe_sections[polipos].rsz, jump, 9)) continue;\n\t    if(xsjs % 128 == 0) {\n\t\tif(xsjs == 1280) break;\n\t\tif(!(jumps=(uint32_t *)cli_realloc2(jumps, (xsjs+128)*sizeof(uint32_t)))) {\n\t\t    free(exe_sections);\n\t\t    return CL_EMEM;\n\t\t}\n\t    }\n\t    j=0;\n\t    for(; j<xsjs; j++) {\n\t\tif(jumps[j]<jump) continue;\n\t\tif(jumps[j]==jump) {\n\t\t    xsjs--;\n\t\t    break;\n\t\t}\n\t\tjold=jumps[j];\n\t\tjumps[j]=jump;\n\t\tjump=jold;\n\t    }\n\t    jumps[j]=jump;\n\t    xsjs++;\n\t}\n\tif(!xsjs) break;\n\tcli_dbgmsg(\"Polipos: Checking %d xsect jump(s)\\n\", xsjs);\n\tfor(i=0;i<xsjs;i++) {\n\t    if(!(code = fmap_need_off_once(map, jumps[i], 9))) continue;\n\t    if((jump=cli_readint32(code))==0x60ec8b55 || (code[4]==0x0ec && ((jump==0x83ec8b55 && code[6]==0x60) || (jump==0x81ec8b55 && !code[7] && !code[8])))) {\n\t\tcli_append_virus(ctx,\"Heuristics.W32.Polipos.A\");\n\t\tif (!SCAN_ALL) {\n\t\t    free(jumps);\n\t\t    free(exe_sections);\n\t\t    return CL_VIRUS;\n\t\t}\n\t\tviruses_found++;\n\t    }\n\t}\n\tfree(jumps);\n\tbreak;\n    }\n\n    /* Trojan.Swizzor.Gen */\n    if (SCAN_ALGO && (DCONF & PE_CONF_SWIZZOR) && nsections > 1 && fsize > 64*1024 && fsize < 4*1024*1024) {\n\t    if(dirs[2].Size) {\n\t\t    struct swizz_stats *stats = cli_calloc(1, sizeof(*stats));\n\t\t    unsigned int m = 1000;\n\t\t    ret = CL_CLEAN;\n\n\t\t    if (!stats)\n\t\t\t    ret = CL_EMEM;\n\t\t    else {\n\t\t\t    cli_parseres_special(EC32(dirs[2].VirtualAddress), EC32(dirs[2].VirtualAddress), map, exe_sections, nsections, fsize, hdr_size, 0, 0, &m, stats);\n\t\t\t    if ((ret = cli_detect_swizz(stats)) == CL_VIRUS) {\n\t\t\t\tcli_append_virus(ctx,\"Heuristics.Trojan.Swizzor.Gen\");\n\t\t\t    }\n\t\t\t    free(stats);\n\t\t    }\n\t\t    if (ret != CL_CLEAN) {\n\t\t\tif (!(ret == CL_VIRUS && SCAN_ALL)) {\n\t\t\t    free(exe_sections);\n\t\t\t    return ret;\n\t\t\t}\n\t\t\tviruses_found++;\n\t\t    }\n\t    }\n    }\n\n\n    /* !!!!!!!!!!!!!!    PACKERS START HERE    !!!!!!!!!!!!!! */\n    corrupted_cur = ctx->corrupted_input;\n    ctx->corrupted_input = 2; /* caller will reset on return */\n\n\n    /* UPX, FSG, MEW support */\n\n    /* try to find the first section with physical size == 0 */\n    found = 0;\n    if(DCONF & (PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW)) {\n\tfor(i = 0; i < (unsigned int) nsections - 1; i++) {\n\t    if(!exe_sections[i].rsz && exe_sections[i].vsz && exe_sections[i + 1].rsz && exe_sections[i + 1].vsz) {\n\t\tfound = 1;\n\t\tcli_dbgmsg(\"UPX/FSG/MEW: empty section found - assuming compression\\n\");\n#if HAVE_JSON\n        cli_jsonbool(pe_json, \"HasEmptySection\", 1);\n#endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    /* MEW support */\n    if (found && (DCONF & PE_CONF_MEW) && epsize>=16 && epbuff[0]=='\\xe9') {\n\tuint32_t fileoffset;\n\tconst char *tbuff;\n\n\tfileoffset = (vep + cli_readint32(epbuff + 1) + 5);\n\twhile (fileoffset == 0x154 || fileoffset == 0x158) {\n\t    char *src;\n\t    uint32_t offdiff, uselzma;\n\n\t    cli_dbgmsg (\"MEW: found MEW characteristics %08X + %08X + 5 = %08X\\n\", \n\t\t\tcli_readint32(epbuff + 1), vep, cli_readint32(epbuff + 1) + vep + 5);\n\n\t    if(!(tbuff = fmap_need_off_once(map, fileoffset, 0xb0)))\n\t\tbreak;\n\t    if (fileoffset == 0x154) cli_dbgmsg(\"MEW: Win9x compatibility was set!\\n\");\n\t    else cli_dbgmsg(\"MEW: Win9x compatibility was NOT set!\\n\");\n\n\t    if((offdiff = cli_readint32(tbuff+1) - EC32(optional_hdr32.ImageBase)) <= exe_sections[i + 1].rva || offdiff >= exe_sections[i + 1].rva + exe_sections[i + 1].raw - 4) {\n\t        cli_dbgmsg(\"MEW: ESI is not in proper section\\n\");\n\t\tbreak;\n\t    }\n\t    offdiff -= exe_sections[i + 1].rva;\n\n\t    if(!exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: mew section is empty\\n\");\n\t\tbreak;\n\t    }\n\t    ssize = exe_sections[i + 1].vsz;\n\t    dsize = exe_sections[i].vsz;\n\n\t    cli_dbgmsg(\"MEW: ssize %08x dsize %08x offdiff: %08x\\n\", ssize, dsize, offdiff);\n\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize, dsize));\n\t    CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize + dsize, exe_sections[i + 1].rsz));\n\n\t    if (exe_sections[i + 1].rsz < offdiff + 12 || exe_sections[i + 1].rsz > ssize) {\n\t        cli_dbgmsg(\"MEW: Size mismatch: %08x\\n\", exe_sections[i + 1].rsz);\n\t\tbreak;\n\t    }\n\n\t    /* allocate needed buffer */\n\t    if (!(src = cli_calloc (ssize + dsize, sizeof(char)))) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((bytes = fmap_readn(map, src + dsize, exe_sections[i + 1].raw, exe_sections[i + 1].rsz)) != exe_sections[i + 1].rsz) {\n\t\tcli_dbgmsg(\"MEW: Can't read %d bytes [read: %lu]\\n\", exe_sections[i + 1].rsz, (unsigned long)bytes);\n\t\tfree(exe_sections);\n\t\tfree(src);\n\t\treturn CL_EREAD;\n\t    }\n\t    cli_dbgmsg(\"MEW: %u (%08x) bytes read\\n\", (unsigned int)bytes, (unsigned int)bytes);\n\n\t    /* count offset to lzma proc, if lzma used, 0xe8 -> call */\n\t    if (tbuff[0x7b] == '\\xe8') {\n\t        if (!CLI_ISCONTAINED(exe_sections[1].rva, exe_sections[1].vsz, cli_readint32(tbuff + 0x7c) + fileoffset + 0x80, 4)) {\n\t\t    cli_dbgmsg(\"MEW: lzma proc out of bounds!\\n\");\n\t\t    free(src);\n\t\t    break; /* to next unpacker in chain */\n\t\t}\n\t\tuselzma = cli_readint32(tbuff + 0x7c) - (exe_sections[0].rva - fileoffset - 0x80);\n\t    } else {\n\t        uselzma = 0;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"MEW\");\n#endif\n\n\t    CLI_UNPTEMP(\"MEW\",(src,exe_sections,0));\n\t    CLI_UNPRESULTS(\"MEW\",(unmew11(src, offdiff, ssize, dsize, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, uselzma, ndesc)),1,(src,0));\n\t    break;\n\t}\n    }\n\n    if(epsize<168) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    if (found || upack) {\n\t/* Check EP for UPX vs. FSG vs. Upack */\n\n\t/* Upack 0.39 produces 2 types of executables\n\t * 3 sections:           | 2 sections (one empty, I don't chech found if !upack, since it's in OR above):\n\t *   mov esi, value      |   pusha\n\t *   lodsd               |   call $+0x9\n\t *   push eax            |\n\t *\n\t * Upack 1.1/1.2 Beta produces [based on 2 samples (sUx) provided by aCaB]:\n\t * 2 sections\n\t *   mov esi, value\n\t *   loads\n\t *   mov edi, eax\n\t *\n\t * Upack unknown [sample 0297729]\n\t * 3 sections\n\t *   mov esi, value\n\t *   push [esi]\n\t *   jmp\n\t * \n\t */\n\t/* upack 0.39-3s + sample 0151477*/\n \twhile(((upack && nsections == 3) && /* 3 sections */\n\t    ((\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x50' /* lodsd; push eax */\n\t     )\n\t    || \n\t    /* based on 0297729 sample from aCaB */\n\t    (epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > min && /* mov esi */\n\t     epbuff[5] == '\\xff' && epbuff[6] == '\\x36' /* push [esi] */\n\t     )\n\t   )) \n\t   ||\n\t   ((!upack && nsections == 2) && /* 2 sections */\n\t    (( /* upack 0.39-2s */\n\t     epbuff[0] == '\\x60' && epbuff[1] == '\\xe8' && cli_readint32(epbuff+2) == 0x9 /* pusha; call+9 */\n\t     )\n\t    ||\n\t    ( /* upack 1.1/1.2, based on 2 samples */\n\t     epbuff[0] == '\\xbe' && cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase) < min &&  /* mov esi */\n\t     cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > 0 &&\n\t     epbuff[5] == '\\xad' && epbuff[6] == '\\x8b' && epbuff[7] == '\\xf8' /* loads;  mov edi, eax */\n\t     )\n\t   ))\n\t   ) { \n\t    uint32_t vma, off;\n\t    int a,b,c;\n\n\t    cli_dbgmsg(\"Upack characteristics found.\\n\");\n\t    a = exe_sections[0].vsz;\n\t    b = exe_sections[1].vsz;\n\t    if (upack) {\n\t        cli_dbgmsg(\"Upack: var set\\n\");\n\t\tc = exe_sections[2].vsz;\n\t\tssize = exe_sections[0].ursz + exe_sections[0].uraw;\n\t\toff = exe_sections[0].rva;\n\t\tvma = EC32(optional_hdr32.ImageBase) + exe_sections[0].rva;\n\t    } else {\n\t        cli_dbgmsg(\"Upack: var NOT set\\n\");\n\t\tc = exe_sections[1].rva;\n\t\tssize = exe_sections[1].uraw;\n\t\toff = 0;\n\t\tvma = exe_sections[1].rva - exe_sections[1].uraw;\n\t    }\n\n\t    dsize = a+b+c;\n\n\t    CLI_UNPSIZELIMITS(\"Upack\", MAX(MAX(dsize, ssize), exe_sections[1].ursz));\n\n\t    if (!CLI_ISCONTAINED(0, dsize, exe_sections[1].rva - off, exe_sections[1].ursz) || (upack && !CLI_ISCONTAINED(0, dsize, exe_sections[2].rva - exe_sections[0].rva, ssize)) || ssize > dsize) {\n\t        cli_dbgmsg(\"Upack: probably malformed pe-header, skipping to next unpacker\\n\");\n\t\tbreak;\n\t    }\n\t\t\t\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t        free(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    if((unsigned int)fmap_readn(map, dest, 0, ssize) != ssize) {\n\t        cli_dbgmsg(\"Upack: Can't read raw data of section 0\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n\t    if(upack) memmove(dest + exe_sections[2].rva - exe_sections[0].rva, dest, ssize);\n\n\t    if((unsigned int)fmap_readn(map, dest + exe_sections[1].rva - off, exe_sections[1].uraw, exe_sections[1].ursz) != exe_sections[1].ursz) {\n\t\tcli_dbgmsg(\"Upack: Can't read raw data of section 1\\n\");\n\t\tfree(dest);\n\t\tbreak;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Upack\");\n#endif\n\n\t    CLI_UNPTEMP(\"Upack\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Upack\",(unupack(upack, dest, dsize, epbuff, vma, ep, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, ndesc)),1,(dest,0));\n\t    break;\n\t}\n    }\n\n    \n    while(found  && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\x87' && epbuff[1] == '\\x25') {\n\tconst char *dst;\n\n\t/* FSG v2.0 support - thanks to aCaB ! */\n\n\tuint32_t newesi, newedi, newebx, newedx;\n\t\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\t\n\tnewedx = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: xchg out of bounds (%x), giving up\\n\", newedx);\n\t    break;\n\t}\n\t\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i + 1);\n\t    free(exe_sections);\n\t    return CL_ESEEK;\n\t}\n\n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(newedx < exe_sections[i + 1].rva || !CLI_ISCONTAINED(src, ssize, dst, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {\n\t    cli_dbgmsg(\"FSG: New ESP (%x) is wrong\\n\", newedx);\n\t    break;\n\t}\n \n\tdst = src + newedx - exe_sections[i + 1].rva;\n\tif(!CLI_ISCONTAINED(src, ssize, dst, 32)) {\n\t    cli_dbgmsg(\"FSG: New stack out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedi = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);\n\tnewesi = cli_readint32(dst + 4) - EC32(optional_hdr32.ImageBase);\n\tnewebx = cli_readint32(dst + 16) - EC32(optional_hdr32.ImageBase);\n\tnewedx = cli_readint32(dst + 20);\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination buffer (edi is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newebx, 16)) {\n\t    cli_dbgmsg(\"FSG: Array of functions out of bounds\\n\");\n\t    break;\n\t}\n\n\tnewedx=cli_readint32(newebx + 12 - exe_sections[i + 1].rva + src) - EC32(optional_hdr32.ImageBase);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\",newedx);\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,exe_sections,0));\n\tCLI_UNPRESULTSFSG2(\"FSG\",(unfsg_200(newesi - exe_sections[i + 1].rva + src, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, newedi, EC32(optional_hdr32.ImageBase), newedx, ndesc)),1,(dest,0));\n\tbreak;\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min) {\n\n\t/* FSG support - v. 1.33 (thx trog for the many samples) */\n\n\tint sectcnt = 0;\n\tconst char *support;\n\tuint32_t newesi, newedi, oldep, gp, t;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!(t = cli_rawaddr(cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size)) && err ) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp);\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* newebx = cli_readint32(support) - EC32(optional_hdr32.ImageBase);  Unused */\n\tnewedi = cli_readint32(support + 4) - EC32(optional_hdr32.ImageBase); /* 1st dest */\n\tnewesi = cli_readint32(support + 8) - EC32(optional_hdr32.ImageBase); /* Source */\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 12; t < gp - 4; t += 4) {\n\t    uint32_t rva = cli_readint32(support+t);\n\n\t    if(!rva)\n\t\tbreak;\n\n\t    rva -= EC32(optional_hdr32.ImageBase)+1;\n\t    sectcnt++;\n\n\t    if(rva % 0x1000) cli_dbgmsg(\"FSG: Original section %d is misaligned\\n\", sectcnt);\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp - 4 || cli_readint32(support + t)) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 1; t <= (uint32_t)sectcnt; t++)\n\t    sections[t].rva = cli_readint32(support + 8 + t * 4) - 1 - EC32(optional_hdr32.ImageBase);\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\toldep = vep + 161 + 6 + cli_readint32(epbuff+163);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.33 */\n    }\n\n\n    while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbb' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min && epbuff[5] == '\\xbf' && epbuff[10] == '\\xbe' && vep >= exe_sections[i + 1].rva && vep - exe_sections[i + 1].rva > exe_sections[i + 1].rva - 0xe0 ) {\n\n\t/* FSG support - v. 1.31 */\n\n\tint sectcnt = 0;\n\tuint32_t gp, t = cli_rawaddr(cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size);\n\tconst char *support;\n\tuint32_t newesi = cli_readint32(epbuff+11) - EC32(optional_hdr32.ImageBase);\n\tuint32_t newedi = cli_readint32(epbuff+6) - EC32(optional_hdr32.ImageBase);\n\tuint32_t oldep = vep - exe_sections[i + 1].rva;\n\tstruct cli_exe_section *sections;\n\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz;\n\n\tif(err) {\n\t    cli_dbgmsg(\"FSG: Support data out of padding area\\n\");\n\t    break;\n\t}\n\n\tif(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].raw) {\n\t    cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");\n\t    break;\n\t}\n\n\tif(newedi != exe_sections[i].rva) {\n\t    cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);\n\t    break;\n\t}\n\n\tCLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize) {\n\t    cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tgp = exe_sections[i + 1].raw - t;\n\n\tCLI_UNPSIZELIMITS(\"FSG\", gp)\n\n\tif(!(support = fmap_need_off_once(map, t, gp))) {\n\t    cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp); \n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\t/* Counting original sections */\n\tfor(t = 0; t < gp - 2; t += 2) {\n\t    uint32_t rva = support[t]|(support[t+1]<<8);\n\n\t    if (rva == 2 || rva == 1)\n\t\tbreak;\n\n\t    rva = ((rva-2)<<12) - EC32(optional_hdr32.ImageBase);\n\t    sectcnt++;\n\n\t    if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {\n\t\tcli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);\n\t\tbreak;\n\t    }\n\t}\n\n\tif(t >= gp-10 || cli_readint32(support + t + 6) != 2) {\n\t    break;\n\t}\n\n\tif((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {\n        cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tsections[0].rva = newedi;\n\tfor(t = 0; t <= (uint32_t)sectcnt - 1; t++) {\n\t    sections[t+1].rva = (((support[t*2]|(support[t*2+1]<<8))-2)<<12)-EC32(optional_hdr32.ImageBase);\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"FSG: Can't read raw data of section %d\\n\", i);\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    free(sections);\n\t    return CL_EMEM;\n\t}\n\n\tgp = 0xda + 6*(epbuff[16]=='\\xe8');\n\toldep = vep + gp + 6 + cli_readint32(src+gp+2+oldep);\n\tcli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"FSG\");\n#endif\n\n\tCLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));\n\tCLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));\n\tbreak; /* were done with 1.31 */\n    }\n\n\n    if(found && (DCONF & PE_CONF_UPX)) {\n\n\t/* UPX support */\n\n\t/* we assume (i + 1) is UPX1 */\n\tssize = exe_sections[i + 1].rsz;\n\tdsize = exe_sections[i].vsz + exe_sections[i + 1].vsz;\n\n        /* cli_dbgmsg(\"UPX: ssize %u dsize %u\\n\", ssize, dsize); */\n\n\tCLI_UNPSIZELIMITS(\"UPX\", MAX(dsize, ssize));\n\n\tif(ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) {\n\t    cli_dbgmsg(\"UPX: Size mismatch or dsize too big (ssize: %d, dsize: %d)\\n\", ssize, dsize);\n\t    free(exe_sections);\n\t    return CL_CLEAN;\n\t}\n\n\tif(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {\n\t    cli_dbgmsg(\"UPX: Can't read raw data of section %d\\n\", i+1);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n\tif((dest = (char *) cli_calloc(dsize + 8192, sizeof(char))) == NULL) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\t/* try to detect UPX code */\n\tif(cli_memstr(UPX_NRV2B, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2B, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2B decompression routine\\n\");\n\t    upxfn = upx_inflate2b;\n\t} else if(cli_memstr(UPX_NRV2D, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2D, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2D decompression routine\\n\");\n\t    upxfn = upx_inflate2d;\n\t} else if(cli_memstr(UPX_NRV2E, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2E, 24, epbuff + 0x69 + 8, 13)) {\n\t    cli_dbgmsg(\"UPX: Looks like a NRV2E decompression routine\\n\");\n\t    upxfn = upx_inflate2e;\n\t}\n\n\tif(upxfn) {\n\t    int skew = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase) - exe_sections[i + 1].rva;\n\n\t    if(epbuff[1] != '\\xbe' || skew <= 0 || skew > 0xfff) { /* FIXME: legit skews?? */\n\t\tskew = 0; \n\t    } else if ((unsigned int)skew > ssize) {\n\t\t/* Ignore suggested skew larger than section size */\n\t\tskew = 0;\n\t    } else {\n\t\tcli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);\n\t    }\n\n\t    /* Try skewed first (skew may be zero) */\n\t    if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0) {\n\t\tupx_success = 1;\n\t    }\n\t    /* If skew not successful and non-zero, try no skew */\n\t    else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {\n\t\tupx_success = 1;\n\t    }\n\n\t    if(upx_success)\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed\\n\");\n\t    else\n\t\tcli_dbgmsg(\"UPX: Preferred decompressor failed\\n\");\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2b) {\n\t    if(upx_inflate2b(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2b(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2B decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2B\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2d) {\n\t    if(upx_inflate2d(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2d(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\n\t\tcli_dbgmsg(\"UPX: NRV2D decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2D\\n\");\n\t    }\n\t}\n\n\tif(!upx_success && upxfn != upx_inflate2e) {\n\t    if(upx_inflate2e(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2e(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {\n\t\tcli_dbgmsg(\"UPX: NRV2E decompressor failed\\n\");\n\t    } else {\n\t\tupx_success = 1;\n\t\tcli_dbgmsg(\"UPX: Successfully decompressed with NRV2E\\n\");\n\t    }\n\t}\n\n\tif(cli_memstr(UPX_LZMA2, 20, epbuff + 0x2f, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x21), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t} else if (cli_memstr(UPX_LZMA1, 20, epbuff + 0x39, 20)) {\n\t    uint32_t strictdsize=cli_readint32(epbuff+0x2b), skew = 0;\n\t    if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {\n\t\tskew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;\n\t\tif(skew!=0x15) skew = 0;\n\t    }\n\t    if(strictdsize<=dsize)\n\t\tupx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;\n\t}\n\n\tif(!upx_success) {\n\t    cli_dbgmsg(\"UPX: All decompressors failed\\n\");\n\t    free(dest);\n\t}\n    }\n\n    if(upx_success) {\n\tfree(exe_sections);\n\n\tCLI_UNPTEMP(\"UPX/FSG\",(dest,0));\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"UPX\");\n#endif\n\n\tif((unsigned int) write(ndesc, dest, dsize) != dsize) {\n\t    cli_dbgmsg(\"UPX/FSG: Can't write %d bytes\\n\", dsize);\n\t    free(tempfile);\n\t    free(dest);\n\t    close(ndesc);\n\t    return CL_EWRITE;\n\t}\n\n\tfree(dest);\n\tif (lseek(ndesc, 0, SEEK_SET) == -1) {\n        cli_dbgmsg(\"UPX/FSG: lseek() failed\\n\");\n        close(ndesc);\n        CLI_TMPUNLK();\n        free(tempfile);\n        SHA_RESET;\n        return CL_ESEEK;\n    }\n\n\tif(ctx->engine->keeptmp)\n\t    cli_dbgmsg(\"UPX/FSG: Decompressed data saved in %s\\n\", tempfile);\n\n\tcli_dbgmsg(\"***** Scanning decompressed file *****\\n\");\n\tSHA_OFF;\n\tif((ret = cli_magic_scandesc(ndesc, ctx)) == CL_VIRUS) {\n\t    close(ndesc);\n\t    CLI_TMPUNLK();\n\t    free(tempfile);\n\t    SHA_RESET;\n\t    return CL_VIRUS;\n\t}\n\n\tSHA_RESET;\n\tclose(ndesc);\n\tCLI_TMPUNLK();\n\tfree(tempfile);\n\treturn ret;\n    }\n\n\n    /* Petite */\n\n    if(epsize<200) {\n\tfree(exe_sections);\n\treturn CL_CLEAN;\n    }\n\n    found = 2;\n\n    if(epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 1].rva + EC32(optional_hdr32.ImageBase)) {\n\tif(nsections < 2 || epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 2].rva + EC32(optional_hdr32.ImageBase))\n\t    found = 0;\n\telse\n\t    found = 1;\n    }\n\n    if(found && (DCONF & PE_CONF_PETITE)) {\n\tcli_dbgmsg(\"Petite: v2.%d compression detected\\n\", found);\n\n\tif(cli_readint32(epbuff + 0x80) == 0x163c988d) {\n\t    cli_dbgmsg(\"Petite: level zero compression is not supported yet\\n\");\n\t} else {\n\t    dsize = max - min;\n\n\t    CLI_UNPSIZELIMITS(\"Petite\", dsize);\n\n\t    if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {\n\t\tcli_dbgmsg(\"Petite: Can't allocate %d bytes\\n\", dsize);\n\t\tfree(exe_sections);\n\t\treturn CL_EMEM;\n\t    }\n\n\t    for(i = 0 ; i < nsections; i++) {\n\t\tif(exe_sections[i].raw) {\n\t\t    if(!exe_sections[i].rsz || (unsigned int)fmap_readn(map, dest + exe_sections[i].rva - min, exe_sections[i].raw, exe_sections[i].ursz) != exe_sections[i].ursz) {\n\t\t\tfree(exe_sections);\n\t\t\tfree(dest);\n\t\t\treturn CL_CLEAN;\n\t\t    }\n\t\t}\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Petite\");\n#endif\n\n\t    CLI_UNPTEMP(\"Petite\",(dest,exe_sections,0));\n\t    CLI_UNPRESULTS(\"Petite\",(petite_inflate2x_1to9(dest, min, max - min, exe_sections, nsections - (found == 1 ? 1 : 0), EC32(optional_hdr32.ImageBase),vep, ndesc, found, EC32(optional_hdr32.DataDirectory[2].VirtualAddress),EC32(optional_hdr32.DataDirectory[2].Size))),0,(dest,0));\n\t}\n    }\n\n    /* PESpin 1.1 */\n\n    if((DCONF & PE_CONF_PESPIN) && nsections > 1 &&\n       vep >= exe_sections[nsections - 1].rva &&\n       vep < exe_sections[nsections - 1].rva + exe_sections[nsections - 1].rsz - 0x3217 - 4 &&\n       memcmp(epbuff+4, \"\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3\", 10) == 0)  {\n\n\tchar *spinned;\n\n\tCLI_UNPSIZELIMITS(\"PEspin\", fsize);\n\n\tif((spinned = (char *) cli_malloc(fsize)) == NULL) {\n        cli_errmsg(\"PESping: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\n\tif((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t    cli_dbgmsg(\"PESpin: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t    free(spinned);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"PEspin\");\n#endif\n\n\tCLI_UNPTEMP(\"PESpin\",(spinned,exe_sections,0));\n\tCLI_UNPRESULTS_(\"PEspin\",SPINCASE(),(unspin(spinned, fsize, exe_sections, nsections - 1, vep, ndesc, ctx)),0,(spinned,0));\n    }\n\n\n    /* yC 1.3 & variants */\n    if((DCONF & PE_CONF_YC) && nsections > 1 &&\n       (EC32(optional_hdr32.AddressOfEntryPoint) == exe_sections[nsections - 1].rva + 0x60)) {\n\n\tuint32_t ecx = 0;\n\tint16_t offset;\n\n\t/* yC 1.3 */\n\tif (!memcmp(epbuff, \"\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED\", 15) &&\n\t    !memcmp(epbuff+0x26, \"\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC\", 13) &&\n\t    ((uint8_t)epbuff[0x13] == 0xB9) &&\n\t    ((uint16_t)(cli_readint16(epbuff+0x18)) == 0xE981) &&\n\t    !memcmp(epbuff+0x1e,\"\\x8B\\xD5\\x81\\xC2\", 4)) {\n\n\t    offset = 0;\n\t    if (0x6c - cli_readint32(epbuff+0xf) + cli_readint32(epbuff+0x22) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x14) - cli_readint32(epbuff+0x1a);\n\t}\n\n\t/* yC 1.3 variant */\n\tif (!ecx && !memcmp(epbuff, \"\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57\", 9) &&\n\t    !memcmp(epbuff+0x17, \"\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\", 8) &&\n\t    ((uint8_t)epbuff[0x23] == 0xB9)) {\n\n\t    offset = 0x10;\n\t    if (0x6c - cli_readint32(epbuff+0x1f) + cli_readint32(epbuff+0x32) == 0xC6)\n\t\tecx = cli_readint32(epbuff+0x24) - cli_readint32(epbuff+0x2a);\n\t}\n\n\t/* yC 1.x/modified */\n\tif (!ecx && !memcmp(epbuff, \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\",9) &&\n\t    ((uint8_t)epbuff[0xd] == 0xb9) &&\n\t    ((uint16_t)cli_readint16(epbuff + 0x12)== 0xbd8d) &&\n\t    !memcmp(epbuff+0x18, \"\\x8b\\xf7\\xac\", 3)) {\n\n\t    offset = -0x18;\n\t    if (0x66 - cli_readint32(epbuff+0x9) + cli_readint32(epbuff+0x14) == 0xae)\n\t\tecx = cli_readint32(epbuff+0xe);\n\t}\n\n\tif (ecx > 0x800 && ecx < 0x2000 &&\n\t    !memcmp(epbuff+0x63+offset, \"\\xaa\\xe2\\xcc\", 3) &&\n\t    (fsize >= exe_sections[nsections-1].raw + 0xC6 + ecx + offset)) {\n\n\t    char *spinned;\n\n\t    if((spinned = (char *) cli_malloc(fsize)) == NULL) {\n            cli_errmsg(\"yC: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);\n\t      free(exe_sections);\n\t      return CL_EMEM;\n\t    }\n\n\t    if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {\n\t      cli_dbgmsg(\"yC: Can't read %lu bytes\\n\", (unsigned long)fsize);\n\t      free(spinned);\n\t      free(exe_sections);\n\t      return CL_EREAD;\n\t    }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"yC\");\n#endif\n\n\t    cli_dbgmsg(\"%d,%d,%d,%d\\n\", nsections-1, e_lfanew, ecx, offset);\n\t    CLI_UNPTEMP(\"yC\",(spinned,exe_sections,0));\n\t    CLI_UNPRESULTS(\"yC\",(yc_decrypt(spinned, fsize, exe_sections, nsections-1, e_lfanew, ndesc, ecx, offset)),0,(spinned,0));\n\t}\n    }\n\n    /* WWPack */\n\n    while ((DCONF & PE_CONF_WWPACK) && nsections > 1 &&\n       vep == exe_sections[nsections - 1].rva &&\n       memcmp(epbuff, \"\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb\", 7) == 0 &&\n       memcmp(epbuff+0x68, \"\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50\", 19) == 0)  {\n\tuint32_t head = exe_sections[nsections - 1].raw;\n        uint8_t *packer;\n\tchar *src;\n\n\tssize = 0;\n\tfor(i=0 ; ; i++) {\n\t    if(exe_sections[i].raw<head)\n\t        head=exe_sections[i].raw;\n\t    if(i+1==nsections) break;\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\t}\n\tif(!head || !ssize || head>ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"WWPack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif((size_t) fmap_readn(map, src, 0, head) != head) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from headers\\n\", head);\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections-1; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i+1!=nsections) {\n            cli_dbgmsg(\"WWpack: Probably hacked/damaged file.\\n\");\n            free(src);\n            break;\n        }\n\tif((packer = (uint8_t *) cli_calloc(exe_sections[nsections - 1].rsz, sizeof(char))) == NULL) {\n\t    free(src);\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n\tif(!exe_sections[nsections - 1].rsz || (size_t) fmap_readn(map, packer, exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz) != exe_sections[nsections - 1].rsz) {\n\t    cli_dbgmsg(\"WWPack: Can't read %d bytes from wwpack sect\\n\", exe_sections[nsections - 1].rsz);\n\t    free(src);\n\t    free(packer);\n\t    free(exe_sections);\n\t    return CL_EREAD;\n\t}\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"WWPack\");\n#endif\n\n\tCLI_UNPTEMP(\"WWPack\",(src,packer,exe_sections,0));\n\tCLI_UNPRESULTS(\"WWPack\",(wwunpack((uint8_t *)src, ssize, packer, exe_sections, nsections-1, e_lfanew, ndesc)),0,(src,packer,0));\n\tbreak;\n    }\n\n\n    /* ASPACK support */\n    while((DCONF & PE_CONF_ASPACK) && ep+58+0x70e < fsize && !memcmp(epbuff,\"\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb\",8)) {\n\tchar *src;\n\n        if(epsize<0x3bf || memcmp(epbuff+0x3b9, \"\\x68\\x00\\x00\\x00\\x00\\xc3\",6)) break;\n\tssize = 0;\n\tfor(i=0 ; i< nsections ; i++)\n\t    if(ssize<exe_sections[i].rva+exe_sections[i].vsz)\n\t\tssize=exe_sections[i].rva+exe_sections[i].vsz;\n\tif(!ssize) break;\n\n\tCLI_UNPSIZELIMITS(\"Aspack\", ssize);\n\n        if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {\n\t    free(exe_sections);\n\t    return CL_EMEM;\n\t}\n        for(i = 0 ; i < (unsigned int)nsections; i++) {\n\t    if(!exe_sections[i].rsz) continue;\n            if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;\n            if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;\n        }\n        if(i!=nsections) {\n            cli_dbgmsg(\"Aspack: Probably hacked/damaged Aspack file.\\n\");\n            free(src);\n            break;\n        }\n\n#if HAVE_JSON\n        cli_jsonstr(pe_json, \"Packer\", \"Aspack\");\n#endif\n\n\tCLI_UNPTEMP(\"Aspack\",(src,exe_sections,0));\n\tCLI_UNPRESULTS(\"Aspack\",(unaspack212((uint8_t *)src, ssize, exe_sections, nsections, vep-1, EC32(optional_hdr32.ImageBase), ndesc)),1,(src,0));\n\tbreak;\n    }\n\n    /* NsPack */\n\n    while (DCONF & PE_CONF_NSPACK) {\n\tuint32_t eprva = vep;\n\tuint32_t start_of_stuff, rep = ep;\n\tunsigned int nowinldr;\n\tconst char *nbuff;\n\n\tsrc=epbuff;\n\tif (*epbuff=='\\xe9') { /* bitched headers */\n\t    eprva = cli_readint32(epbuff+1)+vep+5;\n\t    if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) break;\n\t    if (!(nbuff = fmap_need_off_once(map, rep, 24))) break;\n\t    src = nbuff;\n\t}\n\n\tif (memcmp(src, \"\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00\", 13)) break;\n\n\tnowinldr = 0x54-cli_readint32(src+17);\n\tcli_dbgmsg(\"NsPack: Found *start_of_stuff @delta-%x\\n\", nowinldr);\n\n\tif(!(nbuff = fmap_need_off_once(map, rep-nowinldr, 4))) break;\n\tstart_of_stuff=rep+cli_readint32(nbuff);\n\tif(!(nbuff = fmap_need_off_once(map, start_of_stuff, 20))) break;\n\tsrc = nbuff;\n\tif (!cli_readint32(nbuff)) {\n\t    start_of_stuff+=4; /* FIXME: more to do */\n\t    src+=4;\n\t}\n\n\tssize = cli_readint32(src+5)|0xff;\n\tdsize = cli_readint32(src+9);\n\n\tCLI_UNPSIZELIMITS(\"NsPack\", MAX(ssize,dsize));\n\n\tif (!ssize || !dsize || dsize != exe_sections[0].vsz) break;\n\tif (!(dest=cli_malloc(dsize))) {\n        cli_errmsg(\"NsPack: Unable to allocate memory for dest %u\\n\", dsize);\n        break;\n    }\n\t/* memset(dest, 0xfc, dsize); */\n\n\tif(!(src = fmap_need_off(map, start_of_stuff, ssize))) {\n\t    free(dest);\n\t    break;\n\t}\n\t/* memset(src, 0x00, ssize); */\n\n\teprva+=0x27a;\n\tif (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) {\n\t  free(dest);\n\t  break;\n\t}\n\tif(!(nbuff = fmap_need_off_once(map, rep, 5))) {\n\t  free(dest);\n\t  break;\n\t}\n\tfmap_unneed_off(map, start_of_stuff, ssize);\n\teprva=eprva+5+cli_readint32(nbuff+1);\n\tcli_dbgmsg(\"NsPack: OEP = %08x\\n\", eprva);\n\n#if HAVE_JSON\n    cli_jsonstr(pe_json, \"Packer\", \"NsPack\");\n#endif\n\n\tCLI_UNPTEMP(\"NsPack\",(dest,exe_sections,0));\n\tCLI_UNPRESULTS(\"NsPack\",(unspack(src, dest, ctx, exe_sections[0].rva, EC32(optional_hdr32.ImageBase), eprva, ndesc)),0,(dest,0));\n\tbreak;\n    }\n\n    /* to be continued ... */\n\n\n\n\n    /* !!!!!!!!!!!!!!    PACKERS END HERE    !!!!!!!!!!!!!! */\n    ctx->corrupted_input = corrupted_cur;\n\n    /* Bytecode BC_PE_UNPACKER hook */\n    bc_ctx = cli_bytecode_context_alloc();\n    if (!bc_ctx) {\n\tcli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");\n\treturn CL_EMEM;\n    }\n    cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);\n    cli_bytecode_context_setctx(bc_ctx, ctx);\n    ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_UNPACKER, map);\n    switch (ret) {\n\tcase CL_VIRUS:\n\t    free(exe_sections);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    return CL_VIRUS;\n\tcase CL_SUCCESS:\n\t    ndesc = cli_bytecode_context_getresult_file(bc_ctx, &tempfile);\n\t    cli_bytecode_context_destroy(bc_ctx);\n\t    if (ndesc != -1 && tempfile) {\n\t\tCLI_UNPRESULTS(\"bytecode PE hook\", 1, 1, (0));\n\t    }\n\t    break;\n\tdefault:\n\t    cli_bytecode_context_destroy(bc_ctx);\n    }\n\n    free(exe_sections);\n#if HAVE_JSON\n    if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n        return CL_ETIMEOUT;\n    }\n#endif\n    if (SCAN_ALL && viruses_found)\n\treturn CL_VIRUS;\n    return CL_CLEAN;",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 544,
    "critical_vars": [
      "res"
    ],
    "function": "PHP_FUNCTION",
    "filename": "php-radius/CVE-2013-2220/CVE-2013-2220_CWE-119_13c149b051f82b709e8d7cc32111e84b49d57234_radius.c.diff",
    "function_code": "PHP_FUNCTION(curl_unescape)\n{\n\tchar       *str = NULL, *out = NULL;\n\tsize_t     str_len = 0;\n\tint        out_len;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (str_len > INT_MAX) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((out = curl_easy_unescape(ch->cp, str, str_len, &out_len))) {\n\t\tRETVAL_STRINGL(out, out_len);\n\t\tcurl_free(out);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 544,
    "critical_vars": [
      "*raw",
      "*data"
    ],
    "function": "PHP_FUNCTION",
    "filename": "php-radius/CVE-2013-2220/CVE-2013-2220_CWE-119_13c149b051f82b709e8d7cc32111e84b49d57234_radius.c.diff",
    "function_code": "PHP_FUNCTION(curl_unescape)\n{\n\tchar       *str = NULL, *out = NULL;\n\tsize_t     str_len = 0;\n\tint        out_len;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_SIZE_T_INT_OVFL(str_len)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((out = curl_easy_unescape(ch->cp, str, str_len, &out_len))) {\n\t\tRETVAL_STRINGL(out, out_len);\n\t\tcurl_free(out);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2307,
    "critical_vars": [
      "i"
    ],
    "function": "excluded_channels",
    "filename": "faad2/CVE-2019-15296/CVE-2019-15296_CWE-119_942c3e0aee748ea6fe97cb2c1aa5893225316174_syntax.c.diff",
    "function_code": "static uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        if (i >= MAX_CHANNELS - num_excl_chan - 7)\n            return n;\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n\n    return n;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 170,
    "critical_vars": [
      "ld->bytes_left"
    ],
    "function": "faad_resetbits",
    "filename": "faad2/CVE-2019-15296/CVE-2019-15296_CWE-119_942c3e0aee748ea6fe97cb2c1aa5893225316174_bits.c.diff",
    "function_code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 170,
    "critical_vars": [
      "ld->buffer_size"
    ],
    "function": "faad_resetbits",
    "filename": "faad2/CVE-2019-15296/CVE-2019-15296_CWE-119_942c3e0aee748ea6fe97cb2c1aa5893225316174_bits.c.diff",
    "function_code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    if (ld->buffer_size < words * 4)\n        ld->bytes_left = 0;\n    else\n        ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 309,
    "critical_vars": [
      "intptr_t"
    ],
    "function": "SQLSetDescField",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescField.c.diff",
    "function_code": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n    \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT\n        && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&\n        (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 318,
    "critical_vars": [
      "value"
    ],
    "function": "SQLSetDescField",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescField.c.diff",
    "function_code": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n    \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT\n        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 416,
    "critical_vars": [
      "szSepLine"
    ],
    "function": "ExecuteSQL",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_iusql.c.diff",
    "function_code": "static int ExecuteSQL( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLTCHAR        szUcSQL[32001]; \n    SQLSMALLINT     cols;\n    SQLINTEGER      ret;\n    SQLLEN          nRows                   = 0;\n\n    szSepLine[ 0 ] = 0;\n\n    ansi_to_unicode( szSQL, szUcSQL );\n\n    /****************************\n     * EXECUTE SQL\n     ***************************/\n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n\n    if ( buseED ) {\n        ret = SQLExecDirect( hStmt, szUcSQL, SQL_NTS );\n\n        if ( ret == SQL_NO_DATA )\n        {\n            fprintf( stderr, \"[ISQL]INFO: SQLExecDirect returned SQL_NO_DATA\\n\" );\n        }\n        else if ( ret == SQL_SUCCESS_WITH_INFO )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]INFO: SQLExecDirect returned SQL_SUCCESS_WITH_INFO\\n\" );\n        }\n        else if ( ret != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLExecDirect\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            free(szSepLine);\n            return 0;\n        }\n    }\n    else {\n        if ( SQLPrepare( hStmt, szUcSQL, SQL_NTS ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLPrepare\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    \n        ret =  SQLExecute( hStmt );\n    \n        if ( ret == SQL_NO_DATA )\n        {\n            fprintf( stderr, \"[ISQL]INFO: SQLExecute returned SQL_NO_DATA\\n\" );\n        }\n        else if ( ret == SQL_SUCCESS_WITH_INFO )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]INFO: SQLExecute returned SQL_SUCCESS_WITH_INFO\\n\" );\n        }\n        else if ( ret != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLExecute\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n\n    do \n    {\n        /*\n         * check to see if it has generated a result set\n         */\n\n        if ( SQLNumResultCols( hStmt, &cols ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLNumResultCols\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n\n        if ( cols > 0 )\n        {\n            /****************************\n             * WRITE HEADER\n             ***************************/\n            if ( bHTMLTable )\n                WriteHeaderHTMLTable( hStmt );\n            else if ( cDelimiter == 0 )\n                UWriteHeaderNormal( hStmt, szSepLine );\n            else if ( cDelimiter && bColumnNames )\n                WriteHeaderDelimited( hStmt, cDelimiter );\n\n            /****************************\n             * WRITE BODY\n             ***************************/\n            if ( bHTMLTable )\n                WriteBodyHTMLTable( hStmt );\n            else if ( cDelimiter == 0 )\n                nRows = WriteBodyNormal( hStmt );\n            else\n                WriteBodyDelimited( hStmt, cDelimiter );\n        }\n\n        /****************************\n         * WRITE FOOTER\n         ***************************/\n        if ( bHTMLTable )\n            WriteFooterHTMLTable( hStmt );\n        else if ( cDelimiter == 0 )\n            UWriteFooterNormal( hStmt, szSepLine, nRows );\n    }\n    while ( SQL_SUCCEEDED( SQLMoreResults( hStmt )));\n\n    /****************************\n     * CLEANUP\n     ***************************/\n    SQLFreeStmt( hStmt, SQL_DROP );\n\n    return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 291,
    "critical_vars": [
      "intptr_t"
    ],
    "function": "SQLSetDescFieldW",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescFieldW.c.diff",
    "function_code": "SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n#ifdef WITH_HANDLE_REDIRECT\n\t\t{\n\t\t\tDMHDESC parent_desc;\n\n\t\t\tparent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC );\n\n\t\t\tif ( parent_desc ) {\n        \t\tdm_log_write( __FILE__, \n                \t__LINE__, \n                    \tLOG_INFO, \n                    \tLOG_INFO, \n                    \t\"Info: found parent handle\" );\n\n\t\t\t\tif ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection ))\n\t\t\t\t{\n        \t\t\tdm_log_write( __FILE__, \n                \t\t__LINE__, \n                   \t\t \tLOG_INFO, \n                   \t\t \tLOG_INFO, \n                   \t\t \t\"Info: calling redirected driver function\" );\n\n                \treturn  SQLSETDESCFIELDW( parent_desc -> connection,\n\t\t\t\t\t\t\tdescriptor,\n\t\t\t\t\t\t\trec_number,\n\t\t\t\t\t\t\tfield_identifier,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tbuffer_length );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT\n        && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&\n        (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( descriptor -> connection -> unicode_driver ||\n\t\t    CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n\t{\n    \tif ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n    \tret = SQLSETDESCFIELDW( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\t}\n\telse\n\t{\n\t\tSQLCHAR *ascii_str = NULL;\n\n    \tif ( !CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n\t\t/*\n\t\t * is it a char arg...\n\t\t */\n\n\t\tswitch ( field_identifier )\n\t\t{\n\t\t\tcase SQL_DESC_NAME:\t\t/* This is the only R/W SQLCHAR* type */\n        \t\tascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL );\n\t\t\t\tvalue = ascii_str;\n\t\t\t\tbuffer_length = strlen((char*) ascii_str );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n    \tret = SQLSETDESCFIELD( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\n\t\tif ( ascii_str ) \n\t\t{\n\t\t\tfree( ascii_str );\n\t\t}\n\t}\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 300,
    "critical_vars": [
      "value"
    ],
    "function": "SQLSetDescFieldW",
    "filename": "unixODBC/CVE-2018-7485/CVE-2018-7485_CWE-119_45ef78e037f578b15fc58938a3a3251655e71d6f_SQLSetDescFieldW.c.diff",
    "function_code": "SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n#ifdef WITH_HANDLE_REDIRECT\n\t\t{\n\t\t\tDMHDESC parent_desc;\n\n\t\t\tparent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC );\n\n\t\t\tif ( parent_desc ) {\n        \t\tdm_log_write( __FILE__, \n                \t__LINE__, \n                    \tLOG_INFO, \n                    \tLOG_INFO, \n                    \t\"Info: found parent handle\" );\n\n\t\t\t\tif ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection ))\n\t\t\t\t{\n        \t\t\tdm_log_write( __FILE__, \n                \t\t__LINE__, \n                   \t\t \tLOG_INFO, \n                   \t\t \tLOG_INFO, \n                   \t\t \t\"Info: calling redirected driver function\" );\n\n                \treturn  SQLSETDESCFIELDW( parent_desc -> connection,\n\t\t\t\t\t\t\tdescriptor,\n\t\t\t\t\t\t\trec_number,\n\t\t\t\t\t\t\tfield_identifier,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tbuffer_length );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT\n        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( descriptor -> connection -> unicode_driver ||\n\t\t    CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n\t{\n    \tif ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n    \tret = SQLSETDESCFIELDW( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\t}\n\telse\n\t{\n\t\tSQLCHAR *ascii_str = NULL;\n\n    \tif ( !CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    \t{\n        \tdm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        \t__post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        \treturn function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n\t\t}\n\n\t\t/*\n\t\t * is it a char arg...\n\t\t */\n\n\t\tswitch ( field_identifier )\n\t\t{\n\t\t\tcase SQL_DESC_NAME:\t\t/* This is the only R/W SQLCHAR* type */\n        \t\tascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL );\n\t\t\t\tvalue = ascii_str;\n\t\t\t\tbuffer_length = strlen((char*) ascii_str );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n    \tret = SQLSETDESCFIELD( descriptor -> connection,\n            \tdescriptor -> driver_desc,\n            \trec_number, \n            \tfield_identifier,\n            \tvalue, \n            \tbuffer_length );\n\t\n    \tif ( log_info.log_flag )\n    \t{\n        \tsprintf( descriptor -> msg, \n                \t\"\\n\\t\\tExit:[%s]\",\n                    \t__get_return_status( ret, s1 ));\n\t\n        \tdm_log_write( __FILE__, \n                \t__LINE__, \n                \tLOG_INFO, \n                \tLOG_INFO, \n                \tdescriptor -> msg );\n    \t}\n\n\t\tif ( ascii_str ) \n\t\t{\n\t\t\tfree( ascii_str );\n\t\t}\n\t}\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 333,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horAcc8",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n\tassert((cc%stride)==0);\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcc -= 3;\n\t\t\t\tcp += 3;\n\t\t\t}\n\t\t} else if (stride == 4)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tunsigned int ca = cp[3];\n\t\t\tcc -= 4;\n\t\t\tcp += 4;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcp[3] = (unsigned char) ((ca += cp[3]) & 0xff);\n\t\t\t\tcc -= 4;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 350,
    "critical_vars": [
      "stride"
    ],
    "function": "horAcc8",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n    if((cc%stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n                     \"%s\", \"(cc%stride)!=0\");\n        return 0;\n    }\n\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcc -= 3;\n\t\t\t\tcp += 3;\n\t\t\t}\n\t\t} else if (stride == 4)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tunsigned int ca = cp[3];\n\t\t\tcc -= 4;\n\t\t\tcp += 4;\n\t\t\twhile (cc>0) {\n\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\n\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\n\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\n\t\t\t\tcp[3] = (unsigned char) ((ca += cp[3]) & 0xff);\n\t\t\t\tcc -= 4;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 361,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horAcc16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 384,
    "critical_vars": [
      "stride"
    ],
    "function": "horAcc16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",\n                     \"%s\", \"cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 414,
    "critical_vars": [
      "stride",
      "bps"
    ],
    "function": "fpAcc",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 435,
    "critical_vars": [
      "op0",
      "occ0"
    ],
    "function": "PredictorDecodeRow",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decoderow != NULL);\n\tassert(sp->decodepfunc != NULL);  \n\n\tif ((*sp->decoderow)(tif, op0, occ0, s)) {\n\t\t(*sp->decodepfunc)(tif, op0, occ0);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 483,
    "critical_vars": [
      "occ0%rowsize"
    ],
    "function": "PredictorDecodeTile",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp->rowsize;\n\t\tassert(rowsize > 0);\n\t\tif((occ0%rowsize) !=0)\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"PredictorDecodeTile\",\n                         \"%s\", \"occ0%rowsize != 0\");\n            return 0;\n        }\n\t\tassert(sp->decodepfunc != NULL);\n\t\twhile (occ0 > 0) {\n\t\t\tif( !(*sp->decodepfunc)(tif, op0, rowsize) )\n                return 0;\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 462,
    "critical_vars": [
      "op0",
      "rowsize"
    ],
    "function": "PredictorDecodeTile",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp->rowsize;\n\t\tassert(rowsize > 0);\n\t\tassert((occ0%rowsize)==0);\n\t\tassert(sp->decodepfunc != NULL);\n\t\twhile (occ0 > 0) {\n\t\t\t(*sp->decodepfunc)(tif, op0, rowsize);\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 562,
    "critical_vars": [
      "stride"
    ],
    "function": "horDiff16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n                     \"%s\", \"(cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 544,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horDiff16",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 601,
    "critical_vars": [
      "stride"
    ],
    "function": "horDiff32",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n    if((cc%(4*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff32\",\n                     \"%s\", \"(cc%(4*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 575,
    "critical_vars": [
      "tif",
      "cp0",
      "cc"
    ],
    "function": "horDiff32",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n\tassert((cc%(4*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 645,
    "critical_vars": [
      "stride",
      "bps"
    ],
    "function": "fpDiff",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if((cc%(bps*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                     \"%s\", \"(cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 685,
    "critical_vars": [
      "cc",
      "bp"
    ],
    "function": "PredictorEncodeRow",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encoderow != NULL);\n\n\t/* XXX horizontal differencing alters user's data XXX */\n\tif( !(*sp->encodepfunc)(tif, bp, cc) )\n        return 0;\n\treturn (*sp->encoderow)(tif, bp, cc, s);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 721,
    "critical_vars": [
      "cc0%rowsize"
    ],
    "function": "PredictorEncodeTile",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_3ca657a8793dd011bf869695d72ad31c779c3cc1_tif_predict.c.diff",
    "function_code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n\n        /* \n         * Do predictor manipulation in a working buffer to avoid altering\n         * the callers buffer. http://trac.osgeo.org/gdal/ticket/1965\n         */\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tif((cc0%rowsize)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n                     \"%s\", \"(cc0%rowsize)!=0\");\n        _TIFFfree( working_copy );\n        return 0;\n    }\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n\n        _TIFFfree( working_copy );\n\n        return result_code;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 412,
    "critical_vars": [
      "*tmp"
    ],
    "function": "fpAcc",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_6a984bf7905c6621281588431f384e79d11a2e33_tif_predict.c.diff",
    "function_code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 643,
    "critical_vars": [
      "*tmp"
    ],
    "function": "fpDiff",
    "filename": "libtiff/CVE-2016-9535/CVE-2016-9535_CWE-119_6a984bf7905c6621281588431f384e79d11a2e33_tif_predict.c.diff",
    "function_code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n    if((cc%(bps*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                     \"%s\", \"(cc%(bps*stride))!=0\");\n        return 0;\n    }\n\tif (!tmp)\n\t\treturn 0;\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1341,
    "critical_vars": [
      "colb"
    ],
    "function": "DECLAREreadFunc",
    "filename": "libtiff/CVE-2016-9540/CVE-2016-9540_CWE-119_5ad9d8016fbb60109302d558f7edb2cb2a3bb8e3_tiffcp.c.diff",
    "function_code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1526,
    "critical_vars": [
      "colb"
    ],
    "function": "DECLAREwriteFunc",
    "filename": "libtiff/CVE-2016-9540/CVE-2016-9540_CWE-119_5ad9d8016fbb60109302d558f7edb2cb2a3bb8e3_tiffcp.c.diff",
    "function_code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\n\t(void) spp;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t */\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2411,
    "critical_vars": [
      "buffer"
    ],
    "function": "t2p_readwrite_pdf_image",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tiff2pdf.c.diff",
    "function_code": "tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){\n\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t bufferoffset=0;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\ttstrip_t i=0;\n\ttstrip_t j=0;\n\ttstrip_t stripcount=0;\n\ttsize_t stripsize=0;\n\ttsize_t sepstripcount=0;\n\ttsize_t sepstripsize=0;\n#ifdef OJPEG_SUPPORT\n\ttoff_t inputoffset=0;\n\tuint16 h_samp=1;\n\tuint16 v_samp=1;\n\tuint16 ri=1;\n\tuint32 rows=0;\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint64* sbc;\n\tunsigned char* stripbuffer;\n\ttsize_t striplength=0;\n\tuint32 max_striplength=0;\n#endif /* ifdef JPEG_SUPPORT */\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif (buffer == NULL) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n                                          \"Can't allocate %lu bytes of memory for \"\n                                          \"t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\t/*\n\t\t\t\t\t * make sure is lsb-to-msb\n\t\t\t\t\t * bit-endianness fill order\n\t\t\t\t\t */\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef ZIP_SUPPORT\n\t\tif (t2p->pdf_compression == T2P_COMPRESS_ZIP) {\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer == NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef ZIP_SUPPORT */\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG) {\n\n\t\t\tif(t2p->tiff_dataoffset != 0) {\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\tif(t2p->pdf_ojpegiflength==0){\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pReadFile(input, (tdata_t) buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize);\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t\t\t      t2p->tiff_datasize);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(t2p->tiff_datasize);\n\t\t\t\t} else {\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tbufferoffset = t2pReadFile(input,\n\t\t\t\t\t\t(tdata_t) buffer,\n\t\t\t\t\t\tt2p->pdf_ojpegiflength);\n\t\t\t\t\tt2p->pdf_ojpegiflength = 0;\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t\t\t     &h_samp, &v_samp);\n\t\t\t\t\tbuffer[bufferoffset++]= 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= 0xdd;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x00;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x04;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t     &rows);\n\t\t\t\t\tri*=(rows+v_samp-1)/v_samp;\n\t\t\t\t\tbuffer[bufferoffset++]= (ri>>8) & 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= ri & 0xff;\n\t\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\t\tif(i != 0 ){ \n\t\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\t\ti, \n\t\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t\t-1);\n\t\t\t\t\t}\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(bufferoffset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for OJPEG image %s with bad tables\", \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer==NULL){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t}\n\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\ti, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n\t\t\t\t}\n\t\t\t\tif( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\t\t}\n\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(bufferoffset);\n#if 0\n                                /*\n                                  This hunk of code removed code is clearly\n                                  mis-placed and we are not sure where it\n                                  should be (if anywhere)\n                                */\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"No support for OJPEG image %s with no JPEG File Interchange offset\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\t}\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\n\t\t\tuint32 count = 0;\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tif (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif(count > 4) {\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count);\n\t\t\t\t\tbufferoffset += count - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tif(sbc[i]>max_striplength) max_striplength=sbc[i];\n\t\t\t}\n\t\t\tstripbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(max_striplength);\n\t\t\tif(stripbuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\tmax_striplength, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tstriplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);\n\t\t\t\tif(!t2p_process_jpeg_strip(\n\t\t\t\t\tstripbuffer, \n\t\t\t\t\t&striplength, \n\t\t\t\t\tbuffer,\n                    t2p->tiff_datasize,\n\t\t\t\t\t&bufferoffset, \n\t\t\t\t\ti, \n\t\t\t\t\tt2p->tiff_length)){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't process JPEG data in input file %s\", \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer[bufferoffset++]=0xff; \n\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(stripbuffer);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif /* ifdef JPEG_SUPPORT */\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\t} else {\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\n\t\t\tsepstripsize=TIFFStripSize(input);\n\t\t\tsepstripcount=TIFFNumberOfStrips(input);\n\t\t\n\t\t\tstripsize=sepstripsize*t2p->tiff_samplesperpixel;\n\t\t\tstripcount=sepstripcount/t2p->tiff_samplesperpixel;\n\t\t\t\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(stripsize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n                                _TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tsamplebufferoffset=0;\n\t\t\t\tfor(j=0;j<t2p->tiff_samplesperpixel;j++){\n\t\t\t\t\tread = \n\t\t\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\t\tTIFFmin(sepstripsize, stripsize - samplebufferoffset));\n\t\t\t\t\tif(read==-1){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t\tsamplebufferoffset+=read;\n\t\t\t\t}\n\t\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\t\tt2p,\n\t\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\t\tsamplebuffer, \n\t\t\t\t\tsamplebufferoffset); \n\t\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t}\n\t\t\t_TIFFfree(samplebuffer);\n\t\t\tgoto dataready;\n\t\t}\n\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\n\t\t\t// FIXME: overflow?\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc( \n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_datasize * t2p->tiff_samplesperpixel);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t\tt2p->tiff_datasize *= t2p->tiff_samplesperpixel;\n\t\t\t}\n\t\t\tt2p_sample_realize_palette(t2p, buffer);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length*4);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t}\n\t\t\tif(!TIFFReadRGBAImageOriented(\n\t\t\t\tinput, \n\t\t\t\tt2p->tiff_width, \n\t\t\t\tt2p->tiff_length, \n\t\t\t\t(uint32*)buffer, \n\t\t\t\tORIENTATION_TOPLEFT,\n\t\t\t\t0)){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tt2p->tiff_datasize=t2p_sample_abgr_to_rgb(\n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\t}\n\ndataready:\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {\n\t\t\t\tif(hor != 0 && ver != 0){\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tif(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\"Unable to use JPEG compression for input %s and output %s\", \n\t\t\t\tTIFFFileName(input),\n\t\t\t\tTIFFFileName(output));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\n\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\n\t\tbreak;\n#endif /* ifdef JPEG_SUPPORT */\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif /* ifdef ZIP_SUPPORT */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG\n\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     stripsize * stripcount); \n\t} else\n#endif /* ifdef JPEG_SUPPORT */\n        {\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize); \n\t}\n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer=NULL;\n\t}\n\n\tif (bufferoffset == (tsize_t)-1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded strip to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\treturn(written);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3443,
    "critical_vars": [
      "buffersize"
    ],
    "function": "t2p_process_jpeg_strip",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tiff2pdf.c.diff",
    "function_code": "int t2p_process_jpeg_strip(\n\tunsigned char* strip, \n\ttsize_t* striplength, \n\tunsigned char* buffer, \n    tsize_t buffersize,\n\ttsize_t* bufferoffset, \n\ttstrip_t no, \n\tuint32 height){\n\n\ttsize_t i=0;\n\n\twhile (i < *striplength) {\n\t\ttsize_t datalen;\n\t\tuint16 ri;\n\t\tuint16 v_samp;\n\t\tuint16 h_samp;\n\t\tint j;\n\t\tint ncomp;\n\n\t\t/* marker header: one or more FFs */\n\t\tif (strip[i] != 0xff)\n\t\t\treturn(0);\n\t\ti++;\n\t\twhile (i < *striplength && strip[i] == 0xff)\n\t\t\ti++;\n\t\tif (i >= *striplength)\n\t\t\treturn(0);\n\t\t/* SOI is the only pre-SOS marker without a length word */\n\t\tif (strip[i] == 0xd8)\n\t\t\tdatalen = 0;\n\t\telse {\n\t\t\tif ((*striplength - i) <= 2)\n\t\t\t\treturn(0);\n\t\t\tdatalen = (strip[i+1] << 8) | strip[i+2];\n\t\t\tif (datalen < 2 || datalen >= (*striplength - i))\n\t\t\t\treturn(0);\n\t\t}\n\t\tswitch( strip[i] ){\n\t\t\tcase 0xd8:\t/* SOI - start of image */\n                if( *bufferoffset + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);\n\t\t\t\t*bufferoffset+=2;\n\t\t\t\tbreak;\n\t\t\tcase 0xc0:\t/* SOF0 */\n\t\t\tcase 0xc1:\t/* SOF1 */\n\t\t\tcase 0xc3:\t/* SOF3 */\n\t\t\tcase 0xc9:\t/* SOF9 */\n\t\t\tcase 0xca:\t/* SOF10 */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 + 6 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n                    if( *bufferoffset + 9 >= buffersize )\n                        return(0);\n\t\t\t\t\tncomp = buffer[*bufferoffset+9];\n\t\t\t\t\tif (ncomp < 1 || ncomp > 4)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tv_samp=1;\n\t\t\t\t\th_samp=1;\n                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )\n                        return(0);\n\t\t\t\t\tfor(j=0;j<ncomp;j++){\n\t\t\t\t\t\tuint16 samp = buffer[*bufferoffset+11+(3*j)];\n\t\t\t\t\t\tif( (samp>>4) > h_samp) \n\t\t\t\t\t\t\th_samp = (samp>>4);\n\t\t\t\t\t\tif( (samp & 0x0f) > v_samp) \n\t\t\t\t\t\t\tv_samp = (samp & 0x0f);\n\t\t\t\t\t}\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \n\t\t\t\t\tv_samp);\n\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \n\t\t\t\t\th_samp);\n\t\t\t\t\tbuffer[*bufferoffset+5]=\n                                          (unsigned char) ((height>>8) & 0xff);\n\t\t\t\t\tbuffer[*bufferoffset+6]=\n                                            (unsigned char) (height & 0xff);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t\t/* insert a DRI marker */\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xc4: /* DHT */\n\t\t\tcase 0xdb: /* DQT */\n                if( *bufferoffset + datalen + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\tbreak;\n\t\t\tcase 0xda: /* SOS */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t} else {\n                    if( *bufferoffset + 2 > buffersize )\n                        return(0);\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=\n                                            (unsigned char)(0xd0 | ((no-1)%8));\n\t\t\t\t}\n\t\t\t\ti += datalen + 1;\n\t\t\t\t/* copy remainder of strip */\n                if( *bufferoffset + *striplength - i > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);\n\t\t\t\t*bufferoffset+= *striplength - i;\n\t\t\t\treturn(1);\n\t\t\tdefault:\n\t\t\t\t/* ignore any other marker */\n\t\t\t\tbreak;\n\t\t}\n\t\ti += datalen + 1;\n\t}\n\n\t/* failed to find SOS marker */\n\treturn(0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 986,
    "critical_vars": [
      "ip"
    ],
    "function": "horizontalDifferenceF",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t/* point to last one */\n\t    wp += n - 1;\t/* point to last one */\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 988,
    "critical_vars": [
      "n"
    ],
    "function": "horizontalDifferenceF",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1039,
    "critical_vars": [
      "ip"
    ],
    "function": "horizontalDifference16",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n/* assumption is unsigned pixel values */\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t/* point to last one */\n\t    wp += n - 1;\t/* point to last one */\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1036,
    "critical_vars": [
      "ip",
      "stride",
      "wp"
    ],
    "function": "horizontalDifference16",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n/* assumption is unsigned pixel values */\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n\t    n -= stride;\n\t    while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1092,
    "critical_vars": [
      "wp"
    ],
    "function": "horizontalDifference8",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t/* point to last one */\n\t    ip += n + stride - 1;\t/* point to last one */\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 1088,
    "critical_vars": [
      "n"
    ],
    "function": "horizontalDifference8",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_pixarlog.c.diff",
    "function_code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n    }\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 5761,
    "line_new": 5761,
    "critical_vars": [
      "nstrips"
    ],
    "function": "loadImage",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tiffcrop.c.diff",
    "function_code": "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 805,
    "critical_vars": [
      "tif->tif_rawcc"
    ],
    "function": "TIFFFlushData1",
    "filename": "libtiff/CVE-2016-9537/CVE-2016-9537_CWE-119_83a4b92815ea04969d494416eaae3d4c6b338e4a_tif_write.c.diff",
    "function_code": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            /* We update those variables even in case of error since there's */\n            /* code that doesn't really check the return code of this */\n            /* function */\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 594,
    "critical_vars": [
      "samplesperpixel"
    ],
    "function": "pickCopyFunc",
    "filename": "libtiff/CVE-2017-5225/CVE-2017-5225_CWE-119_5c080298d59efa53264d7248bbe3a04660db6ef7_tiffcp.c.diff",
    "function_code": "pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;\n\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n\t\t/* if biased, force decoded copying to allow image subtraction */\n\t\tbychunk = !bias && (rowsperstrip == irps);\n\t}else{  /* either in or out is tiled */\n\t\tif (bias) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\n\t\t\tTIFFFileName(in));\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (TIFFIsTiled(out)) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\n\t\t\t\ttw = w;\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\n\t\t\t\ttl = l;\n\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\n\t\t} else {  /* out's not, so in must be tiled */\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t\t\tbychunk = (tw == w && tl == rowsperstrip);\n\t\t}\n\t}\n#define\tT 1\n#define\tF 0\n#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\n\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\n\t\t/* Strips -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpContigStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpContigStrips2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpSeparateStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpSeparateStrips2SeparateTiles;\n\t\t/* Tiles -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpContigTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpContigTiles2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpSeparateTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpSeparateTiles2SeparateTiles;\n\t\t/* Tiles -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpContigTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpContigTiles2SeparateStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpSeparateTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpSeparateTiles2SeparateStrips;\n\t\t/* Strips -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\n\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpDecodedStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\n\t\t\treturn cpContig2SeparateByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpSeparate2ContigByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\n\t\t\treturn cpSeparate2SeparateByRow;\n\t}\n#undef pack\n#undef F\n#undef T\n\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\n\t    TIFFFileName(in));\n\treturn (NULL);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 594,
    "critical_vars": [
      "bitspersample"
    ],
    "function": "pickCopyFunc",
    "filename": "libtiff/CVE-2017-5225/CVE-2017-5225_CWE-119_5c080298d59efa53264d7248bbe3a04660db6ef7_tiffcp.c.diff",
    "function_code": "pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;\n\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n\t\t/* if biased, force decoded copying to allow image subtraction */\n\t\tbychunk = !bias && (rowsperstrip == irps);\n\t}else{  /* either in or out is tiled */\n\t\tif (bias) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\n\t\t\tTIFFFileName(in));\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (TIFFIsTiled(out)) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\n\t\t\t\ttw = w;\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\n\t\t\t\ttl = l;\n\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\n\t\t} else {  /* out's not, so in must be tiled */\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t\t\tbychunk = (tw == w && tl == rowsperstrip);\n\t\t}\n\t}\n#define\tT 1\n#define\tF 0\n#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\n\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\n\t\t/* Strips -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpContigStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpContigStrips2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpSeparateStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpSeparateStrips2SeparateTiles;\n\t\t/* Tiles -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpContigTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpContigTiles2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpSeparateTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpSeparateTiles2SeparateTiles;\n\t\t/* Tiles -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpContigTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpContigTiles2SeparateStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpSeparateTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpSeparateTiles2SeparateStrips;\n\t\t/* Strips -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\n\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpDecodedStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\n\t\t\treturn cpContig2SeparateByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpSeparate2ContigByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\n\t\t\treturn cpSeparate2SeparateByRow;\n\t}\n#undef pack\n#undef F\n#undef T\n\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\n\t    TIFFFileName(in));\n\treturn (NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1070,
    "critical_vars": [
      "bps"
    ],
    "function": "DECLAREcpFunc",
    "filename": "libtiff/CVE-2017-5225/CVE-2017-5225_CWE-119_5c080298d59efa53264d7248bbe3a04660db6ef7_tiffcp.c.diff",
    "function_code": "DECLAREcpFunc(cpContig2SeparateByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n\tregister uint32 n;\n\tuint32 row;\n\ttsample_t s;\n        uint16 bps = 0;\n\n        (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps != 8 )\n        {\n            TIFFError(TIFFFileName(in),\n                      \"Error, can only handle BitsPerSample=8 in %s\",\n                      \"cpContig2SeparateByRow\");\n            return 0;\n        }\n\n\tinbuf = _TIFFmalloc(scanlinesizein);\n\toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n\t\tgoto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\t/* unpack channels */\n\tfor (s = 0; s < spp; s++) {\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = ((uint8*)inbuf) + s;\n\t\t\toutp = (uint8*)outbuf;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp++ = *inp;\n\t\t\t\tinp += spp;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, s) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1351,
    "critical_vars": [
      "colb",
      "tilew"
    ],
    "function": "DECLAREreadFunc",
    "filename": "libtiff/CVE-2016-10093/CVE-2016-10093_CWE-119_787c0ee906430b772f33ca50b97b8b5ca070faec_tiffcp.c.diff",
    "function_code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 403,
    "critical_vars": [
      "code"
    ],
    "function": "process",
    "filename": "libtiff/CVE-2013-4244/CVE-2013-4244_CWE-119_ce6841d9e41d621ba23cf18b190ee6a23b2cc833_gif2tiff.c.diff",
    "function_code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 155,
    "critical_vars": [
      "ch",
      "alloc"
    ],
    "function": "chunk_new_with_alloc_size",
    "filename": "tor/CVE-2016-8860/CVE-2016-8860_CWE-119_3cea86eb2fbb65949673eb4ba8ebb695c87a57ce_buffers.c.diff",
    "function_code": "chunk_new_with_alloc_size(size_t alloc)\n{\n  chunk_t *ch;\n  ch = tor_malloc(alloc);\n  ch->next = NULL;\n  ch->datalen = 0;\n#ifdef DEBUG_CHUNK_ALLOC\n  ch->DBG_alloc = alloc;\n#endif\n  ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);\n  total_bytes_allocated_in_chunks += alloc;\n  ch->data = &ch->mem[0];\n  CHUNK_SET_SENTINEL(ch, alloc);\n  return ch;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 542,
    "critical_vars": [
      "buflen"
    ],
    "function": "bittok2str_internal",
    "filename": "tcpdump/CVE-2017-13011/CVE-2017-13011_CWE-119_9f0730bee3eb65d07b49fd468bc2f269173352fe_util-print.c.diff",
    "function_code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; /* our stringbuffer */\n        int buflen=0;\n        register u_int rotbit; /* this is the bit we rotate through all bitpositions */\n        register u_int tokval;\n        const char * sepstr = \"\";\n\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   /* load our first value */\n            rotbit=1;\n            while (rotbit != 0) {\n                /*\n                 * lets AND the rotating bit with our token value\n                 * and see if we have got a match\n                 */\n\t\tif (tokval == (v&rotbit)) {\n                    /* ok we have found something */\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; /* no match - lets shift and try again */\n            }\n            lp++;\n\t}\n\n        if (buflen == 0)\n            /* bummer - lets print the \"unknown\" message as advised in the fmt string if we got one */\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 543,
    "critical_vars": [
      "space_left"
    ],
    "function": "bittok2str_internal",
    "filename": "tcpdump/CVE-2017-13011/CVE-2017-13011_CWE-119_9f0730bee3eb65d07b49fd468bc2f269173352fe_util-print.c.diff",
    "function_code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[1024+1]; /* our string buffer */\n        char *bufp = buf;\n        size_t space_left = sizeof(buf), string_size;\n        register u_int rotbit; /* this is the bit we rotate through all bitpositions */\n        register u_int tokval;\n        const char * sepstr = \"\";\n\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   /* load our first value */\n            rotbit=1;\n            while (rotbit != 0) {\n                /*\n                 * lets AND the rotating bit with our token value\n                 * and see if we have got a match\n                 */\n\t\tif (tokval == (v&rotbit)) {\n                    /* ok we have found something */\n                    if (space_left <= 1)\n                        return (buf); /* only enough room left for NUL, if that */\n                    string_size = strlcpy(bufp, sepstr, space_left);\n                    if (string_size >= space_left)\n                        return (buf);    /* we ran out of room */\n                    bufp += string_size;\n                    space_left -= string_size;\n                    if (space_left <= 1)\n                        return (buf); /* only enough room left for NUL, if that */\n                    string_size = strlcpy(bufp, lp->s, space_left);\n                    if (string_size >= space_left)\n                        return (buf);    /* we ran out of room */\n                    bufp += string_size;\n                    space_left -= string_size;\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; /* no match - lets shift and try again */\n            }\n            lp++;\n\t}\n\n        if (bufp == buf)\n            /* bummer - lets print the \"unknown\" message as advised in the fmt string if we got one */\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1371,
    "critical_vars": [
      "s"
    ],
    "function": "ppp_hdlc",
    "filename": "tcpdump/CVE-2014-9140/CVE-2014-9140_CWE-119_0f95d441e4b5d7512cc5c326c8668a120e048eda_print-ppp.c.diff",
    "function_code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1 || !ND_TTEST(*s))\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1373,
    "critical_vars": [
      "i"
    ],
    "function": "ppp_hdlc",
    "filename": "tcpdump/CVE-2014-9140/CVE-2014-9140_CWE-119_0f95d441e4b5d7512cc5c326c8668a120e048eda_print-ppp.c.diff",
    "function_code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *s, *t, c;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (uint8_t *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 81,
    "critical_vars": [
      "xWantedSize"
    ],
    "function": "pvPortMalloc",
    "filename": "FreeRTOS-Kernel/CVE-2021-32020/CVE-2021-32020_CWE-119_c7a9a01c94987082b223d3e59969ede64363da63_heap_1.c.diff",
    "function_code": "void * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    void * pvReturn = NULL;\r\n\r\n    /* The heap must be initialised before the first call to\r\n     * prvPortMalloc(). */\r\n    configASSERT( pxEnd );\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* Check the requested block size is not so large that the top bit is\r\n         * set.  The top bit of the block size member of the BlockLink_t structure\r\n         * is used to determine who owns the block - the application or the\r\n         * kernel, so it must be free. */\r\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n        {\r\n            /* The wanted size is increased so it can contain a BlockLink_t\r\n             * structure in addition to the requested amount of bytes. */\r\n            if( xWantedSize > 0 )\r\n            {\r\n                xWantedSize += xHeapStructSize;\r\n\r\n                /* Ensure that blocks are always aligned to the required number\r\n                 * of bytes. */\r\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                {\r\n                    /* Byte alignment required. */\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n            {\r\n                /* Traverse the list from the start\t(lowest address) block until\r\n                 * one\tof adequate size is found. */\r\n                pxPreviousBlock = &xStart;\r\n                pxBlock = xStart.pxNextFreeBlock;\r\n\r\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n                {\r\n                    pxPreviousBlock = pxBlock;\r\n                    pxBlock = pxBlock->pxNextFreeBlock;\r\n                }\r\n\r\n                /* If the end marker was reached then a block of adequate size\r\n                 * was\tnot found. */\r\n                if( pxBlock != pxEnd )\r\n                {\r\n                    /* Return the memory space pointed to - jumping over the\r\n                     * BlockLink_t structure at its start. */\r\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\r\n\r\n                    /* This block is being returned for use so must be taken out\r\n                     * of the list of free blocks. */\r\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                    /* If the block is larger than required it can be split into\r\n                     * two. */\r\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                    {\r\n                        /* This block is to be split into two.  Create a new\r\n                         * block following the number of bytes requested. The void\r\n                         * cast is used to prevent byte alignment warnings from the\r\n                         * compiler. */\r\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n\r\n                        /* Calculate the sizes of two blocks split from the\r\n                         * single block. */\r\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                        pxBlock->xBlockSize = xWantedSize;\r\n\r\n                        /* Insert the new block into the list of free blocks. */\r\n                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n\r\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\r\n                    {\r\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    /* The block is being returned - it is allocated and owned\r\n                     * by the application and has no \"next\" block. */\r\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\r\n                    pxBlock->pxNextFreeBlock = NULL;\r\n                    xNumberOfSuccessfulAllocations++;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\r\n\r\n    return pvReturn;\r\n}\r",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 80,
    "critical_vars": [
      "portBYTE_ALIGNMENT_MASK",
      "xWantedSize",
      "portBYTE_ALIGNMENT"
    ],
    "function": "pvPortMalloc",
    "filename": "FreeRTOS-Kernel/CVE-2021-32020/CVE-2021-32020_CWE-119_c7a9a01c94987082b223d3e59969ede64363da63_heap_1.c.diff",
    "function_code": "void * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    void * pvReturn = NULL;\r\n    static uint8_t * pucAlignedHeap = NULL;\r\n\r\n    /* Ensure that blocks are always aligned. */\r\n    #if ( portBYTE_ALIGNMENT != 1 )\r\n        {\r\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\r\n            {\r\n                /* Byte alignment required. Check for overflow. */\r\n                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )\r\n                {\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                } \r\n                else \r\n                {\r\n                    xWantedSize = 0;\r\n                }\r\n            }\r\n        }\r\n    #endif\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        if( pucAlignedHeap == NULL )\r\n        {\r\n            /* Ensure the heap starts on a correctly aligned boundary. */\r\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n        }\r\n\r\n        /* Check there is enough room left for the allocation and. */\r\n        if( ( xWantedSize > 0 ) && /* valid size */\r\n            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\r\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\r\n        {\r\n            /* Return the next free byte then increment the index past this\r\n             * block. */\r\n            pvReturn = pucAlignedHeap + xNextFreeByte;\r\n            xNextFreeByte += xWantedSize;\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n        }\r\n    #endif\r\n\r\n    return pvReturn;\r\n}\r",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 284,
    "critical_vars": [
      "caplentoobig"
    ],
    "function": "main",
    "filename": "tcpreplay/CVE-2017-6429/CVE-2017-6429_CWE-119_d689d14dbcd768c028eab2fb378d849e543dcfe9_tcpcapinfo.c.diff",
    "function_code": "int main(int argc, char *argv[])\n{\n  char *p, *q;\n\n  Clp_Parser *clp =\n    Clp_NewParser(argc, (const char * const *)argv, sizeof(options) / sizeof(options[0]), options);\n  program_name = Clp_ProgramName(clp);\n\n  /* interpret command line arguments using CLP */\n  while (1) {\n    int opt = Clp_Next(clp);\n    switch (opt) {\n\n     case BLOCK_LEN_OPT:\n      blocklen = clp->val.i;\n      break;\n\n     output_file:\n     case OUTPUT_OPT:\n      if (ofp)\n\tfatal_error(\"output file already specified\");\n      if (strcmp(clp->vstr, \"-\") == 0)\n\tofp = stdout;\n      else if (!(ofp = fopen(clp->vstr, \"w\")))\n\tfatal_error(\"%s: %s\", clp->vstr, strerror(errno));\n      break;\n\n     case PFB_OPT:\n      pfb = 1;\n      break;\n\n     case PFA_OPT:\n      pfb = 0;\n      break;\n\n     case HELP_OPT:\n      usage();\n      exit(0);\n      break;\n\n     case VERSION_OPT:\n      printf(\"t1asm (LCDF t1utils) %s\\n\", VERSION);\n      printf(\"Copyright (C) 1992-2010 I. Lee Hetherington, Eddie Kohler et al.\\n\\\nThis is free software; see the source for copying conditions.\\n\\\nThere is NO warranty, not even for merchantability or fitness for a\\n\\\nparticular purpose.\\n\");\n      exit(0);\n      break;\n\n     case Clp_NotOption:\n      if (ifp && ofp)\n\tfatal_error(\"too many arguments\");\n      else if (ifp)\n\tgoto output_file;\n      if (strcmp(clp->vstr, \"-\") == 0)\n\tifp = stdin;\n      else if (!(ifp = fopen(clp->vstr, \"r\")))\n\tfatal_error(\"%s: %s\", clp->vstr, strerror(errno));\n      break;\n\n     case Clp_Done:\n      goto done;\n\n     case Clp_BadOption:\n      short_usage();\n      exit(1);\n      break;\n\n    }\n  }\n\n done:\n  if (!pfb) {\n    if (blocklen == -1)\n      blocklen = 64;\n    else if (blocklen < 8) {\n      blocklen = 8;\n      error(\"warning: line length raised to %d\", blocklen);\n    } else if (blocklen > 1024) {\n      blocklen = 1024;\n      error(\"warning: line length lowered to %d\", blocklen);\n    }\n  }\n\n  if (!ifp) ifp = stdin;\n  if (!ofp) ofp = stdout;\n\n  if (pfb)\n    init_pfb_writer(&w, blocklen, ofp);\n\n#if defined(_MSDOS) || defined(_WIN32)\n  /* If we are processing a PFB (binary) output */\n  /* file, we must set its file mode to binary. */\n  if (pfb)\n    _setmode(_fileno(ofp), _O_BINARY);\n#endif\n\n  /* Finally, we loop until no more input. Some special things to look for are\n     the `currentfile eexec' line, the beginning of the `/Subrs' or\n     `/CharStrings' definition, the definition of `/lenIV', and the definition\n     of the charstring start command which has `...string currentfile...' in\n     it.\n\n     Being careful: Check with `/Subrs' and `/CharStrings' to see that a\n     number follows the token -- otherwise, the token is probably nested in a\n     subroutine a la Adobe Jenson, and we shouldn't pay attention to it.\n\n     Bugs: Occurrence of `/Subrs 9' in a comment will fool t1asm.\n\n     Thanks to Tom Kacvinsky <tjk@ams.org> who reported that some fonts come\n     without /Subrs sections and provided a patch. */\n\n  while (!feof(ifp) && !ferror(ifp)) {\n    t1utils_getline();\n\n    if (!ever_active) {\n      if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace((unsigned char) line[17])) {\n\t/* Allow arbitrary whitespace after \"currentfile eexec\".\n\t   Thanks to Tom Kacvinsky <tjk@ams.org> for reporting this.\n\t   Note: strlen(\"currentfile eexec\") == 17. */\n\tfor (p = line + 18; isspace((unsigned char) *p); p++)\n\t  ;\n\teexec_start(p);\n\tcontinue;\n      } else if (strncmp(line, \"/lenIV\", 6) == 0) {\n        set_lenIV(line);\n      } else if ((p = strstr(line, \"string currentfile\"))) {\n        set_cs_start(line);\n      }\n    }\n\n    if (!active) {\n      if ((p = strstr(line, \"/Subrs\")) && isdigit((unsigned char) p[7]))\n\tever_active = active = 1;\n      else if ((p = strstr(line, \"/CharStrings\")) && isdigit((unsigned char) p[13]))\n\tever_active = active = 1;\n    }\n    if ((p = strstr(line, \"currentfile closefile\"))) {\n      /* 2/14/99 -- happy Valentine's day! -- don't look for `mark\n\t currentfile closefile'; the `mark' might be on a different line */\n      /* 1/3/2002 -- happy new year! -- Luc Devroye reports a failure with\n         some printers when `currentfile closefile' is followed by space */\n      p += sizeof(\"currentfile closefile\") - 1;\n      for (q = p; isspace((unsigned char) *q) && *q != '\\n'; q++)\n\t/* nada */;\n      if (q == p && !*q)\n\terror(\"warning: `currentfile closefile' line too long\");\n      else if (q != p) {\n\tif (*q != '\\n')\n\t  error(\"text after `currentfile closefile' ignored\");\n\t*p++ = '\\n';\n\t*p++ = '\\0';\n      }\n      eexec_string(line);\n      break;\n    }\n\n    eexec_string(line);\n\n    /* output line data */\n    if (start_charstring) {\n      if (!cs_start[0])\n\tfatal_error(\"couldn't find charstring start command\");\n      parse_charstring();\n    }\n  }\n\n  /* Handle remaining PostScript after the eexec section */\n  if (in_eexec)\n    eexec_end();\n\n  /* There may be additional code. */\n  while (!feof(ifp) && !ferror(ifp)) {\n    t1utils_getline();\n    eexec_string(line);\n  }\n\n  if (pfb)\n    pfb_writer_end(&w);\n\n  /* the end! */\n  if (!ever_active)\n    error(\"warning: no charstrings found in input file\");\n  fclose(ifp);\n  fclose(ofp);\n  return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 73,
    "critical_vars": [
      "ci->platdata->flags"
    ],
    "function": "host_start",
    "filename": "linux/CVE-2013-2058/CVE-2013-2058_CWE-119_929473ea05db455ad88cdc081f2adc556b8dc48f_host.c.diff",
    "function_code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1731,
    "critical_vars": [
      "skb"
    ],
    "function": "cipso_v4_validate",
    "filename": "linux/CVE-2013-0310/CVE-2013-0310_CWE-119_89d7ae34cdda4195809a5a987f697a517a2a3177_cipso_ipv4.c.diff",
    "function_code": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_LOCAL:\n\t\t\t/* This is a non-standard tag that we only allow for\n\t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. Further,\n\t\t\t * there is no legitimate reason for setting this from\n\t\t\t * userspace so reject it if skb is NULL. */\n\t\t\tif (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 581,
    "critical_vars": [
      "len"
    ],
    "function": "fwnet_incoming_packet",
    "filename": "linux/CVE-2016-8633/CVE-2016-8633_CWE-119_667121ace9dbafb368618dbabcf07901c962ddac_net.c.diff",
    "function_code": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 734,
    "critical_vars": [
      "source_node_id"
    ],
    "function": "fwnet_receive_broadcast",
    "filename": "linux/CVE-2016-8633/CVE-2016-8633_CWE-119_667121ace9dbafb368618dbabcf07901c962ddac_net.c.diff",
    "function_code": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n#endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n\t\t\t\t      context->card->generation, true);\n\t}\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 777,
    "critical_vars": [
      "length",
      "buf_ptr"
    ],
    "function": "fwnet_receive_broadcast",
    "filename": "linux/CVE-2016-8633/CVE-2016-8633_CWE-119_667121ace9dbafb368618dbabcf07901c962ddac_net.c.diff",
    "function_code": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (length > IEEE1394_GASP_HDR_SIZE &&\n\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n\t    ))\n\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n\t\t\t\t      gasp_source_id(buf_ptr),\n\t\t\t\t      context->card->generation, true);\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1252,
    "line_new": 1252,
    "critical_vars": [
      "evt->event.lun[1]"
    ],
    "function": "vhost_scsi_send_evt",
    "filename": "linux/CVE-2015-4036/CVE-2015-4036_CWE-119_59c816c1f24df0204e01851431d3bab3eb76719c_scsi.c.diff",
    "function_code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 2123,
    "line_new": 2123,
    "critical_vars": [
      "tpgt"
    ],
    "function": "vhost_scsi_make_tpg",
    "filename": "linux/CVE-2015-4036/CVE-2015-4036_CWE-119_59c816c1f24df0204e01851431d3bab3eb76719c_scsi.c.diff",
    "function_code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tu16 tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1208,
    "line_new": 1208,
    "critical_vars": [
      "tpgt"
    ],
    "function": "*tcm_loop_make_naa_tpg",
    "filename": "linux/CVE-2011-5327/CVE-2011-5327_CWE-119_12f09ccb4612734a53e47ed5302e0479c10a50f8_tcm_loop.c.diff",
    "function_code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; /* Skip ahead of \"tpgt_\" */\n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\n\tif (tpgt >= TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t/*\n\t * Register the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 259,
    "line_new": 259,
    "critical_vars": [
      "vdev->ctx"
    ],
    "function": "vfio_msi_enable",
    "filename": "linux/CVE-2016-9083/CVE-2016-9083_CWE-119_05692d7005a364add85c6e25a6c4447ce08f913a_vfio_pci_intrs.c.diff",
    "function_code": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\tvdev->ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n\tif (!vdev->ctx)\n\t\treturn -ENOMEM;\n\n\t/* return the number of supported vectors if we can't get all: */\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\t/*\n\t\t * Compute the virtual hardware field for max msi vectors -\n\t\t * it is the log base 2 of the number of vectors.\n\t\t */\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 832,
    "critical_vars": [
      "size"
    ],
    "function": "vfio_pci_ioctl",
    "filename": "linux/CVE-2016-9083/CVE-2016-9083_CWE-119_05692d7005a364add85c6e25a6c4447ce08f913a_vfio_pci.c.diff",
    "function_code": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 845,
    "critical_vars": [
      "hdr.flags"
    ],
    "function": "vfio_pci_ioctl",
    "filename": "linux/CVE-2016-9083/CVE-2016-9083_CWE-119_05692d7005a364add85c6e25a6c4447ce08f913a_vfio_pci.c.diff",
    "function_code": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 646,
    "critical_vars": [
      "*d"
    ],
    "function": "usb_parse_configuration",
    "filename": "linux/CVE-2017-16531/CVE-2017-16531_CWE-119_bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb_config.c.diff",
    "function_code": "static int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_warn(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 78,
    "critical_vars": [
      "ret"
    ],
    "function": "ceph_x_decrypt",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_decrypt(struct ceph_crypto_key *secret,\n\t\t\t  void **p, void *end, void *obuf, size_t olen)\n{\n\tstruct ceph_x_encrypt_header head;\n\tsize_t head_len = sizeof(head);\n\tint len, ret;\n\n\tlen = ceph_decode_32(p);\n\tif (*p + len > end)\n\t\treturn -EINVAL;\n\n\tdout(\"ceph_x_decrypt len %d\\n\", len);\n\tret = ceph_decrypt2(secret, &head, &head_len, obuf, &olen,\n\t\t\t    *p, len);\n\tif (ret)\n\t\treturn ret;\n\tif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\n\t\treturn -EPERM;\n\t*p += len;\n\treturn olen;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 76,
    "critical_vars": [
      "obuf"
    ],
    "function": "ceph_x_decrypt",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_decrypt(struct ceph_crypto_key *secret,\n\t\t\t  void **p, void *end, void **obuf, size_t olen)\n{\n\tstruct ceph_x_encrypt_header head;\n\tsize_t head_len = sizeof(head);\n\tint len, ret;\n\n\tlen = ceph_decode_32(p);\n\tif (*p + len > end)\n\t\treturn -EINVAL;\n\n\tdout(\"ceph_x_decrypt len %d\\n\", len);\n\tif (*obuf == NULL) {\n\t\t*obuf = kmalloc(len, GFP_NOFS);\n\t\tif (!*obuf)\n\t\t\treturn -ENOMEM;\n\t\tolen = len;\n\t}\n\n\tret = ceph_decrypt2(secret, &head, &head_len, *obuf, &olen, *p, len);\n\tif (ret)\n\t\treturn ret;\n\tif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\n\t\treturn -EPERM;\n\t*p += len;\n\treturn olen;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 170,
    "line_new": 175,
    "critical_vars": [
      "dlen"
    ],
    "function": "process_one_ticket",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int process_one_ticket(struct ceph_auth_client *ac,\n\t\t\t      struct ceph_crypto_key *secret,\n\t\t\t      void **p, void *end)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint type;\n\tu8 tkt_struct_v, blob_struct_v;\n\tstruct ceph_x_ticket_handler *th;\n\tvoid *dbuf = NULL;\n\tvoid *dp, *dend;\n\tint dlen;\n\tchar is_enc;\n\tstruct timespec validity;\n\tstruct ceph_crypto_key old_key;\n\tvoid *ticket_buf = NULL;\n\tvoid *tp, *tpend;\n\tstruct ceph_timespec new_validity;\n\tstruct ceph_crypto_key new_session_key;\n\tstruct ceph_buffer *new_ticket_blob;\n\tunsigned long new_expires, new_renew_after;\n\tu64 new_secret_id;\n\tint ret;\n\n\tceph_decode_need(p, end, sizeof(u32) + 1, bad);\n\n\ttype = ceph_decode_32(p);\n\tdout(\" ticket type %d %s\\n\", type, ceph_entity_type_name(type));\n\n\ttkt_struct_v = ceph_decode_8(p);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tth = get_ticket_handler(ac, type);\n\tif (IS_ERR(th)) {\n\t\tret = PTR_ERR(th);\n\t\tgoto out;\n\t}\n\n\t/* blob for me */\n\tdlen = ceph_x_decrypt(secret, p, end, &dbuf, 0);\n\tif (dlen <= 0) {\n\t\tret = dlen;\n\t\tgoto out;\n\t}\n\tdout(\" decrypted %d bytes\\n\", dlen);\n\tdp = dbuf;\n\tdend = dp + dlen;\n\n\ttkt_struct_v = ceph_decode_8(&dp);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tmemcpy(&old_key, &th->session_key, sizeof(old_key));\n\tret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\n\tif (ret)\n\t\tgoto out;\n\n\tceph_decode_copy(&dp, &new_validity, sizeof(new_validity));\n\tceph_decode_timespec(&validity, &new_validity);\n\tnew_expires = get_seconds() + validity.tv_sec;\n\tnew_renew_after = new_expires - (validity.tv_sec / 4);\n\tdout(\" expires=%lu renew_after=%lu\\n\", new_expires,\n\t     new_renew_after);\n\n\t/* ticket blob for service */\n\tceph_decode_8_safe(p, end, is_enc, bad);\n\tif (is_enc) {\n\t\t/* encrypted */\n\t\tdout(\" encrypted ticket\\n\");\n\t\tdlen = ceph_x_decrypt(&old_key, p, end, &ticket_buf, 0);\n\t\tif (dlen < 0) {\n\t\t\tret = dlen;\n\t\t\tgoto out;\n\t\t}\n\t\ttp = ticket_buf;\n\t\tdlen = ceph_decode_32(&tp);\n\t} else {\n\t\t/* unencrypted */\n\t\tceph_decode_32_safe(p, end, dlen, bad);\n\t\tticket_buf = kmalloc(dlen, GFP_NOFS);\n\t\tif (!ticket_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttp = ticket_buf;\n\t\tceph_decode_need(p, end, dlen, bad);\n\t\tceph_decode_copy(p, ticket_buf, dlen);\n\t}\n\ttpend = tp + dlen;\n\tdout(\" ticket blob is %d bytes\\n\", dlen);\n\tceph_decode_need(&tp, tpend, 1 + sizeof(u64), bad);\n\tblob_struct_v = ceph_decode_8(&tp);\n\tnew_secret_id = ceph_decode_64(&tp);\n\tret = ceph_decode_buffer(&new_ticket_blob, &tp, tpend);\n\tif (ret)\n\t\tgoto out;\n\n\t/* all is well, update our ticket */\n\tceph_crypto_key_destroy(&th->session_key);\n\tif (th->ticket_blob)\n\t\tceph_buffer_put(th->ticket_blob);\n\tth->session_key = new_session_key;\n\tth->ticket_blob = new_ticket_blob;\n\tth->validity = new_validity;\n\tth->secret_id = new_secret_id;\n\tth->expires = new_expires;\n\tth->renew_after = new_renew_after;\n\tdout(\" got ticket service %d (%s) secret_id %lld len %d\\n\",\n\t     type, ceph_entity_type_name(type), th->secret_id,\n\t     (int)th->ticket_blob->vec.iov_len);\n\txi->have_keys |= th->service;\n\nout:\n\tkfree(ticket_buf);\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 198,
    "critical_vars": [
      "tp"
    ],
    "function": "process_one_ticket",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int process_one_ticket(struct ceph_auth_client *ac,\n\t\t\t      struct ceph_crypto_key *secret,\n\t\t\t      void **p, void *end,\n\t\t\t      void *dbuf, void *ticket_buf)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint type;\n\tu8 tkt_struct_v, blob_struct_v;\n\tstruct ceph_x_ticket_handler *th;\n\tvoid *dp, *dend;\n\tint dlen;\n\tchar is_enc;\n\tstruct timespec validity;\n\tstruct ceph_crypto_key old_key;\n\tvoid *tp, *tpend;\n\tstruct ceph_timespec new_validity;\n\tstruct ceph_crypto_key new_session_key;\n\tstruct ceph_buffer *new_ticket_blob;\n\tunsigned long new_expires, new_renew_after;\n\tu64 new_secret_id;\n\tint ret;\n\n\tceph_decode_need(p, end, sizeof(u32) + 1, bad);\n\n\ttype = ceph_decode_32(p);\n\tdout(\" ticket type %d %s\\n\", type, ceph_entity_type_name(type));\n\n\ttkt_struct_v = ceph_decode_8(p);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tth = get_ticket_handler(ac, type);\n\tif (IS_ERR(th)) {\n\t\tret = PTR_ERR(th);\n\t\tgoto out;\n\t}\n\n\t/* blob for me */\n\tdlen = ceph_x_decrypt(secret, p, end, dbuf,\n\t\t\t      TEMP_TICKET_BUF_LEN);\n\tif (dlen <= 0) {\n\t\tret = dlen;\n\t\tgoto out;\n\t}\n\tdout(\" decrypted %d bytes\\n\", dlen);\n\tdp = dbuf;\n\tdend = dp + dlen;\n\n\ttkt_struct_v = ceph_decode_8(&dp);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tmemcpy(&old_key, &th->session_key, sizeof(old_key));\n\tret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\n\tif (ret)\n\t\tgoto out;\n\n\tceph_decode_copy(&dp, &new_validity, sizeof(new_validity));\n\tceph_decode_timespec(&validity, &new_validity);\n\tnew_expires = get_seconds() + validity.tv_sec;\n\tnew_renew_after = new_expires - (validity.tv_sec / 4);\n\tdout(\" expires=%lu renew_after=%lu\\n\", new_expires,\n\t     new_renew_after);\n\n\t/* ticket blob for service */\n\tceph_decode_8_safe(p, end, is_enc, bad);\n\ttp = ticket_buf;\n\tif (is_enc) {\n\t\t/* encrypted */\n\t\tdout(\" encrypted ticket\\n\");\n\t\tdlen = ceph_x_decrypt(&old_key, p, end, ticket_buf,\n\t\t\t\t      TEMP_TICKET_BUF_LEN);\n\t\tif (dlen < 0) {\n\t\t\tret = dlen;\n\t\t\tgoto out;\n\t\t}\n\t\tdlen = ceph_decode_32(&tp);\n\t} else {\n\t\t/* unencrypted */\n\t\tceph_decode_32_safe(p, end, dlen, bad);\n\t\tceph_decode_need(p, end, dlen, bad);\n\t\tceph_decode_copy(p, ticket_buf, dlen);\n\t}\n\ttpend = tp + dlen;\n\tdout(\" ticket blob is %d bytes\\n\", dlen);\n\tceph_decode_need(&tp, tpend, 1 + sizeof(u64), bad);\n\tblob_struct_v = ceph_decode_8(&tp);\n\tnew_secret_id = ceph_decode_64(&tp);\n\tret = ceph_decode_buffer(&new_ticket_blob, &tp, tpend);\n\tif (ret)\n\t\tgoto out;\n\n\t/* all is well, update our ticket */\n\tceph_crypto_key_destroy(&th->session_key);\n\tif (th->ticket_blob)\n\t\tceph_buffer_put(th->ticket_blob);\n\tth->session_key = new_session_key;\n\tth->ticket_blob = new_ticket_blob;\n\tth->validity = new_validity;\n\tth->secret_id = new_secret_id;\n\tth->expires = new_expires;\n\tth->renew_after = new_renew_after;\n\tdout(\" got ticket service %d (%s) secret_id %lld len %d\\n\",\n\t     type, ceph_entity_type_name(type), th->secret_id,\n\t     (int)th->ticket_blob->vec.iov_len);\n\txi->have_keys |= th->service;\n\nout:\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 252,
    "critical_vars": [
      "*dbuf"
    ],
    "function": "ceph_x_proc_ticket_reply",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tchar *dbuf;\n\tchar *ticket_buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tdbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!ticket_buf)\n\t\tgoto out_dbuf;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end,\n\t\t\t\t\t dbuf, ticket_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(ticket_buf);\nout_dbuf:\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 275,
    "line_new": 275,
    "critical_vars": [
      "ret"
    ],
    "function": "ceph_x_proc_ticket_reply",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 599,
    "critical_vars": [
      "*preply"
    ],
    "function": "ceph_x_verify_authorizer_reply",
    "filename": "linux/CVE-2014-6416/CVE-2014-6416_CWE-119_c27a3e4d667fdcad3db7b104f75659478e0c68d8_auth_x.c.diff",
    "function_code": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 664,
    "critical_vars": [
      "obuf",
      "ibuf"
    ],
    "function": "su3000_i2c_transfer",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 obuf[0x40], ibuf[0x40];\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tobuf[0] = msg[0].buf[0] + 0x36;\n\t\t\tobuf[1] = 3;\n\t\t\tobuf[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tobuf[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = ibuf[0];\n\t\t\tmsg[0].buf[0] = ibuf[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tobuf[0] = 0x08;\n\t\t\tobuf[1] = msg[0].addr;\n\t\t\tobuf[2] = msg[0].len;\n\n\t\t\tmemcpy(&obuf[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\n\t\t\t\t\t\tibuf, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tobuf[0] = 0x09;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[1].len;\n\t\tobuf[3] = msg[0].addr;\n\t\tmemcpy(&obuf[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\n\t\t\t\t\tibuf, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 665,
    "critical_vars": [
      "*state"
    ],
    "function": "su3000_i2c_transfer",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dw2102_state *state;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\n\tstate = d->priv;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tif (mutex_lock_interruptible(&d->data_mutex) < 0) {\n\t\tmutex_unlock(&d->i2c_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tstate->data[0] = msg[0].buf[0] + 0x36;\n\t\t\tstate->data[1] = 3;\n\t\t\tstate->data[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 3,\n\t\t\t\t\tstate->data, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tstate->data[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 1,\n\t\t\t\t\tstate->data, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = state->data[0];\n\t\t\tmsg[0].buf[0] = state->data[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tstate->data[0] = 0x08;\n\t\t\tstate->data[1] = msg[0].addr;\n\t\t\tstate->data[2] = msg[0].len;\n\n\t\t\tmemcpy(&state->data[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 3,\n\t\t\t\t\t\tstate->data, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tstate->data[0] = 0x09;\n\t\tstate->data[1] = msg[0].len;\n\t\tstate->data[2] = msg[1].len;\n\t\tstate->data[3] = msg[0].addr;\n\t\tmemcpy(&state->data[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 4,\n\t\t\t\t\tstate->data, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &state->data[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->data_mutex);\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Head",
    "line_old": 1363,
    "critical_vars": [
      "*adap"
    ],
    "function": "su3000_frontend_attach",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 1388,
    "critical_vars": [
      "*adap"
    ],
    "function": "su3000_frontend_attach",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int su3000_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x02;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\tadap->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Head",
    "line_old": 1413,
    "critical_vars": [
      "*adap"
    ],
    "function": "t220_frontend_attach",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tmsleep(50);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 1446,
    "critical_vars": [
      "*adap"
    ],
    "function": "t220_frontend_attach",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int t220_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x87;\n\tstate->data[2] = 0x0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x86;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tmsleep(50);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\tadap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->i2c_adap, NULL);\n\tif (adap->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1442,
    "critical_vars": [
      "u8obuf[3]"
    ],
    "function": "tt_s2_4600_frontend_attach",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1488,
    "critical_vars": [
      "&d->data_mutex"
    ],
    "function": "tt_s2_4600_frontend_attach",
    "filename": "linux/CVE-2017-8062/CVE-2017-8062_CWE-119_606142af57dad981b78707234cfbd15f9f7b7125_dw2102.c.diff",
    "function_code": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0x0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x02;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 151,
    "critical_vars": [
      "data"
    ],
    "function": "k90_backlight_get",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 151,
    "critical_vars": [
      "*data"
    ],
    "function": "k90_backlight_get",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = brightness;\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 256,
    "critical_vars": [
      "data"
    ],
    "function": "k90_show_macro_mode",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 266,
    "critical_vars": [
      "*data"
    ],
    "function": "k90_show_macro_mode",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 323,
    "critical_vars": [
      "data"
    ],
    "function": "k90_show_current_profile",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 343,
    "critical_vars": [
      "*data"
    ],
    "function": "k90_show_current_profile",
    "filename": "linux/CVE-2017-5547/CVE-2017-5547_CWE-119_6d104af38b570d37aa32a5803b04c354f8ed513d_hid-corsair.c.diff",
    "function_code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1539,
    "critical_vars": [
      "len"
    ],
    "function": "dma_rx",
    "filename": "linux/CVE-2011-3359/CVE-2011-3359_CWE-119_c85ce65ecac078ab1a1835c87c4a6319cf74660a_dma.c.diff",
    "function_code": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n\t\tdmaaddr = meta->dmaaddr;\n\t\tgoto drop_recycle_buffer;\n\t}\n\tif (unlikely(len > ring->rx_buffersize)) {\n\t\t/* The data did not fit into one descriptor buffer\n\t\t * and is split over multiple buffers.\n\t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1539,
    "critical_vars": [
      "ring->frameoffset",
      "len"
    ],
    "function": "dma_rx",
    "filename": "linux/CVE-2011-3359/CVE-2011-3359_CWE-119_c85ce65ecac078ab1a1835c87c4a6319cf74660a_dma.c.diff",
    "function_code": "static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n\t\tdmaaddr = meta->dmaaddr;\n\t\tgoto drop_recycle_buffer;\n\t}\n\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n\t\t/* The data did not fit into one descriptor buffer\n\t\t * and is split over multiple buffers.\n\t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2392,
    "critical_vars": [
      "bytes"
    ],
    "function": "cifs_iovec_write",
    "filename": "linux/CVE-2014-0069/CVE-2014-0069_CWE-119_5d81de8e8667da7135d3a32a964087c0faf5483f_file.c.diff",
    "function_code": "cifs_iovec_write(struct file *file, const struct iovec *iov,\n\t\t unsigned long nr_segs, loff_t *poffset)\n{\n\tunsigned long nr_pages, i;\n\tsize_t bytes, copied, len, cur_len;\n\tssize_t total_written = 0;\n\tloff_t offset;\n\tstruct iov_iter it;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tint rc;\n\tpid_t pid;\n\n\tlen = iov_length(iov, nr_segs);\n\tif (!len)\n\t\treturn 0;\n\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\toffset = *poffset;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tiov_iter_init(&it, iov, nr_segs, len, 0);\n\tdo {\n\t\tsize_t save_len;\n\n\t\tnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tbreak;\n\t\t}\n\n\t\tsave_len = cur_len;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n\t\t\t\t\t\t\t 0, bytes);\n\t\t\tcur_len -= copied;\n\t\t\tiov_iter_advance(&it, copied);\n\t\t\t/*\n\t\t\t * If we didn't copy as much as we expected, then that\n\t\t\t * may mean we trod into an unmapped area. Stop copying\n\t\t\t * at that point. On the next pass through the big\n\t\t\t * loop, we'll likely end up getting a zero-length\n\t\t\t * write and bailing out of it.\n\t\t\t */\n\t\t\tif (copied < bytes)\n\t\t\t\tbreak;\n\t\t}\n\t\tcur_len = save_len - cur_len;\n\n\t\t/*\n\t\t * If we have no data to send, then that probably means that\n\t\t * the copy above failed altogether. That's most likely because\n\t\t * the address in the iovec was bogus. Set the rc to -EFAULT,\n\t\t * free anything we allocated and bail out.\n\t\t */\n\t\tif (!cur_len) {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(wdata->pages[i]);\n\t\t\tkfree(wdata);\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * i + 1 now represents the number of pages we actually used in\n\t\t * the copy phase above. Bring nr_pages down to that, and free\n\t\t * any pages that we didn't use.\n\t\t */\n\t\tfor ( ; nr_pages > i + 1; nr_pages--)\n\t\t\tput_page(wdata->pages[nr_pages - 1]);\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\trc = cifs_uncached_retry_writev(wdata);\n\t\tif (rc) {\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, &wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = cifs_uncached_retry_writev(wdata);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2447,
    "critical_vars": [
      "copied"
    ],
    "function": "cifs_iovec_write",
    "filename": "linux/CVE-2014-0069/CVE-2014-0069_CWE-119_5d81de8e8667da7135d3a32a964087c0faf5483f_file.c.diff",
    "function_code": "cifs_iovec_write(struct file *file, const struct iovec *iov,\n\t\t unsigned long nr_segs, loff_t *poffset)\n{\n\tunsigned long nr_pages, i;\n\tsize_t copied, len, cur_len;\n\tssize_t total_written = 0;\n\tloff_t offset;\n\tstruct iov_iter it;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tint rc;\n\tpid_t pid;\n\n\tlen = iov_length(iov, nr_segs);\n\tif (!len)\n\t\treturn 0;\n\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\toffset = *poffset;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tiov_iter_init(&it, iov, nr_segs, len, 0);\n\tdo {\n\t\tsize_t save_len;\n\n\t\tnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tbreak;\n\t\t}\n\n\t\tsave_len = cur_len;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tcopied = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n\t\t\t\t\t\t\t 0, copied);\n\t\t\tcur_len -= copied;\n\t\t\tiov_iter_advance(&it, copied);\n\t\t}\n\t\tcur_len = save_len - cur_len;\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\trc = cifs_uncached_retry_writev(wdata);\n\t\tif (rc) {\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, &wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = cifs_uncached_retry_writev(wdata);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2697,
    "critical_vars": [
      "hdr->sadb_msg_satype"
    ],
    "function": "key_notify_policy_flush",
    "filename": "linux/CVE-2013-2237/CVE-2013-2237_CWE-119_85dfb745ee40232876663ae206cba35f24ab2a40_af_key.c.diff",
    "function_code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 324,
    "critical_vars": [
      "mc_saved_count"
    ],
    "function": "get_matching_model_microcode",
    "filename": "linux/CVE-2015-2666/CVE-2015-2666_CWE-119_f84598bd7c851f8b0bf8cd0d7c3be0d73c432ff4_intel_early.c.diff",
    "function_code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\n\twhile (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\n\t\tleftover -= mc_size;\n\n\t\t/*\n\t\t * Since APs with same family and model as the BSP may boot in\n\t\t * the platform, we need to find and save microcode patches\n\t\t * with the same family and model as the BSP.\n\t\t */\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\n\t\tucode_ptr += mc_size;\n\t}\n\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 517,
    "critical_vars": [
      "urb->actual_length"
    ],
    "function": "command_port_read_callback",
    "filename": "linux/CVE-2014-3185/CVE-2014-3185_CWE-119_6817ae225cd650fb1c3295d769298c38b1eba818_whiteheat.c.diff",
    "function_code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - empty response, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\t/* These are unsolicited reports from the firmware, hence no\n\t\t   waiting command to wakeup */\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) &&\n\t\t(urb->actual_length - 1 <= sizeof(command_info->result_buffer))) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t/* Continue trying to always read */\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 64,
    "line_new": 66,
    "critical_vars": [
      "hx",
      "buf"
    ],
    "function": "usb_cypress_load_firmware",
    "filename": "linux/CVE-2017-8061/CVE-2017-8061_CWE-119_67b0503db9c29b04eadfeede6bebbfe5ddad94ef_dvb-usb-firmware.c.diff",
    "function_code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 *buf;\n\tint ret, pos = 0;\n\tu16 cpu_cs_register = cypress[type].cpu_cs_register;\n\n\tbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\thx = (struct hexline *)buf;\n\n\t/* stop the CPU */\n\tbuf[0] = 1;\n\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\tbuf[0] = 0;\n\t\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 70,
    "critical_vars": [
      "reset"
    ],
    "function": "usb_cypress_load_firmware",
    "filename": "linux/CVE-2017-8061/CVE-2017-8061_CWE-119_67b0503db9c29b04eadfeede6bebbfe5ddad94ef_dvb-usb-firmware.c.diff",
    "function_code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\n\t/* stop the CPU */\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(hx);\n\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 43,
    "critical_vars": [
      "size"
    ],
    "function": "exitcode_proc_write",
    "filename": "linux/CVE-2013-4512/CVE-2013-4512_CWE-119_201f99f170df14ba52ea4c52847779042b7a623b_exitcode.c.diff",
    "function_code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tsize_t size;\n\tint tmp;\n\n\tsize = min(count, sizeof(buf));\n\tif (copy_from_user(buf, buffer, size))\n\t\treturn -EFAULT;\n\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 45,
    "critical_vars": [
      "buffer",
      "count",
      "buf"
    ],
    "function": "exitcode_proc_write",
    "filename": "linux/CVE-2013-4512/CVE-2013-4512_CWE-119_201f99f170df14ba52ea4c52847779042b7a623b_exitcode.c.diff",
    "function_code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 224,
    "line_new": 224,
    "critical_vars": [
      "map"
    ],
    "function": "__videobuf_mmap_mapper",
    "filename": "linux/CVE-2007-6761/CVE-2007-6761_CWE-119_0b29669c065f60501e7289e1950fa2a618962358_videobuf-vmalloc.c.diff",
    "function_code": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1073,
    "critical_vars": [
      "bpf_reg_state",
      "reg",
      "size"
    ],
    "function": "check_ptr_alignment",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\t/* The stack spill tracking logic in check_stack_write()\n\t\t * and check_stack_read() relies on stack accesses being\n\t\t * aligned.\n\t\t */\n\t\tstrict = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1203,
    "critical_vars": [
      "regs[value_regno].var_off"
    ],
    "function": "check_mem_access",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* ctx accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t */\n\t\tif (reg->off) {\n\t\t\tverbose(env,\n\t\t\t\t\"dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\\n\",\n\t\t\t\tregno, reg->off, off - reg->off);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env,\n\t\t\t\t\"variable ctx access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\telse\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\tregs[value_regno].id = 0;\n\t\t\tregs[value_regno].off = 0;\n\t\t\tregs[value_regno].range = 0;\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* stack accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t * See check_stack_read().\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\toff += reg->var_off.value;\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off,\n\t\t\t\tsize);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (env->prog->aux->stack_depth < -off)\n\t\t\tenv->prog->aux->stack_depth = -off;\n\n\t\tif (t == BPF_WRITE)\n\t\t\terr = check_stack_write(env, state, off, size,\n\t\t\t\t\t\tvalue_regno);\n\t\telse\n\t\t\terr = check_stack_read(env, state, off, size,\n\t\t\t\t\t       value_regno);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tregs[value_regno].var_off =\n\t\t\ttnum_cast(regs[value_regno].var_off, size);\n\t\t__update_reg_bounds(&regs[value_regno]);\n\t}\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1226,
    "critical_vars": [
      "&regs[value_regno]",
      "size"
    ],
    "function": "check_mem_access",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* ctx accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t */\n\t\tif (reg->off) {\n\t\t\tverbose(env,\n\t\t\t\t\"dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\\n\",\n\t\t\t\tregno, reg->off, off - reg->off);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env,\n\t\t\t\t\"variable ctx access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\telse\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\tregs[value_regno].id = 0;\n\t\t\tregs[value_regno].off = 0;\n\t\t\tregs[value_regno].range = 0;\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* stack accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t * See check_stack_read().\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\toff += reg->var_off.value;\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off,\n\t\t\t\tsize);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (env->prog->aux->stack_depth < -off)\n\t\t\tenv->prog->aux->stack_depth = -off;\n\n\t\tif (t == BPF_WRITE)\n\t\t\terr = check_stack_write(env, state, off, size,\n\t\t\t\t\t\tvalue_regno);\n\t\telse\n\t\t\terr = check_stack_read(env, state, off, size,\n\t\t\t\t\t       value_regno);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2020,
    "critical_vars": [
      "dst_reg"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift, so make the appropriate casts */\n\t\tif (dst_reg->smin_value < 0) {\n\t\t\tif (umin_val) {\n\t\t\t\t/* Sign bit will be cleared */\n\t\t\t\tdst_reg->smin_value = 0;\n\t\t\t} else {\n\t\t\t\t/* Lost sign bit information */\n\t\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t\t}\n\t\t} else {\n\t\t\tdst_reg->smin_value =\n\t\t\t\t(u64)(dst_reg->smin_value) >> umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2033,
    "critical_vars": [
      "dst_reg"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2402,
    "critical_vars": [
      "regs[insn->dst_reg].var_off"
    ],
    "function": "check_alu_op",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2414,
    "critical_vars": [
      "&regs[insn->dst_reg]"
    ],
    "function": "check_alu_op",
    "filename": "linux/CVE-2017-16996/CVE-2017-16996_CWE-119_0c17d1d2c61936401f4702e1846e2c19b200f958_verifier.c.diff",
    "function_code": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\tcoerce_reg_to_size(&regs[insn->dst_reg], 4);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 532,
    "critical_vars": [
      "size",
      "i"
    ],
    "function": "zerocopy_sg_from_iovec",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\n\t/* Skip over from offset */\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\n\t/* copy up to skb headlen */\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\n\tif (len == offset1)\n\t\treturn 0;\n\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tif (i + size > MAX_SKB_FRAGS)\n\t\t\treturn -EMSGSIZE;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif (num_pages != size) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\t/* increase sk_wmem_alloc */\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 533,
    "critical_vars": [
      "num_pages"
    ],
    "function": "zerocopy_sg_from_iovec",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\n\t/* Skip over from offset */\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\n\t/* copy up to skb headlen */\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\n\tif (len == offset1)\n\t\treturn 0;\n\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\t/* increase sk_wmem_alloc */\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 654,
    "critical_vars": [
      "copylen"
    ],
    "function": "macvtap_get_user",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n\t\t\t\tconst struct iovec *iv, unsigned long total_len,\n\t\t\t\tsize_t count, int noblock)\n{\n\tstruct sk_buff *skb;\n\tstruct macvlan_dev *vlan;\n\tunsigned long len = total_len;\n\tint err;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint vnet_hdr_len = 0;\n\tint copylen;\n\tbool zerocopy = false;\n\n\tif (q->flags & IFF_VNET_HDR) {\n\t\tvnet_hdr_len = q->vnet_hdr_sz;\n\n\t\terr = -EINVAL;\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto err;\n\t\tlen -= vnet_hdr_len;\n\n\t\terr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\n\t\t\t\t\t   sizeof(vnet_hdr));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\tif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t     vnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\n\t\t\t\t\t\t\tvnet_hdr.hdr_len)\n\t\t\tvnet_hdr.hdr_len = vnet_hdr.csum_start +\n\t\t\t\t\t\tvnet_hdr.csum_offset + 2;\n\t\terr = -EINVAL;\n\t\tif (vnet_hdr.hdr_len > len)\n\t\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (unlikely(len < ETH_HLEN))\n\t\tgoto err;\n\n\tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n\t\tzerocopy = true;\n\n\tif (zerocopy) {\n\t\t/* There are 256 bytes to be copied in skb, so there is enough\n\t\t * room for skb expand head in case it is used.\n\t\t * The rest buffer is mapped from userspace.\n\t\t */\n\t\tcopylen = vnet_hdr.hdr_len;\n\t\tif (!copylen)\n\t\t\tcopylen = GOODCOPY_LEN;\n\t} else\n\t\tcopylen = len;\n\n\tskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\n\t\t\t\tvnet_hdr.hdr_len, noblock, &err);\n\tif (!skb)\n\t\tgoto err;\n\n\tif (zerocopy)\n\t\terr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\n\telse\n\t\terr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\n\t\t\t\t\t\t   len);\n\tif (err)\n\t\tgoto err_kfree;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\tif (vnet_hdr_len) {\n\t\terr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto err_kfree;\n\t}\n\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\t/* copy skb_ubuf_info for callback when skb has no error */\n\tif (zerocopy) {\n\t\tskb_shinfo(skb)->destructor_arg = m->msg_control;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\t}\n\tif (vlan)\n\t\tmacvlan_start_xmit(skb, vlan->dev);\n\telse\n\t\tkfree_skb(skb);\n\trcu_read_unlock_bh();\n\n\treturn total_len;\n\nerr_kfree:\n\tkfree_skb(skb);\n\nerr:\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\tif (vlan)\n\t\tvlan->dev->stats.tx_dropped++;\n\trcu_read_unlock_bh();\n\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 655,
    "critical_vars": [
      "copylen"
    ],
    "function": "macvtap_get_user",
    "filename": "linux/CVE-2012-2119/CVE-2012-2119_CWE-119_b92946e2919134ebe2a4083e4302236295ea2a73_macvtap.c.diff",
    "function_code": "static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n\t\t\t\tconst struct iovec *iv, unsigned long total_len,\n\t\t\t\tsize_t count, int noblock)\n{\n\tstruct sk_buff *skb;\n\tstruct macvlan_dev *vlan;\n\tunsigned long len = total_len;\n\tint err;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint vnet_hdr_len = 0;\n\tint copylen = 0;\n\tbool zerocopy = false;\n\n\tif (q->flags & IFF_VNET_HDR) {\n\t\tvnet_hdr_len = q->vnet_hdr_sz;\n\n\t\terr = -EINVAL;\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto err;\n\t\tlen -= vnet_hdr_len;\n\n\t\terr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\n\t\t\t\t\t   sizeof(vnet_hdr));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\tif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t     vnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\n\t\t\t\t\t\t\tvnet_hdr.hdr_len)\n\t\t\tvnet_hdr.hdr_len = vnet_hdr.csum_start +\n\t\t\t\t\t\tvnet_hdr.csum_offset + 2;\n\t\terr = -EINVAL;\n\t\tif (vnet_hdr.hdr_len > len)\n\t\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (unlikely(len < ETH_HLEN))\n\t\tgoto err;\n\n\terr = -EMSGSIZE;\n\tif (unlikely(count > UIO_MAXIOV))\n\t\tgoto err;\n\n\tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n\t\tzerocopy = true;\n\n\tif (zerocopy) {\n\t\t/* Userspace may produce vectors with count greater than\n\t\t * MAX_SKB_FRAGS, so we need to linearize parts of the skb\n\t\t * to let the rest of data to be fit in the frags.\n\t\t */\n\t\tif (count > MAX_SKB_FRAGS) {\n\t\t\tcopylen = iov_length(iv, count - MAX_SKB_FRAGS);\n\t\t\tif (copylen < vnet_hdr_len)\n\t\t\t\tcopylen = 0;\n\t\t\telse\n\t\t\t\tcopylen -= vnet_hdr_len;\n\t\t}\n\t\t/* There are 256 bytes to be copied in skb, so there is enough\n\t\t * room for skb expand head in case it is used.\n\t\t * The rest buffer is mapped from userspace.\n\t\t */\n\t\tif (copylen < vnet_hdr.hdr_len)\n\t\t\tcopylen = vnet_hdr.hdr_len;\n\t\tif (!copylen)\n\t\t\tcopylen = GOODCOPY_LEN;\n\t} else\n\t\tcopylen = len;\n\n\tskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\n\t\t\t\tvnet_hdr.hdr_len, noblock, &err);\n\tif (!skb)\n\t\tgoto err;\n\n\tif (zerocopy)\n\t\terr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\n\telse\n\t\terr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\n\t\t\t\t\t\t   len);\n\tif (err)\n\t\tgoto err_kfree;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\tif (vnet_hdr_len) {\n\t\terr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto err_kfree;\n\t}\n\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\t/* copy skb_ubuf_info for callback when skb has no error */\n\tif (zerocopy) {\n\t\tskb_shinfo(skb)->destructor_arg = m->msg_control;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\t}\n\tif (vlan)\n\t\tmacvlan_start_xmit(skb, vlan->dev);\n\telse\n\t\tkfree_skb(skb);\n\trcu_read_unlock_bh();\n\n\treturn total_len;\n\nerr_kfree:\n\tkfree_skb(skb);\n\nerr:\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\tif (vlan)\n\t\tvlan->dev->stats.tx_dropped++;\n\trcu_read_unlock_bh();\n\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2080,
    "critical_vars": [
      "cmd"
    ],
    "function": "do_ip_vs_set_ctl",
    "filename": "linux/CVE-2013-4588/CVE-2013-4588_CWE-119_04bcef2a83f40c6db24222b27a52892cba39dffb_ip_vs_ctl.c.diff",
    "function_code": "do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2359,
    "critical_vars": [
      "copylen"
    ],
    "function": "do_ip_vs_get_ctl",
    "filename": "linux/CVE-2013-4588/CVE-2013-4588_CWE-119_04bcef2a83f40c6db24222b27a52892cba39dffb_ip_vs_ctl.c.diff",
    "function_code": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2365,
    "critical_vars": [
      "cmd"
    ],
    "function": "do_ip_vs_get_ctl",
    "filename": "linux/CVE-2013-4588/CVE-2013-4588_CWE-119_04bcef2a83f40c6db24222b27a52892cba39dffb_ip_vs_ctl.c.diff",
    "function_code": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 173,
    "critical_vars": [
      "lower_file"
    ],
    "function": "ecryptfs_privileged_open",
    "filename": "linux/CVE-2016-1583/CVE-2016-1583_CWE-119_2f36db71009304b3f0b95afacd8eba1f9f046b87_kthread.c.diff",
    "function_code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto have_file;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file)) {\n\t\trc = PTR_ERR(*lower_file);\n\t\tgoto out;\n\t}\nhave_file:\n\tif ((*lower_file)->f_op->mmap == NULL) {\n\t\tfput(*lower_file);\n\t\t*lower_file = NULL;\n\t\trc = -EMEDIUMTYPE;\n\t}\nout:\n\treturn rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2194,
    "critical_vars": [
      "do_vnet"
    ],
    "function": "tpacket_rcv",
    "filename": "linux/CVE-2017-14497/CVE-2017-14497_CWE-119_edbd58be15a957f6a760c4a514cd475217eb97fd_af_packet.c.diff",
    "function_code": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\tbool do_vnet = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\t\tdo_vnet = true;\n\t\t}\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0) {\n\t\t\t\tsnaplen = 0;\n\t\t\t\tdo_vnet = false;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t\tdo_vnet = false;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tif (do_vnet) {\n\t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2301,
    "critical_vars": [
      "po->has_vnet_hdr"
    ],
    "function": "tpacket_rcv",
    "filename": "linux/CVE-2017-14497/CVE-2017-14497_CWE-119_edbd58be15a957f6a760c4a514cd475217eb97fd_af_packet.c.diff",
    "function_code": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr)\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0)\n\t\t\t\tsnaplen = 0;\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tif (po->has_vnet_hdr) {\n\t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 361,
    "critical_vars": [
      "i_ext",
      "f2fs_extent",
      "inode"
    ],
    "function": "f2fs_init_extent_tree",
    "filename": "linux/CVE-2017-18193/CVE-2017-18193_CWE-119_dad48e73127ba10279ea33e6dbc8d3905c4d31c0_extent_cache.c.diff",
    "function_code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tbool ret =  __f2fs_init_extent_tree(inode, i_ext);\n\n\tif (!F2FS_I(inode)->extent_tree)\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 186,
    "critical_vars": [
      "odata"
    ],
    "function": "crypto_ccm_auth",
    "filename": "linux/CVE-2017-8065/CVE-2017-8065_CWE-119_3b30460c5b0ed762be75a004e924ec3f8711e032_ccm.c.diff",
    "function_code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\n\t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 187,
    "critical_vars": [
      "*odata"
    ],
    "function": "crypto_ccm_auth",
    "filename": "linux/CVE-2017-8065/CVE-2017-8065_CWE-119_3b30460c5b0ed762be75a004e924ec3f8711e032_ccm.c.diff",
    "function_code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 *odata = pctx->odata;\n\tu8 *idata = pctx->idata;\n\tint ilen, err;\n\n\t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 353,
    "critical_vars": [
      "size"
    ],
    "function": "picolcd_raw_event",
    "filename": "linux/CVE-2014-3186/CVE-2014-3186_CWE-119_844817e47eef14141cf59b8d5ac08dd11c0a9189_hid-picolcd_core.c.diff",
    "function_code": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn 1;\n\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t/*\n\t\t * We let the caller of picolcd_send_and_wait() check if the\n\t\t * report we got is one of the expected ones or not.\n\t\t */\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 115,
    "critical_vars": [
      "free"
    ],
    "function": "mlx4_register_mac",
    "filename": "linux/CVE-2010-5332/CVE-2010-5332_CWE-119_0926f91083f34d047abc74f1ca4fa6a9c161f7db_port.c.diff",
    "function_code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 214,
    "critical_vars": [
      "free"
    ],
    "function": "mlx4_register_vlan",
    "filename": "linux/CVE-2010-5332/CVE-2010-5332_CWE-119_0926f91083f34d047abc74f1ca4fa6a9c161f7db_port.c.diff",
    "function_code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 2391,
    "critical_vars": [
      "cnt2end"
    ],
    "function": "arcmsr_iop_message_xfer",
    "filename": "linux/CVE-2016-7425/CVE-2016-7425_CWE-119_7bc2b55a5c030685b399bb65b6baa9ccc3d1f167_arcmsr_hba.c.diff",
    "function_code": "static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tint32_t user_len, cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2392,
    "critical_vars": [
      "cnt2end"
    ],
    "function": "arcmsr_iop_message_xfer",
    "filename": "linux/CVE-2016-7425/CVE-2016-7425_CWE-119_7bc2b55a5c030685b399bb65b6baa9ccc3d1f167_arcmsr_hba.c.diff",
    "function_code": "static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tchar *buffer;\n\tunsigned short use_sg;\n\tint retvalue = 0, transfer_len = 0;\n\tunsigned long flags;\n\tstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\n\tuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\n\t\t(uint32_t)cmd->cmnd[6] << 16 |\n\t\t(uint32_t)cmd->cmnd[7] << 8 |\n\t\t(uint32_t)cmd->cmnd[8];\n\tstruct scatterlist *sg;\n\n\tuse_sg = scsi_sg_count(cmd);\n\tsg = scsi_sglist(cmd);\n\tbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\n\tif (use_sg > 1) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tgoto message_out;\n\t}\n\ttransfer_len += sg->length;\n\tif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: ARCMSR_MESSAGE_FAIL!\\n\", __func__);\n\t\tgoto message_out;\n\t}\n\tpcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\n\tswitch (controlcode) {\n\tcase ARCMSR_MESSAGE_READ_RQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint8_t *ptmpQbuffer;\n\t\tuint32_t allxfer_len = 0;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tpr_info(\"%s: memory not enough!\\n\", __func__);\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpQbuffer = ver_addr;\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\n\t\t\tunsigned int tail = acb->rqbuf_getIndex;\n\t\t\tunsigned int head = acb->rqbuf_putIndex;\n\t\t\tunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\n\n\t\t\tallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\n\t\t\tif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\n\t\t\t\tallxfer_len = ARCMSR_API_DATA_BUFLEN;\n\n\t\t\tif (allxfer_len <= cnt_to_end)\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\n\t\t\telse {\n\t\t\t\tmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\n\t\t\t\tmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\n\t\t\t}\n\t\t\tacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\n\t\t}\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\n\t\t\tallxfer_len);\n\t\tif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\n\t\t\tstruct QBUFFER __iomem *prbuffer;\n\t\t\tacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\n\t\t\tprbuffer = arcmsr_get_iop_rqbuffer(acb);\n\t\t\tif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\n\t\t\t\tacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\n\t\tunsigned char *ver_addr;\n\t\tuint32_t user_len;\n\t\tint32_t cnt2end;\n\t\tuint8_t *pQbuffer, *ptmpuserbuffer;\n\t\tver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\n\t\tif (!ver_addr) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tgoto message_out;\n\t\t}\n\t\tptmpuserbuffer = ver_addr;\n\t\tuser_len = pcmdmessagefld->cmdmessage.Length;\n\t\tif (user_len > ARCMSR_API_DATA_BUFLEN) {\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t\tkfree(ver_addr);\n\t\t\tgoto message_out;\n\t\t}\n\t\tmemcpy(ptmpuserbuffer,\n\t\t\tpcmdmessagefld->messagedatabuffer, user_len);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\n\t\t\tstruct SENSE_DATA *sensebuffer =\n\t\t\t\t(struct SENSE_DATA *)cmd->sense_buffer;\n\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t/* has error report sensedata */\n\t\t\tsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\n\t\t\tsensebuffer->SenseKey = ILLEGAL_REQUEST;\n\t\t\tsensebuffer->AdditionalSenseLength = 0x0A;\n\t\t\tsensebuffer->AdditionalSenseCode = 0x20;\n\t\t\tsensebuffer->Valid = 1;\n\t\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\t} else {\n\t\t\tpQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\n\t\t\tcnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\n\t\t\tif (user_len > cnt2end) {\n\t\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\n\t\t\t\tptmpuserbuffer += cnt2end;\n\t\t\t\tuser_len -= cnt2end;\n\t\t\t\tacb->wqbuf_putIndex = 0;\n\t\t\t\tpQbuffer = acb->wqbuffer;\n\t\t\t}\n\t\t\tmemcpy(pQbuffer, ptmpuserbuffer, user_len);\n\t\t\tacb->wqbuf_putIndex += user_len;\n\t\t\tacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\n\t\t\tif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\n\t\t\t\tacb->acb_flags &=\n\t\t\t\t\t\t~ACB_F_MESSAGE_WQBUFFER_CLEARED;\n\t\t\t\tarcmsr_write_ioctldata2iop(acb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tkfree(ver_addr);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->rqbuffer;\n\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\n\t\tuint8_t *pQbuffer = acb->wqbuffer;\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\n\t\tuint8_t *pQbuffer;\n\t\tarcmsr_clear_iop2drv_rqueue_buffer(acb);\n\t\tspin_lock_irqsave(&acb->rqbuffer_lock, flags);\n\t\tacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\n\t\tacb->rqbuf_getIndex = 0;\n\t\tacb->rqbuf_putIndex = 0;\n\t\tpQbuffer = acb->rqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\n\t\tspin_lock_irqsave(&acb->wqbuffer_lock, flags);\n\t\tacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\n\t\t\tACB_F_MESSAGE_WQBUFFER_READED);\n\t\tacb->wqbuf_getIndex = 0;\n\t\tacb->wqbuf_putIndex = 0;\n\t\tpQbuffer = acb->wqbuffer;\n\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));\n\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_3F;\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_HELLO: {\n\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tmemcpy(pcmdmessagefld->messagedatabuffer,\n\t\t\thello_string, (int16_t)strlen(hello_string));\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_iop_parking(acb);\n\t\tbreak;\n\t}\n\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\n\t\tif (acb->fw_flag == FW_DEADLOCK)\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\n\t\telse\n\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =\n\t\t\t\tARCMSR_MESSAGE_RETURNCODE_OK;\n\t\tarcmsr_flush_adapter_cache(acb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tretvalue = ARCMSR_MESSAGE_FAIL;\n\t\tpr_info(\"%s: unknown controlcode!\\n\", __func__);\n\t}\nmessage_out:\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = scsi_sglist(cmd);\n\t\tkunmap_atomic(buffer - sg->offset);\n\t}\n\treturn retvalue;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1366,
    "critical_vars": [
      "&q->key"
    ],
    "function": "*queue_lock",
    "filename": "linux/CVE-2014-0205/CVE-2014-0205_CWE-119_7ada876a8703f23befbb20a7465a702ee39b1704_futex.c.diff",
    "function_code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1484,
    "critical_vars": [
      "&q->key"
    ],
    "function": "unqueue_me_pi",
    "filename": "linux/CVE-2014-0205/CVE-2014-0205_CWE-119_7ada876a8703f23befbb20a7465a702ee39b1704_futex.c.diff",
    "function_code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n\n\tdrop_futex_key_refs(&q->key);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1836,
    "critical_vars": [
      "&q.key",
      "fshared"
    ],
    "function": "futex_wait",
    "filename": "linux/CVE-2014-0205/CVE-2014-0205_CWE-119_7ada876a8703f23befbb20a7465a702ee39b1704_futex.c.diff",
    "function_code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/* Prepare to wait on uaddr. */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 4082,
    "critical_vars": [
      "name_len"
    ],
    "function": "CIFSFindNext",
    "filename": "linux/CVE-2011-3191/CVE-2011-3191_CWE-119_9438fabb73eb48055b58b89fc51e0bc4db22fabd_cifssmb.c.diff",
    "function_code": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned, name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 4083,
    "critical_vars": [
      "name_len"
    ],
    "function": "CIFSFindNext",
    "filename": "linux/CVE-2011-3191/CVE-2011-3191_CWE-119_9438fabb73eb48055b58b89fc51e0bc4db22fabd_cifssmb.c.diff",
    "function_code": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 83,
    "critical_vars": [
      "err"
    ],
    "function": "udf_symlink_filler",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_a1d47b262952a45aae62bd49cfaf33dd76c11a2c_symlink.c.diff",
    "function_code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tsymlink = bh->b_data;\n\t}\n\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 83,
    "critical_vars": [
      "err"
    ],
    "function": "udf_symlink_filler",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_a1d47b262952a45aae62bd49cfaf33dd76c11a2c_symlink.c.diff",
    "function_code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\n\t/* We don't support symlinks longer than one block */\n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unmap;\n\t}\n\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\n\t\tsymlink = bh->b_data;\n\t}\n\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nout_unlock_inode:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\nout_unmap:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 45,
    "critical_vars": [
      "elen"
    ],
    "function": "udf_pc_to_char",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_e237ec37ec154564f8690c5bd1795339955eeef9_symlink.c.diff",
    "function_code": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\telen += sizeof(struct pathComponent);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0) {\n\t\t\t\telen += pc->lengthComponentIdent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\telen += pc->lengthComponentIdent;\n\t\t\tif (elen > fromlen)\n\t\t\t\treturn -EIO;\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 88,
    "critical_vars": [
      "elen"
    ],
    "function": "udf_pc_to_char",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_e237ec37ec154564f8690c5bd1795339955eeef9_symlink.c.diff",
    "function_code": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1493,
    "critical_vars": [
      "iinfo->i_alloc_type"
    ],
    "function": "udf_read_inode",
    "filename": "linux/CVE-2014-9728/CVE-2014-9728_CWE-119_e159332b9af4b04d882dbcfe1bb0117f0a6d4b58_inode.c.diff",
    "function_code": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > inode->i_sb->s_blocksize -\n\t\t\t\t\tudf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 122,
    "line_new": 122,
    "critical_vars": [
      "pfn"
    ],
    "function": "kvm_iommu_map_pages",
    "filename": "linux/CVE-2014-8369/CVE-2014-8369_CWE-119_3d32e4dbe71374a6780eaf51d719d76f9a9bf22f_iommu.c.diff",
    "function_code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3941,
    "critical_vars": [
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2013-4591/CVE-2013-4591_CWE-119_7d3e91a89b7adbc2831334def9e494dd9892f9af_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 62,
    "critical_vars": [
      "wo"
    ],
    "function": "cxusb_ctrl_msg",
    "filename": "linux/CVE-2017-8063/CVE-2017-8063_CWE-119_3f190e3aec212fc8c61e202c51400afa7384d4bc_cxusb.c.diff",
    "function_code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); /* write-only */\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 69,
    "critical_vars": [
      "rlen"
    ],
    "function": "cxusb_ctrl_msg",
    "filename": "linux/CVE-2017-8063/CVE-2017-8063_CWE-119_3f190e3aec212fc8c61e202c51400afa7384d4bc_cxusb.c.diff",
    "function_code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c rd: len=%d is too big!\\n\", rlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen, st->data, rlen, 0);\n\tif (!ret && rbuf && rlen)\n\t\tmemcpy(rbuf, st->data, rlen);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 80,
    "critical_vars": [
      "priv",
      "sta_id"
    ],
    "function": "iwl_process_add_sta_resp",
    "filename": "linux/CVE-2012-6712/CVE-2012-6712_CWE-119_2da424b0773cea3db47e1e81db71eeebde8269d4_iwl-agn-sta.c.diff",
    "function_code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 84,
    "critical_vars": [
      "ret"
    ],
    "function": "iwl_process_add_sta_resp",
    "filename": "linux/CVE-2012-6712/CVE-2012-6712_CWE-119_2da424b0773cea3db47e1e81db71eeebde8269d4_iwl-agn-sta.c.diff",
    "function_code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tret = iwl_sta_ucode_activate(priv, sta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1026,
    "critical_vars": [
      "&dev",
      "name"
    ],
    "function": "dvb_usbv2_disconnect",
    "filename": "linux/CVE-2017-8064/CVE-2017-8064_CWE-119_005145378c9ad7575a01b6ce1ba118fb427f583a_dvb_usb_core.c.diff",
    "function_code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1026,
    "critical_vars": [
      "devname",
      "drvname"
    ],
    "function": "dvb_usbv2_disconnect",
    "filename": "linux/CVE-2017-8064/CVE-2017-8064_CWE-119_005145378c9ad7575a01b6ce1ba118fb427f583a_dvb_usb_core.c.diff",
    "function_code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\n\tconst char *drvname = d->name;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tpr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\n\t\tKBUILD_MODNAME, drvname, devname);\n\tkfree(devname);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 786,
    "critical_vars": [
      "qid"
    ],
    "function": "nvmet_fc_find_target_queue",
    "filename": "linux/CVE-2017-18379/CVE-2017-18379_CWE-119_0c319d3a144d4b8f1ea2047fd614d2149b68f889_fc.c.diff",
    "function_code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n\tu16 qid = nvmet_fc_getqueueid(connection_id);\n\tunsigned long flags;\n\n\tif (qid > NVMET_NR_QUEUES)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 779,
    "critical_vars": [
      "i"
    ],
    "function": "catc_probe",
    "filename": "linux/CVE-2017-8070/CVE-2017-8070_CWE-119_2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478_catc.c.diff",
    "function_code": "static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint i, pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\tinit_timer(&catc->timer);\n\tcatc->timer.data = (long) catc;\n\tcatc->timer.function = catc_stats_timer;\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) || \n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */\n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 && \n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\t\t\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\t\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\ti = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, &i, 4);\n\t\ti = 0x87654321;\t\n\t\tcatc_write_mem(catc, 0xfa80, &i, 4);\n\t\tcatc_read_mem(catc, 0x7a80, &i, 4);\n\t  \n\t\tswitch (i) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\t  \n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\t\t\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\t\t\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\t\t\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\t\t\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 843,
    "critical_vars": [
      "*buf"
    ],
    "function": "catc_probe",
    "filename": "linux/CVE-2017-8070/CVE-2017-8070_CWE-119_2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478_catc.c.diff",
    "function_code": "static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\tinit_timer(&catc->timer);\n\tcatc->timer.data = (long) catc;\n\tcatc->timer.function = catc_stats_timer;\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) || \n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */\n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 && \n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\t\t\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\t\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\t  \n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\t  \n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\t\t\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\t\t\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\t\t\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\t\t\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1406,
    "critical_vars": [
      "pid"
    ],
    "function": "kill_something_info",
    "filename": "linux/CVE-2018-10124/CVE-2018-10124_CWE-119_4ea77014af0d6205b05503d1c7aac6eace11d473_signal.c.diff",
    "function_code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1952,
    "critical_vars": [
      "bh"
    ],
    "function": "journal_unmap_buffer",
    "filename": "linux/CVE-2011-4086/CVE-2011-4086_CWE-119_15291164b22a357cb211b618adfef4fa82fc0de3_transaction.c.diff",
    "function_code": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\tint ret;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * buffer can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tret = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. So we just set j_next_transaction to the\n\t\t * running transaction (if there is one) and mark\n\t\t * buffer as freed so that commit code knows it should\n\t\t * clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\twrite_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3987,
    "critical_vars": [
      "*mapping"
    ],
    "function": "hugetlb_mcopy_atomic_pte",
    "filename": "linux/CVE-2017-15128/CVE-2017-15128_CWE-119_1e3921471354244f70fe268586ff94a97a6dd4df_hugetlb.c.diff",
    "function_code": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4028,
    "critical_vars": [
      "*mapping"
    ],
    "function": "hugetlb_mcopy_atomic_pte",
    "filename": "linux/CVE-2017-15128/CVE-2017-15128_CWE-119_1e3921471354244f70fe268586ff94a97a6dd4df_hugetlb.c.diff",
    "function_code": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 293,
    "critical_vars": [
      "npoints"
    ],
    "function": "magicmouse_raw_event",
    "filename": "linux/CVE-2014-3181/CVE-2014-3181_CWE-119_c54def7bd64d7c0b6993336abcffb8444795bf38_hid-magicmouse.c.diff",
    "function_code": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n\t\t/* Expect four bytes of prefix, and N*9 bytes of touch data. */\n\t\tif (size < 4 || ((size - 4) % 9) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 4) / 9;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for TRACKPAD_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\n\t\tclicks = data[1];\n\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;\n\t\t */\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n\t\t/* Expect six bytes of prefix, and N*8 bytes of touch data. */\n\t\tif (size < 6 || ((size - 6) % 8) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 6) / 8;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for MOUSE_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\n\t\t/* When emulating three-button mode, it is important\n\t\t * to have the current touch information before\n\t\t * generating a click event.\n\t\t */\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;\n\t\t */\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\t/* Sometimes the trackpad sends two touch reports in one\n\t\t * packet.\n\t\t */\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */\n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\n\tinput_sync(input);\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 389,
    "critical_vars": [
      "p->replacement_session_keyring"
    ],
    "function": "copy_creds",
    "filename": "linux/CVE-2012-2745/CVE-2012-2745_CWE-119_79549c6dfda0603dba9a70a53467ce62d9335c33_cred.c.diff",
    "function_code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tp->replacement_session_keyring = NULL;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 139,
    "critical_vars": [
      "error"
    ],
    "function": "bat_socket_read",
    "filename": "linux/CVE-2011-4604/CVE-2011-4604_CWE-119_b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c_icmp_socket.c.diff",
    "function_code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 139,
    "critical_vars": [
      "packet_len"
    ],
    "function": "bat_socket_read",
    "filename": "linux/CVE-2011-4604/CVE-2011-4604_CWE-119_b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c_icmp_socket.c.diff",
    "function_code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\tpacket_len = min(count, socket_packet->icmp_len);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\n\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 329,
    "line_new": 329,
    "critical_vars": [
      "n"
    ],
    "function": "oz_usb_handle_ep_data",
    "filename": "linux/CVE-2015-4002/CVE-2015-4002_CWE-119_9a59029bc218b48eff8b5d4dde5662fd79d3e1a8_ozusbsvc1.c.diff",
    "function_code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 393,
    "critical_vars": [
      "data_len"
    ],
    "function": "oz_usb_rx",
    "filename": "linux/CVE-2015-4002/CVE-2015-4002_CWE-119_d114b9fe78c8d6fc6e70808c2092aa307c36dc8e_ozusbsvc1.c.diff",
    "function_code": "void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)\n{\n\tstruct oz_usb_hdr *usb_hdr = (struct oz_usb_hdr *)(elt + 1);\n\tstruct oz_usb_ctx *usb_ctx;\n\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tusb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB];\n\tif (usb_ctx)\n\t\toz_usb_get(usb_ctx);\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tif (usb_ctx == NULL)\n\t\treturn; /* Context has gone so nothing to do. */\n\tif (usb_ctx->stopped)\n\t\tgoto done;\n\t/* If sequence number is non-zero then check it is not a duplicate.\n\t * Zero sequence numbers are always accepted.\n\t */\n\tif (usb_hdr->elt_seq_num != 0) {\n\t\tif (((usb_ctx->rx_seq_num - usb_hdr->elt_seq_num) & 0x80) == 0)\n\t\t\t/* Reject duplicate element. */\n\t\t\tgoto done;\n\t}\n\tusb_ctx->rx_seq_num = usb_hdr->elt_seq_num;\n\tswitch (usb_hdr->type) {\n\tcase OZ_GET_DESC_RSP: {\n\t\t\tstruct oz_get_desc_rsp *body =\n\t\t\t\t(struct oz_get_desc_rsp *)usb_hdr;\n\t\t\tint data_len = elt->length -\n\t\t\t\t\tsizeof(struct oz_get_desc_rsp) + 1;\n\t\t\tu16 offs = le16_to_cpu(get_unaligned(&body->offset));\n\t\t\tu16 total_size =\n\t\t\t\tle16_to_cpu(get_unaligned(&body->total_size));\n\t\t\toz_dbg(ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\n\");\n\t\t\toz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\t\tbody->rcode, body->data,\n\t\t\t\t\tdata_len, offs, total_size);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_CONFIG_RSP: {\n\t\t\tstruct oz_set_config_rsp *body =\n\t\t\t\t(struct oz_set_config_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_INTERFACE_RSP: {\n\t\t\tstruct oz_set_interface_rsp *body =\n\t\t\t\t(struct oz_set_interface_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport,\n\t\t\t\tbody->req_id, body->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_VENDOR_CLASS_RSP: {\n\t\t\tstruct oz_vendor_class_rsp *body =\n\t\t\t\t(struct oz_vendor_class_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, body->data, elt->length-\n\t\t\t\tsizeof(struct oz_vendor_class_rsp)+1);\n\t\t}\n\t\tbreak;\n\tcase OZ_USB_ENDPOINT_DATA:\n\t\toz_usb_handle_ep_data(usb_ctx, usb_hdr, elt->length);\n\t\tbreak;\n\t}\ndone:\n\toz_usb_put(usb_ctx);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 393,
    "critical_vars": [
      "total_size",
      "offs"
    ],
    "function": "oz_usb_rx",
    "filename": "linux/CVE-2015-4002/CVE-2015-4002_CWE-119_d114b9fe78c8d6fc6e70808c2092aa307c36dc8e_ozusbsvc1.c.diff",
    "function_code": "void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)\n{\n\tstruct oz_usb_hdr *usb_hdr = (struct oz_usb_hdr *)(elt + 1);\n\tstruct oz_usb_ctx *usb_ctx;\n\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tusb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB];\n\tif (usb_ctx)\n\t\toz_usb_get(usb_ctx);\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB]);\n\tif (usb_ctx == NULL)\n\t\treturn; /* Context has gone so nothing to do. */\n\tif (usb_ctx->stopped)\n\t\tgoto done;\n\t/* If sequence number is non-zero then check it is not a duplicate.\n\t * Zero sequence numbers are always accepted.\n\t */\n\tif (usb_hdr->elt_seq_num != 0) {\n\t\tif (((usb_ctx->rx_seq_num - usb_hdr->elt_seq_num) & 0x80) == 0)\n\t\t\t/* Reject duplicate element. */\n\t\t\tgoto done;\n\t}\n\tusb_ctx->rx_seq_num = usb_hdr->elt_seq_num;\n\tswitch (usb_hdr->type) {\n\tcase OZ_GET_DESC_RSP: {\n\t\t\tstruct oz_get_desc_rsp *body =\n\t\t\t\t(struct oz_get_desc_rsp *)usb_hdr;\n\t\t\tu16 offs, total_size;\n\t\t\tu8 data_len;\n\n\t\t\tif (elt->length < sizeof(struct oz_get_desc_rsp) - 1)\n\t\t\t\tbreak;\n\t\t\tdata_len = elt->length -\n\t\t\t\t\t(sizeof(struct oz_get_desc_rsp) - 1);\n\t\t\toffs = le16_to_cpu(get_unaligned(&body->offset));\n\t\t\ttotal_size =\n\t\t\t\tle16_to_cpu(get_unaligned(&body->total_size));\n\t\t\toz_dbg(ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\n\");\n\t\t\toz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\t\tbody->rcode, body->data,\n\t\t\t\t\tdata_len, offs, total_size);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_CONFIG_RSP: {\n\t\t\tstruct oz_set_config_rsp *body =\n\t\t\t\t(struct oz_set_config_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_SET_INTERFACE_RSP: {\n\t\t\tstruct oz_set_interface_rsp *body =\n\t\t\t\t(struct oz_set_interface_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport,\n\t\t\t\tbody->req_id, body->rcode, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase OZ_VENDOR_CLASS_RSP: {\n\t\t\tstruct oz_vendor_class_rsp *body =\n\t\t\t\t(struct oz_vendor_class_rsp *)usb_hdr;\n\t\t\toz_hcd_control_cnf(usb_ctx->hport, body->req_id,\n\t\t\t\tbody->rcode, body->data, elt->length-\n\t\t\t\tsizeof(struct oz_vendor_class_rsp)+1);\n\t\t}\n\t\tbreak;\n\tcase OZ_USB_ENDPOINT_DATA:\n\t\toz_usb_handle_ep_data(usb_ctx, usb_hdr, elt->length);\n\t\tbreak;\n\t}\ndone:\n\toz_usb_put(usb_ctx);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 949,
    "critical_vars": [
      "dd_config",
      "&dd",
      "dd"
    ],
    "function": "vop_ioctl",
    "filename": "linux/CVE-2016-5728/CVE-2016-5728_CWE-119_9bf292bfca94694a721449e3fd752493856710f6_vop_vringh.c.diff",
    "function_code": "static long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct vop_vdev *vdev = f->private_data;\n\tstruct vop_info *vi = vdev->vi;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase MIC_VIRTIO_ADD_DEVICE:\n\t{\n\t\tstruct mic_device_desc dd, *dd_config;\n\n\t\tif (copy_from_user(&dd, argp, sizeof(dd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\n\t\t    dd.num_vq > MIC_MAX_VRINGS)\n\t\t\treturn -EINVAL;\n\n\t\tdd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\n\t\tif (!dd_config)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_ret;\n\t\t}\n\t\t/* Ensure desc has not changed between the two reads */\n\t\tif (memcmp(&dd, dd_config, sizeof(dd))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_ret;\n\t\t}\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tmutex_lock(&vi->vop_mutex);\n\t\tret = vop_virtio_add_device(vdev, dd_config);\n\t\tif (ret)\n\t\t\tgoto unlock_ret;\n\t\tlist_add_tail(&vdev->list, &vi->vdev_list);\nunlock_ret:\n\t\tmutex_unlock(&vi->vop_mutex);\n\t\tmutex_unlock(&vdev->vdev_mutex);\nfree_ret:\n\t\tkfree(dd_config);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_COPY_DESC:\n\t{\n\t\tstruct mic_copy_desc copy;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto _unlock_ret;\n\n\t\tif (copy_from_user(&copy, argp, sizeof(copy))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto _unlock_ret;\n\t\t}\n\n\t\tret = vop_virtio_copy_desc(vdev, &copy);\n\t\tif (ret < 0)\n\t\t\tgoto _unlock_ret;\n\t\tif (copy_to_user(\n\t\t\t&((struct mic_copy_desc __user *)argp)->out_len,\n\t\t\t&copy.out_len, sizeof(copy.out_len)))\n\t\t\tret = -EFAULT;\n_unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_CONFIG_CHANGE:\n\t{\n\t\tvoid *buf;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto __unlock_ret;\n\t\tbuf = kzalloc(vdev->dd->config_len, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto __unlock_ret;\n\t\t}\n\t\tif (copy_from_user(buf, argp, vdev->dd->config_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tret = vop_virtio_config_change(vdev, buf);\ndone:\n\t\tkfree(buf);\n__unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t};\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1283,
    "critical_vars": [
      "net",
      "status"
    ],
    "function": "sctp_net_init",
    "filename": "linux/CVE-2015-5283/CVE-2015-5283_CWE-119_8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4_protocol.c.diff",
    "function_code": "static int __net_init sctp_net_init(struct net *net)\n{\n\tint status;\n\n\t/*\n\t * 14. Suggested SCTP Protocol Parameter Values\n\t */\n\t/* The following protocol parameters are RECOMMENDED:  */\n\t/* RTO.Initial              - 3  seconds */\n\tnet->sctp.rto_initial\t\t\t= SCTP_RTO_INITIAL;\n\t/* RTO.Min                  - 1  second */\n\tnet->sctp.rto_min\t \t\t= SCTP_RTO_MIN;\n\t/* RTO.Max                 -  60 seconds */\n\tnet->sctp.rto_max \t\t\t= SCTP_RTO_MAX;\n\t/* RTO.Alpha                - 1/8 */\n\tnet->sctp.rto_alpha\t\t\t= SCTP_RTO_ALPHA;\n\t/* RTO.Beta                 - 1/4 */\n\tnet->sctp.rto_beta\t\t\t= SCTP_RTO_BETA;\n\n\t/* Valid.Cookie.Life        - 60  seconds */\n\tnet->sctp.valid_cookie_life\t\t= SCTP_DEFAULT_COOKIE_LIFE;\n\n\t/* Whether Cookie Preservative is enabled(1) or not(0) */\n\tnet->sctp.cookie_preserve_enable \t= 1;\n\n\t/* Default sctp sockets to use md5 as their hmac alg */\n#if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"md5\";\n#elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"sha1\";\n#else\n\tnet->sctp.sctp_hmac_alg\t\t\t= NULL;\n#endif\n\n\t/* Max.Burst\t\t    - 4 */\n\tnet->sctp.max_burst\t\t\t= SCTP_DEFAULT_MAX_BURST;\n\n\t/* Association.Max.Retrans  - 10 attempts\n\t * Path.Max.Retrans         - 5  attempts (per destination address)\n\t * Max.Init.Retransmits     - 8  attempts\n\t */\n\tnet->sctp.max_retrans_association\t= 10;\n\tnet->sctp.max_retrans_path\t\t= 5;\n\tnet->sctp.max_retrans_init\t\t= 8;\n\n\t/* Sendbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.sndbuf_policy\t\t\t= 0;\n\n\t/* Rcvbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.rcvbuf_policy\t\t\t= 0;\n\n\t/* HB.interval              - 30 seconds */\n\tnet->sctp.hb_interval\t\t\t= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;\n\n\t/* delayed SACK timeout */\n\tnet->sctp.sack_timeout\t\t\t= SCTP_DEFAULT_TIMEOUT_SACK;\n\n\t/* Disable ADDIP by default. */\n\tnet->sctp.addip_enable = 0;\n\tnet->sctp.addip_noauth = 0;\n\tnet->sctp.default_auto_asconf = 0;\n\n\t/* Enable PR-SCTP by default. */\n\tnet->sctp.prsctp_enable = 1;\n\n\t/* Disable AUTH by default. */\n\tnet->sctp.auth_enable = 0;\n\n\t/* Set SCOPE policy to enabled */\n\tnet->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;\n\n\t/* Set the default rwnd update threshold */\n\tnet->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;\n\n\t/* Initialize maximum autoclose timeout. */\n\tnet->sctp.max_autoclose\t\t= INT_MAX / HZ;\n\n\tstatus = sctp_sysctl_net_register(net);\n\tif (status)\n\t\tgoto err_sysctl_register;\n\n\t/* Allocate and initialise sctp mibs.  */\n\tstatus = init_sctp_mibs(net);\n\tif (status)\n\t\tgoto err_init_mibs;\n\n\t/* Initialize proc fs directory.  */\n\tstatus = sctp_proc_init(net);\n\tif (status)\n\t\tgoto err_init_proc;\n\n\tsctp_dbg_objcnt_init(net);\n\n\t/* Initialize the control inode/socket for handling OOTB packets.  */\n\tif ((status = sctp_ctl_sock_init(net))) {\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\t\tgoto err_ctl_sock_init;\n\t}\n\n\t/* Initialize the local address list. */\n\tINIT_LIST_HEAD(&net->sctp.local_addr_list);\n\tspin_lock_init(&net->sctp.local_addr_lock);\n\tsctp_get_local_addr_list(net);\n\n\t/* Initialize the address event list */\n\tINIT_LIST_HEAD(&net->sctp.addr_waitq);\n\tINIT_LIST_HEAD(&net->sctp.auto_asconf_splist);\n\tspin_lock_init(&net->sctp.addr_wq_lock);\n\tnet->sctp.addr_wq_timer.expires = 0;\n\tsetup_timer(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler,\n\t\t    (unsigned long)net);\n\n\treturn 0;\n\nerr_ctl_sock_init:\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\nerr_init_proc:\n\tcleanup_sctp_mibs(net);\nerr_init_mibs:\n\tsctp_sysctl_net_unregister(net);\nerr_sysctl_register:\n\treturn status;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1465,
    "line_new": 1476,
    "critical_vars": [
      "status"
    ],
    "function": "sctp_init",
    "filename": "linux/CVE-2015-5283/CVE-2015-5283_CWE-119_8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4_protocol.c.diff",
    "function_code": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\n\tstatus = register_pernet_subsys(&sctp_defaults_ops);\n\tif (status)\n\t\tgoto err_register_defaults;\n\n\tstatus = sctp_v4_protosw_init();\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&sctp_ctrlsock_ops);\n\tif (status)\n\t\tgoto err_register_ctrlsock;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\nerr_register_ctrlsock:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tunregister_pernet_subsys(&sctp_defaults_ops);\nerr_register_defaults:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1530,
    "line_new": 1546,
    "critical_vars": [
      "&sctp_ctrlsock_ops",
      "&sctp_net_ops"
    ],
    "function": "sctp_exit",
    "filename": "linux/CVE-2015-5283/CVE-2015-5283_CWE-119_8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4_protocol.c.diff",
    "function_code": "static __exit void sctp_exit(void)\n{\n\t/* BUG.  This should probably do something useful like clean\n\t * up all the remaining associations and all that memory.\n\t */\n\n\t/* Unregister with inet6/inet layers. */\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n\n\t/* Free protosw registrations */\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\tunregister_pernet_subsys(&sctp_defaults_ops);\n\n\t/* Unregister with socket layer. */\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 520,
    "critical_vars": [
      "uref->usage_index",
      "cmd",
      "uref_multi->num_values"
    ],
    "function": "hiddev_ioctl_usage",
    "filename": "linux/CVE-2016-5829/CVE-2016-5829_CWE-119_93a2001bdfd5376c3dc2158653034c20392d15c5_hiddev.c.diff",
    "function_code": "static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_usage_ref_multi *uref_multi = NULL;\n\tstruct hiddev_usage_ref *uref;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\n\turef_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\n\tif (!uref_multi)\n\t\treturn -ENOMEM;\n\turef = &uref_multi->uref;\n\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\tif (copy_from_user(uref_multi, user_arg,\n\t\t\t\t   sizeof(*uref_multi)))\n\t\t\tgoto fault;\n\t} else {\n\t\tif (copy_from_user(uref, user_arg, sizeof(*uref)))\n\t\t\tgoto fault;\n\t}\n\n\tswitch (cmd) {\n\tcase HIDIOCGUCODE:\n\t\trinfo.report_type = uref->report_type;\n\t\trinfo.report_id = uref->report_id;\n\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\tgoto inval;\n\n\t\tif (uref->field_index >= report->maxfield)\n\t\t\tgoto inval;\n\n\t\tfield = report->field[uref->field_index];\n\t\tif (uref->usage_index >= field->maxusage)\n\t\t\tgoto inval;\n\n\t\turef->usage_code = field->usage[uref->usage_index].hid;\n\n\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\tgoto fault;\n\n\t\tgoto goodreturn;\n\n\tdefault:\n\t\tif (cmd != HIDIOCGUSAGE &&\n\t\t    cmd != HIDIOCGUSAGES &&\n\t\t    uref->report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tgoto inval;\n\n\t\tif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\n\t\t\tfield = hiddev_lookup_usage(hid, uref);\n\t\t\tif (field == NULL)\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\trinfo.report_type = uref->report_type;\n\t\t\trinfo.report_id = uref->report_id;\n\t\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\t\tgoto inval;\n\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\n\t\t\telse if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t\t\t (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t\t\t  uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCGCOLLECTIONINDEX:\n\t\t\ti = field->usage[uref->usage_index].collection_index;\n\t\t\tkfree(uref_multi);\n\t\t\treturn i;\n\t\tcase HIDIOCGUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\turef_multi->values[i] =\n\t\t\t\t    field->value[uref->usage_index + i];\n\t\t\tif (copy_to_user(user_arg, uref_multi,\n\t\t\t\t\t sizeof(*uref_multi)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\tfield->value[uref->usage_index + i] =\n\t\t\t\t    uref_multi->values[i];\n\t\t\tgoto goodreturn;\n\t\t}\n\ngoodreturn:\n\t\tkfree(uref_multi);\n\t\treturn 0;\nfault:\n\t\tkfree(uref_multi);\n\t\treturn -EFAULT;\ninval:\n\t\tkfree(uref_multi);\n\t\treturn -EINVAL;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 521,
    "critical_vars": [
      "uref->usage_index",
      "cmd",
      "uref_multi->num_values"
    ],
    "function": "hiddev_ioctl_usage",
    "filename": "linux/CVE-2016-5829/CVE-2016-5829_CWE-119_93a2001bdfd5376c3dc2158653034c20392d15c5_hiddev.c.diff",
    "function_code": "static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_usage_ref_multi *uref_multi = NULL;\n\tstruct hiddev_usage_ref *uref;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\n\turef_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\n\tif (!uref_multi)\n\t\treturn -ENOMEM;\n\turef = &uref_multi->uref;\n\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\tif (copy_from_user(uref_multi, user_arg,\n\t\t\t\t   sizeof(*uref_multi)))\n\t\t\tgoto fault;\n\t} else {\n\t\tif (copy_from_user(uref, user_arg, sizeof(*uref)))\n\t\t\tgoto fault;\n\t}\n\n\tswitch (cmd) {\n\tcase HIDIOCGUCODE:\n\t\trinfo.report_type = uref->report_type;\n\t\trinfo.report_id = uref->report_id;\n\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\tgoto inval;\n\n\t\tif (uref->field_index >= report->maxfield)\n\t\t\tgoto inval;\n\n\t\tfield = report->field[uref->field_index];\n\t\tif (uref->usage_index >= field->maxusage)\n\t\t\tgoto inval;\n\n\t\turef->usage_code = field->usage[uref->usage_index].hid;\n\n\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\tgoto fault;\n\n\t\tgoto goodreturn;\n\n\tdefault:\n\t\tif (cmd != HIDIOCGUSAGE &&\n\t\t    cmd != HIDIOCGUSAGES &&\n\t\t    uref->report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tgoto inval;\n\n\t\tif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\n\t\t\tfield = hiddev_lookup_usage(hid, uref);\n\t\t\tif (field == NULL)\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\trinfo.report_type = uref->report_type;\n\t\t\trinfo.report_id = uref->report_id;\n\t\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\t\tgoto inval;\n\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tif ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t     uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\tgoto inval;\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCGCOLLECTIONINDEX:\n\t\t\ti = field->usage[uref->usage_index].collection_index;\n\t\t\tkfree(uref_multi);\n\t\t\treturn i;\n\t\tcase HIDIOCGUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\turef_multi->values[i] =\n\t\t\t\t    field->value[uref->usage_index + i];\n\t\t\tif (copy_to_user(user_arg, uref_multi,\n\t\t\t\t\t sizeof(*uref_multi)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\tfield->value[uref->usage_index + i] =\n\t\t\t\t    uref_multi->values[i];\n\t\t\tgoto goodreturn;\n\t\t}\n\ngoodreturn:\n\t\tkfree(uref_multi);\n\t\treturn 0;\nfault:\n\t\tkfree(uref_multi);\n\t\treturn -EFAULT;\ninval:\n\t\tkfree(uref_multi);\n\t\treturn -EINVAL;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 645,
    "critical_vars": [
      "*mem"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-6763/CVE-2013-6763_CWE-119_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 648,
    "critical_vars": [
      "vma->vm_ops"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-6763/CVE-2013-6763_CWE-119_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 133,
    "line_new": 133,
    "critical_vars": [
      "iter"
    ],
    "function": "netlbl_cipsov4_add_common",
    "filename": "linux/CVE-2007-6762/CVE-2007-6762_CWE-119_2a2f11c227bdf292b3a2900ad04139d301b56ac4_netlabel_cipso_v4.c.diff",
    "function_code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 137,
    "critical_vars": [
      "iter"
    ],
    "function": "netlbl_cipsov4_add_common",
    "filename": "linux/CVE-2007-6762/CVE-2007-6762_CWE-119_2a2f11c227bdf292b3a2900ad04139d301b56ac4_netlabel_cipso_v4.c.diff",
    "function_code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 911,
    "critical_vars": [
      "*hconf"
    ],
    "function": "gs_usb_probe",
    "filename": "linux/CVE-2017-8066/CVE-2017-8066_CWE-119_c919a3069c775c1c876bec55e00b2305d5125caa_gs_usb.c.diff",
    "function_code": "static int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\n\thconf->byte_order = 0x0000beef;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\n\tkfree(hconf);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n\tif (!dconf)\n\t\treturn -ENOMEM;\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     dconf,\n\t\t\t     sizeof(*dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(dconf);\n\t\treturn rc;\n\t}\n\n\ticount = dconf->icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\tkfree(dconf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(dconf);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tatomic_set(&dev->active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dconf);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\n\tkfree(dconf);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 912,
    "critical_vars": [
      ".byte_order"
    ],
    "function": "gs_usb_probe",
    "filename": "linux/CVE-2017-8066/CVE-2017-8066_CWE-119_c919a3069c775c1c876bec55e00b2305d5125caa_gs_usb.c.diff",
    "function_code": "static int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config hconf = {\n\t\t.byte_order = 0x0000beef,\n\t};\n\tstruct gs_device_config dconf;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     &hconf,\n\t\t\t     sizeof(hconf),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     &dconf,\n\t\t\t     sizeof(dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\ticount = dconf.icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tatomic_set(&dev->active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, &dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 109,
    "line_new": 109,
    "critical_vars": [
      "nfca_poll->nfcid1_len"
    ],
    "function": "*nci_extract_rf_params_nfca_passive_poll",
    "filename": "linux/CVE-2012-3364/CVE-2012-3364_CWE-119_67de956ff5dc1d4f321e16cfbd63f5be3b691b43_ntf.c.diff",
    "function_code": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 133,
    "line_new": 133,
    "critical_vars": [
      "nfcb_poll->sensb_res_len"
    ],
    "function": "*nci_extract_rf_params_nfcb_passive_poll",
    "filename": "linux/CVE-2012-3364/CVE-2012-3364_CWE-119_67de956ff5dc1d4f321e16cfbd63f5be3b691b43_ntf.c.diff",
    "function_code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 148,
    "line_new": 148,
    "critical_vars": [
      "nfcf_poll->sensf_res_len"
    ],
    "function": "*nci_extract_rf_params_nfcf_passive_poll",
    "filename": "linux/CVE-2012-3364/CVE-2012-3364_CWE-119_67de956ff5dc1d4f321e16cfbd63f5be3b691b43_ntf.c.diff",
    "function_code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 334,
    "line_new": 334,
    "critical_vars": [
      "nfca_poll->rats_res_len"
    ],
    "function": "nci_extract_activation_params_iso_dep",
    "filename": "linux/CVE-2012-3364/CVE-2012-3364_CWE-119_67de956ff5dc1d4f321e16cfbd63f5be3b691b43_ntf.c.diff",
    "function_code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = min_t(__u8, *data++, 20);\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = min_t(__u8, *data++, 50);\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\n\treturn NCI_STATUS_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1018,
    "critical_vars": [
      "fhdr"
    ],
    "function": "ip6_ufo_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1041,
    "critical_vars": [
      "err"
    ],
    "function": "ip6_ufo_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1230,
    "critical_vars": [
      "cork->length"
    ],
    "function": "ip6_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1221,
    "critical_vars": [
      "dontfrag",
      "sk->sk_protocol",
      "length"
    ],
    "function": "ip6_append_data",
    "filename": "linux/CVE-2013-4387/CVE-2013-4387_CWE-119_2811ebac2521ceac84f2bdae402455baa6a7fb47_ip6_output.c.diff",
    "function_code": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tif ((length > mtu) && dontfrag && (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t\t\t   sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tskb = skb_peek_tail(&sk->sk_write_queue);\n\tcork->length += length;\n\tif (((length > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1875,
    "critical_vars": [
      "err"
    ],
    "function": "fuse_do_ioctl",
    "filename": "linux/CVE-2010-4650/CVE-2010-4650_CWE-119_7572777eef78ebdee1ecb7c258c0ef94d35bad16_file.c.diff",
    "function_code": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = page_address(iov_page);\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1158,
    "line_new": 1158,
    "critical_vars": [
      "assoc"
    ],
    "function": "__driver_rfc4106_decrypt",
    "filename": "linux/CVE-2015-3331/CVE-2015-3331_CWE-119_ccfe8c3f7e52ae83155cb038753f4c75b774ca8a_aesni-intel_glue.c.diff",
    "function_code": "static int __driver_rfc4106_decrypt(struct aead_request *req)\n{\n\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\t__be32 counter = cpu_to_be32(1);\n\tint retval = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n\tu32 key_len = ctx->aes_key_expanded.key_length;\n\tvoid *aes_ctx = &(ctx->aes_key_expanded);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 iv_and_authTag[32+AESNI_ALIGN];\n\tu8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);\n\tu8 *authTag = iv + 16;\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk assoc_sg_walk;\n\tstruct scatter_walk dst_sg_walk;\n\tunsigned int i;\n\n\tif (unlikely((req->cryptlen < auth_tag_len) ||\n\t\t(req->assoclen != 8 && req->assoclen != 12)))\n\t\treturn -EINVAL;\n\tif (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))\n\t        return -EINVAL;\n\tif (unlikely(key_len != AES_KEYSIZE_128 &&\n\t             key_len != AES_KEYSIZE_192 &&\n\t             key_len != AES_KEYSIZE_256))\n\t        return -EINVAL;\n\n\t/* Assuming we are supporting rfc4106 64-bit extended */\n\t/* sequence numbers We need to have the AAD length */\n\t/* equal to 8 or 12 bytes */\n\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\t/* IV below built */\n\tfor (i = 0; i < 4; i++)\n\t\t*(iv+i) = ctx->nonce[i];\n\tfor (i = 0; i < 8; i++)\n\t\t*(iv+4+i) = req->iv[i];\n\t*((__be32 *)(iv+12)) = counter;\n\n\tif ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tscatterwalk_start(&assoc_sg_walk, req->assoc);\n\t\tsrc = scatterwalk_map(&src_sg_walk);\n\t\tassoc = scatterwalk_map(&assoc_sg_walk);\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk);\n\t\t}\n\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n\t\tsrc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n\t\tif (!src)\n\t\t\treturn -ENOMEM;\n\t\tassoc = (src + req->cryptlen);\n\t\tscatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n\t\tscatterwalk_map_and_copy(assoc, req->assoc, 0,\n\t\t\treq->assoclen, 0);\n\t\tdst = src;\n\t}\n\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\tctx->hash_subkey, assoc, (unsigned long)req->assoclen,\n\t\tauthTag, auth_tag_len);\n\n\t/* Compare generated tag with passed in tag. */\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst);\n\t\t\tscatterwalk_done(&dst_sg_walk, 0, 0);\n\t\t}\n\t\tscatterwalk_unmap(src);\n\t\tscatterwalk_unmap(assoc);\n\t\tscatterwalk_done(&src_sg_walk, 0, 0);\n\t\tscatterwalk_done(&assoc_sg_walk, 0, 0);\n\t} else {\n\t\tscatterwalk_map_and_copy(dst, req->dst, 0, tempCipherLen, 1);\n\t\tkfree(src);\n\t}\n\treturn retval;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 593,
    "critical_vars": [
      "same->dest_count"
    ],
    "function": "ioctl_file_dedupe_range",
    "filename": "linux/CVE-2016-6516/CVE-2016-6516_CWE-119_10eec60ce79187686e052092e5383c99b4420a20_ioctl.c.diff",
    "function_code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 159,
    "critical_vars": [
      "length"
    ],
    "function": "wdm_in_callback",
    "filename": "linux/CVE-2013-1860/CVE-2013-1860_CWE-119_c0f5ecee4e741667b2493c742b60b6218d40b3aa_cdc-wdm.c.diff",
    "function_code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 188,
    "critical_vars": [
      "desc->reslength"
    ],
    "function": "wdm_in_callback",
    "filename": "linux/CVE-2013-1860/CVE-2013-1860_CWE-119_c0f5ecee4e741667b2493c742b60b6218d40b3aa_cdc-wdm.c.diff",
    "function_code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1023,
    "critical_vars": [
      "&desc->flags"
    ],
    "function": "wdm_post_reset",
    "filename": "linux/CVE-2013-1860/CVE-2013-1860_CWE-119_c0f5ecee4e741667b2493c742b60b6218d40b3aa_cdc-wdm.c.diff",
    "function_code": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 158,
    "critical_vars": [
      "count"
    ],
    "function": "oz_cdev_write",
    "filename": "linux/CVE-2013-4513/CVE-2013-4513_CWE-119_c2c65cd2e14ada6de44cb527e7f1990bede24e15_ozcdev.c.diff",
    "function_code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 134,
    "critical_vars": [],
    "function": "flush_tmregs_to_thread",
    "filename": "linux/CVE-2018-1091/CVE-2018-1091_CWE-119_c1fa0768a8713b135848f78fd43ffc208d8ded70_ptrace.c.diff",
    "function_code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 348,
    "line_new": 348,
    "critical_vars": [
      "rsize"
    ],
    "function": "*lg_report_fixup",
    "filename": "linux/CVE-2014-3184/CVE-2014-3184_CWE-119_4ab25786c87eb20857bbb715c3ae34ec8fd6a214_hid-lg.c.diff",
    "function_code": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tstruct usb_device_descriptor *udesc;\n\t__u16 bcdDevice, rev_maj, rev_min;\n\n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 91 && rdesc[83] == 0x26 &&\n\t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n\t\trdesc[84] = rdesc[89] = 0x4d;\n\t\trdesc[85] = rdesc[90] = 0x10;\n\t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 51 &&\n\t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n\t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 503,
    "critical_vars": [
      "*args"
    ],
    "function": "apparmor_setprocattr",
    "filename": "linux/CVE-2016-6187/CVE-2016-6187_CWE-119_30a46a4647fd1df9cf52e43bf467f0d9265096ca_lsm.c.diff",
    "function_code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\n\tif (!error)\n\t\terror = size;\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 503,
    "critical_vars": [
      "*largs"
    ],
    "function": "apparmor_setprocattr",
    "filename": "linux/CVE-2016-6187/CVE-2016-6187_CWE-119_30a46a4647fd1df9cf52e43bf467f0d9265096ca_lsm.c.diff",
    "function_code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tgoto out;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1963,
    "critical_vars": [
      "vcpu->arch.time_offset",
      "pvclock_vcpu_time_info"
    ],
    "function": "kvm_set_msr_common",
    "filename": "linux/CVE-2013-1796/CVE-2013-1796_CWE-119_c300aa64ddf57d9c5d9c898a64b36877345dd4a9_x86.c.diff",
    "function_code": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn set_msr_mtrr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\tkvm_set_apic_base(vcpu, data);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\tu64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tkvmclock_reset(vcpu);\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\t/* ...but clean it before doing the actual write */\n\t\tvcpu->arch.time_offset = data & ~(PAGE_MASK | 1);\n\n\t\t/* Check that the address is 32-byte aligned. */\n\t\tif (vcpu->arch.time_offset &\n\t\t\t\t(sizeof(struct pvclock_vcpu_time_info) - 1))\n\t\t\tbreak;\n\n\t\tvcpu->arch.time_page =\n\t\t\t\tgfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);\n\n\t\tif (is_error_page(vcpu->arch.time_page))\n\t\t\tvcpu->arch.time_page = NULL;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\t\tpreempt_disable();\n\t\taccumulate_steal_time(vcpu);\n\t\tpreempt_enable();\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\t/* Performance counters are not protected by a CPUID bit,\n\t * so we should check all of them in the generic path for the sake of\n\t * cross vendor migration.\n\t * Writing a zero into the event select MSRs disables them,\n\t * which we perfectly emulate ;-). Any other value should be at least\n\t * reported, some guests depend on them.\n\t */\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\t\tif (data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\t/* at least RHEL 4 unconditionally writes to the perfctr registers,\n\t * so we ignore writes to make it happy.\n\t */\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\t\tpr = true;\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr, data);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = set_msr_hyperv_pw(vcpu, msr, data);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn set_msr_hyperv(vcpu, msr, data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr, data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 431,
    "critical_vars": [
      "*sb"
    ],
    "function": "gfs2_bmap_alloc",
    "filename": "linux/CVE-2011-4098/CVE-2011-4098_CWE-119_64dd153c83743af81f20924c6343652d731eeecb_bmap.c.diff",
    "function_code": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 810,
    "critical_vars": [
      "curr"
    ],
    "function": "fallocate_chunk",
    "filename": "linux/CVE-2011-4098/CVE-2011-4098_CWE-119_64dd153c83743af81f20924c6343652d731eeecb_file.c.diff",
    "function_code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\n\tmark_inode_dirty(inode);\n\n\tbrelse(dibh);\n\nout:\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 693,
    "critical_vars": [
      "len"
    ],
    "function": "fallocate_chunk",
    "filename": "linux/CVE-2011-4098/CVE-2011-4098_CWE-119_64dd153c83743af81f20924c6343652d731eeecb_file.c.diff",
    "function_code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))\n\t\ti_size_write(inode, offset + len);\n\n\tmark_inode_dirty(inode);\n\nout:\n\tbrelse(dibh);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 757,
    "critical_vars": [
      "max_chunk_size"
    ],
    "function": "gfs2_fallocate",
    "filename": "linux/CVE-2011-4098/CVE-2011-4098_CWE-119_64dd153c83743af81f20924c6343652d731eeecb_file.c.diff",
    "function_code": "static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t   loff_t len)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tstruct gfs2_alloc *al;\n\tint error;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\t/* We only support the FALLOC_FL_KEEP_SIZE mode */\n\tif (mode & ~FALLOC_FL_KEEP_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\n\terror = gfs2_glock_nq(&ip->i_gh);\n\tif (unlikely(error))\n\t\tgoto out_uninit;\n\n\tif (!gfs2_write_alloc_required(ip, offset, len))\n\t\tgoto out_unlock;\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tal = gfs2_alloc_get(ip);\n\t\tif (!al) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\tgoto out_alloc_put;\n\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tal->al_requested = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n\t\tal->al_requested = data_blocks + ind_blocks;\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t\tgfs2_alloc_put(ip);\n\t}\n\tgoto out_unlock;\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\nout_alloc_put:\n\tgfs2_alloc_put(ip);\nout_unlock:\n\tgfs2_glock_dq(&ip->i_gh);\nout_uninit:\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3409,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_trigger_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3414,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_trigger_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3575,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_start_sched_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3582,
    "critical_vars": [
      "request->ssids[i].ssid_len"
    ],
    "function": "nl80211_start_sched_scan",
    "filename": "linux/CVE-2011-2517/CVE-2011-2517_CWE-119_208c72f4fe44fe09577e7975ba0e7fa0278f3d03_nl80211.c.diff",
    "function_code": "\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1075,
    "critical_vars": [
      "fork_nctx"
    ],
    "function": "userfaultfd_ctx_read",
    "filename": "linux/CVE-2017-15126/CVE-2017-15126_CWE-119_384632e67e0829deb8015ee6ad916b180049d252_userfaultfd.c.diff",
    "function_code": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1096,
    "critical_vars": [
      "&ctx->event_wqh.lock"
    ],
    "function": "userfaultfd_ctx_read",
    "filename": "linux/CVE-2017-15126/CVE-2017-15126_CWE-119_384632e67e0829deb8015ee6ad916b180049d252_userfaultfd.c.diff",
    "function_code": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\n\t\tif (!ret) {\n\t\t\tspin_lock(&ctx->event_wqh.lock);\n\t\t\tif (!list_empty(&fork_event)) {\n\t\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t\t       wq.entry);\n\t\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\t}\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 232,
    "critical_vars": [
      "s->target_offset"
    ],
    "function": "get_chainname_rulenum",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 233,
    "critical_vars": [
      "s"
    ],
    "function": "get_chainname_rulenum",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 479,
    "critical_vars": [
      "e->target_offset"
    ],
    "function": "mark_source_chains",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||\n\t\t\t    visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 479,
    "critical_vars": [
      "e"
    ],
    "function": "mark_source_chains",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 718,
    "critical_vars": [
      "&e->ip"
    ],
    "function": "check_underflow",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 717,
    "critical_vars": [
      "e"
    ],
    "function": "check_underflow",
    "filename": "linux/CVE-2016-3134/CVE-2016-3134_CWE-119_54d83fc74aa9ec72794373cb47432c5f7fb1a309_ip_tables.c.diff",
    "function_code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1713,
    "critical_vars": [
      "hdr->sadb_msg_reserved"
    ],
    "function": "key_notify_sa_flush",
    "filename": "linux/CVE-2013-2234/CVE-2013-2234_CWE-119_a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887_af_key.c.diff",
    "function_code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 718,
    "line_new": 718,
    "critical_vars": [
      "sk->sk_sndbuf"
    ],
    "function": "sock_setsockopt",
    "filename": "linux/CVE-2016-9793/CVE-2016-9793_CWE-119_b98b0bc8c431e3ceb4b26b0dfc8db509518fb290_sock.c.diff",
    "function_code": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 159,
    "critical_vars": [
      "cmd->msg_len"
    ],
    "function": "ttusbdecfe_dvbs_diseqc_send_master_cmd",
    "filename": "linux/CVE-2014-8884/CVE-2014-8884_CWE-119_f2e323ec96077642d397bb1c355def536d489d16_ttusbdecfe.c.diff",
    "function_code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 580,
    "critical_vars": [
      "val"
    ],
    "function": "sock_setsockopt",
    "filename": "linux/CVE-2012-6704/CVE-2012-6704_CWE-119_82981930125abfd39d7c8378a9cfdf5e1be2002b_sock.c.diff",
    "function_code": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 978,
    "line_new": 966,
    "critical_vars": [
      "v.val"
    ],
    "function": "sock_getsockopt",
    "filename": "linux/CVE-2012-6704/CVE-2012-6704_CWE-119_82981930125abfd39d7c8378a9cfdf5e1be2002b_sock.c.diff",
    "function_code": "int sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tunion {\n\t\tint val;\n\t\tstruct linger ling;\n\t\tstruct timeval tm;\n\t} v;\n\n\tint lv = sizeof(int);\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tmemset(&v, 0, sizeof(v));\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tv.val = sock_flag(sk, SOCK_DBG);\n\t\tbreak;\n\n\tcase SO_DONTROUTE:\n\t\tv.val = sock_flag(sk, SOCK_LOCALROUTE);\n\t\tbreak;\n\n\tcase SO_BROADCAST:\n\t\tv.val = !!sock_flag(sk, SOCK_BROADCAST);\n\t\tbreak;\n\n\tcase SO_SNDBUF:\n\t\tv.val = sk->sk_sndbuf;\n\t\tbreak;\n\n\tcase SO_RCVBUF:\n\t\tv.val = sk->sk_rcvbuf;\n\t\tbreak;\n\n\tcase SO_REUSEADDR:\n\t\tv.val = sk->sk_reuse;\n\t\tbreak;\n\n\tcase SO_KEEPALIVE:\n\t\tv.val = !!sock_flag(sk, SOCK_KEEPOPEN);\n\t\tbreak;\n\n\tcase SO_TYPE:\n\t\tv.val = sk->sk_type;\n\t\tbreak;\n\n\tcase SO_PROTOCOL:\n\t\tv.val = sk->sk_protocol;\n\t\tbreak;\n\n\tcase SO_DOMAIN:\n\t\tv.val = sk->sk_family;\n\t\tbreak;\n\n\tcase SO_ERROR:\n\t\tv.val = -sock_error(sk);\n\t\tif (v.val == 0)\n\t\t\tv.val = xchg(&sk->sk_err_soft, 0);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tv.val = !!sock_flag(sk, SOCK_URGINLINE);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tv.val = sk->sk_no_check;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tv.val = sk->sk_priority;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tlv\t\t= sizeof(v.ling);\n\t\tv.ling.l_onoff\t= !!sock_flag(sk, SOCK_LINGER);\n\t\tv.ling.l_linger\t= sk->sk_lingertime / HZ;\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"getsockopt\");\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMP) &&\n\t\t\t\t!sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPNS:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tv.val = 0;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_TX_HARDWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_TX_SOFTWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_RX_HARDWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_RX_SOFTWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_SOFTWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_SYS_HARDWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_RAW_HARDWARE;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tlv = sizeof(struct timeval);\n\t\tif (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tlv = sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = !!test_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = !!test_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tv.val = !!sock_flag(sk, SOCK_RXQ_OVFL);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tv.val = !!sock_flag(sk, SOCK_WIFI_STATUS);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (!sock->ops->set_peek_off)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tv.val = sk->sk_peek_off;\n\t\tbreak;\n\tcase SO_NOFCS:\n\t\tv.val = !!sock_flag(sk, SOCK_NOFCS);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 744,
    "critical_vars": [
      "size"
    ],
    "function": "usbip_recv_xbuff",
    "filename": "linux/CVE-2016-3955/CVE-2016-3955_CWE-119_b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb_usbip_common.c.diff",
    "function_code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\n\tif (ud->side == USBIP_STUB) {\n\t\t/* the direction of urb must be OUT. */\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\t/* the direction of urb must be IN. */\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->actual_length;\n\t}\n\n\t/* no need to recv xbuff */\n\tif (!(size > 0))\n\t\treturn 0;\n\n\tif (size > urb->transfer_buffer_length) {\n\t\t/* should not happen, probably malicious packet */\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 120,
    "critical_vars": [
      "*buffer"
    ],
    "function": "atusb_read_reg",
    "filename": "linux/CVE-2017-5548/CVE-2017-5548_CWE-119_05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655_atusb.c.diff",
    "function_code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 125,
    "critical_vars": [
      "&value"
    ],
    "function": "atusb_read_reg",
    "filename": "linux/CVE-2017-5548/CVE-2017-5548_CWE-119_05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655_atusb.c.diff",
    "function_code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 651,
    "critical_vars": [
      "buffer"
    ],
    "function": "atusb_get_and_show_revision",
    "filename": "linux/CVE-2017-5548/CVE-2017-5548_CWE-119_05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655_atusb.c.diff",
    "function_code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 640,
    "critical_vars": [
      "build"
    ],
    "function": "atusb_get_and_show_revision",
    "filename": "linux/CVE-2017-5548/CVE-2017-5548_CWE-119_05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655_atusb.c.diff",
    "function_code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 673,
    "critical_vars": [
      "build"
    ],
    "function": "atusb_get_and_show_build",
    "filename": "linux/CVE-2017-5548/CVE-2017-5548_CWE-119_05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655_atusb.c.diff",
    "function_code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar *build;\n\tint ret;\n\n\tbuild = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);\n\tif (!build)\n\t\treturn -ENOMEM;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\tkfree(build);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2072,
    "critical_vars": [
      "elength",
      "buflen"
    ],
    "function": "cdc_parse_cdc_header",
    "filename": "linux/CVE-2017-16534/CVE-2017-16534_CWE-119_2e1c42391ff2556387b3cb6308b24f6f65619feb_message.c.diff",
    "function_code": "int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\t/* duplicates are ignored */\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\n\t/* duplicates are not tolerated */\n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\n\tunsigned int elength;\n\tint cnt = 0;\n\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif ((buflen < elength) || (elength < 3)) {\n\t\t\tdev_err(&intf->dev, \"invalid descriptor buffer length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE: /* we've found it */\n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc *))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc *))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * there are LOTS more CDC descriptors that\n\t\t\t * could legitimately be found here.\n\t\t\t */\n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 689,
    "critical_vars": [
      "pLtv->u.u16[0]",
      "&pLtv->u.u8[2]",
      "lp->StationName"
    ],
    "function": "wvlan_uil_put_info",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 690,
    "critical_vars": [
      "len"
    ],
    "function": "wvlan_uil_put_info",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1788,
    "critical_vars": [
      "len"
    ],
    "function": "wvlan_set_station_nickname",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tsize_t len;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\n\tstrlcpy(lp->StationName, extra, len);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1797,
    "critical_vars": [
      "extra",
      "wrqu->data.length",
      "lp->StationName"
    ],
    "function": "wvlan_set_station_nickname",
    "filename": "linux/CVE-2013-4514/CVE-2013-4514_CWE-119_b5e2f339865fb443107e5b10603e53bbc92dc054_wl_priv.c.diff",
    "function_code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 241,
    "critical_vars": [
      "dj_report->device_index"
    ],
    "function": "logi_dj_recv_add_djhid_device",
    "filename": "linux/CVE-2014-3182/CVE-2014-3182_CWE-119_ad3e14d7c5268c2e24477c6ef54bbdf88add5d36_hid-logitech-dj.c.diff",
    "function_code": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 1610,
    "critical_vars": [
      "resp"
    ],
    "function": "create_qp_common",
    "filename": "linux/CVE-2018-20855/CVE-2018-20855_CWE-119_0625b4ba1a5d4703c7fb01c497bd6c156908af00_qp.c.diff",
    "function_code": "static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_create_qp_resp resp;\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&qp->mutex);\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr->create_flags &\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n\t\t    (init_attr->qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd && pd->uobject) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\t\t&ucmd, udata->inlen, &uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\n\t\tqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp->tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr->qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev->mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp->underlay_qpn = init_attr->source_qpn;\n\t\t}\n\t} else {\n\t\tqp->wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\n\t\t\t  qp, (pd && pd->uobject) ? &ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd->uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, \"invalid rq params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count > max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr->create_flags &\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n\t\t\t\t\t     &resp, &inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp->flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"create qp failed\\n\");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1610,
    "critical_vars": [
      "resp"
    ],
    "function": "create_qp_common",
    "filename": "linux/CVE-2018-20855/CVE-2018-20855_CWE-119_0625b4ba1a5d4703c7fb01c497bd6c156908af00_qp.c.diff",
    "function_code": "static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_create_qp_resp resp = {};\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&qp->mutex);\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr->create_flags &\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n\t\t    (init_attr->qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd && pd->uobject) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\t\t&ucmd, udata->inlen, &uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\n\t\tqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp->tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr->qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev->mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp->underlay_qpn = init_attr->source_qpn;\n\t\t}\n\t} else {\n\t\tqp->wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\n\t\t\t  qp, (pd && pd->uobject) ? &ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd->uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, \"invalid rq params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count > max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr->create_flags &\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n\t\t\t\t\t     &resp, &inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp->flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"create qp failed\\n\");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 515,
    "line_new": 515,
    "critical_vars": [
      "*outlen"
    ],
    "function": "xlate_to_uni",
    "filename": "linux/CVE-2013-1773/CVE-2013-1773_CWE-119_0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd_namei_vfat.c.diff",
    "function_code": "xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tif (nls) {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     *outlen += 1)\n\t\t\t{\n\t\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\t\tif (i > len - 5)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tec = 0;\n\t\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\t\tnc = ip[k];\n\t\t\t\t\t\tec <<= 4;\n\t\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t\t*op++ = ec >> 8;\n\t\t\t\t\tip += 5;\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t\tif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tip += charlen;\n\t\t\t\t\ti += charlen;\n\t\t\t\t\top += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t} else {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     i++, *outlen += 1)\n\t\t\t{\n\t\t\t\t*op++ = *ip++;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t}\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 123,
    "critical_vars": [
      "&unix_gc_lock"
    ],
    "function": "unix_inflight",
    "filename": "linux/CVE-2013-4312/CVE-2013-4312_CWE-119_712f4aad406bb1ed67f3f98d04c044191f0ff593_garbage.c.diff",
    "function_code": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tfp->f_cred->user->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 126,
    "critical_vars": [
      "&unix_gc_lock"
    ],
    "function": "unix_inflight",
    "filename": "linux/CVE-2013-4312/CVE-2013-4312_CWE-119_712f4aad406bb1ed67f3f98d04c044191f0ff593_garbage.c.diff",
    "function_code": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1539,
    "critical_vars": [
      "current"
    ],
    "function": "unix_attach_fds",
    "filename": "linux/CVE-2013-4312/CVE-2013-4312_CWE-119_712f4aad406bb1ed67f3f98d04c044191f0ff593_af_unix.c.diff",
    "function_code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t/*\n\t * Need to duplicate file references for the sake of garbage\n\t * collection.  Otherwise a socket in the fps might become a\n\t * candidate for GC while the skb is not yet queued.\n\t */\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n\treturn max_level;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1545,
    "critical_vars": [
      "unix_sock_count"
    ],
    "function": "unix_attach_fds",
    "filename": "linux/CVE-2013-4312/CVE-2013-4312_CWE-119_712f4aad406bb1ed67f3f98d04c044191f0ff593_af_unix.c.diff",
    "function_code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t/*\n\t * Need to duplicate file references for the sake of garbage\n\t * collection.  Otherwise a socket in the fps might become a\n\t * candidate for GC while the skb is not yet queued.\n\t */\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tif (unix_sock_count) {\n\t\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\t\tunix_inflight(scm->fp->fp[i]);\n\t}\n\treturn max_level;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1234,
    "critical_vars": [
      "base"
    ],
    "function": "xdr_set_page_base",
    "filename": "linux/CVE-2021-38201/CVE-2021-38201_CWE-119_6d1c0f3d28f98ea2736128ed3e46821496dc3a8c_xdr.c.diff",
    "function_code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 101,
    "critical_vars": [
      "max_length"
    ],
    "function": "ieee80211_radiotap_iterator_init",
    "filename": "linux/CVE-2013-7027/CVE-2013-7027_CWE-119_f5563318ff1bde15b10e736e97ffce13be08bc1a_radiotap.c.diff",
    "function_code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\t/* check the radiotap header can actually be present */\n\tif (max_length < sizeof(struct ieee80211_radiotap_header))\n\t\treturn -EINVAL;\n\n\t/* Linux only supports version 0 radiotap format */\n\tif (radiotap_header->it_version)\n\t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n\t\t\t */\n\n\t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader +\n\t\t\t    sizeof(uint32_t) >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 761,
    "critical_vars": [
      "key",
      "extra_response->key"
    ],
    "function": "iscsi_add_notunderstood_response",
    "filename": "linux/CVE-2013-2850/CVE-2013-2850_CWE-119_cea4dcfdad926a27a18e188720efe0f2c9403456_iscsi_target_parameters.c.diff",
    "function_code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 761,
    "critical_vars": [
      "key",
      "extra_response->key"
    ],
    "function": "iscsi_add_notunderstood_response",
    "filename": "linux/CVE-2013-2850/CVE-2013-2850_CWE-119_cea4dcfdad926a27a18e188720efe0f2c9403456_iscsi_target_parameters.c.diff",
    "function_code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1632,
    "critical_vars": [
      "*tmpptr"
    ],
    "function": "iscsi_decode_text_input",
    "filename": "linux/CVE-2013-2850/CVE-2013-2850_CWE-119_cea4dcfdad926a27a18e188720efe0f2c9403456_iscsi_target_parameters.c.diff",
    "function_code": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 305,
    "critical_vars": [
      "hdr"
    ],
    "function": "nfssvc_decode_writeargs",
    "filename": "linux/CVE-2017-7895/CVE-2017-7895_CWE-119_13bf9fbff0e5e099e2b6f003a0ab8ae145436309_nfsxdr.c.diff",
    "function_code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 4530,
    "critical_vars": [
      "ssid_ie->len"
    ],
    "function": "brcmf_cfg80211_start_ap",
    "filename": "linux/CVE-2016-8658/CVE-2016-8658_CWE-119_ded89912156b1a47d940a0c954c43afbabd0c42c_cfg80211.c.diff",
    "function_code": "brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\tstruct cfg80211_ap_settings *settings)\n{\n\ts32 ie_offset;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tconst struct brcmf_tlv *ssid_ie;\n\tconst struct brcmf_tlv *country_ie;\n\tstruct brcmf_ssid_le ssid_le;\n\ts32 err = -EPERM;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tstruct brcmf_join_params join_params;\n\tenum nl80211_iftype dev_role;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tu16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);\n\tbool mbss;\n\tint is_11d;\n\n\tbrcmf_dbg(TRACE, \"ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\\n\",\n\t\t  settings->chandef.chan->hw_value,\n\t\t  settings->chandef.center_freq1, settings->chandef.width,\n\t\t  settings->beacon_interval, settings->dtim_period);\n\tbrcmf_dbg(TRACE, \"ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\\n\",\n\t\t  settings->ssid, settings->ssid_len, settings->auth_type,\n\t\t  settings->inactivity_timeout);\n\tdev_role = ifp->vif->wdev.iftype;\n\tmbss = ifp->vif->mbss;\n\n\t/* store current 11d setting */\n\tbrcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d);\n\tcountry_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t      settings->beacon.tail_len,\n\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n\n\tif (!mbss) {\n\t\tbrcmf_set_mpc(ifp, 0);\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\t}\n\n\t/* find the RSN_IE */\n\trsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len, WLAN_EID_RSN);\n\n\t/* find the WPA_IE */\n\twpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len);\n\n\tif ((wpa_ie != NULL || rsn_ie != NULL)) {\n\t\tbrcmf_dbg(TRACE, \"WPA(2) IE is found\\n\");\n\t\tif (wpa_ie != NULL) {\n\t\t\t/* WPA IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, wpa_ie, false);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tstruct brcmf_vs_tlv *tmp_ie;\n\n\t\t\ttmp_ie = (struct brcmf_vs_tlv *)rsn_ie;\n\n\t\t\t/* RSN IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, tmp_ie, true);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"No WPA(2) IEs found\\n\");\n\t\tbrcmf_configure_opensecurity(ifp);\n\t}\n\n\tbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\n\n\t/* Parameters shared by all radio interfaces */\n\tif (!mbss) {\n\t\tif (is_11d != ifp->vif->is_11d) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t\t\t    is_11d);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Regulatory Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->beacon_interval) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\n\t\t\t\t\t\t    settings->beacon_interval);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Beacon Interval Set Error, %d\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->dtim_period) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\n\t\t\t\t\t\t    settings->dtim_period);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"DTIM Interval Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif ((dev_role == NL80211_IFTYPE_AP) &&\n\t\t    ((ifp->ifidx == 0) ||\n\t\t     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 0);\n\t\t}\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET INFRA error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (WARN_ON(is_11d != ifp->vif->is_11d)) {\n\t\t/* Multiple-BSS should use same 11d configuration */\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Interface specific setup */\n\tif (dev_role == NL80211_IFTYPE_AP) {\n\t\tif ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 1);\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!mbss) {\n\t\t\t/* Firmware 10.x requires setting channel after enabling\n\t\t\t * AP and before bringing interface up.\n\t\t\t */\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t\t  chanspec, err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"BRCMF_C_UP error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\t/* On DOWN the firmware removes the WEP keys, reconfigure\n\t\t * them if they were set.\n\t\t */\n\t\tbrcmf_cfg80211_reconfigure_wep(ifp);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\t/* join parameters starts with ssid */\n\t\tmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\n\t\t/* create softap */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (settings->hidden_ssid) {\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"closednet\", 1);\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"closednet error (%d)\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"AP mode configuration complete\\n\");\n\t} else if (dev_role == NL80211_IFTYPE_P2P_GO) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t  chanspec, err);\n\t\t\tgoto exit;\n\t\t}\n\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"ssid\", &ssid_le,\n\t\t\t\t\t\tsizeof(ssid_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(1);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"GO mode configuration complete\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, true);\n\nexit:\n\tif ((err) && (!mbss)) {\n\t\tbrcmf_set_mpc(ifp, 1);\n\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t}\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 4937,
    "critical_vars": [
      "len"
    ],
    "function": "brcmf_cfg80211_mgmt_tx",
    "filename": "linux/CVE-2017-7541/CVE-2017-7541_CWE-119_8f44c9a41386729fea410e688959ddaa9d51be7c_cfg80211.c.diff",
    "function_code": "brcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t       struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct ieee80211_channel *chan = params->chan;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\ts32 ie_offset;\n\ts32 ie_len;\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_fil_af_params_le *af_params;\n\tbool ack;\n\ts32 chan_nr;\n\tu32 freq;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t*cookie = 0;\n\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control)) {\n\t\tbrcmf_err(\"Driver only allows MGMT packet type\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\t/* Right now the only reason to get a probe response */\n\t\t/* is for p2p listen response or for p2p GO from     */\n\t\t/* wpa_supplicant. Unfortunately the probe is send   */\n\t\t/* on primary ndev, while dongle wants it on the p2p */\n\t\t/* vif. Since this is only reason for a probe        */\n\t\t/* response to be sent, the vif is taken from cfg.   */\n\t\t/* If ever desired to send proberesp for non p2p     */\n\t\t/* response then data should be checked for          */\n\t\t/* \"DIRECT-\". Note in future supplicant will take    */\n\t\t/* dedicated p2p wdev to do this and then this 'hack'*/\n\t\t/* is not needed anymore.                            */\n\t\tie_offset =  DOT11_MGMT_HDR_LEN +\n\t\t\t     DOT11_BCN_PRB_FIXED_LEN;\n\t\tie_len = len - ie_offset;\n\t\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)\n\t\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\t\terr = brcmf_vif_set_mgmt_ie(vif,\n\t\t\t\t\t    BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t\t    &buf[ie_offset],\n\t\t\t\t\t    ie_len);\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\n\t\t\t\t\tGFP_KERNEL);\n\t} else if (ieee80211_is_action(mgmt->frame_control)) {\n\t\tif (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {\n\t\t\tbrcmf_err(\"invalid action frame length\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\taf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);\n\t\tif (af_params == NULL) {\n\t\t\tbrcmf_err(\"unable to allocate frame\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\taction_frame = &af_params->action_frame;\n\t\t/* Add the packet Id */\n\t\taction_frame->packet_id = cpu_to_le32(*cookie);\n\t\t/* Add BSSID */\n\t\tmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);\n\t\tmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);\n\t\t/* Add the length exepted for 802.11 header  */\n\t\taction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);\n\t\t/* Add the channel. Use the one specified as parameter if any or\n\t\t * the current one (got from the firmware) otherwise\n\t\t */\n\t\tif (chan)\n\t\t\tfreq = chan->center_freq;\n\t\telse\n\t\t\tbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,\n\t\t\t\t\t      &freq);\n\t\tchan_nr = ieee80211_frequency_to_channel(freq);\n\t\taf_params->channel = cpu_to_le32(chan_nr);\n\n\t\tmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],\n\t\t       le16_to_cpu(action_frame->len));\n\n\t\tbrcmf_dbg(TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\",\n\t\t\t  *cookie, le16_to_cpu(action_frame->len), freq);\n\n\t\tack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),\n\t\t\t\t\t\t  af_params);\n\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,\n\t\t\t\t\tGFP_KERNEL);\n\t\tkfree(af_params);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control);\n\t\tbrcmf_dbg_hex_dump(true, buf, len, \"payload, len=%zu\\n\", len);\n\t}\n\nexit:\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 14607,
    "critical_vars": [
      "tp->fw_ver",
      "len",
      "&vpd_data[j]"
    ],
    "function": "tg3_read_vpd",
    "filename": "linux/CVE-2013-1929/CVE-2013-1929_CWE-119_715230a44310a8cf66fbfb5a46f9a62a9b2de424_tg3.c.diff",
    "function_code": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end)\n\t\t\tgoto partno;\n\n\t\tmemcpy(tp->fw_ver, &vpd_data[j], len);\n\t\tstrncat(tp->fw_ver, \" bc \", vpdlen - len - 1);\n\t}\n\npartno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 14607,
    "critical_vars": [
      "len"
    ],
    "function": "tg3_read_vpd",
    "filename": "linux/CVE-2013-1929/CVE-2013-1929_CWE-119_715230a44310a8cf66fbfb5a46f9a62a9b2de424_tg3.c.diff",
    "function_code": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end)\n\t\t\tgoto partno;\n\n\t\tif (len >= sizeof(tp->fw_ver))\n\t\t\tlen = sizeof(tp->fw_ver) - 1;\n\t\tmemset(tp->fw_ver, 0, sizeof(tp->fw_ver));\n\t\tsnprintf(tp->fw_ver, sizeof(tp->fw_ver), \"%.*s bc \", len,\n\t\t\t &vpd_data[j]);\n\t}\n\npartno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 560,
    "line_new": 560,
    "critical_vars": [
      "count"
    ],
    "function": "logi_dj_ll_raw_request",
    "filename": "linux/CVE-2014-3183/CVE-2014-3183_CWE-119_51217e69697fba92a06e07e16f55c9a52d8e8945_hid-logitech-dj.c.diff",
    "function_code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count > DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 471,
    "critical_vars": [
      "ret"
    ],
    "function": "GetCode_",
    "filename": "visit_repo_url/CVE-2014-9709/CVE-2014-9709_CWE-119_47eb44b2e90ca88a08dca9f9a1aa9041e9587f43_gd_gif_in.c.diff",
    "function_code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t\t/* Oh well */\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t}\n\n\tscd->curbit += code_size;\n\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 473,
    "critical_vars": [
      "i"
    ],
    "function": "GetCode_",
    "filename": "visit_repo_url/CVE-2014-9709/CVE-2014-9709_CWE-119_47eb44b2e90ca88a08dca9f9a1aa9041e9587f43_gd_gif_in.c.diff",
    "function_code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t\t/* Oh well */\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tif (i < CSD_BUF_SIZE * 8) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tscd->curbit += code_size;\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 485,
    "critical_vars": [
      "buf"
    ],
    "function": "read_attribute",
    "filename": "visit_repo_url/CVE-2017-5337/CVE-2017-5337_CWE-119_94fcf1645ea17223237aaf8d19132e004afddc1a_read-packet.c.diff",
    "function_code": "read_attribute(cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr,\n\t       int name_size)\n{\n\tconst byte *p;\n\tbyte *buf;\n\tsize_t len, nread;\n\tcdk_error_t rc;\n\n\tif (!inp || !attr || !pktlen)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_attribute: %d octets\\n\",\n\t\t\t\t  (int) pktlen);\n\n\t_gnutls_str_cpy(attr->name, name_size, ATTRIBUTE);\n\tattr->len = MIN(name_size, sizeof(ATTRIBUTE) - 1);\n\n\tbuf = cdk_calloc(1, pktlen);\n\tif (!buf)\n\t\treturn CDK_Out_Of_Core;\n\trc = stream_read(inp, buf, pktlen, &nread);\n\tif (rc) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp = buf;\n\tlen = *p++;\n\tpktlen--;\n\tif (len == 255) {\n\t\tlen = _cdk_buftou32(p);\n\t\tp += 4;\n\t\tpktlen -= 4;\n\t} else if (len >= 192) {\n\t\tif (pktlen < 2) {\n\t\t\tcdk_free(buf);\n\t\t\treturn CDK_Inv_Packet;\n\t\t}\n\t\tlen = ((len - 192) << 8) + *p + 192;\n\t\tp++;\n\t\tpktlen--;\n\t}\n\n\tif (*p != 1) {\t\t/* Currently only 1, meaning an image, is defined. */\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp++;\n\tlen--;\n\n\tif (len >= pktlen) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tattr->attrib_img = cdk_calloc(1, len);\n\tif (!attr->attrib_img) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Out_Of_Core;\n\t}\n\tattr->attrib_len = len;\n\tmemcpy(attr->attrib_img, p, len);\n\tcdk_free(buf);\n\treturn rc;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 486,
    "critical_vars": [
      "rc"
    ],
    "function": "read_attribute",
    "filename": "visit_repo_url/CVE-2017-5337/CVE-2017-5337_CWE-119_94fcf1645ea17223237aaf8d19132e004afddc1a_read-packet.c.diff",
    "function_code": "read_attribute(cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr,\n\t       int name_size)\n{\n\tconst byte *p;\n\tbyte *buf;\n\tsize_t len, nread;\n\tcdk_error_t rc;\n\n\tif (!inp || !attr || !pktlen)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_attribute: %d octets\\n\",\n\t\t\t\t  (int) pktlen);\n\n\t_gnutls_str_cpy(attr->name, name_size, ATTRIBUTE);\n\tattr->len = MIN(name_size, sizeof(ATTRIBUTE) - 1);\n\n\tbuf = cdk_calloc(1, pktlen);\n\tif (!buf)\n\t\treturn CDK_Out_Of_Core;\n\trc = stream_read(inp, buf, pktlen, &nread);\n\tif (rc) {\n\t\tgnutls_assert();\n\t\trc = CDK_Inv_Packet;\n\t\tgoto error;\n\t}\n\n\tp = buf;\n\tlen = *p++;\n\tpktlen--;\n\n\tif (len == 255) {\n\t\tif (pktlen < 4) {\n\t\t\tgnutls_assert();\n\t\t\trc = CDK_Inv_Packet;\n\t\t\tgoto error;\n\t\t}\n\n\t\tlen = _cdk_buftou32(p);\n\t\tp += 4;\n\t\tpktlen -= 4;\n\t} else if (len >= 192) {\n\t\tif (pktlen < 2) {\n\t\t\tgnutls_assert();\n\t\t\trc = CDK_Inv_Packet;\n\t\t\tgoto error;\n\t\t}\n\n\t\tlen = ((len - 192) << 8) + *p + 192;\n\t\tp++;\n\t\tpktlen--;\n\t}\n\n\tif (!len || *p != 1) {\t\t/* Currently only 1, meaning an image, is defined. */\n\t\trc = CDK_Inv_Packet;\n\t\tgoto error;\n\t}\n\n\tp++;\n\tlen--;\n\n\tif (len >= pktlen) {\n\t\trc = CDK_Inv_Packet;\n\t\tgoto error;\n\t}\n\n\tattr->attrib_img = cdk_calloc(1, len);\n\tif (!attr->attrib_img) {\n\t\trc = CDK_Out_Of_Core;\n\t\tgoto error;\n\t}\n\n\tattr->attrib_len = len;\n\tmemcpy(attr->attrib_img, p, len);\n\tcdk_free(buf);\n\treturn rc;\n\n error:\n\tcdk_free(buf);\n\treturn rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 521,
    "critical_vars": [
      "rc"
    ],
    "function": "cdk_pk_get_keyid",
    "filename": "visit_repo_url/CVE-2017-5336/CVE-2017-5336_CWE-119_5140422e0d7319a8e2fe07f02cbcafc4d6538732_pubkey.c.diff",
    "function_code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tint rc;\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\trc = _gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tif (rc < 0 || n < 8) {\n\t\t\t\tkeyid[0] = keyid[1] = (u32)-1;\n\t\t\t\treturn (u32)-1;\n\t\t\t}\n\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\n\treturn lowbits;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 528,
    "critical_vars": [
      "p",
      "pk->mpi[0]",
      "&n"
    ],
    "function": "cdk_pk_get_keyid",
    "filename": "visit_repo_url/CVE-2017-5336/CVE-2017-5336_CWE-119_5140422e0d7319a8e2fe07f02cbcafc4d6538732_pubkey.c.diff",
    "function_code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\n\treturn lowbits;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 4786,
    "critical_vars": [
      "err_msg"
    ],
    "function": "dbd_bind_ph",
    "filename": "DBD-mysql/CVE-2016-1246/CVE-2016-1246_CWE-119_7c164a0c86cec6ee95df1d141e67b0e85dfdefd2_dbdimp.c.diff",
    "function_code": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char err_msg[64];\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n  IV tmp;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upon binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      sprintf(err_msg,\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n\n          tmp = SvIV(imp_sth->params[idx].value);\n          if (tmp > INT32_MAX)\n\t        croak(\"Could not bind %ld: Integer too large for MYSQL_TYPE_LONG\", tmp);\n          imp_sth->fbind[idx].numeric_val.lval= tmp;\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%\"PRId32\"<- IS A INT NUMBER\\n\",\n                          (int) sql_type, *(int32_t *)buffer);\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%f<- IS A FLOAT NUMBER\\n\",\n                          (int) sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %d, buffertype=%d\\n\", (int) sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %d ->length %d<- IS A STRING or BLOB\\n\",\n                        (int) sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      /* Note: this looks like being another bug:\n       * if type of parameter N changes, then a bind is triggered\n       * with an only partially filled bind structure ??\n       */\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%d\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, (int) sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has not been called */\n    if (imp_sth->has_been_bound == 0)\n    {\n      imp_sth->bind[idx].buffer_type= buffer_type;\n      imp_sth->bind[idx].buffer= buffer;\n      imp_sth->bind[idx].buffer_length= buffer_length;\n    }\n    else /* prepare has been called */\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 4786,
    "critical_vars": [
      "*err_msg"
    ],
    "function": "dbd_bind_ph",
    "filename": "DBD-mysql/CVE-2016-1246/CVE-2016-1246_CWE-119_7c164a0c86cec6ee95df1d141e67b0e85dfdefd2_dbdimp.c.diff",
    "function_code": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char *err_msg;\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n  IV tmp;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upon binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0))));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n\n          tmp = SvIV(imp_sth->params[idx].value);\n          if (tmp > INT32_MAX)\n\t        croak(\"Could not bind %ld: Integer too large for MYSQL_TYPE_LONG\", tmp);\n          imp_sth->fbind[idx].numeric_val.lval= tmp;\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%\"PRId32\"<- IS A INT NUMBER\\n\",\n                          (int) sql_type, *(int32_t *)buffer);\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%f<- IS A FLOAT NUMBER\\n\",\n                          (int) sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %d, buffertype=%d\\n\", (int) sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %d ->length %d<- IS A STRING or BLOB\\n\",\n                        (int) sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      /* Note: this looks like being another bug:\n       * if type of parameter N changes, then a bind is triggered\n       * with an only partially filled bind structure ??\n       */\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%d\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, (int) sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has not been called */\n    if (imp_sth->has_been_bound == 0)\n    {\n      imp_sth->bind[idx].buffer_type= buffer_type;\n      imp_sth->bind[idx].buffer= buffer;\n      imp_sth->bind[idx].buffer_length= buffer_length;\n    }\n    else /* prepare has been called */\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1392,
    "line_new": 1392,
    "critical_vars": [
      "len"
    ],
    "function": "mainloop",
    "filename": "nbd/CVE-2011-0530/CVE-2011-0530_CWE-119_3ef52043861ab16352d49af89e048ba6339d6df8_nbd-server.c.diff",
    "function_code": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE - sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 740,
    "critical_vars": [
      "tmp_line_len"
    ],
    "function": "*php_stream_url_wrap_http_ex",
    "filename": "php-src/CVE-2018-7584/CVE-2018-7584_CWE-119_523f230c831d7b33353203fa34aee4e92ac12bba_http_fopen_wrapper.c.diff",
    "function_code": "php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper, \n\t\tconst char *path, const char *mode, int options, char **opened_path, \n\t\tphp_stream_context *context, int redirect_max, int flags STREAMS_DC TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *stream = NULL;\n\tphp_url *resource = NULL;\n\tint use_ssl;\n\tint use_proxy = 0;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *ua_str = NULL;\n\tzval **ua_zval = NULL, **tmpzval = NULL, *ssl_proxy_peer_name = NULL;\n\tint scratch_len = 0;\n\tint body = 0;\n\tchar location[HTTP_HEADER_BLOCK_SIZE];\n\tzval *response_header = NULL;\n\tint reqok = 0;\n\tchar *http_header_line = NULL;\n\tchar tmp_line[128];\n\tsize_t chunk_size = 0, file_size = 0;\n\tint eol_detect = 0;\n\tchar *transport_string, *errstr = NULL;\n\tint transport_len, have_header = 0, request_fulluri = 0, ignore_errors = 0;\n\tchar *protocol_version = NULL;\n\tint protocol_version_len = 3; /* Default: \"1.0\" */\n\tstruct timeval timeout;\n\tchar *user_headers = NULL;\n\tint header_init = ((flags & HTTP_WRAPPER_HEADER_INIT) != 0);\n\tint redirected = ((flags & HTTP_WRAPPER_REDIRECTED) != 0);\n\tint follow_location = 1;\n\tphp_stream_filter *transfer_encoding = NULL;\n\tint response_code;\n\n\ttmp_line[0] = '\\0';\n\n\tif (redirect_max < 1) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Redirection limit reached, aborting\");\n\t\treturn NULL;\n\t}\n\n\tresource = php_url_parse(path);\n\tif (resource == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (strncasecmp(resource->scheme, \"http\", sizeof(\"http\")) && strncasecmp(resource->scheme, \"https\", sizeof(\"https\"))) {\n\t\tif (!context ||\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == FAILURE ||\n\t\t\tZ_TYPE_PP(tmpzval) != IS_STRING ||\n\t\t\tZ_STRLEN_PP(tmpzval) <= 0) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_open_wrapper_ex(path, mode, REPORT_ERRORS, NULL, context);\n\t\t}\n\t\t/* Called from a non-http wrapper with http proxying requested (i.e. ftp) */\n\t\trequest_fulluri = 1;\n\t\tuse_ssl = 0;\n\t\tuse_proxy = 1;\n\n\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\t/* Normal http request (possibly with proxy) */\n\n\t\tif (strpbrk(mode, \"awx+\")) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP wrapper does not support writeable connections\");\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuse_ssl = resource->scheme && (strlen(resource->scheme) > 4) && resource->scheme[4] == 's';\n\t\t/* choose default ports */\n\t\tif (use_ssl && resource->port == 0)\n\t\t\tresource->port = 443;\n\t\telse if (resource->port == 0)\n\t\t\tresource->port = 80;\n\n\t\tif (context &&\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == SUCCESS &&\n\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING &&\n\t\t\tZ_STRLEN_PP(tmpzval) > 0) {\n\t\t\tuse_proxy = 1;\n\t\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t\t} else {\n\t\t\ttransport_len = spprintf(&transport_string, 0, \"%s://%s:%d\", use_ssl ? \"ssl\" : \"tcp\", resource->host, resource->port);\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, wrapper->wops->label, \"timeout\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\ttimeout.tv_sec = (time_t) Z_DVAL_PP(tmpzval);\n\t\ttimeout.tv_usec = (size_t) ((Z_DVAL_PP(tmpzval) - timeout.tv_sec) * 1000000);\n\t} else {\n\t\ttimeout.tv_sec = FG(default_socket_timeout);\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tstream = php_stream_xport_create(transport_string, transport_len, options,\n\t\t\tSTREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n\t\t\tNULL, &timeout, context, &errstr, NULL);\n\n\tif (stream) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &timeout);\n\t}\n\n\tif (errstr) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"%s\", errstr);\n\t\tefree(errstr);\n\t\terrstr = NULL;\n\t}\n\n\tefree(transport_string);\n\n\tif (stream && use_proxy && use_ssl) {\n\t\tsmart_str header = {0};\n\n\t\t/* Set peer_name or name verification will try to use the proxy server name */\n\t\tif (!context || php_stream_context_get_option(context, \"ssl\", \"peer_name\", &tmpzval) == FAILURE) {\n\t\t\tMAKE_STD_ZVAL(ssl_proxy_peer_name);\n\t\t\tZVAL_STRING(ssl_proxy_peer_name, resource->host, 1);\n\t\t\tphp_stream_context_set_option(stream->context, \"ssl\", \"peer_name\", ssl_proxy_peer_name);\n\t\t}\n\n\t\tsmart_str_appendl(&header, \"CONNECT \", sizeof(\"CONNECT \")-1);\n\t\tsmart_str_appends(&header, resource->host);\n\t\tsmart_str_appendc(&header, ':');\n\t\tsmart_str_append_unsigned(&header, resource->port);\n\t\tsmart_str_appendl(&header, \" HTTP/1.0\\r\\n\", sizeof(\" HTTP/1.0\\r\\n\")-1);\n\n\t    /* check if we have Proxy-Authorization header */\n\t\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\t\tchar *s, *p;\n\n\t\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\t\tHashPosition pos;\n\t\t\t\tzval **tmpheader = NULL;\n\n\t\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)) {\n\t\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\t\ts = Z_STRVAL_PP(tmpheader);\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\t\t\tp = s;\n\t\t\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = p;\n\t\t\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t\t\t} while (*s != 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t\ts = Z_STRVAL_PP(tmpzval);\n\t\t\t\tdo {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\tp = s;\n\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = p;\n\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t} while (*s != 0);\n\t\t\t}\n\t\t}\nfinish:\n\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\n\t\tif (php_stream_write(stream, header.c, header.len) != header.len) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\tphp_stream_close(stream);\n\t\t\tstream = NULL;\n\t\t}\n \t \tsmart_str_free(&header);\n\n \t \tif (stream) {\n \t \t\tchar header_line[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t/* get response header */\n\t\t\twhile (php_stream_gets(stream, header_line, HTTP_HEADER_BLOCK_SIZE-1) != NULL) {\n\t\t\t\tif (header_line[0] == '\\n' ||\n\t\t\t\t    header_line[0] == '\\r' ||\n\t\t\t\t    header_line[0] == '\\0') {\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* enable SSL transport layer */\n\t\tif (stream) {\n\t\t\tif (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL TSRMLS_CC) < 0 ||\n\t\t\t    php_stream_xport_crypto_enable(stream, 1 TSRMLS_CC) < 0) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\t\tphp_stream_close(stream);\n\t\t\t\tstream = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream == NULL)\n\t\tgoto out;\n\n\t/* avoid buffering issues while reading header */\n\tif (options & STREAM_WILL_CAST)\n\t\tchunk_size = php_stream_set_chunk_size(stream, 1);\n\n\t/* avoid problems with auto-detecting when reading the headers -> the headers\n\t * are always in canonical \\r\\n format */\n\teol_detect = stream->flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\tstream->flags &= ~(PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\n\tphp_stream_context_set(stream, context);\n\n\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_CONNECT, NULL, 0);\n\n\tif (header_init && context && php_stream_context_get_option(context, \"http\", \"max_redirects\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_long_ex(tmpzval);\n\t\tredirect_max = Z_LVAL_PP(tmpzval);\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"method\", &tmpzval) == SUCCESS) {\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\t\t/* As per the RFC, automatically redirected requests MUST NOT use other methods than\n\t\t\t * GET and HEAD unless it can be confirmed by the user */\n\t\t\tif (!redirected\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 3 && memcmp(\"GET\", Z_STRVAL_PP(tmpzval), 3) == 0)\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 4 && memcmp(\"HEAD\",Z_STRVAL_PP(tmpzval), 4) == 0)\n\t\t\t) {\n\t\t\t\tscratch_len = strlen(path) + 29 + Z_STRLEN_PP(tmpzval);\n\t\t\t\tscratch = emalloc(scratch_len);\n\t\t\t\tstrlcpy(scratch, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval) + 1);\n\t\t\t\tstrncat(scratch, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"protocol_version\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\tprotocol_version_len = spprintf(&protocol_version, 0, \"%.1F\", Z_DVAL_PP(tmpzval));\n\t}\n\n\tif (!scratch) {\n\t\tscratch_len = strlen(path) + 29 + protocol_version_len;\n\t\tscratch = emalloc(scratch_len);\n\t\tstrncpy(scratch, \"GET \", scratch_len);\n\t}\n\n\t/* Should we send the entire path in the request line, default to no. */\n\tif (!request_fulluri &&\n\t\tcontext &&\n\t\tphp_stream_context_get_option(context, \"http\", \"request_fulluri\", &tmpzval) == SUCCESS) {\n\t\tzval ztmp = **tmpzval;\n\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_boolean(&ztmp);\n\t\trequest_fulluri = Z_BVAL(ztmp) ? 1 : 0;\n\t\tzval_dtor(&ztmp);\n\t}\n\n\tif (request_fulluri) {\n\t\t/* Ask for everything */\n\t\tstrcat(scratch, path);\n\t} else {\n\t\t/* Send the traditional /path/to/file?query_string */\n\n\t\t/* file */\n\t\tif (resource->path && *resource->path) {\n\t\t\tstrlcat(scratch, resource->path, scratch_len);\n\t\t} else {\n\t\t\tstrlcat(scratch, \"/\", scratch_len);\n\t\t}\n\n\t\t/* query string */\n\t\tif (resource->query) {\n\t\t\tstrlcat(scratch, \"?\", scratch_len);\n\t\t\tstrlcat(scratch, resource->query, scratch_len);\n\t\t}\n\t}\n\n\t/* protocol version we are speaking */\n\tif (protocol_version) {\n\t\tstrlcat(scratch, \" HTTP/\", scratch_len);\n\t\tstrlcat(scratch, protocol_version, scratch_len);\n\t\tstrlcat(scratch, \"\\r\\n\", scratch_len);\n\t} else {\n\t\tstrlcat(scratch, \" HTTP/1.0\\r\\n\", scratch_len);\n\t}\n\n\t/* send it */\n\tphp_stream_write(stream, scratch, strlen(scratch));\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\ttmp = NULL;\n\n\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\tHashPosition pos;\n\t\t\tzval **tmpheader = NULL;\n\t\t\tsmart_str tmpstr = {0};\n\n\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)\n\t\t\t) {\n\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&tmpstr, Z_STRVAL_PP(tmpheader), Z_STRLEN_PP(tmpheader));\n\t\t\t\t\tsmart_str_appendl(&tmpstr, \"\\r\\n\", sizeof(\"\\r\\n\") - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmart_str_0(&tmpstr);\n\t\t\t/* Remove newlines and spaces from start and end. there's at least one extra \\r\\n at the end that needs to go. */\n\t\t\tif (tmpstr.c) {\n\t\t\t\ttmp = php_trim(tmpstr.c, strlen(tmpstr.c), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t\t\tsmart_str_free(&tmpstr);\n\t\t\t}\n\t\t}\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t/* Remove newlines and spaces from start and end php_trim will estrndup() */\n\t\t\ttmp = php_trim(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t}\n\t\tif (tmp && strlen(tmp) > 0) {\n\t\t\tchar *s;\n\n\t\t\tuser_headers = estrdup(tmp);\n\n\t\t\t/* Make lowercase for easy comparison against 'standard' headers */\n\t\t\tphp_strtolower(tmp, strlen(tmp));\n\n\t\t\tif (!header_init) {\n\t\t\t\t/* strip POST headers on redirect */\n\t\t\t\tstrip_header(user_headers, tmp, \"content-length:\");\n\t\t\t\tstrip_header(user_headers, tmp, \"content-type:\");\n\t\t\t}\n\n\t\t\tif ((s = strstr(tmp, \"user-agent:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_USER_AGENT;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"host:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_HOST;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"from:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_FROM;\n\t\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_AUTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-length:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-type:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_TYPE;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"connection:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' || \n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONNECTION;\n\t\t\t}\n\t\t\t/* remove Proxy-Authorization header */\n\t\t\tif (use_proxy && use_ssl && (s = strstr(tmp, \"proxy-authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\tchar *p = s + sizeof(\"proxy-authorization:\") - 1;\n\n\t\t\t\twhile (s > tmp && (*(s-1) == ' ' || *(s-1) == '\\t')) s--;\n\t\t\t\twhile (*p != 0 && *p != '\\r' && *p != '\\n') p++;\n\t\t\t\twhile (*p == '\\r' || *p == '\\n') p++;\n\t\t\t\tif (*p == 0) {\n\t\t\t\t\tif (s == tmp) {\n\t\t\t\t\t\tefree(user_headers);\n\t\t\t\t\t\tuser_headers = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (s > tmp && (*(s-1) == '\\r' || *(s-1) == '\\n')) s--;\n\t\t\t\t\t\tuser_headers[s - tmp] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmemmove(user_headers + (s - tmp), user_headers + (p - tmp), strlen(p) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (tmp) {\n\t\t\tefree(tmp);\n\t\t}\n\t}\n\n\t/* auth header if it was specified */\n\tif (((have_header & HTTP_HEADER_AUTH) == 0) && resource->user) {\n\t\t/* decode the strings first */\n\t\tphp_url_decode(resource->user, strlen(resource->user));\n\n\t\t/* scratch is large enough, since it was made large enough for the whole URL */\n\t\tstrcpy(scratch, resource->user);\n\t\tstrcat(scratch, \":\");\n\n\t\t/* Note: password is optional! */\n\t\tif (resource->pass) {\n\t\t\tphp_url_decode(resource->pass, strlen(resource->pass));\n\t\t\tstrcat(scratch, resource->pass);\n\t\t}\n\n\t\ttmp = (char*)php_base64_encode((unsigned char*)scratch, strlen(scratch), NULL);\n\n\t\tif (snprintf(scratch, scratch_len, \"Authorization: Basic %s\\r\\n\", tmp) > 0) {\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_AUTH_REQUIRED, NULL, 0);\n\t\t}\n\n\t\tefree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\t/* if the user has configured who they are, send a From: line */\n\tif (((have_header & HTTP_HEADER_FROM) == 0) && FG(from_address)) {\n\t\tif (snprintf(scratch, scratch_len, \"From: %s\\r\\n\", FG(from_address)) > 0)\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t}\n\n\t/* Send Host: header so name-based virtual hosts work */\n\tif ((have_header & HTTP_HEADER_HOST) == 0) {\n\t\tif ((use_ssl && resource->port != 443 && resource->port != 0) ||\n\t\t\t(!use_ssl && resource->port != 80 && resource->port != 0)) {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s:%i\\r\\n\", resource->host, resource->port) > 0)\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t} else {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s\\r\\n\", resource->host) > 0) {\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send a Connection: close header to avoid hanging when the server\n\t * interprets the RFC literally and establishes a keep-alive connection,\n\t * unless the user specifically requests something else by specifying a\n\t * Connection header in the context options. Send that header even for\n\t * HTTP/1.0 to avoid issues when the server respond with a HTTP/1.1\n\t * keep-alive response, which is the preferred response type. */\n\tif ((have_header & HTTP_HEADER_CONNECTION) == 0) {\n\t\tphp_stream_write_string(stream, \"Connection: close\\r\\n\");\n\t}\n\n\tif (context &&\n\t    php_stream_context_get_option(context, \"http\", \"user_agent\", &ua_zval) == SUCCESS &&\n\t\tZ_TYPE_PP(ua_zval) == IS_STRING) {\n\t\tua_str = Z_STRVAL_PP(ua_zval);\n\t} else if (FG(user_agent)) {\n\t\tua_str = FG(user_agent);\n\t}\n\n\tif (((have_header & HTTP_HEADER_USER_AGENT) == 0) && ua_str) {\n#define _UA_HEADER \"User-Agent: %s\\r\\n\"\n\t\tchar *ua;\n\t\tsize_t ua_len;\n\n\t\tua_len = sizeof(_UA_HEADER) + strlen(ua_str);\n\n\t\t/* ensure the header is only sent if user_agent is not blank */\n\t\tif (ua_len > sizeof(_UA_HEADER)) {\n\t\t\tua = emalloc(ua_len + 1);\n\t\t\tif ((ua_len = slprintf(ua, ua_len, _UA_HEADER, ua_str)) > 0) {\n\t\t\t\tua[ua_len] = 0;\n\t\t\t\tphp_stream_write(stream, ua, ua_len);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot construct User-agent header\");\n\t\t\t}\n\n\t\t\tif (ua) {\n\t\t\t\tefree(ua);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (user_headers) {\n\t\t/* A bit weird, but some servers require that Content-Length be sent prior to Content-Type for POST\n\t\t * see bug #44603 for details. Since Content-Type maybe part of user's headers we need to do this check first.\n\t\t */\n\t\tif (\n\t\t\t\theader_init &&\n\t\t\t\tcontext &&\n\t\t\t\t!(have_header & HTTP_HEADER_CONTENT_LENGTH) &&\n\t\t\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0\n\t\t) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t\thave_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t}\n\n\t\tphp_stream_write(stream, user_headers, strlen(user_headers));\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tefree(user_headers);\n\t}\n\n\t/* Request content, such as for POST requests */\n\tif (header_init && context &&\n\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\tif (!(have_header & HTTP_HEADER_CONTENT_LENGTH)) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t}\n\t\tif (!(have_header & HTTP_HEADER_TYPE)) {\n\t\t\tphp_stream_write(stream, \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n\t\t\t\tsizeof(\"Content-Type: application/x-www-form-urlencoded\\r\\n\") - 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Content-type not specified assuming application/x-www-form-urlencoded\");\n\t\t}\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tphp_stream_write(stream, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t}\n\n\tlocation[0] = '\\0';\n\n\tif (!EG(active_symbol_table)) {\n\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t}\n\n\tif (header_init) {\n\t\tzval *ztmp;\n\t\tMAKE_STD_ZVAL(ztmp);\n\t\tarray_init(ztmp);\n\t\tZEND_SET_SYMBOL(EG(active_symbol_table), \"http_response_header\", ztmp);\n\t}\n\n\t{\n\t\tzval **rh;\n\t\tif(zend_hash_find(EG(active_symbol_table), \"http_response_header\", sizeof(\"http_response_header\"), (void **) &rh) != SUCCESS || Z_TYPE_PP(rh) != IS_ARRAY) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, http_response_header overwritten\");\n\t\t\tgoto out;\n\t\t}\n\t\tresponse_header = *rh;\n\t\tZ_ADDREF_P(response_header);\n\t}\n\n\tif (!php_stream_eof(stream)) {\n\t\tsize_t tmp_line_len;\n\t\t/* get response header */\n\n\t\tif (php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL) {\n\t\t\tzval *http_response;\n\n\t\t\tif (tmp_line_len > 9) {\n\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t} else {\n\t\t\t\tresponse_code = 0;\n\t\t\t}\n\t\t\tif (context && SUCCESS==php_stream_context_get_option(context, \"http\", \"ignore_errors\", &tmpzval)) {\n\t\t\t\tignore_errors = zend_is_true(*tmpzval);\n\t\t\t}\n\t\t\t/* when we request only the header, don't fail even on error codes */\n\t\t\tif ((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) {\n\t\t\t\treqok = 1;\n\t\t\t}\n\n\t\t\t/* status codes of 1xx are \"informational\", and will be followed by a real response\n\t\t\t * e.g \"100 Continue\". RFC 7231 states that unexpected 1xx status MUST be parsed,\n\t\t\t * and MAY be ignored. As such, we need to skip ahead to the \"real\" status*/\n\t\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t\t/* consume lines until we find a line starting 'HTTP/1' */\n\t\t\t\twhile (\n\t\t\t\t\t!php_stream_eof(stream)\n\t\t\t\t\t&& php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL\n\t\t\t\t\t&& ( tmp_line_len < sizeof(\"HTTP/1\") - 1 || strncasecmp(tmp_line, \"HTTP/1\", sizeof(\"HTTP/1\") - 1) )\n\t\t\t\t);\n\n\t\t\t\tif (tmp_line_len > 9) {\n\t\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t\t} else {\n\t\t\t\t\tresponse_code = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all status codes in the 2xx range are defined by the specification as successful;\n\t\t\t * all status codes in the 3xx range are for redirection, and so also should never\n\t\t\t * fail */\n\t\t\tif (response_code >= 200 && response_code < 400) {\n\t\t\t\treqok = 1;\n\t\t\t} else {\n\t\t\t\tswitch(response_code) {\n\t\t\t\t\tcase 403:\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_AUTH_RESULT,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* safety net in the event tmp_line == NULL */\n\t\t\t\t\t\tif (!tmp_line_len) {\n\t\t\t\t\t\t\ttmp_line[0] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_FAILURE,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_line_len >= 1 && tmp_line[tmp_line_len - 1] == '\\n') {\n\t\t\t\t--tmp_line_len;\n\t\t\t\tif (tmp_line_len >= 1 &&tmp_line[tmp_line_len - 1] == '\\r') {\n\t\t\t\t\t--tmp_line_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMAKE_STD_ZVAL(http_response);\n\t\t\tZVAL_STRINGL(http_response, tmp_line, tmp_line_len, 1);\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_response, sizeof(zval *), NULL);\n\t\t}\n\t} else {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, unexpected end of socket!\");\n\t\tgoto out;\n\t}\n\n\t/* read past HTTP headers */\n\n\thttp_header_line = emalloc(HTTP_HEADER_BLOCK_SIZE);\n\n\twhile (!body && !php_stream_eof(stream)) {\n\t\tsize_t http_header_line_length;\n\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) && *http_header_line != '\\n' && *http_header_line != '\\r') {\n\t\t\tchar *e = http_header_line + http_header_line_length - 1;\n\t\t\tif (*e != '\\n') {\n\t\t\t\tdo { /* partial header */\n\t\t\t\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) == NULL) {\n\t\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Failed to read HTTP headers\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\te = http_header_line + http_header_line_length - 1;\n\t\t\t\t} while (*e != '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (*e == '\\n' || *e == '\\r') {\n\t\t\t\te--;\n\t\t\t}\n\t\t\thttp_header_line_length = e - http_header_line + 1;\n\t\t\thttp_header_line[http_header_line_length] = '\\0';\n\n\t\t\tif (!strncasecmp(http_header_line, \"Location: \", 10)) {\n\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"follow_location\", &tmpzval) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\tconvert_to_long_ex(tmpzval);\n\t\t\t\t\tfollow_location = Z_LVAL_PP(tmpzval);\n\t\t\t\t} else if (!(response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code)) {\n\t\t\t\t\t/* we shouldn't redirect automatically\n\t\t\t\t\tif follow_location isn't set and response_code not in (300, 301, 302, 303 and 307)\n\t\t\t\t\tsee http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1\n\t\t\t\t\tRFC 7238 defines 308: http://tools.ietf.org/html/rfc7238 */\n\t\t\t\t\tfollow_location = 0;\n\t\t\t\t}\n\t\t\t\tstrlcpy(location, http_header_line + 10, sizeof(location));\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Type: \", 14)) {\n\t\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_MIME_TYPE_IS, http_header_line + 14, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Length: \", 16)) {\n\t\t\t\tfile_size = atoi(http_header_line + 16);\n\t\t\t\tphp_stream_notify_file_size(context, file_size, http_header_line, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Transfer-Encoding: chunked\", sizeof(\"Transfer-Encoding: chunked\"))) {\n\n\t\t\t\t/* create filter to decode response body */\n\t\t\t\tif (!(options & STREAM_ONLY_GET_HEADERS)) {\n\t\t\t\t\tlong decode = 1;\n\n\t\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"auto_decode\", &tmpzval) == SUCCESS) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\t\tconvert_to_boolean(*tmpzval);\n\t\t\t\t\t\tdecode = Z_LVAL_PP(tmpzval);\n\t\t\t\t\t}\n\t\t\t\t\tif (decode) {\n\t\t\t\t\t\ttransfer_encoding = php_stream_filter_create(\"dechunk\", NULL, php_stream_is_persistent(stream) TSRMLS_CC);\n\t\t\t\t\t\tif (transfer_encoding) {\n\t\t\t\t\t\t\t/* don't store transfer-encodeing header */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (http_header_line[0] == '\\0') {\n\t\t\t\tbody = 1;\n\t\t\t} else {\n\t\t\t\tzval *http_header;\n\n\t\t\t\tMAKE_STD_ZVAL(http_header);\n\n\t\t\t\tZVAL_STRINGL(http_header, http_header_line, http_header_line_length, 1);\n\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_header, sizeof(zval *), NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!reqok || (location[0] != '\\0' && follow_location)) {\n\t\tif (!follow_location || (((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) && redirect_max <= 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (location[0] != '\\0')\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_REDIRECTED, location, 0);\n\n\t\tphp_stream_close(stream);\n\t\tstream = NULL;\n\n\t\tif (location[0] != '\\0') {\n\n\t\t\tchar new_path[HTTP_HEADER_BLOCK_SIZE];\n\t\t\tchar loc_path[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t*new_path='\\0';\n\t\t\tif (strlen(location)<8 || (strncasecmp(location, \"http://\", sizeof(\"http://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"https://\", sizeof(\"https://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftp://\", sizeof(\"ftp://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftps://\", sizeof(\"ftps://\")-1)))\n\t\t\t{\n\t\t\t\tif (*location != '/') {\n\t\t\t\t\tif (*(location+1) != '\\0' && resource->path) {\n\t\t\t\t\t\tchar *s = strrchr(resource->path, '/');\n\t\t\t\t\t\tif (!s) {\n\t\t\t\t\t\t\ts = resource->path;\n\t\t\t\t\t\t\tif (!s[0]) {\n\t\t\t\t\t\t\t\tefree(s);\n\t\t\t\t\t\t\t\ts = resource->path = estrdup(\"/\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*s = '/';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[1] = '\\0';\n\t\t\t\t\t\tif (resource->path && *(resource->path) == '/' && *(resource->path + 1) == '\\0') {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s%s\", resource->path, location);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s/%s\", resource->path, location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"/%s\", location);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(loc_path, location, sizeof(loc_path));\n\t\t\t\t}\n\t\t\t\tif ((use_ssl && resource->port != 443) || (!use_ssl && resource->port != 80)) {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s:%d%s\", resource->scheme, resource->host, resource->port, loc_path);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s%s\", resource->scheme, resource->host, loc_path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(new_path, location, sizeof(new_path));\n\t\t\t}\n\n\t\t\tphp_url_free(resource);\n\t\t\t/* check for invalid redirection URLs */\n\t\t\tif ((resource = php_url_parse(new_path)) == NULL) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n#define CHECK_FOR_CNTRL_CHARS(val) { \\\n\tif (val) { \\\n\t\tunsigned char *s, *e; \\\n\t\tint l; \\\n\t\tl = php_url_decode(val, strlen(val)); \\\n\t\ts = (unsigned char*)val; e = s + l; \\\n\t\twhile (s < e) { \\\n\t\t\tif (iscntrl(*s)) { \\\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path); \\\n\t\t\t\tgoto out; \\\n\t\t\t} \\\n\t\t\ts++; \\\n\t\t} \\\n\t} \\\n}\n\t\t\t/* check for control characters in login, password & path */\n\t\t\tif (strncasecmp(new_path, \"http://\", sizeof(\"http://\") - 1) || strncasecmp(new_path, \"https://\", sizeof(\"https://\") - 1)) {\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->user)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->pass)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->path)\n\t\t\t}\n\t\t\tstream = php_stream_url_wrap_http_ex(wrapper, new_path, mode, options, opened_path, context, --redirect_max, HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed! %s\", tmp_line);\n\t\t}\n\t}\nout:\n\tif (protocol_version) {\n\t\tefree(protocol_version);\n\t}\n\n\tif (http_header_line) {\n\t\tefree(http_header_line);\n\t}\n\n\tif (scratch) {\n\t\tefree(scratch);\n\t}\n\n\tif (resource) {\n\t\tphp_url_free(resource);\n\t}\n\n\tif (stream) {\n\t\tif (header_init) {\n\t\t\tstream->wrapperdata = response_header;\n\t\t} else {\n\t\t\tif(response_header) {\n\t\t\t\tZ_DELREF_P(response_header);\n\t\t\t}\n\t\t}\n\t\tphp_stream_notify_progress_init(context, 0, file_size);\n\n\t\t/* Restore original chunk size now that we're done with headers */\n\t\tif (options & STREAM_WILL_CAST)\n\t\t\tphp_stream_set_chunk_size(stream, chunk_size);\n\n\t\t/* restore the users auto-detect-line-endings setting */\n\t\tstream->flags |= eol_detect;\n\n\t\t/* as far as streams are concerned, we are now at the start of\n\t\t * the stream */\n\t\tstream->position = 0;\n\n\t\t/* restore mode */\n\t\tstrlcpy(stream->mode, mode, sizeof(stream->mode));\n\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_append(&stream->readfilters, transfer_encoding);\n\t\t}\n\t} else {\n\t\tif(response_header) {\n\t\t\tZ_DELREF_P(response_header);\n\t\t}\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_free(transfer_encoding TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn stream;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 775,
    "critical_vars": [
      "&entry"
    ],
    "function": "SPL_METHOD",
    "filename": "php-src/CVE-2016-7480/CVE-2016-7480_CWE-119_61cdd1255d5b9c8453be71aacbbf682796ac77d4_spl_observer.c.diff",
    "function_code": "SPL_METHOD(SplObjectStorage, unserialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tchar *buf;\n\tsize_t buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval entry, inf;\n\tzval *pcount, *pmembers;\n\tspl_SplObjectStorageElement *element;\n\tzend_long count;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpcount = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\t--p; /* for ';' */\n\tcount = Z_LVAL_P(pcount);\n\n\tZVAL_UNDEF(&entry);\n\tZVAL_UNDEF(&inf);\n\n\twhile (count-- > 0) {\n\t\tspl_SplObjectStorageElement *pelement;\n\t\tzend_string *hash;\n\n\t\tif (*p != ';') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t++p;\n\t\tif(*p != 'O' && *p != 'C' && *p != 'r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t/* store reference to allow cross-references between different elements */\n\t\tif (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (*p == ',') { /* new version has inf */\n\t\t\t++p;\n\t\t\tif (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) {\n\t\t\t\tzval_ptr_dtor(&entry);\n\t\t\t\tgoto outexcept;\n\t\t\t}\n\t\t}\n\t\tif (Z_TYPE(entry) != IS_OBJECT) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\n\t\thash = spl_object_storage_get_hash(intern, getThis(), &entry);\n\t\tif (!hash) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tpelement = spl_object_storage_get(intern, hash);\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\tif (pelement) {\n\t\t\tif (!Z_ISUNDEF(pelement->inf)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->inf);\n\t\t\t}\n\t\t\tif (!Z_ISUNDEF(pelement->obj)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->obj);\n\t\t\t}\n\t\t}\n\t\telement = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf);\n\t\tvar_replace(&var_hash, &entry, &element->obj);\n\t\tvar_replace(&var_hash, &inf, &element->inf);\n\t\tzval_ptr_dtor(&entry);\n\t\tZVAL_UNDEF(&entry);\n\t\tzval_ptr_dtor(&inf);\n\t\tZVAL_UNDEF(&inf);\n\t}\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpmembers = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tgoto outexcept;\n\t}\n\n\t/* copy members */\n\tobject_properties_load(&intern->std, Z_ARRVAL_P(pmembers));\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Error at offset %pd of %d bytes\", (zend_long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 790,
    "critical_vars": [
      "entry"
    ],
    "function": "SPL_METHOD",
    "filename": "php-src/CVE-2016-7480/CVE-2016-7480_CWE-119_61cdd1255d5b9c8453be71aacbbf682796ac77d4_spl_observer.c.diff",
    "function_code": "SPL_METHOD(SplObjectStorage, unserialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tchar *buf;\n\tsize_t buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval entry, inf;\n\tzval *pcount, *pmembers;\n\tspl_SplObjectStorageElement *element;\n\tzend_long count;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpcount = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\t--p; /* for ';' */\n\tcount = Z_LVAL_P(pcount);\n\n\twhile (count-- > 0) {\n\t\tspl_SplObjectStorageElement *pelement;\n\t\tzend_string *hash;\n\n\t\tif (*p != ';') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t++p;\n\t\tif(*p != 'O' && *p != 'C' && *p != 'r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t/* store reference to allow cross-references between different elements */\n\t\tif (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (Z_TYPE(entry) != IS_OBJECT) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (*p == ',') { /* new version has inf */\n\t\t\t++p;\n\t\t\tif (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) {\n\t\t\t\tzval_ptr_dtor(&entry);\n\t\t\t\tgoto outexcept;\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_UNDEF(&inf);\n\t\t}\n\n\t\thash = spl_object_storage_get_hash(intern, getThis(), &entry);\n\t\tif (!hash) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tpelement = spl_object_storage_get(intern, hash);\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\tif (pelement) {\n\t\t\tif (!Z_ISUNDEF(pelement->inf)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->inf);\n\t\t\t}\n\t\t\tif (!Z_ISUNDEF(pelement->obj)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->obj);\n\t\t\t}\n\t\t}\n\t\telement = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf);\n\t\tvar_replace(&var_hash, &entry, &element->obj);\n\t\tvar_replace(&var_hash, &inf, &element->inf);\n\t\tzval_ptr_dtor(&entry);\n\t\tZVAL_UNDEF(&entry);\n\t\tzval_ptr_dtor(&inf);\n\t\tZVAL_UNDEF(&inf);\n\t}\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpmembers = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tgoto outexcept;\n\t}\n\n\t/* copy members */\n\tobject_properties_load(&intern->std, Z_ARRVAL_P(pmembers));\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Error at offset %pd of %d bytes\", (zend_long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 428,
    "line_new": 434,
    "critical_vars": [
      "n"
    ],
    "function": "*php_parserr",
    "filename": "php-src/CVE-2014-3597/CVE-2014-3597_CWE-119_2fefae47716d501aec41c1102f3fd4531f070b05_dns.c.diff",
    "function_code": "static u_char *php_parserr(u_char *cp, u_char *end, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, end, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tCHECKCP(10);\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tCHECKCP(dlen);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tCHECKCP(4);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tCHECKCP(2);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tCHECKCP(1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tCHECKCP(1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint l1 = 0, l2 = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n\t\t\t\t\n\t\t\t\twhile (l1 < dlen) {\n\t\t\t\t\tn = cp[l1];\n\t\t\t\t\tif ((l1 + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (l1 + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (n) {\n\t\t\t\t\t\tmemcpy(tp + l2 , cp + l1 + 1, n);\n\t\t\t\t\t\tadd_next_index_stringl(entries, cp + l1 + 1, n, 1);\n\t\t\t\t\t}\n\t\t\t\t\tl1 = l1 + n + 1;\n\t\t\t\t\tl2 = l2 + n;\n\t\t\t\t}\n\t\t\t\ttp[l2] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, l2, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tCHECKCP(5*4);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tCHECKCP(8*2);\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tCHECKCP(1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tCHECKCP(2);\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tCHECKCP(3*2);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tCHECKCP(2*2);\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\n\t\t\tCHECKCP(1);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\n\t\t\tCHECKCP(1);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tcp++;\n\t\t\tCHECKCP(n);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\n\t\t\tn = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 509,
    "critical_vars": [
      "ll"
    ],
    "function": "*php_parserr",
    "filename": "php-src/CVE-2014-3597/CVE-2014-3597_CWE-119_2fefae47716d501aec41c1102f3fd4531f070b05_dns.c.diff",
    "function_code": "static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n\t\t\t\t\n\t\t\t\twhile (ll < dlen) {\n\t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (ll + 1);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n\t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n\t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 440,
    "critical_vars": [
      "rval"
    ],
    "function": "object_common2",
    "filename": "php-src/CVE-2016-7411/CVE-2016-7411_CWE-119_6a7cc8ff85827fa9ac715b3a83c2d9147f33cd43_var_unserializer.c.diff",
    "function_code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    /* We've got partially constructed object on our hands here. Wipe it. */\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 783,
    "critical_vars": [
      "atts[++i]",
      "atts[i][0]"
    ],
    "function": "php_wddx_push_element",
    "filename": "php-src/CVE-2016-7418/CVE-2016-7418_CWE-119_c4cca4c20e75359c9a13a1f9a36cb7b4e9601d29_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 783,
    "critical_vars": [
      "atts[i+1]",
      "atts[i+1][0]"
    ],
    "function": "php_wddx_push_element",
    "filename": "php-src/CVE-2016-7418/CVE-2016-7418_CWE-119_c4cca4c20e75359c9a13a1f9a36cb7b4e9601d29_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i+1], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\ti++;\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1612,
    "critical_vars": [
      "sig_len"
    ],
    "function": "phar_verify_signature",
    "filename": "php-src/CVE-2016-7414/CVE-2016-7414_CWE-119_0bfb970f43acd1e81d11be1154805f86655f15d5_util.c.diff",
    "function_code": "int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error) /* {{{ */\n{\n\tint read_size, len;\n\tzend_off_t read_len;\n\tunsigned char buf[1024];\n\n\tphp_stream_rewind(fp);\n\n\tswitch (sig_type) {\n\t\tcase PHAR_SIG_OPENSSL: {\n#ifdef PHAR_HAVE_OPENSSL\n\t\t\tBIO *in;\n\t\t\tEVP_PKEY *key;\n\t\t\tEVP_MD *mdtype = (EVP_MD *) EVP_sha1();\n\t\t\tEVP_MD_CTX md_ctx;\n#else\n\t\t\tint tempsig;\n#endif\n\t\t\tzend_string *pubkey = NULL;\n\t\t\tchar *pfile;\n\t\t\tphp_stream *pfp;\n#ifndef PHAR_HAVE_OPENSSL\n\t\t\tif (!zend_hash_str_exists(&module_registry, \"openssl\", sizeof(\"openssl\")-1)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl not loaded\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n#endif\n\t\t\t/* use __FILE__ . '.pubkey' for public key file */\n\t\t\tspprintf(&pfile, 0, \"%s.pubkey\", fname);\n\t\t\tpfp = php_stream_open_wrapper(pfile, \"rb\", 0, NULL);\n\t\t\tefree(pfile);\n\n\t\t\tif (!pfp || !(pubkey = php_stream_copy_to_mem(pfp, PHP_STREAM_COPY_ALL, 0)) || !ZSTR_LEN(pubkey)) {\n\t\t\t\tif (pfp) {\n\t\t\t\t\tphp_stream_close(pfp);\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl public key could not be read\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tphp_stream_close(pfp);\n#ifndef PHAR_HAVE_OPENSSL\n\t\t\ttempsig = sig_len;\n\n\t\t\tif (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0, &sig, &tempsig)) {\n\t\t\t\tif (pubkey) {\n\t\t\t\t\tzend_string_release(pubkey);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be verified\");\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (pubkey) {\n\t\t\t\tzend_string_release(pubkey);\n\t\t\t}\n\n\t\t\tsig_len = tempsig;\n#else\n\t\t\tin = BIO_new_mem_buf(pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0);\n\n\t\t\tif (NULL == in) {\n\t\t\t\tzend_string_release(pubkey);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tkey = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);\n\t\t\tBIO_free(in);\n\t\t\tzend_string_release(pubkey);\n\n\t\t\tif (NULL == key) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tEVP_VerifyInit(&md_ctx, mdtype);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\n\t\t\twhile (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tEVP_VerifyUpdate (&md_ctx, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {\n\t\t\t\t/* 1: signature verified, 0: signature does not match, -1: failed signature operation */\n\t\t\t\tEVP_MD_CTX_cleanup(&md_ctx);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken openssl signature\");\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tEVP_MD_CTX_cleanup(&md_ctx);\n#endif\n\n\t\t\t*signature_len = phar_hex_str((const char*)sig, sig_len, signature);\n\t\t}\n\t\tbreak;\n#ifdef PHAR_HASH_OK\n\t\tcase PHAR_SIG_SHA512: {\n\t\t\tunsigned char digest[64];\n\t\t\tPHP_SHA512_CTX context;\n\n\t\t\tif (sig_len < sizeof(digest)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tPHP_SHA512Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA512Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA512Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_SHA256: {\n\t\t\tunsigned char digest[32];\n\t\t\tPHP_SHA256_CTX context;\n\n\t\t\tif (sig_len < sizeof(digest)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tPHP_SHA256Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA256Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA256Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n#else\n\t\tcase PHAR_SIG_SHA512:\n\t\tcase PHAR_SIG_SHA256:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unsupported signature\");\n\t\t\t}\n\t\t\treturn FAILURE;\n#endif\n\t\tcase PHAR_SIG_SHA1: {\n\t\t\tunsigned char digest[20];\n\t\t\tPHP_SHA1_CTX  context;\n\n\t\t\tif (sig_len < sizeof(digest)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tPHP_SHA1Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA1Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA1Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_MD5: {\n\t\t\tunsigned char digest[16];\n\t\t\tPHP_MD5_CTX   context;\n\n\t\t\tif (sig_len < sizeof(digest)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tPHP_MD5Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_MD5Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_MD5Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"broken or unsupported signature\");\n\t\t\t}\n\t\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 421,
    "critical_vars": [
      "read"
    ],
    "function": "phar_parse_zipfile",
    "filename": "php-src/CVE-2016-7414/CVE-2016-7414_CWE-119_0bfb970f43acd1e81d11be1154805f86655f15d5_zip.c.diff",
    "function_code": "int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error) /* {{{ */\n{\n\tphar_zip_dir_end locator;\n\tchar buf[sizeof(locator) + 65536];\n\tzend_long size;\n\tphp_uint16 i;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry = {0};\n\tchar *p = buf, *ext, *actual_alias = NULL;\n\tchar *metadata = NULL;\n\n\tsize = php_stream_tell(fp);\n\n\tif (size > sizeof(locator) + 65536) {\n\t\t/* seek to max comment length + end of central directory record */\n\t\tsize = sizeof(locator) + 65536;\n\t\tif (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: unable to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t}\n\n\tif (!php_stream_read(fp, buf, size)) {\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\twhile ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {\n\t\tif ((p - buf) + sizeof(locator) <= size && !memcmp(p + 1, \"K\\5\\6\", 3)) {\n\t\t\tmemcpy((void *)&locator, (void *) p, sizeof(locator));\n\t\t\tif (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {\n\t\t\t\t/* split archives not handled */\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: split archives spanning multiple zips cannot be processed in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\t\t\tmydata->is_persistent = PHAR_G(persist);\n\n\t\t\t/* read in archive comment, if any */\n\t\t\tif (PHAR_GET_16(locator.comment_len)) {\n\n\t\t\t\tmetadata = p + sizeof(locator);\n\n\t\t\t\tif (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, zip file comment truncated in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tpefree(mydata, mydata->is_persistent);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tmydata->metadata_len = PHAR_GET_16(locator.comment_len);\n\n\t\t\t\tif (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len)) == FAILURE) {\n\t\t\t\t\tmydata->metadata_len = 0;\n\t\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\t\tZVAL_NEW_STR(&mydata->metadata, zend_string_init(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tZVAL_UNDEF(&mydata->metadata);\n\t\t\t}\n\n\t\t\tgoto foundit;\n\t\t}\n\t}\n\n\tphp_stream_close(fp);\n\n\tif (error) {\n\t\tspprintf(error, 4096, \"phar error: end of central directory not found in zip-based phar \\\"%s\\\"\", fname);\n\t}\n\n\treturn FAILURE;\nfoundit:\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->is_zip = 1;\n\tmydata->fname_len = fname_len;\n\text = strrchr(mydata->fname, '/');\n\n\tif (ext) {\n\t\tmydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);\n\t\tif (mydata->ext == ext) {\n\t\t\tmydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\t/* clean up on big-endian systems */\n\t/* seek to central directory */\n\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t/* read in central directory */\n\tzend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tentry.phar = mydata;\n\tentry.is_zip = 1;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n#define PHAR_ZIP_FAIL_FREE(errmsg, save) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.u.flags = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.u.flags = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.u.flags = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tzval_dtor(&mydata->metadata); \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\tefree(save); \\\n\t\t\treturn FAILURE;\n#define PHAR_ZIP_FAIL(errmsg) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.u.flags = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.u.flags = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.u.flags = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tzval_dtor(&mydata->metadata); \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\treturn FAILURE;\n\n\t/* add each central directory item to the manifest */\n\tfor (i = 0; i < PHAR_GET_16(locator.count); ++i) {\n\t\tphar_zip_central_dir_file zipentry;\n\t\tzend_off_t beforeus = php_stream_tell(fp);\n\n\t\tif (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {\n\t\t\tPHAR_ZIP_FAIL(\"unable to read central directory entry, truncated\");\n\t\t}\n\n\t\t/* clean up for bigendian systems */\n\t\tif (memcmp(\"PK\\1\\2\", zipentry.signature, 4)) {\n\t\t\t/* corrupted entry */\n\t\t\tPHAR_ZIP_FAIL(\"corrupted central directory entry, no magic signature\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = i;\n\t\t}\n\n\t\tentry.compressed_filesize = PHAR_GET_32(zipentry.compsize);\n\t\tentry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);\n\t\tentry.crc32 = PHAR_GET_32(zipentry.crc32);\n\t\t/* do not PHAR_GET_16 either on the next line */\n\t\tentry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);\n\t\tentry.flags = PHAR_ENT_PERM_DEF_FILE;\n\t\tentry.header_offset = PHAR_GET_32(zipentry.offset);\n\t\tentry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +\n\t\t\tPHAR_GET_16(zipentry.extra_len);\n\n\t\tif (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process encrypted zip files\");\n\t\t}\n\n\t\tif (!PHAR_GET_16(zipentry.filename_len)) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process zips created from stdin (zero-length filename)\");\n\t\t}\n\n\t\tentry.filename_len = PHAR_GET_16(zipentry.filename_len);\n\t\tentry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);\n\n\t\tif (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tPHAR_ZIP_FAIL(\"unable to read in filename from central directory, truncated\");\n\t\t}\n\n\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t\tif(entry.filename_len > 1) {\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tif (entry.filename_len == sizeof(\".phar/signature.bin\")-1 && !strncmp(entry.filename, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\tsize_t read;\n\t\t\tphp_stream *sigfile;\n\t\t\tzend_off_t now;\n\t\t\tchar *sig;\n\n\t\t\tnow = php_stream_tell(fp);\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tsigfile = php_stream_fopen_tmpfile();\n\t\t\tif (!sigfile) {\n\t\t\t\tPHAR_ZIP_FAIL(\"couldn't open temporary file\");\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t\t\t/* copy file contents + local headers and zip comment, if any, to be hashed for signature */\n\t\t\tphp_stream_copy_to_stream_ex(fp, sigfile, entry.header_offset, NULL);\n\t\t\t/* seek to central directory */\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t\t\t/* copy central directory header */\n\t\t\tphp_stream_copy_to_stream_ex(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);\n\t\t\tif (metadata) {\n\t\t\t\tphp_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));\n\t\t\t}\n\t\t\tphp_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t\tsig = (char *) emalloc(entry.uncompressed_filesize);\n\t\t\tread = php_stream_read(fp, sig, entry.uncompressed_filesize);\n\t\t\tif (read != entry.uncompressed_filesize || read <= 8) {\n\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\tefree(sig);\n\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be read\");\n\t\t\t}\n\t\t\tmydata->sig_flags = PHAR_GET_32(sig);\n\t\t\tif (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error)) {\n\t\t\t\tefree(sig);\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save;\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tspprintf(&save, 4096, \"signature cannot be verified: %s\", *error);\n\t\t\t\t\tefree(*error);\n\t\t\t\t\tPHAR_ZIP_FAIL_FREE(save, save);\n\t\t\t\t} else {\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be verified\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tphp_stream_close(sigfile);\n\t\t\tefree(sig);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (i != PHAR_GET_16(locator.count) - 1) {\n\t\t\t\tPHAR_ZIP_FAIL(\"entries exist after signature, invalid phar\");\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, entry.filename, entry.filename_len);\n\n\t\tif (PHAR_GET_16(zipentry.extra_len)) {\n\t\t\tzend_off_t loc = php_stream_tell(fp);\n\t\t\tif (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"Unable to process extra field header for file in central directory\");\n\t\t\t}\n\t\t\tphp_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t}\n\n\t\tswitch (PHAR_GET_16(zipentry.compressed)) {\n\t\t\tcase PHAR_ZIP_COMP_NONE :\n\t\t\t\t/* compression flag already set */\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_DEFLATE :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_GZ;\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"zlib extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_BZIP2 :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_BZ2;\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"bzip2 extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Shrunk) used in this zip\");\n\t\t\tcase 2 :\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Reduce) used in this zip\");\n\t\t\tcase 6 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Implode) used in this zip\");\n\t\t\tcase 7 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Tokenize) used in this zip\");\n\t\t\tcase 9 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Deflate64) used in this zip\");\n\t\t\tcase 10 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip\");\n\t\t\tcase 14 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (LZMA) used in this zip\");\n\t\t\tcase 18 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM TERSE) used in this zip\");\n\t\t\tcase 19 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM LZ77) used in this zip\");\n\t\t\tcase 97 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (WavPack) used in this zip\");\n\t\t\tcase 98 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PPMd) used in this zip\");\n\t\t\tdefault :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (unknown) used in this zip\");\n\t\t}\n\n\t\t/* get file metadata */\n\t\tif (PHAR_GET_16(zipentry.comment_len)) {\n\t\t\tif (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in file comment, truncated\");\n\t\t\t}\n\n\t\t\tp = buf;\n\t\t\tentry.metadata_len = PHAR_GET_16(zipentry.comment_len);\n\n\t\t\tif (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len)) == FAILURE) {\n\t\t\t\tentry.metadata_len = 0;\n\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\tZVAL_NEW_STR(&entry.metadata, zend_string_init(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent));\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_UNDEF(&entry.metadata);\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\tphp_stream_filter *filter;\n\t\t\tzend_off_t saveloc;\n\t\t\t/* verify local file header */\n\t\t\tphar_zip_file_header local;\n\n\t\t\t/* archive alias found */\n\t\t\tsaveloc = php_stream_tell(fp);\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);\n\n\t\t\tif (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (cannot read local file header for alias)\");\n\t\t\t}\n\n\t\t\t/* verify local header */\n\t\t\tif (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (local header of alias does not match central directory)\");\n\t\t\t}\n\n\t\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\t\tentry.offset = entry.offset_abs =\n\t\t\t\tsizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\t/* these next lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\t/* the above lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\n\t\t\tmydata->alias_len = entry.uncompressed_filesize;\n\t\t\tif (entry.flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", NULL, php_stream_is_persistent(fp));\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to decompress alias, zlib filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\t// TODO: refactor to avoid reallocation ???\n//???\t\t\tentry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)\n\t\t\t\t{\n\t\t\t\t\tzend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tentry.uncompressed_filesize = ZSTR_LEN(str);\n\t\t\t\t\t\tactual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));\n\t\t\t\t\t\tzend_string_release(str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactual_alias = NULL;\n\t\t\t\t\t\tentry.uncompressed_filesize = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!entry.uncompressed_filesize || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1);\n\n\t\t\t} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp));\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, bzip2 filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\t// TODO: refactor to avoid reallocation ???\n//???\t\t\tentry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)\n\t\t\t\t{\n\t\t\t\t\tzend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tentry.uncompressed_filesize = ZSTR_LEN(str);\n\t\t\t\t\t\tactual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));\n\t\t\t\t\t\tzend_string_release(str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactual_alias = NULL;\n\t\t\t\t\t\tentry.uncompressed_filesize = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!entry.uncompressed_filesize || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1);\n\t\t\t} else {\n\t\t\t\t// TODO: refactor to avoid reallocation ???\n//???\t\t\tentry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)\n\t\t\t\t{\n\t\t\t\t\tzend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tentry.uncompressed_filesize = ZSTR_LEN(str);\n\t\t\t\t\t\tactual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));\n\t\t\t\t\t\tzend_string_release(str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactual_alias = NULL;\n\t\t\t\t\t\tentry.uncompressed_filesize = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!entry.uncompressed_filesize || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* return to central directory parsing */\n\t\t\tphp_stream_seek(fp, saveloc, SEEK_SET);\n\t\t}\n\n\t\tphar_set_inode(&entry);\n\t\tzend_hash_str_add_mem(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry, sizeof(phar_entry_info));\n\t}\n\n\tmydata->fp = fp;\n\n\tif (zend_hash_str_exists(&(mydata->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmydata->is_data = 0;\n\t} else {\n\t\tmydata->is_data = 1;\n\t}\n\n\tzend_hash_str_add_ptr(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len, mydata);\n\n\tif (actual_alias) {\n\t\tphar_archive_data *fd_ptr;\n\n\t\tif (!phar_validate_alias(actual_alias, mydata->alias_len)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in zip-based phar \\\"%s\\\"\", actual_alias, fname);\n\t\t\t}\n\t\t\tefree(actual_alias);\n\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 0;\n\n\t\tif (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len))) {\n\t\t\tif (SUCCESS != phar_free_alias(fd_ptr, actual_alias, mydata->alias_len)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with implicit alias, alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tefree(actual_alias);\n\t\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;\n\n\t\tif (entry.is_persistent) {\n\t\t\tefree(actual_alias);\n\t\t}\n\n\t\tzend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);\n\t} else {\n\t\tphar_archive_data *fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {\n\t\t\t\tif (SUCCESS != phar_free_alias(fd_ptr, alias, alias_len)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with explicit alias, alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);\n\t\t\tmydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = alias_len;\n\t\t} else {\n\t\t\tmydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = fname_len;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1588,
    "critical_vars": [
      "packet_end"
    ],
    "function": "php_mysqlnd_rowp_read_text_protocol_aux",
    "filename": "php-src/CVE-2016-7412/CVE-2016-7412_CWE-119_28f80baf3c53e267c9ce46a2a0fadbb981585132_mysqlnd_wireprotocol.c.diff",
    "function_code": "enum_func_status\nphp_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, zend_bool copy_data, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\t\n\tunsigned int i;\n\tzend_bool last_field_was_string = FALSE;\n\tzval **current_field, **end_field, **start_field;\n\tzend_uchar * p = row_buffer->ptr;\n\tsize_t data_size = row_buffer->app;\n\tzend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1; /* we allocate from here */\n\tconst zend_uchar * const packet_end = (zend_uchar*) row_buffer->ptr + data_size;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_aux\");\n\n\tif (!fields) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tend_field = (start_field = fields) + field_count;\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tDBG_INF(\"Directly creating zval\");\n\t\tMAKE_STD_ZVAL(*current_field);\n\t\tif (!*current_field) {\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t}\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\t/* Don't reverse the order. It is significant!*/\n\t\tzend_uchar *this_field_len_pos = p;\n\t\t/* php_mysqlnd_net_field_length() call should be after *this_field_len_pos = p; */\n\t\tconst unsigned long len = php_mysqlnd_net_field_length(&p);\n\n\t\tif (len != MYSQLND_NULL_LENGTH && ((p + len) > packet_end)) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Malformed server packet. Field length pointing \"MYSQLND_SZ_T_SPEC\n\t\t\t\t\t\t\t\t\t\t\t  \" bytes after end of packet\", (p + len) - packet_end - 1);\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t\tif (copy_data == FALSE && current_field > start_field && last_field_was_string) {\n\t\t\t/*\n\t\t\t  Normal queries:\n\t\t\t  We have to put \\0 now to the end of the previous field, if it was\n\t\t\t  a string. IS_NULL doesn't matter. Because we have already read our\n\t\t\t  length, then we can overwrite it in the row buffer.\n\t\t\t  This statement terminates the previous field, not the current one.\n\n\t\t\t  NULL_LENGTH is encoded in one byte, so we can stick a \\0 there.\n\t\t\t  Any string's length is encoded in at least one byte, so we can stick\n\t\t\t  a \\0 there.\n\t\t\t*/\n\n\t\t\t*this_field_len_pos = '\\0';\n\t\t}\n\n\t\t/* NULL or NOT NULL, this is the question! */\n\t\tif (len == MYSQLND_NULL_LENGTH) {\n\t\t\tZVAL_NULL(*current_field);\n\t\t\tlast_field_was_string = FALSE;\n\t\t} else {\n#if defined(MYSQLND_STRING_TO_INT_CONVERSION)\n\t\t\tstruct st_mysqlnd_perm_bind perm_bind =\n\t\t\t\t\tmysqlnd_ps_fetch_functions[fields_metadata[i].type];\n#endif\n\t\t\tif (MYSQLND_G(collect_statistics)) {\n\t\t\t\tenum_mysqlnd_collected_stats statistic;\n\t\t\t\tswitch (fields_metadata[i].type) {\n\t\t\t\t\tcase MYSQL_TYPE_DECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT8; break;\n\t\t\t\t\tcase MYSQL_TYPE_SHORT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT16; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT32; break;\n\t\t\t\t\tcase MYSQL_TYPE_FLOAT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_FLOAT; break;\n\t\t\t\t\tcase MYSQL_TYPE_DOUBLE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DOUBLE; break;\n\t\t\t\t\tcase MYSQL_TYPE_NULL:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_NULL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\tstatistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONGLONG:\tstatistic = STAT_TEXT_TYPE_FETCHED_INT64; break;\n\t\t\t\t\tcase MYSQL_TYPE_INT24:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT24; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIME:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_TIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATETIME:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATETIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_YEAR:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_YEAR; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDATE:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_VARCHAR:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_BIT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BIT; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_ENUM:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_ENUM; break;\n\t\t\t\t\tcase MYSQL_TYPE_SET:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_SET; break;\n\t\t\t\t\tcase MYSQL_TYPE_JSON:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_JSON; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_BLOB:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_VAR_STRING:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_STRING:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_GEOMETRY:\tstatistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY; break;\n\t\t\t\t\tdefault: statistic = STAT_TEXT_TYPE_FETCHED_OTHER; break;\n\t\t\t\t}\n\t\t\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1, STAT_BYTES_RECEIVED_PURE_DATA_TEXT, len);\n\t\t\t}\n#ifdef MYSQLND_STRING_TO_INT_CONVERSION\n\t\t\tif (as_int_or_float && perm_bind.php_type == IS_LONG) {\n\t\t\t\tzend_uchar save = *(p + len);\n\t\t\t\t/* We have to make it ASCIIZ temporarily */\n\t\t\t\t*(p + len) = '\\0';\n\t\t\t\tif (perm_bind.pack_len < SIZEOF_LONG) {\n\t\t\t\t\t/* direct conversion */\n\t\t\t\t\tint64_t v =\n#ifndef PHP_WIN32\n\t\t\t\t\t\tatoll((char *) p);\n#else\n\t\t\t\t\t\t_atoi64((char *) p);\n#endif\n\t\t\t\t\tZVAL_LONG(*current_field, (long) v); /* the cast is safe */\n\t\t\t\t} else {\n\t\t\t\t\tuint64_t v =\n#ifndef PHP_WIN32\n\t\t\t\t\t\t(uint64_t) atoll((char *) p);\n#else\n\t\t\t\t\t\t(uint64_t) _atoi64((char *) p);\n#endif\n\t\t\t\t\tzend_bool uns = fields_metadata[i].flags & UNSIGNED_FLAG? TRUE:FALSE;\n\t\t\t\t\t/* We have to make it ASCIIZ temporarily */\n#if SIZEOF_LONG==8\n\t\t\t\t\tif (uns == TRUE && v > 9223372036854775807L)\n#elif SIZEOF_LONG==4\n\t\t\t\t\tif ((uns == TRUE && v > L64(2147483647)) ||\n\t\t\t\t\t\t(uns == FALSE && (( L64(2147483647) < (int64_t) v) ||\n\t\t\t\t\t\t(L64(-2147483648) > (int64_t) v))))\n#else\n#error Need fix for this architecture\n#endif /* SIZEOF */\n\t\t\t\t\t{\n\t\t\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_LONG(*current_field, (long) v); /* the cast is safe */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*(p + len) = save;\n\t\t\t} else if (as_int_or_float && perm_bind.php_type == IS_DOUBLE) {\n\t\t\t\tzend_uchar save = *(p + len);\n\t\t\t\t/* We have to make it ASCIIZ temporarily */\n\t\t\t\t*(p + len) = '\\0';\n\t\t\t\tZVAL_DOUBLE(*current_field, atof((char *) p));\n\t\t\t\t*(p + len) = save;\n\t\t\t} else\n#endif /* MYSQLND_STRING_TO_INT_CONVERSION */\n\t\t\tif (fields_metadata[i].type == MYSQL_TYPE_BIT) {\n\t\t\t\t/*\n\t\t\t\t  BIT fields are specially handled. As they come as bit mask, we have\n\t\t\t\t  to convert it to human-readable representation. As the bits take\n\t\t\t\t  less space in the protocol than the numbers they represent, we don't\n\t\t\t\t  have enough space in the packet buffer to overwrite inside.\n\t\t\t\t  Thus, a bit more space is pre-allocated at the end of the buffer,\n\t\t\t\t  see php_mysqlnd_rowp_read(). And we add the strings at the end.\n\t\t\t\t  Definitely not nice, _hackish_ :(, but works.\n\t\t\t\t*/\n\t\t\t\tzend_uchar *start = bit_area;\n\t\t\t\tps_fetch_from_1_to_8_bytes(*current_field, &(fields_metadata[i]), 0, &p, len TSRMLS_CC);\n\t\t\t\t/*\n\t\t\t\t  We have advanced in ps_fetch_from_1_to_8_bytes. We should go back because\n\t\t\t\t  later in this function there will be an advancement.\n\t\t\t\t*/\n\t\t\t\tp -= len;\n\t\t\t\tif (Z_TYPE_PP(current_field) == IS_LONG) {\n\t\t\t\t\tbit_area += 1 + sprintf((char *)start, \"%ld\", Z_LVAL_PP(current_field));\n\t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n\t\t\t\t} else if (Z_TYPE_PP(current_field) == IS_STRING){\n\t\t\t\t\tmemcpy(bit_area, Z_STRVAL_PP(current_field), Z_STRLEN_PP(current_field));\n\t\t\t\t\tbit_area += Z_STRLEN_PP(current_field);\n\t\t\t\t\t*bit_area++ = '\\0';\n\t\t\t\t\tzval_dtor(*current_field);\n\t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, copy_data);\n\t\t\t}\n\t\t\tp += len;\n\t\t\tlast_field_was_string = TRUE;\n\t\t}\n\t}\n\tif (copy_data == FALSE && last_field_was_string) {\n\t\t/* Normal queries: The buffer has one more byte at the end, because we need it */\n\t\trow_buffer->ptr[data_size] = '\\0';\n\t}\n\n\tDBG_RETURN(PASS);",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1292,
    "line_new": 1292,
    "critical_vars": [
      "len"
    ],
    "function": "getword",
    "filename": "ppp/CVE-2014-3158/CVE-2014-3158_CWE-119_7658e8257183f062dc01f87969c140707c7e52cb_options.c.diff",
    "function_code": "getword(f, word, newlinep, filename)\n    FILE *f;\n    char *word;\n    int *newlinep;\n    char *filename;\n{\n    int c, len, escape;\n    int quoted, comment;\n    int value, digit, got, n;\n\n#define isoctal(c) ((c) >= '0' && (c) < '8')\n\n    *newlinep = 0;\n    len = 0;\n    escape = 0;\n    comment = 0;\n    quoted = 0;\n\n    /*\n     * First skip white-space and comments.\n     */\n    for (;;) {\n\tc = getc(f);\n\tif (c == EOF)\n\t    break;\n\n\t/*\n\t * A newline means the end of a comment; backslash-newline\n\t * is ignored.  Note that we cannot have escape && comment.\n\t */\n\tif (c == '\\n') {\n\t    if (!escape) {\n\t\t*newlinep = 1;\n\t\tcomment = 0;\n\t    } else\n\t\tescape = 0;\n\t    continue;\n\t}\n\n\t/*\n\t * Ignore characters other than newline in a comment.\n\t */\n\tif (comment)\n\t    continue;\n\n\t/*\n\t * If this character is escaped, we have a word start.\n\t */\n\tif (escape)\n\t    break;\n\n\t/*\n\t * If this is the escape character, look at the next character.\n\t */\n\tif (c == '\\\\') {\n\t    escape = 1;\n\t    continue;\n\t}\n\n\t/*\n\t * If this is the start of a comment, ignore the rest of the line.\n\t */\n\tif (c == '#') {\n\t    comment = 1;\n\t    continue;\n\t}\n\n\t/*\n\t * A non-whitespace character is the start of a word.\n\t */\n\tif (!isspace(c))\n\t    break;\n    }\n\n    /*\n     * Process characters until the end of the word.\n     */\n    while (c != EOF) {\n\tif (escape) {\n\t    /*\n\t     * This character is escaped: backslash-newline is ignored,\n\t     * various other characters indicate particular values\n\t     * as for C backslash-escapes.\n\t     */\n\t    escape = 0;\n\t    if (c == '\\n') {\n\t        c = getc(f);\n\t\tcontinue;\n\t    }\n\n\t    got = 0;\n\t    switch (c) {\n\t    case 'a':\n\t\tvalue = '\\a';\n\t\tbreak;\n\t    case 'b':\n\t\tvalue = '\\b';\n\t\tbreak;\n\t    case 'f':\n\t\tvalue = '\\f';\n\t\tbreak;\n\t    case 'n':\n\t\tvalue = '\\n';\n\t\tbreak;\n\t    case 'r':\n\t\tvalue = '\\r';\n\t\tbreak;\n\t    case 's':\n\t\tvalue = ' ';\n\t\tbreak;\n\t    case 't':\n\t\tvalue = '\\t';\n\t\tbreak;\n\n\t    default:\n\t\tif (isoctal(c)) {\n\t\t    /*\n\t\t     * \\ddd octal sequence\n\t\t     */\n\t\t    value = 0;\n\t\t    for (n = 0; n < 3 && isoctal(c); ++n) {\n\t\t\tvalue = (value << 3) + (c & 07);\n\t\t\tc = getc(f);\n\t\t    }\n\t\t    got = 1;\n\t\t    break;\n\t\t}\n\n\t\tif (c == 'x') {\n\t\t    /*\n\t\t     * \\x<hex_string> sequence\n\t\t     */\n\t\t    value = 0;\n\t\t    c = getc(f);\n\t\t    for (n = 0; n < 2 && isxdigit(c); ++n) {\n\t\t\tdigit = toupper(c) - '0';\n\t\t\tif (digit > 10)\n\t\t\t    digit += '0' + 10 - 'A';\n\t\t\tvalue = (value << 4) + digit;\n\t\t\tc = getc (f);\n\t\t    }\n\t\t    got = 1;\n\t\t    break;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise the character stands for itself.\n\t\t */\n\t\tvalue = c;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Store the resulting character for the escape sequence.\n\t     */\n\t    if (len < MAXWORDLEN) {\n\t\tword[len] = value;\n\t\t++len;\n\t    }\n\n\t    if (!got)\n\t\tc = getc(f);\n\t    continue;\n\t}\n\n\t/*\n\t * Backslash starts a new escape sequence.\n\t */\n\tif (c == '\\\\') {\n\t    escape = 1;\n\t    c = getc(f);\n\t    continue;\n\t}\n\n\t/*\n\t * Not escaped: check for the start or end of a quoted\n\t * section and see if we've reached the end of the word.\n\t */\n\tif (quoted) {\n\t    if (c == quoted) {\n\t\tquoted = 0;\n\t\tc = getc(f);\n\t\tcontinue;\n\t    }\n\t} else if (c == '\"' || c == '\\'') {\n\t    quoted = c;\n\t    c = getc(f);\n\t    continue;\n\t} else if (isspace(c) || c == '#') {\n\t    ungetc (c, f);\n\t    break;\n\t}\n\n\t/*\n\t * An ordinary character: store it in the word and get another.\n\t */\n\tif (len < MAXWORDLEN) {\n\t    word[len] = c;\n\t    ++len;\n\t}\n\n\tc = getc(f);\n    }\n\n    /*\n     * End of the word: check for errors.\n     */\n    if (c == EOF) {\n\tif (ferror(f)) {\n\t    if (errno == 0)\n\t\terrno = EIO;\n\t    option_error(\"Error reading %s: %m\", filename);\n\t    die(1);\n\t}\n\t/*\n\t * If len is zero, then we didn't find a word before the\n\t * end of the file.\n\t */\n\tif (len == 0)\n\t    return 0;\n\tif (quoted)\n\t    option_error(\"warning: quoted word runs to end of file (%.20s...)\",\n\t\t\t filename, word);\n    }\n\n    /*\n     * Warn if the word was too long, and append a terminating null.\n     */\n    if (len >= MAXWORDLEN) {\n\toption_error(\"warning: word in file %s too long (%.20s...)\",\n\t\t     filename, word);\n\tlen = MAXWORDLEN - 1;\n    }\n    word[len] = 0;\n\n    return 1;\n\n#undef isoctal\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 300,
    "critical_vars": [
      "pkt->cnt"
    ],
    "function": "dumpppp",
    "filename": "ppp/CVE-2022-4603/CVE-2022-4603_CWE-119_a75fb7b198eed50d769c80c36629f38346882cbf_pppdump.c.diff",
    "function_code": "dumpppp(f)\n    FILE *f;\n{\n    int c, n, k;\n    int nb, nl, dn, proto, rv;\n    char *dir, *q;\n    unsigned char *p, *r, *endp;\n    unsigned char *d;\n    unsigned short fcs;\n    struct pkt *pkt;\n\n    spkt.cnt = rpkt.cnt = 0;\n    spkt.esc = rpkt.esc = 0;\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    dir = c==1? \"sent\": \"rcvd\";\n\t    pkt = c==1? &spkt: &rpkt;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tswitch (c) {\n\t\tcase EOF:\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    if (spkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete send packet]\\n\",\n\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tif (pkt->cnt >= sizeof(pkt->buf)) {\n\t\t\t    printf(\"%s over-long packet truncated:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    printf(\"\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tfcs = PPP_INITFCS;\n\t\t\tfor (k = 0; k < nb; ++k)\n\t\t\t    fcs = PPP_FCS(fcs, p[k]);\n\t\t\tfcs &= 0xFFFF;\n\t\t\tnb -= 2;\n\t\t\tendp = p + nb;\n\t\t\tr = p;\n\t\t\tif (r[0] == 0xff && r[1] == 3)\n\t\t\t    r += 2;\n\t\t\tif ((r[0] & 1) == 0)\n\t\t\t    ++r;\n\t\t\t++r;\n\t\t\tif (endp - r > mru)\n\t\t\t    printf(\"     ERROR: length (%zd) > MRU (%d)\\n\",\n\t\t\t\t   endp - r, mru);\n\t\t\tif (decompress && fcs == PPP_GOODFCS) {\n\t\t\t    /* See if this is a CCP or compressed packet */\n\t\t\t    d = dbuf;\n\t\t\t    r = p;\n\t\t\t    if (r[0] == 0xff && r[1] == 3) {\n\t\t\t\t*d++ = *r++;\n\t\t\t\t*d++ = *r++;\n\t\t\t    }\n\t\t\t    proto = r[0];\n\t\t\t    if ((proto & 1) == 0)\n\t\t\t\tproto = (proto << 8) + r[1];\n\t\t\t    if (proto == PPP_CCP) {\n\t\t\t\thandle_ccp(pkt, r + 2, endp - r - 2);\n\t\t\t    } else if (proto == PPP_COMP) {\n\t\t\t\tif ((pkt->flags & CCP_ISUP)\n\t\t\t\t    && (pkt->flags & CCP_DECOMP_RUN)\n\t\t\t\t    && pkt->state\n\t\t\t\t    && (pkt->flags & CCP_ERR) == 0) {\n\t\t\t\t    rv = pkt->comp->decompress(pkt->state, r,\n\t\t\t\t\t\t\tendp - r, d, &dn);\n\t\t\t\t    switch (rv) {\n\t\t\t\t    case DECOMP_OK:\n\t\t\t\t\tp = dbuf;\n\t\t\t\t\tnb = d + dn - p;\n\t\t\t\t\tif ((d[0] & 1) == 0)\n\t\t\t\t\t    --dn;\n\t\t\t\t\t--dn;\n\t\t\t\t\tif (dn > mru)\n\t\t\t\t\t    printf(\"     ERROR: decompressed length (%d) > MRU (%d)\\n\", dn, mru);\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_ERROR:\n\t\t\t\t\tprintf(\"     DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_FATALERROR:\n\t\t\t\t\tprintf(\"     FATAL DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_FATALERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } else if (pkt->state\n\t\t\t\t       && (pkt->flags & CCP_DECOMP_RUN)) {\n\t\t\t\tpkt->comp->incomp(pkt->state, r, endp - r);\n\t\t\t    }\n\t\t\t}\n\t\t\tdo {\n\t\t\t    nl = nb < 16? nb: 16;\n\t\t\t    printf(\"%s \", q);\n\t\t\t    for (k = 0; k < nl; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    for (; k < 16; ++k)\n\t\t\t\tprintf(\"   \");\n\t\t\t    printf(\"  \");\n\t\t\t    for (k = 0; k < nl; ++k) {\n\t\t\t\tc = p[k];\n\t\t\t\tputchar((' ' <= c && c <= '~')? c: '.');\n\t\t\t    }\n\t\t\t    printf(\"\\n\");\n\t\t\t    q = \"    \";\n\t\t\t    p += nl;\n\t\t\t    nb -= nl;\n\t\t\t} while (nb > 0);\n\t\t\tif (fcs != PPP_GOODFCS)\n\t\t\t    printf(\"     BAD FCS: (residue = %x)\\n\", fcs);\n\t\t    }\n\t\t    break;\n\t\tcase '}':\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    if (pkt->cnt < sizeof(pkt->buf))\n\t\t\tpkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;\n\t    printf(\"end %s\", dir);\n\t    if (pkt->cnt > 0)\n\t\tprintf(\"  [%d bytes in incomplete packet]\", pkt->cnt);\n\t    printf(\"\\n\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 403,
    "critical_vars": [
      "pkt->buf[pkt->cnt++]"
    ],
    "function": "dumpppp",
    "filename": "ppp/CVE-2022-4603/CVE-2022-4603_CWE-119_a75fb7b198eed50d769c80c36629f38346882cbf_pppdump.c.diff",
    "function_code": "dumpppp(f)\n    FILE *f;\n{\n    int c, n, k;\n    int nb, nl, dn, proto, rv;\n    char *dir, *q;\n    unsigned char *p, *r, *endp;\n    unsigned char *d;\n    unsigned short fcs;\n    struct pkt *pkt;\n\n    spkt.cnt = rpkt.cnt = 0;\n    spkt.esc = rpkt.esc = 0;\n    while ((c = getc(f)) != EOF) {\n\tswitch (c) {\n\tcase 1:\n\tcase 2:\n\t    if (reverse)\n\t\tc = 3 - c;\n\t    dir = c==1? \"sent\": \"rcvd\";\n\t    pkt = c==1? &spkt: &rpkt;\n\t    n = getc(f);\n\t    n = (n << 8) + getc(f);\n\t    *(c==1? &tot_sent: &tot_rcvd) += n;\n\t    for (; n > 0; --n) {\n\t\tc = getc(f);\n\t\tswitch (c) {\n\t\tcase EOF:\n\t\t    printf(\"\\nEOF\\n\");\n\t\t    if (spkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete send packet]\\n\",\n\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    printf(\"\\n\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tfcs = PPP_INITFCS;\n\t\t\tfor (k = 0; k < nb; ++k)\n\t\t\t    fcs = PPP_FCS(fcs, p[k]);\n\t\t\tfcs &= 0xFFFF;\n\t\t\tnb -= 2;\n\t\t\tendp = p + nb;\n\t\t\tr = p;\n\t\t\tif (r[0] == 0xff && r[1] == 3)\n\t\t\t    r += 2;\n\t\t\tif ((r[0] & 1) == 0)\n\t\t\t    ++r;\n\t\t\t++r;\n\t\t\tif (endp - r > mru)\n\t\t\t    printf(\"     ERROR: length (%zd) > MRU (%d)\\n\",\n\t\t\t\t   endp - r, mru);\n\t\t\tif (decompress && fcs == PPP_GOODFCS) {\n\t\t\t    /* See if this is a CCP or compressed packet */\n\t\t\t    d = dbuf;\n\t\t\t    r = p;\n\t\t\t    if (r[0] == 0xff && r[1] == 3) {\n\t\t\t\t*d++ = *r++;\n\t\t\t\t*d++ = *r++;\n\t\t\t    }\n\t\t\t    proto = r[0];\n\t\t\t    if ((proto & 1) == 0)\n\t\t\t\tproto = (proto << 8) + r[1];\n\t\t\t    if (proto == PPP_CCP) {\n\t\t\t\thandle_ccp(pkt, r + 2, endp - r - 2);\n\t\t\t    } else if (proto == PPP_COMP) {\n\t\t\t\tif ((pkt->flags & CCP_ISUP)\n\t\t\t\t    && (pkt->flags & CCP_DECOMP_RUN)\n\t\t\t\t    && pkt->state\n\t\t\t\t    && (pkt->flags & CCP_ERR) == 0) {\n\t\t\t\t    rv = pkt->comp->decompress(pkt->state, r,\n\t\t\t\t\t\t\tendp - r, d, &dn);\n\t\t\t\t    switch (rv) {\n\t\t\t\t    case DECOMP_OK:\n\t\t\t\t\tp = dbuf;\n\t\t\t\t\tnb = d + dn - p;\n\t\t\t\t\tif ((d[0] & 1) == 0)\n\t\t\t\t\t    --dn;\n\t\t\t\t\t--dn;\n\t\t\t\t\tif (dn > mru)\n\t\t\t\t\t    printf(\"     ERROR: decompressed length (%d) > MRU (%d)\\n\", dn, mru);\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_ERROR:\n\t\t\t\t\tprintf(\"     DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    case DECOMP_FATALERROR:\n\t\t\t\t\tprintf(\"     FATAL DECOMPRESSION ERROR\\n\");\n\t\t\t\t\tpkt->flags |= CCP_FATALERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } else if (pkt->state\n\t\t\t\t       && (pkt->flags & CCP_DECOMP_RUN)) {\n\t\t\t\tpkt->comp->incomp(pkt->state, r, endp - r);\n\t\t\t    }\n\t\t\t}\n\t\t\tdo {\n\t\t\t    nl = nb < 16? nb: 16;\n\t\t\t    printf(\"%s \", q);\n\t\t\t    for (k = 0; k < nl; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t\t    for (; k < 16; ++k)\n\t\t\t\tprintf(\"   \");\n\t\t\t    printf(\"  \");\n\t\t\t    for (k = 0; k < nl; ++k) {\n\t\t\t\tc = p[k];\n\t\t\t\tputchar((' ' <= c && c <= '~')? c: '.');\n\t\t\t    }\n\t\t\t    printf(\"\\n\");\n\t\t\t    q = \"    \";\n\t\t\t    p += nl;\n\t\t\t    nb -= nl;\n\t\t\t} while (nb > 0);\n\t\t\tif (fcs != PPP_GOODFCS)\n\t\t\t    printf(\"     BAD FCS: (residue = %x)\\n\", fcs);\n\t\t    }\n\t\t    break;\n\t\tcase '}':\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    pkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;\n\t    printf(\"end %s\", dir);\n\t    if (pkt->cnt > 0)\n\t\tprintf(\"  [%d bytes in incomplete packet]\", pkt->cnt);\n\t    printf(\"\\n\");\n\t    break;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t    show_time(f, c);\n\t    break;\n\tdefault:\n\t    printf(\"?%.2x\\n\", c);\n\t}\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 563,
    "critical_vars": [
      "pmonitor"
    ],
    "function": "privsep_preauth",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_sshd.c.diff",
    "function_code": "privsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t/* Set up unprivileged child process to deal with network data */\n\tpmonitor = monitor_init();\n\t/* Store a pointer to the kex for later rekeying */\n\tpmonitor->m_pkex = &active_state->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init();\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\n\t\t/* Sync memory */\n\t\tmonitor_sync(pmonitor);\n\n\t\t/* Wait for the child's exit status */\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t/* child */\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t/* Arrange for logging to be sent to the monitor */\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1975,
    "critical_vars": [
      "options.compression"
    ],
    "function": "do_ssh2_kex",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_sshd.c.diff",
    "function_code": "do_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t} else if (options.compression == COMP_DELAYED) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t\t    \"none,zlib@openssh.com\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    (time_t)options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tdispatch_run(DISPATCH_BLOCK, &kex->done, active_state);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2511,
    "critical_vars": [
      "r"
    ],
    "function": "newkeys_to_blob",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_packet.c.diff",
    "function_code": "newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t/* The cipher struct is constant and shared, you export pointer */\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2573,
    "critical_vars": [
      "ssh",
      "r",
      "m"
    ],
    "function": "ssh_packet_get_state",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_packet.c.diff",
    "function_code": "ssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tu_char *p;\n\tsize_t slen, rlen;\n\tint r, ssh1cipher;\n\n\tif (!compat20) {\n\t\tssh1cipher = cipher_ctx_get_number(state->receive_context);\n\t\tslen = cipher_get_keyiv_len(state->send_context);\n\t\trlen = cipher_get_keyiv_len(state->receive_context);\n\t\tif ((r = sshbuf_put_u32(m, state->remote_protocol_flags)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, ssh1cipher)) != 0 ||\n\t\t    (r = sshbuf_put_string(m, state->ssh1_key, state->ssh1_keylen)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, slen)) != 0 ||\n\t\t    (r = sshbuf_reserve(m, slen, &p)) != 0 ||\n\t\t    (r = cipher_get_keyiv(state->send_context, p, slen)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, rlen)) != 0 ||\n\t\t    (r = sshbuf_reserve(m, rlen, &p)) != 0 ||\n\t\t    (r = cipher_get_keyiv(state->receive_context, p, rlen)) != 0)\n\t\t\treturn r;\n\t} else {\n\t\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0)\n\t\t\treturn r;\n\t}\n\n\tslen = cipher_get_keycontext(state->send_context, NULL);\n\trlen = cipher_get_keycontext(state->receive_context, NULL);\n\tif ((r = sshbuf_put_u32(m, slen)) != 0 ||\n\t    (r = sshbuf_reserve(m, slen, &p)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state->send_context, p) != (int)slen)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((r = sshbuf_put_u32(m, rlen)) != 0 ||\n\t    (r = sshbuf_reserve(m, rlen, &p)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state->receive_context, p) != (int)rlen)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = ssh_packet_get_compress_state(m, ssh)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2628,
    "critical_vars": [
      "r"
    ],
    "function": "newkeys_from_blob",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_packet.c.diff",
    "function_code": "newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b = NULL;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey = NULL;\n\tsize_t keylen, ivlen, maclen;\n\tint r;\n\n\tif ((newkey = calloc(1, sizeof(*newkey))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\n\tif ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||\n\t    (r = sshbuf_get(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = mac_setup(mac, mac->name)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)\n\t\t\tgoto out;\n\t\tif (maclen > mac->key_len) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tmac->key_len = maclen;\n\t}\n\tif ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&comp->enabled)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)\n\t\tgoto out;\n\tif (enc->name == NULL ||\n\t    cipher_by_name(enc->name) != enc->cipher) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tenc->key_len = keylen;\n\tenc->iv_len = ivlen;\n\tssh->kex->newkeys[mode] = newkey;\n\tnewkey = NULL;\n\tr = 0;\n out:\n\tfree(newkey);\n\tsshbuf_free(b);\n\treturn r;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2756,
    "critical_vars": [
      "ssh",
      "r",
      "m"
    ],
    "function": "ssh_packet_set_state",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_packet.c.diff",
    "function_code": "ssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *ssh1key, *ivin, *ivout, *keyin, *keyout, *input, *output;\n\tsize_t ssh1keylen, rlen, slen, ilen, olen;\n\tint r;\n\tu_int ssh1cipher = 0;\n\n\tif (!compat20) {\n\t\tif ((r = sshbuf_get_u32(m, &state->remote_protocol_flags)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &ssh1cipher)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &ssh1key, &ssh1keylen)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &ivout, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &ivin, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (ssh1cipher > INT_MAX)\n\t\t\treturn SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tssh_packet_set_encryption_key(ssh, ssh1key, ssh1keylen,\n\t\t    (int)ssh1cipher);\n\t\tif (cipher_get_keyiv_len(state->send_context) != (int)slen ||\n\t\t    cipher_get_keyiv_len(state->receive_context) != (int)rlen)\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tif ((r = cipher_set_keyiv(state->send_context, ivout)) != 0 ||\n\t\t    (r = cipher_set_keyiv(state->receive_context, ivin)) != 0)\n\t\t\treturn r;\n\t} else {\n\t\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * We set the time here so that in post-auth privsep slave we\n\t\t * count from the completion of the authentication.\n\t\t */\n\t\tstate->rekey_time = monotime();\n\t\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\t\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_get_string_direct(m, &keyout, &slen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &keyin, &rlen)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state->send_context, NULL) != (int)slen ||\n\t    cipher_get_keycontext(state->receive_context, NULL) != (int)rlen)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tcipher_set_keycontext(state->send_context, keyout);\n\tcipher_set_keycontext(state->receive_context, keyin);\n\n\tif ((r = ssh_packet_set_compress_state(ssh, m)) != 0 ||\n\t    (r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1297,
    "critical_vars": [
      "options.compression"
    ],
    "function": "monitor_apply_keystate",
    "filename": "src/CVE-2016-10012/CVE-2016-10012_CWE-119_3095060f479b86288e31c79ecbc5131a66bcd2f9_monitor.c.diff",
    "function_code": "monitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t/* XXX */\n\tstruct kex *kex;\n\tint r;\n\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\n\tif ((kex = ssh->kex) != NULL) {\n\t\t/* XXX set callbacks */\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n\n\t/* Update with new address */\n\tif (options.compression) {\n\t\tssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 77,
    "line_new": 77,
    "critical_vars": [
      "ulen"
    ],
    "function": "Curl_auth_create_plain_message",
    "filename": "curl/CVE-2018-16839/CVE-2018-16839_CWE-119_f3a24d7916b9173c69a3e0ee790102993833d6c5_cleartext.c.diff",
    "function_code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  /* Compute binary message length. Check for overflows. */\n  if((ulen > SIZE_T_MAX/4) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Calculate the reply */\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n\n  /* Base64 encode the reply */\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n\n  return result;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 116,
    "critical_vars": [
      "ptr[1]"
    ],
    "function": "ourWriteOut",
    "filename": "curl/CVE-2017-7407/CVE-2017-7407_CWE-119_1890d59905414ab84a35892b2e45833654aa5c13_tool_writeout.c.diff",
    "function_code": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n    if('%' == *ptr && ptr[1]) {\n      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 162,
    "critical_vars": [
      "alloc"
    ],
    "function": "Curl_urldecode",
    "filename": "curl/CVE-2013-2174/CVE-2013-2174_CWE-119_192c4f788d48f82c03e9cef40013f34370e90737_escape.c.diff",
    "function_code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      /* this is two hexadecimal digits following a '%' */\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1601,
    "critical_vars": [
      "t1_buf",
      "t1_buf_array"
    ],
    "function": "t1_check_unusual_charstring",
    "filename": "texlive-source/CVE-2018-17407/CVE-2018-17407_CWE-119_6ed0077520e2b0da1fd060c7f88db7b2e6068e4c_writet1.c.diff",
    "function_code": "static void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /* if no number follows \"/CharStrings\", let's read the next line */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        /* pdftex_warn(\"no number found after `%s', I assume it's on the next line\",\n                    charstringname); */\n        strcpy(t1_buf_array, t1_line_array);\n\n        /* t1_getline always appends EOL to t1_line_array; let's change it to\n         * space before appending the next line\n         */\n        *(strend(t1_buf_array) - 1) = ' ';\n\n        t1_getline();\n        alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 780,
    "critical_vars": [
      "s"
    ],
    "function": "xmlrpc_char_encode",
    "filename": "atheme/CVE-2016-4478/CVE-2016-4478_CWE-119_87580d767868360d2fed503980129504da84b63e_xmlrpclib.c.diff",
    "function_code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\ts->append_char(s, 0);\n\n\tstrncpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 781,
    "critical_vars": [
      "s->str",
      "outbuffer"
    ],
    "function": "xmlrpc_char_encode",
    "filename": "atheme/CVE-2016-4478/CVE-2016-4478_CWE-119_87580d767868360d2fed503980129504da84b63e_xmlrpclib.c.diff",
    "function_code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 368,
    "critical_vars": [
      "*rbuff"
    ],
    "function": "squidclamav_check_preview_handler",
    "filename": "squidclamav/CVE-2012-3501/CVE-2012-3501_CWE-119_80f74451f628264d1d9a1f1c0bbcebc932ba5e00_squidclamav.c.diff",
    "function_code": "int squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req)\n{\n     ci_headers_list_t *req_header;\n     struct http_info httpinf;\n     av_req_data_t *data = ci_service_data(req); \n     char *clientip;\n     struct hostent *clientname;\n     unsigned long ip;\n     char *username;\n     char *content_type;\n     ci_off_t content_length;\n     char *chain_ret = NULL;\n     char *ret = NULL;\n     int chkipdone = 0;\n\n     ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: processing preview header.\\n\");\n\n     if (preview_data_len)\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\n\", preview_data_len);\n\n     /* Extract the HTTP header from the request */\n     if ((req_header = ci_http_request_headers(req)) == NULL) {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_ERROR;\n     }\n\n     /* Get the Authenticated user */\n     if ((username = ci_headers_value(req->request_header, \"X-Authenticated-User\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\n\", username);\n        /* if a TRUSTUSER match => no squidguard and no virus scan */\n        if (simple_pattern_compare(username, TRUSTUSER) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\n\", username);\n\t   return CI_MOD_ALLOW204;\n        }\n     } else {\n\t/* set null client to - */\n\tusername = (char *)malloc(sizeof(char)*2);\n\tstrcpy(username, \"-\");\n     }\n\n     /* Check client Ip against SquidClamav trustclient */\n     if ((clientip = ci_headers_value(req->request_header, \"X-Client-IP\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\n\", clientip);\n\tip = inet_addr(clientip);\n\tchkipdone = 0;\n\tif (dnslookup == 1) {\n\t\tif ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) {\n\t\t\tif (clientname->h_name != NULL) {\n\t\t\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\t\t\tif (client_pattern_compare(clientip, clientname->h_name) > 0) {\n\t\t\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\\n\", clientname->h_name, clientip);\n\t\t\t\t   return CI_MOD_ALLOW204;\n\t\t\t\t}\n\t\t\t\tchkipdone = 1;\n\t\t\t}\n\t\t  }\n\t}\n\tif (chkipdone == 0) {\n\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\tif (client_pattern_compare(clientip, NULL) > 0) {\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\\n\", clientip);\n\t\t   return CI_MOD_ALLOW204;\n\t\t}\n\t}\n     } else {\n\t/* set null client to - */\n\tclientip = (char *)malloc(sizeof(char)*2);\n\tstrcpy(clientip, \"-\");\n     }\n     \n     /* Get the requested URL */\n     if (!extract_http_info(req, req_header, &httpinf)) {\n\t/* Something wrong in the header or unknow method */\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tchar *rbuff = NULL;\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\t/* escaping escaped character to prevent unescaping by squidguard */\n\trbuff = replace(httpinf.url, \"%\", \"%25\");\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",rbuff,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\txfree(rbuff);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;\n\t\tgenerate_redirect_page(strtok(chain_ret, \" \"), req, data);\n\t        xfree(chain_ret);\n\t        chain_ret = NULL;\n\t        return CI_MOD_CONTINUE;\n\t   }\n\t   xfree(chain_ret);\n\t   chain_ret = NULL;\n\t}\n     }\n\n     /* CONNECT method (https) can not be scanned so abort */\n     if (strcmp(httpinf.method, \"CONNECT\") == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\\n\", httpinf.method);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Check the URL against SquidClamav abort */\n     if (simple_pattern_compare(httpinf.url, ABORT) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     /* Get the content length header */\n     content_length = ci_http_content_length(req);\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Length: %d\\n\", (int)content_length);\n\n     if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\\n\", content_length, (int)maxsize);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Get the content type header */\n     if ((content_type = http_content_type(req)) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Type: %s\\n\", content_type);\n        /* Check the Content-Type against SquidClamav abortcontent */\n        if (simple_pattern_compare(content_type, ABORTCONTENT)) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\\n\", content_type);\n\t   return CI_MOD_ALLOW204;\n        }\n     }\n\n     /* No data, so nothing to scan */\n     if (!data || !ci_req_hasbody(req)) {\n\t ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No body data, allow 204\\n\");\n          return CI_MOD_ALLOW204;\n     }\n\n     if (preview_data_len == 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     data->url = ci_buffer_alloc(strlen(httpinf.url)+1);\n     strcpy(data->url, httpinf.url);\n     if (username != NULL) {\n\t     data->user = ci_buffer_alloc(strlen(username)+1);\n\t     strcpy(data->user, username);\n     } else {\n\tdata->user = NULL;\n     }\n     if (clientip != NULL) {\n\tdata->clientip = ci_buffer_alloc(strlen(clientip)+1);\n\tstrcpy(data->clientip, clientip);\n     } else {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\\n\");\n\tdata->clientip = NULL;\n     }\n\n     data->body = ci_simple_file_new(0);\n     if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) {\n\tci_req_unlock_data(req);\n\tci_simple_file_lock_all(data->body);\n     }\n     if (!data->body)\n\treturn CI_ERROR;\n\n     if (preview_data_len) {\n\tif (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR)\n\t\treturn CI_ERROR;\n     }\n\n     return CI_MOD_CONTINUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 370,
    "critical_vars": [
      "httpinf.method",
      "username",
      "clientip",
      "sgfpw",
      "httpinf.url"
    ],
    "function": "squidclamav_check_preview_handler",
    "filename": "squidclamav/CVE-2012-3501/CVE-2012-3501_CWE-119_80f74451f628264d1d9a1f1c0bbcebc932ba5e00_squidclamav.c.diff",
    "function_code": "int squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req)\n{\n     ci_headers_list_t *req_header;\n     struct http_info httpinf;\n     av_req_data_t *data = ci_service_data(req); \n     char *clientip;\n     struct hostent *clientname;\n     unsigned long ip;\n     char *username;\n     char *content_type;\n     ci_off_t content_length;\n     char *chain_ret = NULL;\n     char *ret = NULL;\n     int chkipdone = 0;\n\n     ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: processing preview header.\\n\");\n\n     if (preview_data_len)\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\n\", preview_data_len);\n\n     /* Extract the HTTP header from the request */\n     if ((req_header = ci_http_request_headers(req)) == NULL) {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_ERROR;\n     }\n\n     /* Get the Authenticated user */\n     if ((username = ci_headers_value(req->request_header, \"X-Authenticated-User\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\n\", username);\n        /* if a TRUSTUSER match => no squidguard and no virus scan */\n        if (simple_pattern_compare(username, TRUSTUSER) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\n\", username);\n\t   return CI_MOD_ALLOW204;\n        }\n     } else {\n\t/* set null client to - */\n\tusername = (char *)malloc(sizeof(char)*2);\n\tstrcpy(username, \"-\");\n     }\n\n     /* Check client Ip against SquidClamav trustclient */\n     if ((clientip = ci_headers_value(req->request_header, \"X-Client-IP\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\n\", clientip);\n\tip = inet_addr(clientip);\n\tchkipdone = 0;\n\tif (dnslookup == 1) {\n\t\tif ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) {\n\t\t\tif (clientname->h_name != NULL) {\n\t\t\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\t\t\tif (client_pattern_compare(clientip, clientname->h_name) > 0) {\n\t\t\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\\n\", clientname->h_name, clientip);\n\t\t\t\t   return CI_MOD_ALLOW204;\n\t\t\t\t}\n\t\t\t\tchkipdone = 1;\n\t\t\t}\n\t\t  }\n\t}\n\tif (chkipdone == 0) {\n\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\tif (client_pattern_compare(clientip, NULL) > 0) {\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\\n\", clientip);\n\t\t   return CI_MOD_ALLOW204;\n\t\t}\n\t}\n     } else {\n\t/* set null client to - */\n\tclientip = (char *)malloc(sizeof(char)*2);\n\tstrcpy(clientip, \"-\");\n     }\n     \n     /* Get the requested URL */\n     if (!extract_http_info(req, req_header, &httpinf)) {\n\t/* Something wrong in the header or unknow method */\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",httpinf.url,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;\n\t\tgenerate_redirect_page(strtok(chain_ret, \" \"), req, data);\n\t        xfree(chain_ret);\n\t        chain_ret = NULL;\n\t        return CI_MOD_CONTINUE;\n\t   }\n\t   xfree(chain_ret);\n\t   chain_ret = NULL;\n\t}\n     }\n\n     /* CONNECT method (https) can not be scanned so abort */\n     if (strcmp(httpinf.method, \"CONNECT\") == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\\n\", httpinf.method);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Check the URL against SquidClamav abort */\n     if (simple_pattern_compare(httpinf.url, ABORT) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     /* Get the content length header */\n     content_length = ci_http_content_length(req);\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Length: %d\\n\", (int)content_length);\n\n     if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\\n\", content_length, (int)maxsize);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Get the content type header */\n     if ((content_type = http_content_type(req)) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Type: %s\\n\", content_type);\n        /* Check the Content-Type against SquidClamav abortcontent */\n        if (simple_pattern_compare(content_type, ABORTCONTENT)) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\\n\", content_type);\n\t   return CI_MOD_ALLOW204;\n        }\n     }\n\n     /* No data, so nothing to scan */\n     if (!data || !ci_req_hasbody(req)) {\n\t ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No body data, allow 204\\n\");\n          return CI_MOD_ALLOW204;\n     }\n\n     if (preview_data_len == 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     data->url = ci_buffer_alloc(strlen(httpinf.url)+1);\n     strcpy(data->url, httpinf.url);\n     if (username != NULL) {\n\t     data->user = ci_buffer_alloc(strlen(username)+1);\n\t     strcpy(data->user, username);\n     } else {\n\tdata->user = NULL;\n     }\n     if (clientip != NULL) {\n\tdata->clientip = ci_buffer_alloc(strlen(clientip)+1);\n\tstrcpy(data->clientip, clientip);\n     } else {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\\n\");\n\tdata->clientip = NULL;\n     }\n\n     data->body = ci_simple_file_new(0);\n     if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) {\n\tci_req_unlock_data(req);\n\tci_simple_file_lock_all(data->body);\n     }\n     if (!data->body)\n\treturn CI_ERROR;\n\n     if (preview_data_len) {\n\tif (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR)\n\t\treturn CI_ERROR;\n     }\n\n     return CI_MOD_CONTINUE;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 50,
    "line_new": 50,
    "critical_vars": [
      "out"
    ],
    "function": "ImagingPcdDecode",
    "filename": "Pillow/CVE-2016-2533/CVE-2016-2533_CWE-119_ae453aa18b66af54e7ff716f4ccb33adca60afd4_PcdDecode.c.diff",
    "function_code": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n\n    ptr = buf;\n\n    chunk = 3 * state->xsize;\n\n    for (;;) {\n\n\t/* We need data for two full lines before we can do anything */\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\n\t/* Unpack first line */\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 3;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1; /* This can hardly happen */\n\n\t/* Unpack second line */\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 3;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\n\tptr += chunk;\n\tbytes -= chunk;\n\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 188,
    "critical_vars": [
      "x"
    ],
    "function": "ImagingFliDecode",
    "filename": "Pillow/CVE-2016-0775/CVE-2016-0775_CWE-119_893a40850c2d5da41537958e40569c029a6e127b_FliDecode.c.diff",
    "function_code": "ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    UINT8* ptr;\n    int framesize;\n    int c, chunks;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4)\n\treturn 0;\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer (on the other hand, the Python part of the driver\n       makes sure this is always the case) */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr))\n\treturn 0;\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (I16(ptr+4) != 0xF1FA) {\n\tstate->errcode = IMAGING_CODEC_UNKNOWN;\n\treturn -1;\n    }\n\n    chunks = I16(ptr+6);\n    ptr += 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n\tUINT8 *data = ptr + 6;\n\tswitch (I16(ptr+4)) {\n\tcase 4: case 11:\n\t    /* FLI COLOR chunk */\n\t    break; /* ignored; handled by Python code */\n\tcase 7:\n\t    /* FLI SS2 chunk (word delta) */\n\t    lines = I16(data); data += 2;\n\t    for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n\t\tUINT8* buf = (UINT8*) im->image[y];\n\t\tint p, packets;\n\t\tpackets = I16(data); data += 2;\n\t\twhile (packets & 0x8000) {\n\t\t    /* flag word */\n\t\t    if (packets & 0x4000) {\n\t\t\ty += 65536 - packets; /* skip lines */\n\t\t\tif (y >= state->ysize) {\n\t\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t\t    return -1;\n\t\t\t}\n\t\t\tbuf = (UINT8*) im->image[y];\n\t\t    } else {\n\t\t\t/* store last byte (used if line width is odd) */\n\t\t\tbuf[state->xsize-1] = (UINT8) packets;\n\t\t    }\n\t\t    packets = I16(data); data += 2;\n\t\t}\n\t\tfor (p = x = 0; p < packets; p++) {\n\t\t    x += data[0]; /* pixel skip */\n\t\t    if (data[1] >= 128) {\n\t\t\ti = 256-data[1]; /* run */\n\t\t\tif (x + i + i > state->xsize)\n\t\t\t    break;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    buf[x++] = data[2];\n\t\t\t    buf[x++] = data[3];\n\t\t\t}\n\t\t\tdata += 2 + 2;\n\t\t    } else {\n\t\t\ti = 2 * (int) data[1]; /* chunk */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(buf + x, data + 2, i);\n\t\t\tdata += 2 + i;\n\t\t\tx += i;\n\t\t    }\n\t\t}\n\t\tif (p < packets)\n\t\t    break; /* didn't process all packets */\n\t    }\n\t    if (l < lines) {\n\t\t/* didn't process all lines */\n\t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 12:\n\t    /* FLI LC chunk (byte delta) */\n\t    y = I16(data); ymax = y + I16(data+2); data += 4;\n\t    for (; y < ymax && y < state->ysize; y++) {\n\t\tUINT8* out = (UINT8*) im->image[y];\n\t\tint p, packets = *data++;\n\t\tfor (p = x = 0; p < packets; p++, x += i) {\n\t\t    x += data[0]; /* skip pixels */\n\t\t    if (data[1] & 0x80) {\n\t\t\ti = 256-data[1]; /* run */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemset(out + x, data[2], i);\n\t\t\tdata += 3;\n\t\t    } else {\n\t\t\ti = data[1]; /* chunk */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(out + x, data + 2, i);\n\t\t\tdata += i + 2;\n\t\t    }\n\t\t}\n\t\tif (p < packets)\n\t\t    break; /* didn't process all packets */\n\t    }\n\t    if (y < ymax) {\n\t\t/* didn't process all lines */\n\t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 13:\n\t    /* FLI BLACK chunk */\n\t    for (y = 0; y < state->ysize; y++)\n\t\tmemset(im->image[y], 0, state->xsize);\n\t    break;\n\tcase 15:\n\t    /* FLI BRUN chunk */\n\t    for (y = 0; y < state->ysize; y++) {\n\t\tUINT8* out = (UINT8*) im->image[y];\n\t\tdata += 1; /* ignore packetcount byte */\n\t\tfor (x = 0; x < state->xsize; x += i) {\n\t\t    if (data[0] & 0x80) {\n\t\t\ti = 256 - data[0];\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break; /* safety first */\n\t\t\tmemcpy(out + x, data + 1, i);\n\t\t\tdata += i + 1;\n\t\t    } else {\n\t\t\ti = data[0];\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break; /* safety first */\n\t\t\tmemset(out + x, data[1], i);\n\t\t\tdata += 2;\n\t\t    }\n\t\t}\n\t\tif (x != state->xsize) {\n\t\t    /* didn't unpack whole line */\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    return -1;\n\t\t}\n\t    }\n\t    break;\n\tcase 16:\n\t    /* COPY chunk */\n\t    for (y = 0; y < state->ysize; y++) {\n\t\tUINT8* buf = (UINT8*) im->image[y];\n\t\tmemcpy(buf+x, data, state->xsize);\n\t\tdata += state->xsize;\n\t    }\n\t    break;\n\tcase 18:\n\t    /* PSTAMP chunk */\n\t    break; /* ignored */\n\tdefault:\n\t    /* unknown chunk */\n\t    /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n\t    state->errcode = IMAGING_CODEC_UNKNOWN;\n\t    return -1;\n\t}\n\tptr += I32(ptr);\n    }\n\n    return -1; /* end of frame */\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 142,
    "critical_vars": [
      "kmax",
      "xsize"
    ],
    "function": "ImagingResampleHorizontal",
    "filename": "Pillow/CVE-2016-4009/CVE-2016-4009_CWE-119_4e0d9b0b9740d258ade40cce248c93777362ac1e_Resample.c.diff",
    "function_code": "ImagingResampleHorizontal(Imaging imIn, int xsize, int filter)\n{\n    ImagingSectionCookie cookie;\n    Imaging imOut;\n    struct filter *filterp;\n    float support, scale, filterscale;\n    float center, ww, ss, ss0, ss1, ss2, ss3;\n    int xx, yy, x, kmax, xmin, xmax;\n    int *xbounds;\n    float *k, *kk;\n\n    /* check filter */\n    switch (filter) {\n    case IMAGING_TRANSFORM_LANCZOS:\n        filterp = &LANCZOS;\n        break;\n    case IMAGING_TRANSFORM_BILINEAR:\n        filterp = &BILINEAR;\n        break;\n    case IMAGING_TRANSFORM_BICUBIC:\n        filterp = &BICUBIC;\n        break;\n    default:\n        return (Imaging) ImagingError_ValueError(\n            \"unsupported resampling filter\"\n            );\n    }\n\n    /* prepare for horizontal stretch */\n    filterscale = scale = (float) imIn->xsize / xsize;\n\n    /* determine support size (length of resampling filter) */\n    support = filterp->support;\n\n    if (filterscale < 1.0) {\n        filterscale = 1.0;\n    }\n\n    support = support * filterscale;\n\n    /* maximum number of coofs */\n    kmax = (int) ceil(support) * 2 + 1;\n\n    // check for overflow\n    if (kmax > 0 && xsize > SIZE_MAX / kmax)\n        return (Imaging) ImagingError_MemoryError();\n\n    // sizeof(float) should be greater than 0\n    if (xsize * kmax > SIZE_MAX / sizeof(float))\n        return (Imaging) ImagingError_MemoryError();\n\n    /* coefficient buffer */\n    kk = malloc(xsize * kmax * sizeof(float));\n    if ( ! kk)\n        return (Imaging) ImagingError_MemoryError();\n\n    // sizeof(int) should be greater than 0 as well\n    if (xsize > SIZE_MAX / (2 * sizeof(int)))\n        return (Imaging) ImagingError_MemoryError();\n\n    xbounds = malloc(xsize * 2 * sizeof(int));\n    if ( ! xbounds) {\n        free(kk);\n        return (Imaging) ImagingError_MemoryError();\n    }\n\n    for (xx = 0; xx < xsize; xx++) {\n        k = &kk[xx * kmax];\n        center = (xx + 0.5) * scale;\n        ww = 0.0;\n        ss = 1.0 / filterscale;\n        xmin = (int) floor(center - support);\n        if (xmin < 0)\n            xmin = 0;\n        xmax = (int) ceil(center + support);\n        if (xmax > imIn->xsize)\n            xmax = imIn->xsize;\n        for (x = xmin; x < xmax; x++) {\n            float w = filterp->filter((x - center + 0.5) * ss) * ss;\n            k[x - xmin] = w;\n            ww += w;\n        }\n        for (x = 0; x < xmax - xmin; x++) {\n            if (ww != 0.0)\n                k[x] /= ww;\n        }\n        xbounds[xx * 2 + 0] = xmin;\n        xbounds[xx * 2 + 1] = xmax;\n    }\n\n    imOut = ImagingNew(imIn->mode, xsize, imIn->ysize);\n    if ( ! imOut) {\n        free(kk);\n        free(xbounds);\n        return NULL;\n    }\n\n    ImagingSectionEnter(&cookie);\n    /* horizontal stretch */\n    for (yy = 0; yy < imOut->ysize; yy++) {\n        if (imIn->image8) {\n            /* 8-bit grayscale */\n            for (xx = 0; xx < xsize; xx++) {\n                xmin = xbounds[xx * 2 + 0];\n                xmax = xbounds[xx * 2 + 1];\n                k = &kk[xx * kmax];\n                ss = 0.5;\n                for (x = xmin; x < xmax; x++)\n                    ss += i2f(imIn->image8[yy][x]) * k[x - xmin];\n                imOut->image8[yy][xx] = clip8(ss);\n            }\n        } else {\n            switch(imIn->type) {\n            case IMAGING_TYPE_UINT8:\n                /* n-bit grayscale */\n                if (imIn->bands == 2) {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 3] = clip8(ss1);\n                    }\n                } else if (imIn->bands == 3) {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = ss2 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin];\n                            ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 1] = clip8(ss1);\n                        imOut->image[yy][xx*4 + 2] = clip8(ss2);\n                    }\n                } else {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = ss2 = ss3 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin];\n                            ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin];\n                            ss3 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 1] = clip8(ss1);\n                        imOut->image[yy][xx*4 + 2] = clip8(ss2);\n                        imOut->image[yy][xx*4 + 3] = clip8(ss3);\n                    }\n                }\n                break;\n            case IMAGING_TYPE_INT32:\n                /* 32-bit integer */\n                for (xx = 0; xx < xsize; xx++) {\n                    xmin = xbounds[xx * 2 + 0];\n                    xmax = xbounds[xx * 2 + 1];\n                    k = &kk[xx * kmax];\n                    ss = 0.0;\n                    for (x = xmin; x < xmax; x++)\n                        ss += i2f(IMAGING_PIXEL_I(imIn, x, yy)) * k[x - xmin];\n                    IMAGING_PIXEL_I(imOut, xx, yy) = (int) ss;\n                }\n                break;\n            case IMAGING_TYPE_FLOAT32:\n                /* 32-bit float */\n                for (xx = 0; xx < xsize; xx++) {\n                    xmin = xbounds[xx * 2 + 0];\n                    xmax = xbounds[xx * 2 + 1];\n                    k = &kk[xx * kmax];\n                    ss = 0.0;\n                    for (x = xmin; x < xmax; x++)\n                        ss += IMAGING_PIXEL_F(imIn, x, yy) * k[x - xmin];\n                    IMAGING_PIXEL_F(imOut, xx, yy) = ss;\n                }\n                break;\n            }\n        }\n    }\n    ImagingSectionLeave(&cookie);\n    free(kk);\n    free(xbounds);\n    return imOut;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 53,
    "critical_vars": [
      "decoder_info->log2_sb_size"
    ],
    "function": "read_sequence_header",
    "filename": "thor/CVE-2018-0429/CVE-2018-0429_CWE-119_18de8f9f0762c3a542b1122589edb8af859d9813_read_bits.c.diff",
    "function_code": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = // 0: 400  1: 420  2: 422  3: 444\n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 755,
    "critical_vars": [
      "huffcdic->index_count"
    ],
    "function": "mobi_parse_huffdic",
    "filename": "libmobi/CVE-2021-3888/CVE-2021-3888_CWE-119_c78e186739b50d156cb3da5d08d70294f0490853_read.c.diff",
    "function_code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 144,
    "critical_vars": [
      "code_length"
    ],
    "function": "mobi_decompress_huffman_internal",
    "filename": "libmobi/CVE-2021-3889/CVE-2021-3889_CWE-119_bec783e6212439a335ba6e8df7ab8ed610ca9a21_compression.c.diff",
    "function_code": "static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 144,
    "critical_vars": [
      "code_length"
    ],
    "function": "mobi_decompress_huffman_internal",
    "filename": "libmobi/CVE-2021-3889/CVE-2021-3889_CWE-119_bec783e6212439a335ba6e8df7ab8ed610ca9a21_compression.c.diff",
    "function_code": "static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                if (++code_length >= HUFF_CODETABLE_SIZE) {\n                    debug_print(\"Wrong offset to mincode table: %hhu\\n\", code_length);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 902,
    "critical_vars": [
      "l"
    ],
    "function": "vbf_stp_error",
    "filename": "varnish-cache/CVE-2017-8807/CVE-2017-8807_CWE-119_176f8a075a963ffbfa56f1c460c15f6a1a6af5a7_cache_fetch.c.diff",
    "function_code": "vbf_stp_error(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l, ll, o;\n\tdouble now;\n\tuint8_t *ptr;\n\tstruct vsb *synth_body;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\tAN(bo->fetch_objcore->flags & OC_F_BUSY);\n\tassert(bo->director_state == DIR_S_NULL);\n\n\twrk->stats->fetch_failed++;\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Error\", now);\n\n\tif (bo->fetch_objcore->stobj->stevedore != NULL)\n\t\tObjFreeObj(bo->wrk, bo->fetch_objcore);\n\n\t// XXX: reset all beresp flags ?\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\thttp_PutResponse(bo->beresp, \"HTTP/1.1\", 503, \"Backend fetch failed\");\n\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\thttp_SetHeader(bo->beresp, \"Server: Varnish\");\n\n\tbo->fetch_objcore->t_origin = now;\n\tif (!VTAILQ_EMPTY(&bo->fetch_objcore->objhead->waitinglist)) {\n\t\t/*\n\t\t * If there is a waitinglist, it means that there is no\n\t\t * grace-able object, so cache the error return for a\n\t\t * short time, so the waiting list can drain, rather than\n\t\t * each objcore on the waiting list sequentially attempt\n\t\t * to fetch from the backend.\n\t\t */\n\t\tbo->fetch_objcore->ttl = 1;\n\t\tbo->fetch_objcore->grace = 5;\n\t\tbo->fetch_objcore->keep = 5;\n\t} else {\n\t\tbo->fetch_objcore->ttl = 0;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t}\n\n\tsynth_body = VSB_new_auto();\n\tAN(synth_body);\n\n\tVCL_backend_error_method(bo->vcl, wrk, NULL, bo, synth_body);\n\n\tAZ(VSB_finish(synth_body));\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tVSB_destroy(&synth_body);\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\t\tVSLb(bo->vsl, SLT_VCL_Error, \"Too many retries, failing\");\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tll = VSB_len(synth_body);\n\to = 0;\n\twhile (ll > 0) {\n\t\tl = ll;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n\t\t\tbreak;\n\t\tif (l > ll)\n\t\t\tl = ll;\n\t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tll -= l;\n\t\to += l;\n\t}\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN, o));\n\tVSB_destroy(&synth_body);\n\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\treturn (F_STP_DONE);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 854,
    "critical_vars": [
      "packet"
    ],
    "function": "sec_recv",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_secure.c.diff",
    "function_code": "sec_recv(RD_BOOL * is_fastpath)\n{\n\tuint8 fastpath_hdr, fastpath_flags;\n\tuint16 sec_flags;\n\tuint16 channel;\n\tSTREAM s;\n\tstruct stream packet;\n\n\twhile ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)\n\t{\n\t\tpacket = *s;\n\t\tif (*is_fastpath == True)\n\t\t{\n\t\t\t/* If fastpath packet is encrypted, read data\n\t\t\t   signature and decrypt */\n\t\t\t/* FIXME: extracting flags from hdr could be made less obscure */\n\t\t\tfastpath_flags = (fastpath_hdr & 0xC0) >> 6;\n\t\t\tif (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)\n\t\t\t{\n\t\t\t\tif (!s_check_rem(s, 8)) {\n\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume fastpath signature from stream would overrun\", &packet);\n\t\t\t\t}\n\n\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tif (g_encryption || (!g_licence_issued && !g_licence_error_result))\n\t\t{\n\t\t\t/* TS_SECURITY_HEADER */\n\t\t\tin_uint16_le(s, sec_flags);\n\t\t\tin_uint8s(s, 2);\t/* skip sec_flags_hi */\n\n\t\t\tif (g_encryption)\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t\t\t{\n\t\t\t\t\tif (!s_check_rem(s, 8)) {\n\t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume encrypt signature from stream would overrun\", &packet);\n\t\t\t\t\t}\n\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_REDIRECTION_PKT)\n\t\t\t\t{\n\t\t\t\t\tuint8 swapbyte;\n\n\t\t\t\t\tif (!s_check_rem(s, 8)) {\n\t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume redirect signature from stream would overrun\", &packet);\n\t\t\t\t\t}\n\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\n\t\t\t\t\t/* Check for a redirect packet, starts with 00 04 */\n\t\t\t\t\tif (s->p[0] == 0 && s->p[1] == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* for some reason the PDU and the length seem to be swapped.\n\t\t\t\t\t\t   This isn't good, but we're going to do a byte for byte\n\t\t\t\t\t\t   swap.  So the first four value appear as: 00 04 XX YY,\n\t\t\t\t\t\t   where XX YY is the little endian length. We're going to\n\t\t\t\t\t\t   use 04 00 as the PDU type, so after our swap this will look\n\t\t\t\t\t\t   like: XX YY 04 00 */\n\t\t\t\t\t\tswapbyte = s->p[0];\n\t\t\t\t\t\ts->p[0] = s->p[2];\n\t\t\t\t\t\ts->p[2] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[1];\n\t\t\t\t\t\ts->p[1] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[2];\n\t\t\t\t\t\ts->p[2] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts->p -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (channel != MCS_GLOBAL_CHANNEL)\n\t\t{\n\t\t\tchannel_process(s, channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 121,
    "critical_vars": [
      "packet"
    ],
    "function": "cliprdr_process",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_cliprdr.c.diff",
    "function_code": "cliprdr_process(STREAM s)\n{\n\tuint16 type, status;\n\tuint32 length, format;\n\tuint8 *data;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, type);\n\tin_uint16_le(s, status);\n\tin_uint32_le(s, length);\n\tdata = s->p;\n\n\tlogger(Clipboard, Debug, \"cliprdr_process(), type=%d, status=%d, length=%d\", type, status,\n\t       length);\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"cliprdr_process(), consume of packet from stream would overrun\", &packet);\n\t}\n\n\tif (status == CLIPRDR_ERROR)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\t\t/* FIXME: We seem to get this when we send an announce while the server is\n\t\t\t\t   still processing a paste. Try sending another announce. */\n\t\t\t\tcliprdr_send_native_format_announce(last_formats,\n\t\t\t\t\t\t\t\t    last_formats_length);\n\t\t\t\tbreak;\n\t\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\t\tui_clip_request_failed();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Clipboard, Warning,\n\t\t\t\t       \"cliprdr_process(), unhandled error (type=%d)\", type);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase CLIPRDR_CONNECT:\n\t\t\tui_clip_sync();\n\t\t\tbreak;\n\t\tcase CLIPRDR_FORMAT_ANNOUNCE:\n\t\t\tui_clip_format_announce(data, length);\n\t\t\tcliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);\n\t\t\treturn;\n\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_REQUEST:\n\t\t\tin_uint32_le(s, format);\n\t\t\tui_clip_request_data(format);\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\tui_clip_handle_data(data, length);\n\t\t\tbreak;\n\t\tcase 7:\t/* TODO: W2K3 SP1 sends this on connect with a value of 1 */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Clipboard, Warning, \"cliprdr_process(), unhandled packet type %d\",\n\t\t\t       type);\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1262,
    "critical_vars": [
      "packet"
    ],
    "function": "process_secondary_order",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_orders.c.diff",
    "function_code": "process_secondary_order(STREAM s)\n{\n\t/* The length isn't calculated correctly by the server.\n\t * For very compact orders the length becomes negative\n\t * so a signed integer must be used. */\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t/* used by bmpcache2 */\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t/* uncompressed */\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t/* compressed */\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 797,
    "critical_vars": [
      "indexw"
    ],
    "function": "process_plane",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_bitmap.c.diff",
    "function_code": "process_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 92,
    "line_new": 99,
    "critical_vars": [
      "length"
    ],
    "function": "mcs_recv_connect_response",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_mcs.c.diff",
    "function_code": "mcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t/* connect id */\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t/*\n\t   if (length > mcs_data->size)\n\t   {\n\t   logger(Protocol, Error, \"mcs_recv_connect_response(), expected length=%d, got %d\",length, mcs_data->size);\n\t   length = mcs_data->size;\n\t   }\n\n\t   in_uint8a(s, mcs_data->data, length);\n\t   mcs_data->p = mcs_data->data;\n\t   mcs_data->end = mcs_data->data + length;\n\t */\n\treturn s_check_end(s);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 288,
    "critical_vars": [
      "packet"
    ],
    "function": "rdp_in_unistr",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_rdp.c.diff",
    "function_code": "rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n{\n\tstatic iconv_t icv_utf16_to_local;\n\tsize_t ibl, obl;\n\tchar *pin, *pout;\n\n\tstruct stream packet = *s;\n\n\tif ((in_len < 0) || ((uint32)in_len >= (RD_UINT32_MAX / 2)))\n\t{\n\t\tlogger(Protocol, Error, \"rdp_in_unistr(), length of unicode data is out of bounds.\");\n\t\tabort();\n\t}\n\n\tif (!s_check_rem(s, in_len))\n\t{\n\t\trdp_protocol_error(\"rdp_in_unistr(), consume of unicode data from stream would overrun\", &packet);\n\t}\n\n\t// if not already open\n\tif (!icv_utf16_to_local)\n\t{\n\t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);\n\t\tif (icv_utf16_to_local == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);\n\t\t\tabort();\n\t\t}\n\t}\n\n\t/* Dynamic allocate of destination string if not provided */\n\tif (*string == NULL)\n\t{\n\n\t\t*string = xmalloc(in_len * 2);\n\t\t*str_size = in_len * 2;\n\t}\n\n\tibl = in_len;\n\tobl = *str_size - 1;\n\tpin = (char *) s->p;\n\tpout = *string;\n\n\tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tif (errno == E2BIG)\n\t\t{\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);\n\n\t\t\tfree(*string);\n\t\t\t*string = NULL;\n\t\t\t*str_size = 0;\n\t\t}\n\t\tabort();\n\t}\n\n\t/* we must update the location of the current STREAM for future reads of s->p */\n\ts->p += in_len;\n\n\t*pout = 0;\n\n\tif (*string)\n\t\t*str_size = pout - *string;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1227,
    "critical_vars": [
      "packet"
    ],
    "function": "process_demand_active",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_rdp.c.diff",
    "function_code": "process_demand_active(STREAM s)\n{\n\tuint8 type;\n\tuint16 len_src_descriptor, len_combined_caps;\n\tstruct stream packet = *s;\n\n\t/* at this point we need to ensure that we have ui created */\n\trd_create_ui();\n\n\tin_uint32_le(s, g_rdp_shareid);\n\tin_uint16_le(s, len_src_descriptor);\n\tin_uint16_le(s, len_combined_caps);\n\n\tif (!s_check_rem(s, len_src_descriptor))\n\t{\n\t\trdp_protocol_error(\"rdp_demand_active(), consume of source descriptor from stream would overrun\", &packet);\n\t}\n\tin_uint8s(s, len_src_descriptor);\n\n\tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);\n\n\trdp_process_server_caps(s, len_combined_caps);\n\n\trdp_send_confirm_active();\n\trdp_send_synchronise();\n\trdp_send_control(RDP_CTL_COOPERATE);\n\trdp_send_control(RDP_CTL_REQUEST_CONTROL);\n\trdp_recv(&type);\t/* RDP_PDU_SYNCHRONIZE */\n\trdp_recv(&type);\t/* RDP_CTL_COOPERATE */\n\trdp_recv(&type);\t/* RDP_CTL_GRANT_CONTROL */\n\trdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,\n\t\t       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_enum_bmpcache2();\n\t\trdp_send_fonts(3);\n\t}\n\telse\n\t{\n\t\trdp_send_fonts(1);\n\t\trdp_send_fonts(2);\n\t}\n\n\trdp_recv(&type);\t/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */\n\treset_order_state();\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 857,
    "critical_vars": [
      "packet"
    ],
    "function": "rdpdr_process",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_rdpdr.c.diff",
    "function_code": "rdpdr_process(STREAM s)\n{\n\tuint32 handle;\n\tuint16 vmin;\n\tuint16 component;\n\tuint16 pakid;\n\tstruct stream packet = *s;\n\n\tlogger(Protocol, Debug, \"rdpdr_process()\");\n\t/* hexdump(s->p, s->end - s->p); */\n\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n\t\t\t\t/* DR_CORE_SERVER_ANNOUNCE_REQ */\n\t\t\t\tin_uint8s(s, 2);\t/* skip versionMajor */\n\t\t\t\tin_uint16_le(s, vmin);\t/* VersionMinor */\n\n\t\t\t\tin_uint32_le(s, g_client_id);\t/* ClientID */\n\n\t\t\t\t/* g_client_id is sent back to server,\n\t\t\t\t   so lets check that we actually got\n\t\t\t\t   valid data from stream to prevent\n\t\t\t\t   that we leak back data to server */\n\t\t\t\tif (!s_check(s))\n\t\t\t\t{\n\t\t\t\t\trdp_protocol_error(\"rdpdr_process(), consume of g_client_id from stream did overrun\", &packet);\n\t\t\t\t}\n\n\t\t\t\t/* The RDP client is responsibility to provide a random client id\n\t\t\t\t   if server version is < 12 */\n\t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t/* IP address (use 127.0.0.1) 0x815ed39d */\n\t\t\t\tg_epoch++;\n\n#if WITH_SCARD\n\t\t\t\t/*\n\t\t\t\t * We need to release all SCARD contexts to end all\n\t\t\t\t * current transactions and pending calls\n\t\t\t\t */\n\t\t\t\tscard_release_all_contexts();\n\n\t\t\t\t/*\n\t\t\t\t * According to [MS-RDPEFS] 3.2.5.1.2:\n\t\t\t\t *\n\t\t\t\t * If this packet appears after a sequence of other packets,\n\t\t\t\t * it is a signal that the server has reconnected to a new session\n\t\t\t\t * and the whole sequence has been reset. The client MUST treat\n\t\t\t\t * this packet as the beginning of a new sequence.\n\t\t\t\t * The client MUST also cancel all outstanding requests and release\n\t\t\t\t * previous references to all devices.\n\t\t\t\t *\n\t\t\t\t * If any problem arises in the future, please, pay attention to the\n\t\t\t\t * \"If this packet appears after a sequence of other packets\" part\n\t\t\t\t *\n\t\t\t\t */\n\n#endif\n\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 598,
    "critical_vars": [
      "packet"
    ],
    "function": "cssp_read_tsrequest",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_cssp.c.diff",
    "function_code": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\tstruct stream packet;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\t// peek at first 4 bytes to get full message length\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\tpacket = *s;\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n\t\t\t\t    &packet);\n\t}\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tif (!s_check_rem(s, length))\n\t\t{\n\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n\t\t\t\t\t   &packet);\n\t\t}\n\n\t\ts_realloc(token, length);\n\t\ts_reset(token);\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 656,
    "critical_vars": [
      "token->end"
    ],
    "function": "cssp_read_tsrequest",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_cssp.c.diff",
    "function_code": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\t// peek at first 4 bytes to get full message length\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 174,
    "critical_vars": [
      "Protocol",
      "Warning"
    ],
    "function": "seamless_process_line",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_seamless.c.diff",
    "function_code": "seamless_process_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tchar *p, *l;\n\tchar *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;\n\tunsigned long id, flags;\n\tchar *endptr;\n\n\tl = xstrdup(line);\n\tp = l;\n\n\tlogger(Core, Debug, \"seamless_process_line(), got '%s'\", p);\n\n\ttok1 = seamless_get_token(&p);\n\t(void) seamless_get_token(&p);\n\ttok3 = seamless_get_token(&p);\n\ttok4 = seamless_get_token(&p);\n\ttok5 = seamless_get_token(&p);\n\ttok6 = seamless_get_token(&p);\n\ttok7 = seamless_get_token(&p);\n\ttok8 = seamless_get_token(&p);\n\n\tif (!strcmp(\"CREATE\", tok1))\n\t{\n\t\tunsigned long group, parent;\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tgroup = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tparent = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_create_window(id, group, parent, flags);\n\t}\n\telse if (!strcmp(\"DESTROY\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_window(id, flags);\n\n\t}\n\telse if (!strcmp(\"DESTROYGRP\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_group(id, flags);\n\t}\n\telse if (!strcmp(\"SETICON\", tok1))\n\t{\n\t\tint chunk, width, height, len;\n\t\tchar byte[3];\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tchunk = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbyte[2] = '\\0';\n\t\tlen = 0;\n\t\twhile (*tok8 != '\\0')\n\t\t{\n\t\t\tbyte[0] = *tok8;\n\t\t\ttok8++;\n\t\t\tif (*tok8 == '\\0')\n\t\t\t\treturn False;\n\t\t\tbyte[1] = *tok8;\n\t\t\ttok8++;\n\n\t\t\ticon_buf[len] = strtol(byte, NULL, 16);\n\t\t\tlen++;\n\n\t\t\tif ((size_t)len >= sizeof(icon_buf))\n\t\t\t{\n\t\t\t\tlogger(Protocol, Warning, \"seamless_process_line(), icon data would overrun icon_buf\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);\n\t}\n\telse if (!strcmp(\"DELICON\", tok1))\n\t{\n\t\tint width, height;\n\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_delicon(id, tok4, width, height);\n\t}\n\telse if (!strcmp(\"POSITION\", tok1))\n\t{\n\t\tint x, y, width, height;\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tx = strtol(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\ty = strtol(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtol(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\theight = strtol(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok8, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_move_window(id, x, y, width, height, flags);\n\t}\n\telse if (!strcmp(\"ZCHANGE\", tok1))\n\t{\n\t\tunsigned long behind;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbehind = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_restack_window(id, behind, flags);\n\t}\n\telse if (!strcmp(\"TITLE\", tok1))\n\t{\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_settitle(id, tok4, flags);\n\t}\n\telse if (!strcmp(\"STATE\", tok1))\n\t{\n\t\tunsigned int state;\n\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tstate = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_setstate(id, state, flags);\n\t}\n\telse if (!strcmp(\"DEBUG\", tok1))\n\t{\n\t\tlogger(Core, Debug, \"seamless_process_line(), %s\", line);\n\t}\n\telse if (!strcmp(\"SYNCBEGIN\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_syncbegin(flags);\n\t}\n\telse if (!strcmp(\"SYNCEND\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\t/* do nothing, currently */\n\t}\n\telse if (!strcmp(\"HELLO\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));\n\t}\n\telse if (!strcmp(\"ACK\", tok1))\n\t{\n\t\tunsigned int serial;\n\n\t\tserial = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_ack(serial);\n\t}\n\telse if (!strcmp(\"HIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_hide_desktop();\n\t}\n\telse if (!strcmp(\"UNHIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_unhide_desktop();\n\t}\n\n\n\txfree(l);\n\treturn True;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 379,
    "critical_vars": [
      "packet"
    ],
    "function": "seamless_process",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_seamless.c.diff",
    "function_code": "seamless_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tchar *buf;\n\tstruct stream packet = *s;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet);\n\t}\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 138,
    "critical_vars": [
      "packet"
    ],
    "function": "lspci_process",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_lspci.c.diff",
    "function_code": "lspci_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\tstruct stream packet = *s;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"lspci_process(), stream is in unstable state\", &packet);\n\t}\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, lspci_process_line, NULL);\n\txfree(buf);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 272,
    "critical_vars": [
      "packet"
    ],
    "function": "rdpsnd_process_training",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_rdpsnd.c.diff",
    "function_code": "rdpsnd_process_training(STREAM in)\n{\n\tuint16 tick;\n\tuint16 packsize;\n\tSTREAM out;\n\tstruct stream packet = *in;\n\n\tif (!s_check_rem(in, 4))\n\t{\n\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n\t}\n\n\tin_uint16_le(in, tick);\n\tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 454,
    "critical_vars": [
      "s"
    ],
    "function": "rdpsnddbg_process",
    "filename": "rdesktop/CVE-2018-20182/CVE-2018-20182_CWE-119_4dca546d04321a610c1835010b5dad85163b65e1_rdpsnd.c.diff",
    "function_code": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);\n\t}\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 486,
    "critical_vars": [
      "&name[2], &content_name[2], 31L"
    ],
    "function": "chmd_read_headers",
    "filename": "libmspack/CVE-2019-1010305/CVE-2019-1010305_CWE-119_2f084136cfe0d05e5bf5703f3e83c6d955234b4d_chmd.c.diff",
    "function_code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n                             struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n        ((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n        if ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n        sys->message(fh, \"invalid section number '%u'.\", section);\n        continue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n        sys->free(chunk);\n        return MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n                                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        /* system file */\n        if (memcmp(&name[2], &content_name[2], 31L) == 0) {\n          if (memcmp(&name[33], &content_name[33], 8L) == 0) {\n            chm->sec1.content = fi;\n          }\n          else if (memcmp(&name[33], &control_name[33], 11L) == 0) {\n            chm->sec1.control = fi;\n          }\n          else if (memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n            chm->sec1.spaninfo = fi;\n          }\n          else if (memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n            chm->sec1.rtable = fi;\n          }\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {\n        /* normal file */\n        if (link) link->next = fi; else chm->files = fi;\n        link = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 486,
    "critical_vars": [
      "name",
      "name_len",
      "content_name"
    ],
    "function": "chmd_read_headers",
    "filename": "libmspack/CVE-2019-1010305/CVE-2019-1010305_CWE-119_2f084136cfe0d05e5bf5703f3e83c6d955234b4d_chmd.c.diff",
    "function_code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n                             struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n        ((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n        if ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n        sys->message(fh, \"invalid section number '%u'.\", section);\n        continue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n        sys->free(chunk);\n        return MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n                                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        /* system file */\n        if (name_len == 40 && memcmp(name, content_name, 40) == 0) {\n          chm->sec1.content = fi;\n        }\n        else if (name_len == 44 && memcmp(name, control_name, 44) == 0) {\n          chm->sec1.control = fi;\n        }\n        else if (name_len == 41 && memcmp(name, spaninfo_name, 41) == 0) {\n          chm->sec1.spaninfo = fi;\n        }\n        else if (name_len == 105 && memcmp(name, rtable_name, 105) == 0) {\n          chm->sec1.rtable = fi;\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {\n        /* normal file */\n        if (link) link->next = fi; else chm->files = fi;\n        link = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1223,
    "critical_vars": [
      "url_len"
    ],
    "function": "extract_sockaddr",
    "filename": "sgminer/CVE-2014-4501/CVE-2014-4501_CWE-119_b65574bef233474e915fdf18614aa211e31cc6c2_util.c.diff",
    "function_code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\t\n\tif (url_len >= sizeof(url_address))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",\n\t\t       __func__, url_len, url_begin);\n\t\turl_len = sizeof(url_address) - 1;\n\t}\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1738,
    "critical_vars": [
      "port",
      "address",
      "url"
    ],
    "function": "parse_reconnect",
    "filename": "sgminer/CVE-2014-4501/CVE-2014-4501_CWE-119_78cc408369bdbbd440196c93574098d1482efbce_util.c.diff",
    "function_code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect forbidden, aborting.\");\n\t\treturn false;\n\t}\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsprintf(address, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1737,
    "critical_vars": [
      "port",
      "address",
      "url"
    ],
    "function": "parse_reconnect",
    "filename": "sgminer/CVE-2014-4501/CVE-2014-4501_CWE-119_78cc408369bdbbd440196c93574098d1482efbce_util.c.diff",
    "function_code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect received but is disabled, not reconnecting.\");\n\t\treturn false;\n\t}\n\n\tchar *url, *port, address[256];\n\tchar *sockaddr_url, *stratum_port, *tmp; /* Tempvars. */\n\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, sizeof(address), \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1115,
    "critical_vars": [
      "status"
    ],
    "function": "*ReadWPGImage",
    "filename": "ImageMagick/CVE-2016-5688/CVE-2016-5688_CWE-119_fc43974d34318c834fbf78570ca1a3764ed8c7d7_wpg.c.diff",
    "function_code": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2)/3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              if (WPG_Palette.StartIndex > WPG_Palette.NumOfEntries)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp <= 16))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     ReplaceImageInList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1426,
    "critical_vars": [
      "status"
    ],
    "function": "*ReadWPGImage",
    "filename": "ImageMagick/CVE-2016-5688/CVE-2016-5688_CWE-119_fc43974d34318c834fbf78570ca1a3764ed8c7d7_wpg.c.diff",
    "function_code": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp <= 16))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     ReplaceImageInList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 260,
    "line_new": 260,
    "critical_vars": [
      "imbuf"
    ],
    "function": "sixel_decode",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_sixel.c.diff",
    "function_code": "MagickBooleanType sixel_decode(unsigned char              /* in */  *p,         /* sixel bytes */\n                               unsigned char              /* out */ **pixels,   /* decoded pixels */\n                               size_t                     /* out */ *pwidth,    /* image width */\n                               size_t                     /* out */ *pheight,   /* image height */\n                               unsigned char              /* out */ **palette,  /* ARGB palette */\n                               size_t                     /* out */ *ncolors    /* palette size (<= 256) */)\n{\n    int n, i, r, g, b, sixel_vertical_mask, c;\n    int posision_x, posision_y;\n    int max_x, max_y;\n    int attributed_pan, attributed_pad;\n    int attributed_ph, attributed_pv;\n    int repeat_count, color_index, max_color_index = 2, background_color_index;\n    int param[10];\n    int sixel_palet[SIXEL_PALETTE_MAX];\n    unsigned char *imbuf, *dmbuf;\n    int imsx, imsy;\n    int dmsx, dmsy;\n    int y;\n\n    posision_x = posision_y = 0;\n    max_x = max_y = 0;\n    attributed_pan = 2;\n    attributed_pad = 1;\n    attributed_ph = attributed_pv = 0;\n    repeat_count = 1;\n    color_index = 0;\n    background_color_index = 0;\n\n    imsx = 2048;\n    imsy = 2048;\n    imbuf = (unsigned char *) AcquireQuantumMemory(imsx , imsy);\n\n    if (imbuf == NULL) {\n        return(MagickFalse);\n    }\n\n    for (n = 0; n < 16; n++) {\n        sixel_palet[n] = sixel_default_color_table[n];\n    }\n\n    /* colors 16-231 are a 6x6x6 color cube */\n    for (r = 0; r < 6; r++) {\n        for (g = 0; g < 6; g++) {\n            for (b = 0; b < 6; b++) {\n                sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);\n            }\n        }\n    }\n    /* colors 232-255 are a grayscale ramp, intentionally leaving out */\n    for (i = 0; i < 24; i++) {\n        sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);\n    }\n\n    for (; n < SIXEL_PALETTE_MAX; n++) {\n        sixel_palet[n] = SIXEL_RGB(255, 255, 255);\n    }\n\n    (void) ResetMagickMemory(imbuf, background_color_index, (size_t) imsx * imsy);\n\n    while (*p != '\\0') {\n        if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {\n            if (*p == '\\033') {\n                p++;\n            }\n\n            p = get_params(++p, param, &n);\n\n            if (*p == 'q') {\n                p++;\n\n                if (n > 0) {        /* Pn1 */\n                    switch(param[0]) {\n                    case 0:\n                    case 1:\n                        attributed_pad = 2;\n                        break;\n                    case 2:\n                        attributed_pad = 5;\n                        break;\n                    case 3:\n                        attributed_pad = 4;\n                        break;\n                    case 4:\n                        attributed_pad = 4;\n                        break;\n                    case 5:\n                        attributed_pad = 3;\n                        break;\n                    case 6:\n                        attributed_pad = 3;\n                        break;\n                    case 7:\n                        attributed_pad = 2;\n                        break;\n                    case 8:\n                        attributed_pad = 2;\n                        break;\n                    case 9:\n                        attributed_pad = 1;\n                        break;\n                    }\n                }\n\n                if (n > 2) {        /* Pn3 */\n                    if (param[2] == 0) {\n                        param[2] = 10;\n                    }\n                    attributed_pan = attributed_pan * param[2] / 10;\n                    attributed_pad = attributed_pad * param[2] / 10;\n                    if (attributed_pan <= 0) attributed_pan = 1;\n                    if (attributed_pad <= 0) attributed_pad = 1;\n                }\n            }\n\n        } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {\n            break;\n        } else if (*p == '\"') {\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) attributed_pad = param[0];\n            if (n > 1) attributed_pan = param[1];\n            if (n > 2 && param[2] > 0) attributed_ph = param[2];\n            if (n > 3 && param[3] > 0) attributed_pv = param[3];\n\n            if (attributed_pan <= 0) attributed_pan = 1;\n            if (attributed_pad <= 0) attributed_pad = 1;\n\n            if (imsx < attributed_ph || imsy < attributed_pv) {\n                dmsx = imsx > attributed_ph ? imsx : attributed_ph;\n                dmsy = imsy > attributed_pv ? imsy : attributed_pv;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n        } else if (*p == '!') {\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                repeat_count = param[0];\n            }\n\n        } else if (*p == '#') {\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                if ((color_index = param[0]) < 0) {\n                    color_index = 0;\n                } else if (color_index >= SIXEL_PALETTE_MAX) {\n                    color_index = SIXEL_PALETTE_MAX - 1;\n                }\n            }\n\n            if (n > 4) {\n                if (param[1] == 1) {            /* HLS */\n                    if (param[2] > 360) param[2] = 360;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);\n                } else if (param[1] == 2) {    /* RGB */\n                    if (param[2] > 100) param[2] = 100;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);\n                }\n            }\n\n        } else if (*p == '$') {\n            /* DECGCR Graphics Carriage Return */\n            p++;\n            posision_x = 0;\n            repeat_count = 1;\n\n        } else if (*p == '-') {\n            /* DECGNL Graphics Next Line */\n            p++;\n            posision_x  = 0;\n            posision_y += 6;\n            repeat_count = 1;\n\n        } else if (*p >= '?' && *p <= '\\177') {\n            if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {\n                int nx = imsx * 2;\n                int ny = imsy * 2;\n\n                while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {\n                    nx *= 2;\n                    ny *= 2;\n                }\n\n                dmsx = nx;\n                dmsy = ny;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n            if (color_index > max_color_index) {\n                max_color_index = color_index;\n            }\n            if ((b = *(p++) - '?') == 0) {\n                posision_x += repeat_count;\n\n            } else {\n                sixel_vertical_mask = 0x01;\n\n                if (repeat_count <= 1) {\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            imbuf[imsx * (posision_y + i) + posision_x] = color_index;\n                            if (max_x < posision_x) {\n                                max_x = posision_x;\n                            }\n                            if (max_y < (posision_y + i)) {\n                                max_y = posision_y + i;\n                            }\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += 1;\n\n                } else { /* repeat_count > 1 */\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            c = sixel_vertical_mask << 1;\n                            for (n = 1; (i + n) < 6; n++) {\n                                if ((b & c) == 0) {\n                                    break;\n                                }\n                                c <<= 1;\n                            }\n                            for (y = posision_y + i; y < posision_y + i + n; ++y) {\n                                (void) ResetMagickMemory(imbuf + (size_t) imsx * y + posision_x, color_index, repeat_count);\n                            }\n                            if (max_x < (posision_x + repeat_count - 1)) {\n                                max_x = posision_x + repeat_count - 1;\n                            }\n                            if (max_y < (posision_y + i + n - 1)) {\n                                max_y = posision_y + i + n - 1;\n                            }\n\n                            i += (n - 1);\n                            sixel_vertical_mask <<= (n - 1);\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += repeat_count;\n                }\n            }\n            repeat_count = 1;\n        } else {\n            p++;\n        }\n    }\n\n    if (++max_x < attributed_ph) {\n        max_x = attributed_ph;\n    }\n    if (++max_y < attributed_pv) {\n        max_y = attributed_pv;\n    }\n\n    if (imsx > max_x || imsy > max_y) {\n        dmsx = max_x;\n        dmsy = max_y;\n        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy)) == NULL) {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n        }\n        for (y = 0; y < dmsy; ++y) {\n            (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);\n        }\n        imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n        imsx = dmsx;\n        imsy = dmsy;\n        imbuf = dmbuf;\n    }\n\n    *pixels = imbuf;\n    *pwidth = imsx;\n    *pheight = imsy;\n    *ncolors = max_color_index + 1;\n    *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);\n    for (n = 0; n < (ssize_t) *ncolors; ++n) {\n        (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;\n        (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;\n        (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;\n        (*palette)[n * 4 + 3] = 0xff;\n    }\n    return(MagickTrue);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 485,
    "critical_vars": [
      "imbuf"
    ],
    "function": "sixel_decode",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_sixel.c.diff",
    "function_code": "MagickBooleanType sixel_decode(unsigned char              /* in */  *p,         /* sixel bytes */\n                               unsigned char              /* out */ **pixels,   /* decoded pixels */\n                               size_t                     /* out */ *pwidth,    /* image width */\n                               size_t                     /* out */ *pheight,   /* image height */\n                               unsigned char              /* out */ **palette,  /* ARGB palette */\n                               size_t                     /* out */ *ncolors    /* palette size (<= 256) */)\n{\n    int n, i, r, g, b, sixel_vertical_mask, c;\n    int posision_x, posision_y;\n    int max_x, max_y;\n    int attributed_pan, attributed_pad;\n    int attributed_ph, attributed_pv;\n    int repeat_count, color_index, max_color_index = 2, background_color_index;\n    int param[10];\n    int sixel_palet[SIXEL_PALETTE_MAX];\n    unsigned char *imbuf, *dmbuf;\n    int imsx, imsy;\n    int dmsx, dmsy;\n    int y;\n\n    posision_x = posision_y = 0;\n    max_x = max_y = 0;\n    attributed_pan = 2;\n    attributed_pad = 1;\n    attributed_ph = attributed_pv = 0;\n    repeat_count = 1;\n    color_index = 0;\n    background_color_index = 0;\n\n    imsx = 2048;\n    imsy = 2048;\n    imbuf = (unsigned char *) AcquireQuantumMemory(imsx * imsy,1);\n\n    if (imbuf == NULL) {\n        return(MagickFalse);\n    }\n\n    for (n = 0; n < 16; n++) {\n        sixel_palet[n] = sixel_default_color_table[n];\n    }\n\n    /* colors 16-231 are a 6x6x6 color cube */\n    for (r = 0; r < 6; r++) {\n        for (g = 0; g < 6; g++) {\n            for (b = 0; b < 6; b++) {\n                sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);\n            }\n        }\n    }\n    /* colors 232-255 are a grayscale ramp, intentionally leaving out */\n    for (i = 0; i < 24; i++) {\n        sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);\n    }\n\n    for (; n < SIXEL_PALETTE_MAX; n++) {\n        sixel_palet[n] = SIXEL_RGB(255, 255, 255);\n    }\n\n    (void) ResetMagickMemory(imbuf, background_color_index, imsx * imsy);\n\n    while (*p != '\\0') {\n        if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {\n            if (*p == '\\033') {\n                p++;\n            }\n\n            p = get_params(++p, param, &n);\n\n            if (*p == 'q') {\n                p++;\n\n                if (n > 0) {        /* Pn1 */\n                    switch(param[0]) {\n                    case 0:\n                    case 1:\n                        attributed_pad = 2;\n                        break;\n                    case 2:\n                        attributed_pad = 5;\n                        break;\n                    case 3:\n                        attributed_pad = 4;\n                        break;\n                    case 4:\n                        attributed_pad = 4;\n                        break;\n                    case 5:\n                        attributed_pad = 3;\n                        break;\n                    case 6:\n                        attributed_pad = 3;\n                        break;\n                    case 7:\n                        attributed_pad = 2;\n                        break;\n                    case 8:\n                        attributed_pad = 2;\n                        break;\n                    case 9:\n                        attributed_pad = 1;\n                        break;\n                    }\n                }\n\n                if (n > 2) {        /* Pn3 */\n                    if (param[2] == 0) {\n                        param[2] = 10;\n                    }\n                    attributed_pan = attributed_pan * param[2] / 10;\n                    attributed_pad = attributed_pad * param[2] / 10;\n                    if (attributed_pan <= 0) attributed_pan = 1;\n                    if (attributed_pad <= 0) attributed_pad = 1;\n                }\n            }\n\n        } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {\n            break;\n        } else if (*p == '\"') {\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) attributed_pad = param[0];\n            if (n > 1) attributed_pan = param[1];\n            if (n > 2 && param[2] > 0) attributed_ph = param[2];\n            if (n > 3 && param[3] > 0) attributed_pv = param[3];\n\n            if (attributed_pan <= 0) attributed_pan = 1;\n            if (attributed_pad <= 0) attributed_pad = 1;\n\n            if (imsx < attributed_ph || imsy < attributed_pv) {\n                dmsx = imsx > attributed_ph ? imsx : attributed_ph;\n                dmsy = imsy > attributed_pv ? imsy : attributed_pv;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n        } else if (*p == '!') {\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                repeat_count = param[0];\n            }\n\n        } else if (*p == '#') {\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                if ((color_index = param[0]) < 0) {\n                    color_index = 0;\n                } else if (color_index >= SIXEL_PALETTE_MAX) {\n                    color_index = SIXEL_PALETTE_MAX - 1;\n                }\n            }\n\n            if (n > 4) {\n                if (param[1] == 1) {            /* HLS */\n                    if (param[2] > 360) param[2] = 360;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);\n                } else if (param[1] == 2) {    /* RGB */\n                    if (param[2] > 100) param[2] = 100;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);\n                }\n            }\n\n        } else if (*p == '$') {\n            /* DECGCR Graphics Carriage Return */\n            p++;\n            posision_x = 0;\n            repeat_count = 1;\n\n        } else if (*p == '-') {\n            /* DECGNL Graphics Next Line */\n            p++;\n            posision_x  = 0;\n            posision_y += 6;\n            repeat_count = 1;\n\n        } else if (*p >= '?' && *p <= '\\177') {\n            if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {\n                int nx = imsx * 2;\n                int ny = imsy * 2;\n\n                while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {\n                    nx *= 2;\n                    ny *= 2;\n                }\n\n                dmsx = nx;\n                dmsy = ny;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n            if (color_index > max_color_index) {\n                max_color_index = color_index;\n            }\n            if ((b = *(p++) - '?') == 0) {\n                posision_x += repeat_count;\n\n            } else {\n                sixel_vertical_mask = 0x01;\n\n                if (repeat_count <= 1) {\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            imbuf[imsx * (posision_y + i) + posision_x] = color_index;\n                            if (max_x < posision_x) {\n                                max_x = posision_x;\n                            }\n                            if (max_y < (posision_y + i)) {\n                                max_y = posision_y + i;\n                            }\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += 1;\n\n                } else { /* repeat_count > 1 */\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            c = sixel_vertical_mask << 1;\n                            for (n = 1; (i + n) < 6; n++) {\n                                if ((b & c) == 0) {\n                                    break;\n                                }\n                                c <<= 1;\n                            }\n                            for (y = posision_y + i; y < posision_y + i + n; ++y) {\n                                (void) ResetMagickMemory(imbuf + imsx * y + posision_x, color_index, repeat_count);\n                            }\n                            if (max_x < (posision_x + repeat_count - 1)) {\n                                max_x = posision_x + repeat_count - 1;\n                            }\n                            if (max_y < (posision_y + i + n - 1)) {\n                                max_y = posision_y + i + n - 1;\n                            }\n\n                            i += (n - 1);\n                            sixel_vertical_mask <<= (n - 1);\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += repeat_count;\n                }\n            }\n            repeat_count = 1;\n        } else {\n            p++;\n        }\n    }\n\n    if (++max_x < attributed_ph) {\n        max_x = attributed_ph;\n    }\n    if (++max_y < attributed_pv) {\n        max_y = attributed_pv;\n    }\n\n    if (imsx > max_x || imsy > max_y) {\n        dmsx = max_x;\n        dmsy = max_y;\n        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1)) == NULL) {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n        }\n        for (y = 0; y < dmsy; ++y) {\n            (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);\n        }\n        imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n        imsx = dmsx;\n        imsy = dmsy;\n        imbuf = dmbuf;\n    }\n\n    *pixels = imbuf;\n    *pwidth = imsx;\n    *pheight = imsy;\n    *ncolors = max_color_index + 1;\n    *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);\n    for (n = 0; n < (ssize_t) *ncolors; ++n) {\n        (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;\n        (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;\n        (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;\n        (*palette)[n * 4 + 3] = 0xff;\n    }\n    return(MagickTrue);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2496,
    "critical_vars": [
      "image",
      "exception",
      "BilevelType"
    ],
    "function": "WriteGROUP4Image",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_tiff.c.diff",
    "function_code": "static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2497,
    "critical_vars": [
      "image",
      "exception",
      "BilevelType"
    ],
    "function": "WriteGROUP4Image",
    "filename": "ImageMagick/CVE-2016-10056/CVE-2016-10056_CWE-119_eedd0c35bb2d8af7aa05f215689fdebd11633fa1_tiff.c.diff",
    "function_code": "static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 985,
    "critical_vars": [
      "length"
    ],
    "function": "*ReadPICTImage",
    "filename": "ImageMagick/CVE-2018-16644/CVE-2018-16644_CWE-119_afa878a689870c28b6994ecf3bb8dbfb2b76d135_pict.c.diff",
    "function_code": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowPICTException(exception,message) \\\n{ \\\n  if (tile_image != (Image *) NULL) \\\n    tile_image=DestroyImage(tile_image); \\\n  if (read_info != (ImageInfo *) NULL) \\\n    read_info=DestroyImageInfo(read_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image,\n    *tile_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  read_info=(ImageInfo *) NULL;\n  tile_image=(Image *) NULL;\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  version=(ssize_t) ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=(size_t) (frame.right-frame.left);\n  image->rows=(size_t) (frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status != MagickFalse)\n    status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code == 0)\n      continue;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=(size_t) (frame.right-frame.left);\n            image->rows=(size_t) (frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status != MagickFalse)\n              status=ResetImagePixels(image,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=(size_t) pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=(ssize_t) ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=(size_t) (frame.bottom-frame.top);\n            height=(size_t) (frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (ssize_t) height; i++)\n              {\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n              }\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=(ssize_t) ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,(size_t) (frame.right-frame.left),\n              (size_t) (frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n                tile_image->depth=(size_t) pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  (void) SetImageAlpha(tile_image,OpaqueAlpha,exception);\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=(ssize_t) ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  ThrowPICTException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (EOFBlob(image) != MagickFalse)\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                if (length > GetBlobSize(image))\n                  ThrowPICTException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,1,\n                &extent);\n            else\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,\n                (unsigned int) pixmap.bits_per_pixel,&extent);\n            if (pixels == (unsigned char *) NULL)\n              ThrowPICTException(CorruptImageError,\"UnableToUncompressImage\");\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n                  ThrowPICTException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=(Quantum) ConstrainColormapIndex(tile_image,(ssize_t)\n                      *p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(ssize_t) (*p++);\n                        j=(size_t) (*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if ((jpeg == MagickFalse) && (EOFBlob(image) == MagickFalse))\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,(ssize_t) destination.left,(ssize_t)\n                  destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length > GetBlobSize(image))\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowPICTException(ResourceLimitError,\"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        char\n          filename[MaxTextExtent];\n\n        FILE\n          *file;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > GetBlobSize(image))\n          ThrowPICTException(CorruptImageError,\n            \"InsufficientImageDataInFile\");\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              if (fputc(c,file) != c)\n                break;\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          (ssize_t) frame.left,(ssize_t) frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        if (length > GetBlobSize(image))\n          ThrowPICTException(CorruptImageError,\n            \"InsufficientImageDataInFile\");\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        if (length > GetBlobSize(image))\n          ThrowPICTException(CorruptImageError,\n            \"InsufficientImageDataInFile\");\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 325,
    "critical_vars": [
      "i"
    ],
    "function": "*get_pid_environ_val",
    "filename": "das_watchdog/CVE-2015-2831/CVE-2015-2831_CWE-119_bd20bb02e75e2c0483832b52f2577253febfb690_das_watchdog.c.diff",
    "function_code": "static char *get_pid_environ_val(pid_t pid,char *val){\n  int temp_size = 500;\n  char *temp = malloc(temp_size);\n  \n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    \n    if (i >= temp_size) {\n      temp_size *= 2;\n      temp = realloc(temp, temp_size);\n    }\n      \n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 377,
    "critical_vars": [
      "hstartcol"
    ],
    "function": "jpc_qmfb_split_col",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 377,
    "critical_vars": [
      "hstartrow"
    ],
    "function": "jpc_qmfb_split_col",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartrow;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartrow = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);\n\t\tm = numrows - hstartrow;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartrow * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 442,
    "critical_vars": [
      "hstartcol"
    ],
    "function": "jpc_qmfb_split_colgrp",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 442,
    "critical_vars": [
      "hstartrow"
    ],
    "function": "jpc_qmfb_split_colgrp",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartrow;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartrow = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);\n\t\tm = numrows - hstartrow;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartrow * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 529,
    "critical_vars": [
      "buf",
      "bufsize",
      "jpc_fix_t"
    ],
    "function": "jpc_qmfb_split_colres",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 530,
    "critical_vars": [
      "buf",
      "bufsize",
      "jpc_fix_t",
      "numcols"
    ],
    "function": "jpc_qmfb_split_colres",
    "filename": "jasper/CVE-2016-8654/CVE-2016-8654_CWE-119_4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a_jpc_qmfb.c.diff",
    "function_code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 191,
    "line_new": 189,
    "critical_vars": [
      "strbuf",
      "component",
      "name",
      "path"
    ],
    "function": "finish_object",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_rev-list.c.diff",
    "function_code": "static void finish_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 19,
    "critical_vars": [
      "pathlen"
    ],
    "function": "process_blob",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tsize_t pathlen;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\n\tpathlen = path->len;\n\tstrbuf_addstr(path, name);\n\tshow(obj, path->buf, cb_data);\n\tstrbuf_setlen(path, pathlen);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 27,
    "critical_vars": [
      "cb_data",
      "obj",
      "name",
      "path"
    ],
    "function": "process_blob",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 89,
    "critical_vars": [
      "base",
      "cb_data",
      "obj",
      "name"
    ],
    "function": "process_tree",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 95,
    "critical_vars": [
      "cb_data",
      "obj",
      "base->buf"
    ],
    "function": "process_tree",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\n\tobj->flags |= SEEN;\n\tstrbuf_addstr(base, name);\n\tshow(obj, base->buf, cb_data);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 210,
    "line_new": 214,
    "critical_vars": [
      "obj",
      "name",
      "data"
    ],
    "function": "traverse_commit_list",
    "filename": "git/CVE-2016-2324/CVE-2016-2324_CWE-119_de1e67d0703894cb6ea782e36abb63976ab07e60_list-objects.c.diff",
    "function_code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\t/*\n\t\t * an uninteresting boundary commit may not have its tree\n\t\t * parsed yet, but we are not going to show them anyway\n\t\t */\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 41,
    "critical_vars": [
      "name",
      "m"
    ],
    "function": "*path_name",
    "filename": "git/CVE-2016-2315/CVE-2016-2315_CWE-119_34fa79a6cde56d6d428ab0d3160cb094ebad3305_revision.c.diff",
    "function_code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 107,
    "critical_vars": [
      "data->l_head"
    ],
    "function": "ParseNameValue",
    "filename": "miniupnp/CVE-2017-1000494/CVE-2017-1000494_CWE-119_7aeb624b44f86d335841242ff427433190e7168a_upnpreplyparse.c.diff",
    "function_code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 108,
    "critical_vars": [
      "NameValueParserData",
      "data"
    ],
    "function": "ParseNameValue",
    "filename": "miniupnp/CVE-2017-1000494/CVE-2017-1000494_CWE-119_7aeb624b44f86d335841242ff427433190e7168a_upnpreplyparse.c.diff",
    "function_code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tmemset(data, 0, sizeof(struct NameValueParserData));\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 488,
    "line_new": 488,
    "critical_vars": [
      "p->tokenbuf[p->tokenpos]"
    ],
    "function": "check_literal",
    "filename": "jq/CVE-2015-8863/CVE-2015-8863_CWE-119_8eb1367ca44e772963e704a700ef72ae2e12babd_jv_parse.c.diff",
    "function_code": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    // FIXME: better parser\n    p->tokenbuf[p->tokenpos] = 0;\n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 78,
    "line_new": 78,
    "critical_vars": [
      "o_element_count",
      "%u\"",
      "\"%u",
      "%u",
      "l_line",
      "o_row_count",
      "o_column_count"
    ],
    "function": "my_csr_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_pyfr_driver_asp_reg.c.diff",
    "function_code": "int my_csr_reader( const char*           i_csr_file_in,\n                    unsigned int**        o_row_idx,\n                    unsigned int**        o_column_idx,\n                    REALTYPE**            o_values,\n                    unsigned int*         o_row_count,\n                    unsigned int*         o_column_count,\n                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return -1;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return -1;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return -1;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return -1;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return -1;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return -1;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n  return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 120,
    "line_new": 120,
    "critical_vars": [
      "o_element_count",
      "%u\"",
      "\"%u",
      "%u",
      "l_line",
      "o_row_count",
      "o_column_count"
    ],
    "function": "libxsmm_sparse_csc_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_generator_spgemm_csc_reader.c.diff",
    "function_code": "void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC data structure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          /* init column idx */\n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        LIBXSMM_ASSERT(0 != l_row && 0 != l_column);\n        l_row--; l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    /* let's handle empty columns */\n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_column_idx_id );\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 171,
    "critical_vars": [
      "l_row"
    ],
    "function": "libxsmm_sparse_csc_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_generator_spgemm_csc_reader.c.diff",
    "function_code": "void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data structure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          /* init column idx */\n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    /* let's handle empty columns */\n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_column_idx_id );\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 81,
    "line_new": 81,
    "critical_vars": [
      "o_element_count",
      "%u\"",
      "\"%u",
      "%u",
      "l_line",
      "o_row_count",
      "o_column_count"
    ],
    "function": "libxsmm_sparse_csr_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_generator_spgemm_csr_reader.c.diff",
    "function_code": "void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        LIBXSMM_ASSERT(0 != l_row && 0 != l_column);\n        l_row--; l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let's handle empty rows */\n    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 132,
    "critical_vars": [
      "l_row"
    ],
    "function": "libxsmm_sparse_csr_reader",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_generator_spgemm_csr_reader.c.diff",
    "function_code": "void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let's handle empty rows */\n    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 65,
    "line_new": 65,
    "critical_vars": [
      "o_element_count",
      "%u\"",
      "\"%u",
      "%u",
      "l_line",
      "o_row_count",
      "o_column_count"
    ],
    "function": "edge_sparse_csr_reader_double",
    "filename": "libxsmm/CVE-2018-20542/CVE-2018-20542_CWE-119_151481489192e6d1997f8bde52c5c425ea41741d_edge_proxy_common.c.diff",
    "function_code": "void edge_sparse_csr_reader_double( const char*           i_csr_file_in,\n                                    unsigned int**        o_row_idx,\n                                    unsigned int**        o_column_idx,\n                                    double**              o_values,\n                                    unsigned int*         o_row_count,\n                                    unsigned int*         o_column_count,\n                                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        double l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 600,
    "line_new": 617,
    "critical_vars": [
      "msg->fp"
    ],
    "function": "pop_fetch_message",
    "filename": "neomutt/CVE-2018-14362/CVE-2018-14362_CWE-119_9bfab35522301794483f8f9ed60820bdec9be59e_pop.c.diff",
    "function_code": "static int pop_fetch_message (CONTEXT* ctx, MESSAGE* msg, int msgno)\n{\n  int ret;\n  void *uidl;\n  char buf[LONG_STRING];\n  char path[_POSIX_PATH_MAX];\n  progress_t progressbar;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, cache_id (h->data))))\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen (cache->path, \"r\");\n      if (msg->fp)\n\treturn 0;\n      \n      mutt_perror (cache->path);\n      mutt_sleep (2);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink (cache->path);\n      FREE (&cache->path);\n    }\n  }\n\n  FOREVER\n  {\n    if (pop_reconnect (ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error _(\"The message index is incorrect. Try reopening the mailbox.\");\n      mutt_sleep (2);\n      return -1;\n    }\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, cache_id (h->data), 1)))\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n      {\n\tmutt_perror (path);\n\tmutt_sleep (2);\n\treturn -1;\n      }\n    }\n\n    snprintf (buf, sizeof (buf), \"RETR %d\\r\\n\", h->refno);\n\n    ret = pop_fetch_data (pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    safe_fclose (&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink (path);\n\n    if (ret == -2)\n    {\n      mutt_error (\"%s\", pop_data->err_msg);\n      mutt_sleep (2);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error _(\"Can't write message to temporary file!\");\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, cache_id (h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }\n  rewind (msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    hash_delete (ctx->subj_hash, h->env->real_subj, h, NULL);\n  mutt_label_hash_remove (ctx, h);\n  mutt_free_envelope (&h->env);\n  h->env = mutt_read_rfc822_header (msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    hash_insert (ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add (ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets (buf, sizeof (buf), msg->fp);\n  while (!feof (msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets (buf, sizeof (buf), msg->fp);\n  }\n\n  h->content->length = ftello (msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query (h->content);\n\n  mutt_clear_error();\n  rewind (msg->fp);\n\n  return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 786,
    "line_new": 803,
    "critical_vars": [
      "ctx->hdrs[i]->data",
      "pop_data->bcache"
    ],
    "function": "pop_sync_mailbox",
    "filename": "neomutt/CVE-2018-14362/CVE-2018-14362_CWE-119_9bfab35522301794483f8f9ed60820bdec9be59e_pop.c.diff",
    "function_code": "static int pop_sync_mailbox (CONTEXT *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  progress_t progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  FOREVER\n  {\n    if (pop_reconnect (ctx) < 0)\n      return -1;\n\n    mutt_progress_init (&progress, _(\"Marking messages deleted...\"),\n\t\t\tMUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#if USE_HCACHE\n    hc = pop_hcache_open (pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n\tj++;\n\tif (!ctx->quiet)\n\t  mutt_progress_update (&progress, j, -1);\n\tsnprintf (buf, sizeof (buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n\tif ((ret = pop_query (pop_data, buf, sizeof (buf))) == 0)\n\t{\n\t  mutt_bcache_del (pop_data->bcache, cache_id (ctx->hdrs[i]->data));\n#if USE_HCACHE\n\t  mutt_hcache_delete (hc, ctx->hdrs[i]->data, strlen);\n#endif\n\t}\n      }\n\n#if USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n\tmutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);\n      }\n#endif\n\n    }\n\n#if USE_HCACHE\n    mutt_hcache_close (hc);\n#endif\n\n    if (ret == 0)\n    {\n      strfcpy (buf, \"QUIT\\r\\n\", sizeof (buf));\n      ret = pop_query (pop_data, buf, sizeof (buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = 1;\n      pop_clear_cache (pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error (\"%s\", pop_data->err_msg);\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 252,
    "critical_vars": [
      "str",
      "len"
    ],
    "function": "json_tokener_parse_ex",
    "filename": "json-c/CVE-2013-6370/CVE-2013-6370_CWE-119_64e36901a0614bf64a19bc3396469c66dcd0b015_json_tokener.c.diff",
    "function_code": "struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n\t\t\t\t\t  const char *str, int len)\n{\n  struct json_object *obj = NULL;\n  char c = '\\1';\n#ifdef HAVE_SETLOCALE\n  char *oldlocale=NULL, *tmplocale;\n\n  tmplocale = setlocale(LC_NUMERIC, NULL);\n  if (tmplocale) oldlocale = strdup(tmplocale);\n  setlocale(LC_NUMERIC, \"C\");\n#endif\n\n  tok->char_offset = 0;\n  tok->err = json_tokener_success;\n\n  /* this interface is presently not 64-bit clean due to the int len argument\n     and the internal printbuf interface that takes 32-bit int len arguments\n     so the function limits the maximum string size to INT32_MAX (2GB).\n     If the function is called with len == -1 then strlen is called to check\n     the string length is less than INT32_MAX (2GB) */\n  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n    tok->err = json_tokener_error_size;\n    return NULL;\n  }\n\n  while (PEEK_CHAR(c, tok)) {\n\n  redo_char:\n    switch(state) {\n\n    case json_tokener_state_eatws:\n      /* Advance until we change state */\n      while (isspace((int)c)) {\n\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t  goto out;\n      }\n      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {\n\tprintbuf_reset(tok->pb);\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = json_tokener_state_comment_start;\n      } else {\n\tstate = saved_state;\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_start:\n      switch(c) {\n      case '{':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_object_field_start;\n\tcurrent = json_object_new_object();\n\tbreak;\n      case '[':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_array;\n\tcurrent = json_object_new_array();\n\tbreak;\n      case 'I':\n      case 'i':\n\tstate = json_tokener_state_inf;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case 'N':\n      case 'n':\n\tstate = json_tokener_state_null; // or NaN\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case '\\'':\n        if (tok->flags & JSON_TOKENER_STRICT) {\n            /* in STRICT mode only double-quote are allowed */\n            tok->err = json_tokener_error_parse_unexpected;\n            goto out;\n        }\n      case '\"':\n\tstate = json_tokener_state_string;\n\tprintbuf_reset(tok->pb);\n\ttok->quote_char = c;\n\tbreak;\n      case 'T':\n      case 't':\n      case 'F':\n      case 'f':\n\tstate = json_tokener_state_boolean;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n#if defined(__GNUC__)\n\t  case '0' ... '9':\n#else\n\t  case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n#endif\n      case '-':\n\tstate = json_tokener_state_number;\n\tprintbuf_reset(tok->pb);\n\ttok->is_double = 0;\n\tgoto redo_char;\n      default:\n\ttok->err = json_tokener_error_parse_unexpected;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_finish:\n      if(tok->depth == 0) goto out;\n      obj = json_object_get(current);\n      json_tokener_reset_level(tok, tok->depth);\n      tok->depth--;\n      goto redo_char;\n\n    case json_tokener_state_inf: /* aka starts with 'i' */\n      {\n\tint size;\n\tint size_inf;\n\tint is_negative = 0;\n\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_inf = json_min(tok->st_pos+1, json_inf_str_len);\n\tchar *infbuf = tok->pb->buf;\n\tif (*infbuf == '-')\n\t{\n\t\tinfbuf++;\n\t\tis_negative = 1;\n\t}\n\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||\n\t         (strncmp(json_inf_str, infbuf, size_inf) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_inf_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(is_negative ? -INFINITY : INFINITY); \n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\tgoto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n    case json_tokener_state_null: /* aka starts with 'n' */\n      {\n\tint size;\n\tint size_nan;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_nan = json_min(tok->st_pos+1, json_nan_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_null_str, tok->pb->buf, size) == 0)\n\t  || (strncmp(json_null_str, tok->pb->buf, size) == 0)\n\t  ) {\n\t  if (tok->st_pos == json_null_str_len) {\n\t    current = NULL;\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t}\n\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||\n\t         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_nan_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(NAN);\n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t  tok->err = json_tokener_error_parse_null;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_comment_start:\n      if(c == '*') {\n\tstate = json_tokener_state_comment;\n      } else if(c == '/') {\n\tstate = json_tokener_state_comment_eol;\n      } else {\n\ttok->err = json_tokener_error_parse_comment;\n\tgoto out;\n      }\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      break;\n\n    case json_tokener_state_comment:\n              {\n          /* Advance until we change state */\n          const char *case_start = str;\n          while(c != '*') {\n            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n              printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n              goto out;\n            }\n          }\n          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);\n          state = json_tokener_state_comment_end;\n        }\n            break;\n\n    case json_tokener_state_comment_eol:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(c != '\\n') {\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n\tprintbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      }\n      break;\n\n    case json_tokener_state_comment_end:\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      if(c == '/') {\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      } else {\n\tstate = json_tokener_state_comment;\n      }\n      break;\n\n    case json_tokener_state_string:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_string;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_string_escape:\n      switch(c) {\n      case '\"':\n      case '\\\\':\n      case '/':\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = saved_state;\n\tbreak;\n      case 'b':\n      case 'n':\n      case 'r':\n      case 't':\n      case 'f':\n\tif(c == 'b') printbuf_memappend_fast(tok->pb, \"\\b\", 1);\n\telse if(c == 'n') printbuf_memappend_fast(tok->pb, \"\\n\", 1);\n\telse if(c == 'r') printbuf_memappend_fast(tok->pb, \"\\r\", 1);\n\telse if(c == 't') printbuf_memappend_fast(tok->pb, \"\\t\", 1);\n\telse if(c == 'f') printbuf_memappend_fast(tok->pb, \"\\f\", 1);\n\tstate = saved_state;\n\tbreak;\n      case 'u':\n\ttok->ucs_char = 0;\n\ttok->st_pos = 0;\n\tstate = json_tokener_state_escape_unicode;\n\tbreak;\n      default:\n\ttok->err = json_tokener_error_parse_string;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_escape_unicode:\n\t{\n          unsigned int got_hi_surrogate = 0;\n\n\t  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */\n\t  while(1) {\n\t    if(strchr(json_hex_chars, c)) {\n\t      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));\n\t      if(tok->st_pos == 4) {\n\t\tunsigned char unescaped_utf[4];\n\n                if (got_hi_surrogate) {\n\t\t  if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                    /* Recalculate the ucs_char, then fall thru to process normally */\n                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);\n                  } else {\n                    /* Hi surrogate was not followed by a low surrogate */\n                    /* Replace the hi and process the rest normally */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n                  got_hi_surrogate = 0;\n                }\n\n\t\tif (tok->ucs_char < 0x80) {\n\t\t  unescaped_utf[0] = tok->ucs_char;\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);\n\t\t} else if (tok->ucs_char < 0x800) {\n\t\t  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);\n\t\t  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);\n\t\t} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {\n                  /* Got a high surrogate.  Remember it and look for the\n                   * the beginning of another sequence, which should be the\n                   * low surrogate.\n                   */\n                  got_hi_surrogate = tok->ucs_char;\n                  /* Not at end, and the next two chars should be \"\\u\" */\n                  if ((tok->char_offset+1 != len) &&\n                      (tok->char_offset+2 != len) &&\n                      (str[1] == '\\\\') &&\n                      (str[2] == 'u'))\n                  {\n                /* Advance through the 16 bit surrogate, and move on to the\n                 * next sequence. The next step is to process the following\n                 * characters.\n                 */\n\t            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {\n                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n                    /* Advance to the first char of the next sequence and\n                     * continue processing with the next sequence.\n                     */\n\t            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t              goto out;\n                    }\n\t            tok->ucs_char = 0;\n                    tok->st_pos = 0;\n                    continue; /* other json_tokener_state_escape_unicode */\n                  } else {\n                    /* Got a high surrogate without another sequence following\n                     * it.  Put a replacement char in for the hi surrogate\n                     * and pretend we finished.\n                     */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n\t\t} else if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                  /* Got a low surrogate not preceded by a high */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                } else if (tok->ucs_char < 0x10000) {\n\t\t  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);\n\t\t} else if (tok->ucs_char < 0x110000) {\n\t\t  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);\n\t\t} else {\n                  /* Don't know what we got--insert the replacement char */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n\t\tstate = saved_state;\n\t\tbreak;\n\t      }\n\t    } else {\n\t      tok->err = json_tokener_error_parse_string;\n\t      goto out;\n\t    }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n            if (got_hi_surrogate) /* Clean up any pending chars */\n\t      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_boolean:\n      {\n\tint size1, size2;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize1 = json_min(tok->st_pos+1, json_true_str_len);\n\tsize2 = json_min(tok->st_pos+1, json_false_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  ) {\n\t  if(tok->st_pos == json_true_str_len) {\n\t    current = json_object_new_boolean(1);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else if((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)\n\t  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {\n\t  if(tok->st_pos == json_false_str_len) {\n\t    current = json_object_new_boolean(0);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else {\n\t  tok->err = json_tokener_error_parse_boolean;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_number:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\tint case_len=0;\n\twhile(c && strchr(json_number_chars, c)) {\n\t  ++case_len;\n\t  if(c == '.' || c == 'e' || c == 'E')\n\t    tok->is_double = 1;\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, case_len);\n\t    goto out;\n\t  }\n\t}\n        if (case_len>0)\n          printbuf_memappend_fast(tok->pb, case_start, case_len);\n\n\t// Check for -Infinity\n\tif (tok->pb->buf[0] == '-' && case_len == 1 &&\n\t    (c == 'i' || c == 'I'))\n\t{\n\t\tstate = json_tokener_state_inf;\n\t\tgoto redo_char;\n\t}\n      }\n      {\n\tint64_t num64;\n\tdouble  numd;\n\tif (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {\n\t\tif (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {\n\t\t\t/* in strict mode, number must not start with 0 */\n\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\tgoto out;\n\t\t}\n\t\tcurrent = json_object_new_int64(num64);\n\t}\n\telse if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)\n\t{\n          current = json_object_new_double_s(numd, tok->pb->buf);\n        } else {\n          tok->err = json_tokener_error_parse_number;\n          goto out;\n        }\n        saved_state = json_tokener_state_finish;\n        state = json_tokener_state_eatws;\n        goto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_after_sep:\n    case json_tokener_state_array:\n      if(c == ']') {\n\t\tif (state == json_tokener_state_array_after_sep &&\n\t\t\t(tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else {\n\tif(tok->depth >= tok->max_depth-1) {\n\t  tok->err = json_tokener_error_depth;\n\t  goto out;\n\t}\n\tstate = json_tokener_state_array_add;\n\ttok->depth++;\n\tjson_tokener_reset_level(tok, tok->depth);\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_add:\n      json_object_array_add(current, obj);\n      saved_state = json_tokener_state_array_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_array_sep:\n      if(c == ']') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_array_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_array;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field_start:\n    case json_tokener_state_object_field_start_after_sep:\n      if(c == '}') {\n\t\tif (state == json_tokener_state_object_field_start_after_sep &&\n\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if (c == '\"' || c == '\\'') {\n\ttok->quote_char = c;\n\tprintbuf_reset(tok->pb);\n\tstate = json_tokener_state_object_field;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_name;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    obj_field_name = strdup(tok->pb->buf);\n\t    saved_state = json_tokener_state_object_field_end;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_object_field;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_object_field_end:\n      if(c == ':') {\n\tsaved_state = json_tokener_state_object_value;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_sep;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_value:\n      if(tok->depth >= tok->max_depth-1) {\n\ttok->err = json_tokener_error_depth;\n\tgoto out;\n      }\n      state = json_tokener_state_object_value_add;\n      tok->depth++;\n      json_tokener_reset_level(tok, tok->depth);\n      goto redo_char;\n\n    case json_tokener_state_object_value_add:\n      json_object_object_add(current, obj_field_name, obj);\n      free(obj_field_name);\n      obj_field_name = NULL;\n      saved_state = json_tokener_state_object_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_object_sep:\n      if(c == '}') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_object_field_start_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_value_sep;\n\tgoto out;\n      }\n      break;\n\n    }\n    if (!ADVANCE_CHAR(str, tok))\n      goto out;\n  } /* while(POP_CHAR) */\n\n out:\n  if (c &&\n     (state == json_tokener_state_finish) &&\n     (tok->depth == 0) &&\n     (tok->flags & JSON_TOKENER_STRICT)) {\n      /* unexpected char after JSON data */\n      tok->err = json_tokener_error_parse_unexpected;\n  }\n  if (!c) { /* We hit an eof char (0) */\n    if(state != json_tokener_state_finish &&\n       saved_state != json_tokener_state_finish)\n      tok->err = json_tokener_error_parse_eof;\n  }\n\n#ifdef HAVE_SETLOCALE\n  setlocale(LC_NUMERIC, oldlocale);\n  if (oldlocale) free(oldlocale);\n#endif\n\n  if (tok->err == json_tokener_success)\n  {\n    json_object *ret = json_object_get(current);\n\tint ii;\n\n\t/* Partially reset, so we parse additional objects on subsequent calls. */\n    for(ii = tok->depth; ii >= 0; ii--)\n      json_tokener_reset_level(tok, ii);\n    return ret;\n  }\n\n  MC_DEBUG(\"json_tokener_parse_ex: error %s at offset %d\\n\",\n\t   json_tokener_errors[tok->err], tok->char_offset);\n  return NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 161,
    "critical_vars": [
      "IVlen",
      "mode"
    ],
    "function": "ALGnew",
    "filename": "pycrypto/CVE-2013-7459/CVE-2013-7459_CWE-119_8dbe0dc3eea5c689d4f76b37b93fe216cf1f00d4_block_template.c.diff",
    "function_code": "ALGnew(PyObject *self, PyObject *args, PyObject *kwdict)\n{\n\tunsigned char *key, *IV;\n\tALGobject * new=NULL;\n\tint keylen, IVlen=0, mode=MODE_ECB, segment_size=0;\n\tPyObject *counter = NULL;\n\tint counter_shortcut = 0;\n#ifdef PCT_ARC2_MODULE\n        int effective_keylen = 1024;    /* this is a weird default, but it's compatible with old versions of PyCrypto */\n#endif\n\t/* Set default values */\n\tif (!PyArg_ParseTupleAndKeywords(args, kwdict, \"s#|is#Oi\"\n#ifdef PCT_ARC2_MODULE\n\t\t\t\t\t \"i\"\n#endif\n\t\t\t\t\t , kwlist,\n\t\t\t\t\t &key, &keylen, &mode, &IV, &IVlen,\n\t\t\t\t\t &counter, &segment_size\n#ifdef PCT_ARC2_MODULE\n\t\t\t\t\t , &effective_keylen\n#endif\n\t\t)) \n\t{\n\t\treturn NULL;\n\t}\n\n\tif (mode<MODE_ECB || mode>MODE_CTR) \n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Unknown cipher feedback mode %i\",\n\t\t\t     mode);\n\t\treturn NULL;\n\t}\n\tif (mode == MODE_PGP) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"MODE_PGP is not supported anymore\");\n\t\treturn NULL;\n\t}\n\tif (KEY_SIZE!=0 && keylen!=KEY_SIZE)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"Key must be %i bytes long, not %i\",\n\t\t\t     KEY_SIZE, keylen);\n\t\treturn NULL;\n\t}\n\tif (KEY_SIZE==0 && keylen==0)\n\t{\n\t\tPyErr_SetString(PyExc_ValueError,\n\t\t\t\t\"Key cannot be the null string\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != 0 && mode == MODE_ECB)\n\t{\n\t\tPyErr_Format(PyExc_ValueError, \"ECB mode does not use IV\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != 0 && mode == MODE_CTR)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t\"CTR mode needs counter parameter, not IV\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"IV must be %i bytes long\", BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\n\t/* Mode-specific checks */\n\tif (mode == MODE_CFB) {\n\t\tif (segment_size == 0) segment_size = 8;\n\t\tif (segment_size < 1 || segment_size > BLOCK_SIZE*8 || ((segment_size & 7) != 0)) {\n\t\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t\t     \"segment_size must be multiple of 8 (bits) \"\n\t\t\t\t     \"between 1 and %i\", BLOCK_SIZE*8);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (mode == MODE_CTR) {\n\t\tif (counter == NULL) {\n\t\t\tPyErr_SetString(PyExc_TypeError,\n\t\t\t\t\t\"'counter' keyword parameter is required with CTR mode\");\n\t\t\treturn NULL;\n\t\t} else if (Py_TYPE(counter) == PCT_CounterBEType || Py_TYPE(counter) == PCT_CounterLEType) {\n\t\t\tcounter_shortcut = 1;\n\t\t} else if (!PyCallable_Check(counter)) {\n\t\t\tPyErr_SetString(PyExc_ValueError, \n\t\t\t\t\t\"'counter' parameter must be a callable object\");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (counter != NULL) {\n\t\t\tPyErr_SetString(PyExc_ValueError, \n\t\t\t\t\t\"'counter' parameter only useful with CTR mode\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Cipher-specific checks */\n#ifdef PCT_ARC2_MODULE\n        if (effective_keylen<0 || effective_keylen>1024) {\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"RC2: effective_keylen must be between 0 and 1024, not %i\",\n\t\t\t     effective_keylen);\n\t\treturn NULL;\n        }\n#endif\n\n\t/* Copy parameters into object */\n\tnew = newALGobject();\n\tnew->segment_size = segment_size;\n\tnew->counter = counter;\n\tPy_XINCREF(counter);\n\tnew->counter_shortcut = counter_shortcut;\n#ifdef PCT_ARC2_MODULE\n        new->st.effective_keylen = effective_keylen;\n#endif\n\n\tblock_init(&(new->st), key, keylen);\n\tif (PyErr_Occurred())\n\t{\n\t\tPy_DECREF(new);\n\t\treturn NULL;\n\t}\n\tmemset(new->IV, 0, BLOCK_SIZE);\n\tmemset(new->oldCipher, 0, BLOCK_SIZE);\n\tmemcpy(new->IV, IV, IVlen);\n\tnew->mode = mode;\n\tnew->count=BLOCK_SIZE;   /* stores how many bytes in new->oldCipher have been used */\n\treturn new;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1658,
    "critical_vars": [
      "midisize"
    ],
    "function": "*WildMidi_Open",
    "filename": "wildmidi/CVE-2017-1000418/CVE-2017-1000418_CWE-119_814f31d8eceda8401eb812fc2e94ed143fdad0ab_wildmidi_lib.c.diff",
    "function_code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1703,
    "critical_vars": [
      "size"
    ],
    "function": "*WildMidi_OpenBuffer",
    "filename": "wildmidi/CVE-2017-1000418/CVE-2017-1000418_CWE-119_814f31d8eceda8401eb812fc2e94ed143fdad0ab_wildmidi_lib.c.diff",
    "function_code": "WM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n        /* don't bother loading suspiciously long files */\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n        return (NULL);\n    }\n    if (size < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n    } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1097,
    "line_new": 1097,
    "critical_vars": [
      "str"
    ],
    "function": "PGTYPESinterval_from_asc",
    "filename": "postgres/CVE-2014-0063/CVE-2014-0063_CWE-119_4318daecc959886d001a6e79c6ea853e8b1dfb4b_interval.c.diff",
    "function_code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\n\tif (strlen(str) > MAXDATELEN)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\terrno = 0;\n\treturn result;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 297,
    "line_new": 297,
    "critical_vars": [
      "str"
    ],
    "function": "PGTYPEStimestamp_from_asc",
    "filename": "postgres/CVE-2014-0063/CVE-2014-0063_CWE-119_4318daecc959886d001a6e79c6ea853e8b1dfb4b_timestamp.c.diff",
    "function_code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\n\tif (strlen(str) > MAXDATELEN)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\n\t/* AdjustTimestampForTypmod(&result, typmod); */\n\n\t/*\n\t * Since it's difficult to test for noresult, make sure errno is 0 if no\n\t * error occurred.\n\t */\n\terrno = 0;\n\treturn result;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 160,
    "critical_vars": [
      "ptr",
      "length",
      "conn_status->password"
    ],
    "function": "FUNC_DECODER",
    "filename": "ettercap/CVE-2014-6396/CVE-2014-6396_CWE-119_e3abe7d7585ecc420a7cab73313216613aadad5a_ec_postgresql.c.diff",
    "function_code": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n               int length;\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n               GET_ULONG_BE(length, ptr, 1);\n               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n               conn_status->password[length - 4] = 0;\n               DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 160,
    "critical_vars": [
      "length"
    ],
    "function": "FUNC_DECODER",
    "filename": "ettercap/CVE-2014-6396/CVE-2014-6396_CWE-119_e3abe7d7585ecc420a7cab73313216613aadad5a_ec_postgresql.c.diff",
    "function_code": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n               int length;\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n               GET_ULONG_BE(length, ptr, 1);\n               length -= 4;\n               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {\n                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n                   return NULL;\n               }\n               snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));\n               DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 271,
    "critical_vars": [
      "len"
    ],
    "function": "encode_msg",
    "filename": "kamailio/CVE-2016-2385/CVE-2016-2385_CWE-119_f50c9c853e7809810099c970780c30b0765b0643_encode_msg.c.diff",
    "function_code": "int encode_msg(struct sip_msg *msg,char *payload,int len)\n{\n   int i,j,k,u,request;\n   unsigned short int h;\n   struct hdr_field* hf;\n   struct msg_start* ms;\n   struct sip_uri miuri;\n   char *myerror=NULL;\n   ptrdiff_t diff;\n\n   if(len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN)\n      return -1;\n\n   if(parse_headers(msg,HDR_EOH_F,0)<0){\n      myerror=\"in parse_headers\";\n      goto error;\n   }\n   memset(payload,0,len);\n   ms=&msg->first_line;\n\tif(ms->type == SIP_REQUEST)\n\t\trequest=1;\n\telse if(ms->type == SIP_REPLY)\n\t\trequest=0;\n\telse{\n\t\tmyerror=\"message is neither request nor response\";\n\t\tgoto error;\n\t}\n\tif(request) {\n\t\tfor(h=0;h<32;j=(0x01<<h),h++)\n\t\t\tif(j & ms->u.request.method_value)\n\t\t\t\tbreak;\n\t} else {\n\t\th=(unsigned short)(ms->u.reply.statuscode);\n\t}\n   if(h==32){/*statuscode wont be 32...*/\n      myerror=\"unknown message type\\n\";\n      goto error;\n   }\n   h=htons(h);\n   /*first goes the message code type*/\n   memcpy(payload,&h,2);\n   h=htons((unsigned short int)msg->len);\n   /*then goes the message start idx, but we'll put it later*/\n   /*then goes the message length (we hope it to be less than 65535 bytes...)*/\n   memcpy(&payload[MSG_LEN_IDX],&h,2);\n   /*then goes the content start index (starting from SIP MSG START)*/\n   if(0>(diff=(get_body(msg)-(msg->buf)))){\n      myerror=\"body starts before the message (uh ?)\";\n      goto error;\n   }else\n      h=htons((unsigned short int)diff);\n   memcpy(payload+CONTENT_IDX,&h,2);\n   payload[METHOD_CODE_IDX]=(unsigned char)(request?\n\t (ms->u.request.method.s-msg->buf):\n\t (ms->u.reply.status.s-msg->buf));\n   payload[METHOD_CODE_IDX+1]=(unsigned char)(request?\n\t (ms->u.request.method.len):\n\t (ms->u.reply.status.len));\n   payload[URI_REASON_IDX]=(unsigned char)(request?\n\t (ms->u.request.uri.s-msg->buf):\n\t (ms->u.reply.reason.s-msg->buf));\n   payload[URI_REASON_IDX+1]=(unsigned char)(request?\n\t (ms->u.request.uri.len):\n\t (ms->u.reply.reason.len));\n   payload[VERSION_IDX]=(unsigned char)(request?\n\t (ms->u.request.version.s-msg->buf):\n\t (ms->u.reply.version.s-msg->buf));\n   if(request){\n      if (parse_uri(ms->u.request.uri.s,ms->u.request.uri.len, &miuri)<0){\n\t LM_ERR(\"<%.*s>\\n\",ms->u.request.uri.len,ms->u.request.uri.s);\n\t myerror=\"while parsing the R-URI\";\n\t goto error;\n      }\n      if(0>(j=encode_uri2(msg->buf,\n\t\t  ms->u.request.method.s-msg->buf+ms->len,\n\t\t  ms->u.request.uri,&miuri,\n\t\t  (unsigned char*)&payload[REQUEST_URI_IDX+1])))\n      {\n\t    myerror=\"ENCODE_MSG: ERROR while encoding the R-URI\";\n\t    goto error;\n      }\n      payload[REQUEST_URI_IDX]=(unsigned char)j;\n      k=REQUEST_URI_IDX+1+j;\n   }else\n      k=REQUEST_URI_IDX;\n   u=k;\n   k++;\n   for(i=0,hf=msg->headers;hf;hf=hf->next,i++);\n   i++;/*we do as if there was an extra header, that marks the end of\n\t the previous header in the headers hashtable(read below)*/\n   j=k+3*i;\n   for(i=0,hf=msg->headers;hf;hf=hf->next,k+=3){\n      payload[k]=(unsigned char)(hf->type & 0xFF);\n      h=htons(j);\n      /*now goes a payload-based-ptr to where the header-code starts*/\n      memcpy(&payload[k+1],&h,2);\n      /*TODO fix this... fixed with k-=3?*/\n      if(0>(i=encode_header(msg,hf,(unsigned char*)(payload+j),MAX_ENCODED_MSG+MAX_MESSAGE_LEN-j))){\n\t LM_ERR(\"encoding header %.*s\\n\",hf->name.len,hf->name.s);\n\t goto error;\n\t k-=3;\n\t continue;\n      }\n      j+=(unsigned short int)i;\n   }\n   /*now goes the number of headers that have been found, right after the meta-msg-section*/\n   payload[u]=(unsigned char)((k-u-1)/3);\n   j=htons(j);\n   /*now copy the number of bytes that the headers-meta-section has occupied,right afther\n    * headers-meta-section(the array with ['v',[2:where],'r',[2:where],'R',[2:where],...]\n    * this is to know where the LAST header ends, since the length of each header-struct\n    * is calculated substracting the nextHeaderStart - presentHeaderStart \n    * the k+1 is because payload[k] is usually the letter*/\n   memcpy(&payload[k+1],&j,2);\n   k+=3;\n   j=ntohs(j);\n   /*now we copy the headers-meta-section after the msg-headers-meta-section*/\n   /*memcpy(&payload[k],payload2,j);*/\n   /*j+=k;*/\n   /*pkg_free(payload2);*/\n   /*now we copy the actual message after the headers-meta-section*/\n\n\tif(len < j + msg->len + 1) {\n   \t   LM_ERR(\"not enough space to encode sip message\\n\");\n   \t   return -1;\n\t}\n   memcpy(&payload[j],msg->buf,msg->len);\n   LM_DBG(\"msglen = %d,msg starts at %d\\n\",msg->len,j);\n   j=htons(j);\n   /*now we copy at the beginning, the index to where the actual message starts*/\n   memcpy(&payload[MSG_START_IDX],&j,2);\n   return GET_PAY_SIZE( payload );\nerror:\n   LM_ERR(\"%s\\n\",myerror);\n   return -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3529,
    "critical_vars": [
      "recurse"
    ],
    "function": "eval7",
    "filename": "vim/CVE-2022-0351/CVE-2022-0351_CWE-119_fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d_eval.c.diff",
    "function_code": "eval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 311,
    "critical_vars": [
      "ptr",
      "len",
      "result"
    ],
    "function": "*fstrndup",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 311,
    "critical_vars": [
      "ptr",
      "len",
      "result"
    ],
    "function": "*fstrndup",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memcpy(result, ptr, len);\n  return result;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1065,
    "line_new": 1065,
    "critical_vars": [
      "state->indent"
    ],
    "function": "cState_indent_set",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static VALUE cState_indent_set(VALUE self, VALUE indent)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = fstrndup(RSTRING_PTR(indent), len);\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1103,
    "line_new": 1103,
    "critical_vars": [
      "state->space"
    ],
    "function": "cState_space_set",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static VALUE cState_space_set(VALUE self, VALUE space)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space, T_STRING);\n    len = RSTRING_LEN(space);\n    if (len == 0) {\n        if (state->space) {\n            ruby_xfree(state->space);\n            state->space = NULL;\n            state->space_len = 0;\n        }\n    } else {\n        if (state->space) ruby_xfree(state->space);\n        state->space = fstrndup(RSTRING_PTR(space), len);\n        state->space_len = len;\n    }\n    return Qnil;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1139,
    "line_new": 1139,
    "critical_vars": [
      "state->space_before"
    ],
    "function": "cState_space_before_set",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = fstrndup(RSTRING_PTR(space_before), len);\n        state->space_before_len = len;\n    }\n    return Qnil;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1176,
    "line_new": 1176,
    "critical_vars": [
      "state->object_nl"
    ],
    "function": "cState_object_nl_set",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = fstrndup(RSTRING_PTR(object_nl), len);\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1211,
    "line_new": 1211,
    "critical_vars": [
      "state->array_nl"
    ],
    "function": "cState_array_nl_set",
    "filename": "json/CVE-2017-14064/CVE-2017-14064_CWE-119_8f782fd8e181d9cfe9387ded43a5ca9692266b85_generator.c.diff",
    "function_code": "static VALUE cState_array_nl_set(VALUE self, VALUE array_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = fstrndup(RSTRING_PTR(array_nl), len);\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 32,
    "critical_vars": [
      "original_length"
    ],
    "function": "queue_push",
    "filename": "yodl/CVE-2016-10375/CVE-2016-10375_CWE-119_fd85f8c94182558ff1480d06a236d6fb927979a3_queuepush.c.diff",
    "function_code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n\n    if (!extra_length)\n        return;\n\n    memory_length    = qp->d_memory_end - qp->d_memory;\n\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n\n    available_length = memory_length - q_length - 1;\n                            /* -1, as the Q cannot completely fill up all   */\n                            /* available memory in the buffer               */\n\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n\n    if (extra_length > available_length)\n    {\n        size_t original_length = memory_length;\n\n                                                   /* enlarge the buffer:  */\n        memory_length += extra_length - available_length + BLOCK_QUEUE;\n\n        cp = new_memory(memory_length, sizeof(char));\n\n        if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n\n        if (qp->d_read > qp->d_write)               /* q wraps around end   */\n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       /* first part -> begin  */\n                                                    /* 2nd part beyond      */\n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n        }\n        else                                        /* q as one block       */\n        {\n            memcpy(cp, qp->d_memory, original_length);/* cp existing buffer   */\n            qp->d_read = cp + (qp->d_read - qp->d_memory);\n            qp->d_write = cp + (qp->d_write - qp->d_memory);\n        }\n\n        free(qp->d_memory);                         /* free old memory      */\n        qp->d_memory_end = cp + memory_length;      /* update d_memory_end  */\n        qp->d_memory = cp;                          /* update d_memory      */\n    }\n\n    /*\n        Write as much as possible at the begin of the buffer, then write\n        the remaining chars at the end.\n\n        q_length is increased by the length of the info string\n\n        The first chars to write are at the end of info, and the 2nd part to\n        write are the initial chars of info, since the initial part of info\n        is then read first.\n    */\n\n                                                /* # chars available at the */\n    begin_length = qp->d_read - qp->d_memory;   /* begin of the buffer      */\n\n    n_begin = extra_length <= begin_length ?    /* determine # to write at  */\n                    extra_length                /* the begin of the buffer  */\n                :\n                    begin_length;\n\n    memcpy                                      /* write trailing part of   */\n    (                                           /* info first               */\n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n\n    if (extra_length > begin_length)            /* not yet all chars written*/\n    {\n        /* continue with the remaining number of characters. Insert these at*/\n        /* the end of the buffer                                            */\n\n        extra_length -= begin_length;           /* reduce # to write        */\n\n\n        memcpy                                  /* d_read wraps to the end  */\n        (                                       /* write info's rest        */\n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 111,
    "critical_vars": [
      "msg->maxsize",
      "msg->cursize"
    ],
    "function": "MSG_WriteBits",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_msg.c.diff",
    "function_code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\t// this isn't an exact overflow check, but close enough\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 110,
    "critical_vars": [
      "msg->overflowed"
    ],
    "function": "MSG_WriteBits",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_msg.c.diff",
    "function_code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\tif ( msg->overflowed ) {\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {\n\t\t\tmsg->overflowed = qtrue;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tif ( msg->bit + nbits > msg->maxsize << 3 ) {\n\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );\n\t\t\t\tvalue = (value >> 8);\n\n\t\t\t\tif ( msg->bit > msg->maxsize << 3 ) {\n\t\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 182,
    "critical_vars": [
      "msg->readcount"
    ],
    "function": "MSG_ReadBits",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_msg.c.diff",
    "function_code": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n//\tFILE*\tfp;\n\n\tif ( msg->readcount > msg->cursize ) {\n\t\treturn 0;\n\t}\n\n\tvalue = 0;\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\n\tif (msg->oob) {\n\t\tif (msg->readcount + (bits>>3) > msg->cursize) {\n\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\t\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tif (msg->bit + nbits > msg->cursize << 3) {\n\t\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n//\t\t\tfp = fopen(\"c:\\\\netchan.bin\", \"a\");\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit, msg->cursize<<3);\n//\t\t\t\tfwrite(&get, 1, 1, fp);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\n\t\t\t\tif (msg->bit > msg->cursize<<3) {\n\t\t\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfclose(fp);\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\n\treturn value;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 324,
    "critical_vars": [
      "maxoffset"
    ],
    "function": "send",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_huffman.c.diff",
    "function_code": "static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout, maxoffset);\n\t}\n\tif (child) {\n\t\tif (bloc >= maxoffset) {\n\t\t\tbloc = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 425,
    "critical_vars": [
      "size<<3"
    ],
    "function": "Huff_Compress",
    "filename": "ioq3/CVE-2017-11721/CVE-2017-11721_CWE-119_d2b1d124d4055c2fcbe5126863487c52fd58cca1_huffman.c.diff",
    "function_code": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\n\tif (size<=0) {\n\t\treturn;\n\t}\n\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\t// Add the NYT (not yet transmitted) node into the tree/list */\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\n\tbloc = 16;\n\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq, size<<3);\t\t\t\t\t\t/* Transmit symbol */\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t/* Do update */\n\t}\n\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t// next byte\n\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 11546,
    "critical_vars": [
      "ifd"
    ],
    "function": "parse_tiff_ifd",
    "filename": "LibRaw/CVE-2017-6886/CVE-2017-6886_CWE-119_d7c3d2cb460be10a3ea7b32e9443a83c243b2251_dcraw_common.cpp.diff",
    "function_code": "int CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif    \n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 292,
    "critical_vars": [
      "data->strval"
    ],
    "function": "parse_string_node",
    "filename": "libplist/CVE-2017-6435/CVE-2017-6435_CWE-119_fbd8494d5e4e46bf2e90cb6116903e404374fb56_bplist.c.diff",
    "function_code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n\n    return node_create(NULL, data);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "for-Condition",
    "line_old": 373,
    "line_new": 373,
    "critical_vars": [
      "s"
    ],
    "function": "t1mac_output_ascii",
    "filename": "t1utils/CVE-2015-3905/CVE-2015-3905_CWE-119_6b9d1aafcb61a3663c883663eb19ccdbfcde8d33_t1mac.c.diff",
    "function_code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  /* Mac line endings */\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace((unsigned char) *s); s++)\n        /* skip */;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace((unsigned char) *t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 728,
    "line_new": 728,
    "critical_vars": [
      "count"
    ],
    "function": "yr_object_array_set_item",
    "filename": "yara/CVE-2017-11328/CVE-2017-11328_CWE-119_4a342f01e5439b9bb901aff1c6c23c536baeeb3f_object.c.diff",
    "function_code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = 64;\n\n    while (count <= index)\n      count *= 2;\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n\n    while (count <= index)\n      count *= 2;\n\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1401,
    "critical_vars": [
      "condition:tests.integer_array[256]"
    ],
    "function": "test_modules",
    "filename": "yara/CVE-2017-11328/CVE-2017-11328_CWE-119_4a342f01e5439b9bb901aff1c6c23c536baeeb3f_test-rules.c.diff",
    "function_code": "static void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[256] == 256 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) == tests.foobar(1) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) != tests.foobar(2) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 179,
    "critical_vars": [
      "module_object"
    ],
    "function": "module_load",
    "filename": "yara/CVE-2017-11328/CVE-2017-11328_CWE-119_4a342f01e5439b9bb901aff1c6c23c536baeeb3f_tests.c.diff",
    "function_code": "int module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n\n  set_integer(1, module_object, \"struct_array[1].i\");\n\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n  set_integer(256, module_object, \"integer_array[%i]\", 256);\n\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n\n  return ERROR_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 470,
    "critical_vars": [
      "dev",
      "s",
      "stellaris_enet_load",
      "stellaris_enet_save"
    ],
    "function": "stellaris_enet_init",
    "filename": "qemu/CVE-2013-4532/CVE-2013-4532_CWE-119_2e1198672759eda6e122ff38fcf6df06f27e0fe2_stellaris_enet.c.diff",
    "function_code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 479,
    "critical_vars": [
      "s"
    ],
    "function": "stellaris_enet_unrealize",
    "filename": "qemu/CVE-2013-4532/CVE-2013-4532_CWE-119_2e1198672759eda6e122ff38fcf6df06f27e0fe2_stellaris_enet.c.diff",
    "function_code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n\n    memory_region_destroy(&s->mmio);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 508,
    "critical_vars": [
      "dc->vmsd"
    ],
    "function": "stellaris_enet_class_init",
    "filename": "qemu/CVE-2013-4532/CVE-2013-4532_CWE-119_2e1198672759eda6e122ff38fcf6df06f27e0fe2_stellaris_enet.c.diff",
    "function_code": "static void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 128,
    "line_new": 135,
    "critical_vars": [
      "r->qiov.size",
      "r->iov.iov_len"
    ],
    "function": "scsi_read_complete",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->qiov.size);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 184,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_read_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 194,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_read_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    n = scsi_init_iovec(r);\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 242,
    "critical_vars": [
      "len"
    ],
    "function": "scsi_write_complete",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 256,
    "line_new": 256,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_write_complete",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        scsi_init_iovec(r);\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, r->qiov.size);\n        scsi_req_data(&r->req, r->qiov.size);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 287,
    "line_new": 283,
    "critical_vars": [
      "n"
    ],
    "function": "scsi_write_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->qiov.size / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                       scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Called for the first time.  Ask the driver to send us more data.  */\n        scsi_write_complete(r, 0);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 292,
    "critical_vars": [
      "&r->iov",
      "&r->qiov"
    ],
    "function": "scsi_write_data",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_103b40f51e4012b3b0ad20f615562a1806d7f49a_scsi-disk.c.diff",
    "function_code": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->iov.iov_len / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Invoke completion routine to fetch data from host.  */\n        scsi_write_complete(r, 0);\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 326,
    "line_new": 335,
    "critical_vars": [
      "ret"
    ],
    "function": "scsi_dma_restart_bh",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_7285477ab11831b1cf56e45878a89170dd06d9b9_scsi-disk.c.diff",
    "function_code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 998,
    "critical_vars": [
      "*outbuf"
    ],
    "function": "scsi_send_command",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_7285477ab11831b1cf56e45878a89170dd06d9b9_scsi-disk.c.diff",
    "function_code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1031,
    "line_new": 1056,
    "critical_vars": [
      "rc"
    ],
    "function": "scsi_send_command",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_7285477ab11831b1cf56e45878a89170dd06d9b9_scsi-disk.c.diff",
    "function_code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    int rc;\n\n    command = buf[0];\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 1282,
    "critical_vars": [
      "*r"
    ],
    "function": "*scsi_new_request",
    "filename": "qemu/CVE-2011-3346/CVE-2011-3346_CWE-119_7285477ab11831b1cf56e45878a89170dd06d9b9_scsi-disk.c.diff",
    "function_code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 637,
    "critical_vars": [
      "signature"
    ],
    "function": "key_verify",
    "filename": "pam_p11/CVE-2019-16058/CVE-2019-16058_CWE-119_d150b60e1e14c261b113f55681419ad1dfa8a76c_pam_p11.c.diff",
    "function_code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 638,
    "critical_vars": [
      "*signature"
    ],
    "function": "key_verify",
    "filename": "pam_p11/CVE-2019-16058/CVE-2019-16058_CWE-119_d150b60e1e14c261b113f55681419ad1dfa8a76c_pam_p11.c.diff",
    "function_code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char *signature = NULL;\n\tunsigned int siglen;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\tif (NULL == privkey)\n\t\tgoto err;\n\tsiglen = EVP_PKEY_size(privkey);\n\tif (siglen <= 0)\n\t\tgoto err;\n\tsignature = malloc(siglen);\n\tif (NULL == signature)\n\t\tgoto err;\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tfree(signature);\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 810,
    "critical_vars": [
      "update",
      "s"
    ],
    "function": "update_recv",
    "filename": "FreeRDP/CVE-2020-11046/CVE-2020-11046_CWE-119_ed53cd148f43cbab905eaa0f5308c2bf3c48cc37_update.c.diff",
    "function_code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 810,
    "critical_vars": [
      "update",
      "s"
    ],
    "function": "update_recv",
    "filename": "FreeRDP/CVE-2020-11046/CVE-2020-11046_CWE-119_ed53cd148f43cbab905eaa0f5308c2bf3c48cc37_update.c.diff",
    "function_code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 106,
    "line_new": 106,
    "critical_vars": [
      "fs->fat_size",
      "lss"
    ],
    "function": "dump_boot",
    "filename": "dosfstools/CVE-2016-4804/CVE-2016-4804_CWE-119_e8eff147e9da1185f9afd5b25948153a3b97cf52_boot.c.diff",
    "function_code": "static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)\n{\n    unsigned short sectors;\n\n    printf(\"Boot sector contents:\\n\");\n    if (!atari_format) {\n\tchar id[9];\n\tstrncpy(id, (const char *)b->system_id, 8);\n\tid[8] = 0;\n\tprintf(\"System ID \\\"%s\\\"\\n\", id);\n    } else {\n\t/* On Atari, a 24 bit serial number is stored at offset 8 of the boot\n\t * sector */\n\tprintf(\"Serial number 0x%x\\n\",\n\t       b->system_id[5] | (b->system_id[6] << 8) | (b->\n\t\t\t\t\t\t\t   system_id[7] << 16));\n    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start / lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,\n\t   (long long)fs->fat_size / lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->data_start,\n\t   (unsigned long long)fs->data_start / lss);\n    printf(\"%10lu data clusters (%llu bytes)\\n\",\n\t   (unsigned long)fs->data_clusters,\n\t   (unsigned long long)fs->data_clusters * fs->cluster_size);\n    printf(\"%u sectors/track, %u heads\\n\", le16toh(b->secs_track),\n\t   le16toh(b->heads));\n    printf(\"%10u hidden sectors\\n\", atari_format ?\n\t   /* On Atari, the hidden field is only 16 bit wide and unused */\n\t   (((unsigned char *)&b->hidden)[0] |\n\t    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));\n    sectors = GET_UNALIGNED_W(b->sectors);\n    printf(\"%10u sectors total\\n\", sectors ? sectors : le32toh(b->total_sect));\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 332,
    "line_new": 332,
    "critical_vars": [
      "fat_length"
    ],
    "function": "read_boot",
    "filename": "dosfstools/CVE-2016-4804/CVE-2016-4804_CWE-119_e8eff147e9da1185f9afd5b25948153a3b97cf52_boot.c.diff",
    "function_code": "void read_boot(DOS_FS * fs)\n{\n    struct boot_sector b;\n    unsigned total_sectors;\n    unsigned short logical_sector_size, sectors;\n    off_t fat_length;\n    unsigned total_fat_entries;\n    off_t data_size;\n\n    fs_read(0, sizeof(b), &b);\n    logical_sector_size = GET_UNALIGNED_W(b.sector_size);\n    if (!logical_sector_size)\n\tdie(\"Logical sector size is zero.\");\n\n    /* This was moved up because it's the first thing that will fail */\n    /* if the platform needs special handling of unaligned multibyte accesses */\n    /* but such handling isn't being provided. See GET_UNALIGNED_W() above. */\n    if (logical_sector_size & (SECTOR_SIZE - 1))\n\tdie(\"Logical sector size (%d bytes) is not a multiple of the physical \"\n\t    \"sector size.\", logical_sector_size);\n\n    fs->cluster_size = b.cluster_size * logical_sector_size;\n    if (!fs->cluster_size)\n\tdie(\"Cluster size is zero.\");\n    if (b.fats != 2 && b.fats != 1)\n\tdie(\"Currently, only 1 or 2 FATs are supported, not %d.\\n\", b.fats);\n    fs->nfats = b.fats;\n    sectors = GET_UNALIGNED_W(b.sectors);\n    total_sectors = sectors ? sectors : le32toh(b.total_sect);\n    if (verbose)\n\tprintf(\"Checking we can access the last sector of the filesystem\\n\");\n    /* Can't access last odd sector anyway, so round down */\n    fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,\n\t    logical_sector_size);\n\n    fat_length = le16toh(b.fat_length) ?\n\tle16toh(b.fat_length) : le32toh(b.fat32_length);\n    if (!fat_length)\n\tdie(\"FAT size is zero.\");\n\n    fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;\n    fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *\n\tlogical_sector_size;\n    fs->root_entries = GET_UNALIGNED_W(b.dir_entries);\n    fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<\n\t\t\t\t\t\t\tMSDOS_DIR_BITS,\n\t\t\t\t\t\t\tlogical_sector_size);\n\n    data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;\n    if (data_size < fs->cluster_size)\n\tdie(\"Filesystem has no space for any data clusters\");\n\n    fs->data_clusters = data_size / fs->cluster_size;\n    fs->root_cluster = 0;\t/* indicates standard, pre-FAT32 root dir */\n    fs->fsinfo_start = 0;\t/* no FSINFO structure */\n    fs->free_clusters = -1;\t/* unknown */\n    if (!b.fat_length && b.fat32_length) {\n\tfs->fat_bits = 32;\n\tfs->root_cluster = le32toh(b.root_cluster);\n\tif (!fs->root_cluster && fs->root_entries)\n\t    /* M$ hasn't specified this, but it looks reasonable: If\n\t     * root_cluster is 0 but there is a separate root dir\n\t     * (root_entries != 0), we handle the root dir the old way. Give a\n\t     * warning, but convertig to a root dir in a cluster chain seems\n\t     * to complex for now... */\n\t    printf(\"Warning: FAT32 root dir not in cluster chain! \"\n\t\t   \"Compatibility mode...\\n\");\n\telse if (!fs->root_cluster && !fs->root_entries)\n\t    die(\"No root directory!\");\n\telse if (fs->root_cluster && fs->root_entries)\n\t    printf(\"Warning: FAT32 root dir is in a cluster chain, but \"\n\t\t   \"a separate root dir\\n\"\n\t\t   \"  area is defined. Cannot fix this easily.\\n\");\n\tif (fs->data_clusters < FAT16_THRESHOLD)\n\t    printf(\"Warning: Filesystem is FAT32 according to fat_length \"\n\t\t   \"and fat32_length fields,\\n\"\n\t\t   \"  but has only %lu clusters, less than the required \"\n\t\t   \"minimum of %d.\\n\"\n\t\t   \"  This may lead to problems on some systems.\\n\",\n\t\t   (unsigned long)fs->data_clusters, FAT16_THRESHOLD);\n\n\tcheck_fat_state_bit(fs, &b);\n\tfs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;\n\tcheck_backup_boot(fs, &b, logical_sector_size);\n\n\tread_fsinfo(fs, &b, logical_sector_size);\n    } else if (!atari_format) {\n\t/* On real MS-DOS, a 16 bit FAT is used whenever there would be too\n\t * much clusers otherwise. */\n\tfs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;\n\tif (fs->data_clusters >= FAT16_THRESHOLD)\n\t    die(\"Too many clusters (%lu) for FAT16 filesystem.\", fs->data_clusters);\n\tcheck_fat_state_bit(fs, &b);\n    } else {\n\t/* On Atari, things are more difficult: GEMDOS always uses 12bit FATs\n\t * on floppies, and always 16 bit on harddisks. */\n\tfs->fat_bits = 16;\t/* assume 16 bit FAT for now */\n\t/* If more clusters than fat entries in 16-bit fat, we assume\n\t * it's a real MSDOS FS with 12-bit fat. */\n\tif (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||\n\t    /* if it has one of the usual floppy sizes -> 12bit FAT  */\n\t    (total_sectors == 720 || total_sectors == 1440 ||\n\t     total_sectors == 2880))\n\t    fs->fat_bits = 12;\n    }\n    /* On FAT32, the high 4 bits of a FAT entry are reserved */\n    fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;\n    fs->fat_size = fat_length * logical_sector_size;\n\n    fs->label = calloc(12, sizeof(uint8_t));\n    if (fs->fat_bits == 12 || fs->fat_bits == 16) {\n\tstruct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;\n\tif (b16->extended_sig == 0x29)\n\t    memmove(fs->label, b16->label, 11);\n\telse\n\t    fs->label = NULL;\n    } else if (fs->fat_bits == 32) {\n\tif (b.extended_sig == 0x29)\n\t    memmove(fs->label, &b.label, 11);\n\telse\n\t    fs->label = NULL;\n    }\n\n    total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;\n    if (fs->data_clusters > total_fat_entries - 2)\n\tdie(\"Filesystem has %u clusters but only space for %u FAT entries.\",\n\t    fs->data_clusters, total_fat_entries - 2);\n    if (!fs->root_entries && !fs->root_cluster)\n\tdie(\"Root directory has zero size.\");\n    if (fs->root_entries & (MSDOS_DPS - 1))\n\tdie(\"Root directory (%d entries) doesn't span an integral number of \"\n\t    \"sectors.\", fs->root_entries);\n    if (logical_sector_size & (SECTOR_SIZE - 1))\n\tdie(\"Logical sector size (%d bytes) is not a multiple of the physical \"\n\t    \"sector size.\", logical_sector_size);\n#if 0\t\t\t\t/* linux kernel doesn't check that either */\n    /* ++roman: On Atari, these two fields are often left uninitialized */\n    if (!atari_format && (!b.secs_track || !b.heads))\n\tdie(\"Invalid disk format in boot sector.\");\n#endif\n    if (verbose)\n\tdump_boot(fs, &b, logical_sector_size);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 279,
    "line_new": 279,
    "critical_vars": [
      "remain"
    ],
    "function": "dynamicGetbuf",
    "filename": "libgd/CVE-2016-8670/CVE-2016-8670_CWE-119_53110871935244816bbb9d131da0bccff734bfe9_gd_io_dp.c.diff",
    "function_code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1378,
    "critical_vars": [
      "url_address",
      "url_len",
      "url_begin"
    ],
    "function": "extract_sockaddr",
    "filename": "cgminer/CVE-2014-4502/CVE-2014-4502_CWE-119_e1c5050734123973b99d181c45e74b2cbb00272e_util.c.diff",
    "function_code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1688,
    "line_new": 1716,
    "critical_vars": [
      "bbversion",
      "prev_hash",
      "job_id",
      "ntime",
      "coinbase1",
      "coinbase2",
      "nbit"
    ],
    "function": "parse_notify",
    "filename": "cgminer/CVE-2014-4502/CVE-2014-4502_CWE-119_e1c5050734123973b99d181c45e74b2cbb00272e_util.c.diff",
    "function_code": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n\tntime = __json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!valid_hex(job_id) || !valid_hex(prev_hash) || !valid_hex(coinbase1) ||\n\t    !valid_hex(coinbase2) || !valid_hex(bbversion) || !valid_hex(nbit) ||\n\t    !valid_hex(ntime)) {\n\t\t/* Annoying but we must not leak memory */\n\t\tfree(job_id);\n\t\tfree(coinbase1);\n\t\tfree(coinbase2);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1690,
    "critical_vars": [
      "job_id"
    ],
    "function": "parse_notify",
    "filename": "cgminer/CVE-2014-4502/CVE-2014-4502_CWE-119_e1c5050734123973b99d181c45e74b2cbb00272e_util.c.diff",
    "function_code": "static bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, header[228];\n\tunsigned char *cb1 = NULL, *cb2 = NULL;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = __json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = __json_array_string(val, 5);\n\tnbit = __json_array_string(val, 6);\n\tntime = __json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tpool->swork.job_id = job_id;\n\tsnprintf(pool->prev_hash, 65, \"%s\", prev_hash);\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tsnprintf(pool->bbversion, 9, \"%s\", bbversion);\n\tsnprintf(pool->nbit, 9, \"%s\", nbit);\n\tsnprintf(pool->ntime, 9, \"%s\", ntime);\n\tpool->swork.clean = clean;\n\talloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\tif (opt_protocol)\n\t\t\t\tapplog(LOG_DEBUG, \"merkle %d: %s\", i, merkle);\n\t\t\tret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t\tif (unlikely(!ret)) {\n\t\t\t\tapplog(LOG_ERR, \"Failed to convert merkle to merkle_bin in parse_notify\");\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tpool->merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n#if 0\n\theader_len = \t\t strlen(pool->bbversion) +\n\t\t\t\t strlen(pool->prev_hash);\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->ntime) +\n\t\t\t\t strlen(pool->nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n#endif\n\tsnprintf(header, 225,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->bbversion,\n\t\tpool->prev_hash,\n\t\tblank_merkle,\n\t\tpool->ntime,\n\t\tpool->nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tret = hex2bin(pool->header_bin, header, 112);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert header to header_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\n\tcb1 = alloca(cb1_len);\n\tret = hex2bin(cb1, coinbase1, cb1_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb1 to cb1_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tcb2 = alloca(cb2_len);\n\tret = hex2bin(cb2, coinbase2, cb2_len);\n\tif (unlikely(!ret)) {\n\t\tapplog(LOG_ERR, \"Failed to convert cb2 to cb2_bin in parse_notify\");\n\t\tgoto out_unlock;\n\t}\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tif (opt_debug) {\n\t\tchar *cb = bin2hex(pool->coinbase, pool->coinbase_len);\n\n\t\tapplog(LOG_DEBUG, \"Pool %d coinbase %s\", pool->pool_no, cb);\n\t\tfree(cb);\n\t}\nout_unlock:\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 329,
    "critical_vars": [
      "psf",
      "calloc",
      "sizeof"
    ],
    "function": "sf_open",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 329,
    "critical_vars": [
      "psf_allocate",
      "psf"
    ],
    "function": "sf_open",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 361,
    "critical_vars": [
      "psf",
      "calloc",
      "sizeof"
    ],
    "function": "sf_open_fd",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_fd */",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 361,
    "critical_vars": [
      "psf_allocate",
      "psf"
    ],
    "function": "sf_open_fd",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_fd */",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 403,
    "critical_vars": [
      "psf_allocate",
      "psf"
    ],
    "function": "sf_open_virtual",
    "filename": "libsndfile/CVE-2017-7586/CVE-2017-7586_CWE-119_708e996c87c5fae77b104ccfeb8f6db784c32074_sndfile.c.diff",
    "function_code": "sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Make sure we have a valid set ot virtual pointers. */\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\n\tpsf->file.mode = mode ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_virtual */",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 349,
    "critical_vars": [
      "ushorthuff[258],vpred[2][2]"
    ],
    "function": "foveon_dp_load_raw",
    "filename": "LibRaw-demosaic-pack-GPL2/CVE-2017-6890/CVE-2017-6890_CWE-119_194f592e205990ea8fce72b6c571c14350aca716_dcraw_foveon.c.diff",
    "function_code": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse hpred[col & 1] += diff;\n\timage[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 349,
    "critical_vars": [
      "ushorthuff[1024],vpred[2][2]"
    ],
    "function": "foveon_dp_load_raw",
    "filename": "LibRaw-demosaic-pack-GPL2/CVE-2017-6890/CVE-2017-6890_CWE-119_194f592e205990ea8fce72b6c571c14350aca716_dcraw_foveon.c.diff",
    "function_code": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[1024], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse hpred[col & 1] += diff;\n\timage[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 435,
    "critical_vars": [
      "len"
    ],
    "function": "git_pkt_parse_line",
    "filename": "libgit2/CVE-2016-10128/CVE-2016-10128_CWE-119_66e3774d279672ee51c3b54545a79d20d1ada834_smart_pkt.c.diff",
    "function_code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 404,
    "critical_vars": [
      "sc->drefs_count"
    ],
    "function": "mov_read_dref",
    "filename": "FFmpeg/CVE-2016-3062/CVE-2016-3062_CWE-119_689e59b7ffed34eba6159dcc78e87133862e3746_mov.c.diff",
    "function_code": "static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n    av_free(sc->drefs);\n    sc->drefs_count = 0;\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < sc->drefs_count; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb) + size - 4;\n\n        if (size < 12)\n            return AVERROR_INVALIDDATA;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n        av_dlog(c->fc, \"type %.4s size %d\\n\", (char*)&dref->type, size);\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            avio_read(pb, dref->volume, 27);\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            avio_read(pb, dref->filename, 63);\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if(url_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n                    avio_read(pb, dref->path, len);\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':')\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n                    avio_read(pb, dref->dir, len);\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1281,
    "line_new": 1281,
    "critical_vars": [
      "line"
    ],
    "function": "jpeg2000_decode_tile",
    "filename": "FFmpeg/CVE-2013-7024/CVE-2013-7024_CWE-119_fe448cd28d674c3eff3072552eae366d0b659ce9_jpeg2000dec.c.diff",
    "function_code": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n                                AVFrame *picture)\n{\n    int compno, reslevelno, bandno;\n    int x, y;\n\n    uint8_t *line;\n    Jpeg2000T1Context t1;\n\n    /* Loop on tile components */\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp     = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n        /* Loop on resolution levels */\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n            /* Loop on bands */\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n                int nb_precincts, precno;\n                Jpeg2000Band *band = rlevel->band + bandno;\n                int cblkno = 0, bandpos;\n\n                bandpos = bandno + (reslevelno > 0);\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n                    band->coord[1][0] == band->coord[1][1])\n                    continue;\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n                /* Loop on precincts */\n                for (precno = 0; precno < nb_precincts; precno++) {\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n                    /* Loop on codeblocks */\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                        int x, y;\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                        decode_cblk(s, codsty, &t1, cblk,\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n                                    bandpos);\n\n                        x = cblk->coord[0][0];\n                        y = cblk->coord[1][0];\n\n                        if (codsty->transform == FF_DWT97)\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n                        else\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n                   } /* end cblk */\n                } /*end prec */\n            } /* end band */\n        } /* end reslevel */\n\n        /* inverse DWT */\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n    } /*end comp */\n\n    /* inverse MCT transformation */\n    if (tile->codsty[0].mct)\n        mct_decode(s, tile);\n\n    if (s->cdef[0] < 0) {\n        for (x = 0; x < s->ncomponents; x++)\n            s->cdef[x] = x + 1;\n        if ((s->ncomponents & 1) == 0)\n            s->cdef[s->ncomponents-1] = 0;\n    }\n\n    if (s->precision <= 8) {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            line = picture->data[plane] + y / s->cdy[compno] * picture->linesize[plane];\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint8_t *dst;\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = line + x / s->cdx[compno] * pixelsize + compno*!planar;\n\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                line += picture->linesize[plane];\n            }\n        }\n    } else {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            uint16_t *linel;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            linel = (uint16_t *)picture->data[plane] + y / s->cdy[compno] * (picture->linesize[plane] >> 1);\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint16_t *dst;\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = linel + (x / s->cdx[compno] * pixelsize + compno*!planar);\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        /* align 12 bit values in little-endian mode */\n                        *dst = val << (16 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        /* align 12 bit values in little-endian mode */\n                        *dst = val << (16 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                linel += picture->linesize[plane] >> 1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 241,
    "critical_vars": [
      "pc->index"
    ],
    "function": "ff_combine_frame",
    "filename": "FFmpeg/CVE-2013-7023/CVE-2013-7023_CWE-119_f31011e9abfb2ae75bb32bc44e2c34194c8dc40a_parser.c.diff",
    "function_code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n\n    /* Copy overread bytes from last frame into buffer. */\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n\n    /* flush remaining if EOF */\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n\n    pc->last_index= pc->index;\n\n    /* copy into buffer end return */\n    if(next == END_NOT_FOUND){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if(!new_buffer) {\n            pc->index = 0;\n            return AVERROR(ENOMEM);\n        }\n        pc->buffer = new_buffer;\n        memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n        pc->index += *buf_size;\n        return -1;\n    }\n\n    *buf_size=\n    pc->overread_index= pc->index + next;\n\n    /* append to buffer */\n    if(pc->index){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer) {\n            pc->overread_index =\n            pc->index = 0;\n            return AVERROR(ENOMEM);\n        }\n        pc->buffer = new_buffer;\n        if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n            memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n\n    /* store overread bytes */\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 178,
    "line_new": 178,
    "critical_vars": [
      "frame_end",
      "frame"
    ],
    "function": "decode_dds1",
    "filename": "FFmpeg/CVE-2017-9992/CVE-2017-9992_CWE-119_f52fbf4f3ed02a7d872d8a102006f29b4421f360_dfa.c.diff",
    "function_code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 4)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 276,
    "critical_vars": [
      "s->cdx[i]"
    ],
    "function": "get_siz",
    "filename": "FFmpeg/CVE-2013-7016/CVE-2013-7016_CWE-119_8bb11c3ca77b52e05a9ed1496a65f8a76e6e2d8f_jpeg2000dec.c.diff",
    "function_code": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n               s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (!s->cdx[i] || !s->cdy[i]) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample seperation\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 276,
    "critical_vars": [
      "s->cdx[i]",
      "s->cdy[i]"
    ],
    "function": "get_siz",
    "filename": "FFmpeg/CVE-2013-7016/CVE-2013-7016_CWE-119_8bb11c3ca77b52e05a9ed1496a65f8a76e6e2d8f_jpeg2000dec.c.diff",
    "function_code": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n               s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample seperation\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 238,
    "critical_vars": [
      "len"
    ],
    "function": "color_string_to_rgba",
    "filename": "FFmpeg/CVE-2017-9990/CVE-2017-9990_CWE-119_cb243972b121b1ae6b60a78ff55a0506c69f3879_xpmdec.c.diff",
    "function_code": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n    const ColorEntry *entry;\n    char color_name[100];\n\n    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n\n    if (*p == '#') {\n        p++;\n        len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n\n        if (!entry)\n            return ret;\n\n        ret = entry->rgb_color;\n    }\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 302,
    "critical_vars": [
      "*ptr"
    ],
    "function": "xpm_decode_frame",
    "filename": "FFmpeg/CVE-2017-9990/CVE-2017-9990_CWE-119_cb243972b121b1ae6b60a78ff55a0506c69f3879_xpmdec.c.diff",
    "function_code": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    XPMDecContext *x = avctx->priv_data;\n    AVFrame *p=data;\n    const uint8_t *end, *ptr = avpkt->data;\n    int ncolors, cpp, ret, i, j;\n    int64_t size;\n    uint32_t *dst;\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n    end = avpkt->data + avpkt->size;\n    while (memcmp(ptr, \"/* XPM */\", 9) && ptr < end - 9)\n        ptr++;\n\n    if (ptr >= end) {\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    if (cpp <= 0 || cpp >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = 1;\n    for (i = 0; i < cpp; i++)\n        size *= 94;\n\n    if (ncolors <= 0 || ncolors > size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size *= 4;\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n    if (!x->pixels)\n        return AVERROR(ENOMEM);\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n    for (i = 0; i < ncolors; i++) {\n        const uint8_t *index;\n        int len;\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n        if (ptr + cpp > end)\n            return AVERROR_INVALIDDATA;\n        index = ptr;\n        ptr += cpp;\n\n        ptr = strstr(ptr, \"c \");\n        if (ptr) {\n            ptr += 2;\n        } else {\n            return AVERROR_INVALIDDATA;\n        }\n\n        len = strcspn(ptr, \"\\\" \");\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n            return ret;\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n        ptr += mod_strcspn(ptr, \",\") + 1;\n    }\n\n    for (i = 0; i < avctx->height; i++) {\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        for (j = 0; j < avctx->width; j++) {\n            if (ptr + cpp > end)\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n                return ret;\n\n            *dst++ = x->pixels[ret];\n            ptr += cpp;\n        }\n        ptr += mod_strcspn(ptr, \",\") + 1;\n    }\n\n    p->key_frame = 1;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 306,
    "critical_vars": [
      "*end",
      "*ptr"
    ],
    "function": "xpm_decode_frame",
    "filename": "FFmpeg/CVE-2017-9990/CVE-2017-9990_CWE-119_cb243972b121b1ae6b60a78ff55a0506c69f3879_xpmdec.c.diff",
    "function_code": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    XPMDecContext *x = avctx->priv_data;\n    AVFrame *p=data;\n    const uint8_t *end, *ptr;\n    int ncolors, cpp, ret, i, j;\n    int64_t size;\n    uint32_t *dst;\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n    av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);\n    if (!x->buf)\n        return AVERROR(ENOMEM);\n    memcpy(x->buf, avpkt->data, avpkt->size);\n    x->buf[avpkt->size] = 0;\n\n    ptr = x->buf;\n    end = x->buf + avpkt->size;\n    while (end - ptr > 9 && memcmp(ptr, \"/* XPM */\", 9))\n        ptr++;\n\n    if (end - ptr <= 9) {\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    if (cpp <= 0 || cpp >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = 1;\n    for (i = 0; i < cpp; i++)\n        size *= 95;\n\n    if (ncolors <= 0 || ncolors > size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size *= 4;\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n    if (!x->pixels)\n        return AVERROR(ENOMEM);\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n    if (end - ptr < 1)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < ncolors; i++) {\n        const uint8_t *index;\n        int len;\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n        if (end - ptr < cpp)\n            return AVERROR_INVALIDDATA;\n        index = ptr;\n        ptr += cpp;\n\n        ptr = strstr(ptr, \"c \");\n        if (ptr) {\n            ptr += 2;\n        } else {\n            return AVERROR_INVALIDDATA;\n        }\n\n        len = strcspn(ptr, \"\\\" \");\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n            return ret;\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n        ptr += mod_strcspn(ptr, \",\") + 1;\n        if (end - ptr < 1)\n            return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < avctx->height; i++) {\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n        if (end - ptr < 1)\n            return AVERROR_INVALIDDATA;\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n        if (end - ptr < 1)\n            return AVERROR_INVALIDDATA;\n\n        for (j = 0; j < avctx->width; j++) {\n            if (end - ptr < cpp)\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n                return ret;\n\n            *dst++ = x->pixels[ret];\n            ptr += cpp;\n        }\n        ptr += mod_strcspn(ptr, \",\") + 1;\n    }\n\n    p->key_frame = 1;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 428,
    "critical_vars": [
      "&x->buf"
    ],
    "function": "xpm_decode_close",
    "filename": "FFmpeg/CVE-2017-9990/CVE-2017-9990_CWE-119_cb243972b121b1ae6b60a78ff55a0506c69f3879_xpmdec.c.diff",
    "function_code": "static av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n\n    av_freep(&x->buf);\n    x->buf_size = 0;\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 492,
    "line_new": 492,
    "critical_vars": [
      "s->filesize"
    ],
    "function": "http_open",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n\n    s->filesize = UINT64_MAX;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 619,
    "line_new": 619,
    "critical_vars": [
      "s->off"
    ],
    "function": "parse_content_range",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoull(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoull(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; /* we _can_ in fact seek */\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 811,
    "line_new": 811,
    "critical_vars": [
      "s->filesize"
    ],
    "function": "process_line",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int process_line(URLContext *h, char *line, int line_count,\n                        int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    const char *auto_method =  h->flags & AVIO_FLAG_READ ? \"POST\" : \"GET\";\n    char *tag, *p, *end, *method, *resource, *version;\n    int ret;\n\n    /* end of header */\n    if (line[0] == '\\0') {\n        s->end_header = 1;\n        return 0;\n    }\n\n    p = line;\n    if (line_count == 0) {\n        if (s->is_connected_server) {\n            // HTTP method\n            method = p;\n            while (*p && !av_isspace(*p))\n                p++;\n            *(p++) = '\\0';\n            av_log(h, AV_LOG_TRACE, \"Received method: %s\\n\", method);\n            if (s->method) {\n                if (av_strcasecmp(s->method, method)) {\n                    av_log(h, AV_LOG_ERROR, \"Received and expected HTTP method do not match. (%s expected, %s received)\\n\",\n                           s->method, method);\n                    return ff_http_averror(400, AVERROR(EIO));\n                }\n            } else {\n                // use autodetected HTTP method to expect\n                av_log(h, AV_LOG_TRACE, \"Autodetected %s HTTP method\\n\", auto_method);\n                if (av_strcasecmp(auto_method, method)) {\n                    av_log(h, AV_LOG_ERROR, \"Received and autodetected HTTP method did not match \"\n                           \"(%s autodetected %s received)\\n\", auto_method, method);\n                    return ff_http_averror(400, AVERROR(EIO));\n                }\n                if (!(s->method = av_strdup(method)))\n                    return AVERROR(ENOMEM);\n            }\n\n            // HTTP resource\n            while (av_isspace(*p))\n                p++;\n            resource = p;\n            while (!av_isspace(*p))\n                p++;\n            *(p++) = '\\0';\n            av_log(h, AV_LOG_TRACE, \"Requested resource: %s\\n\", resource);\n            if (!(s->resource = av_strdup(resource)))\n                return AVERROR(ENOMEM);\n\n            // HTTP version\n            while (av_isspace(*p))\n                p++;\n            version = p;\n            while (*p && !av_isspace(*p))\n                p++;\n            *p = '\\0';\n            if (av_strncasecmp(version, \"HTTP/\", 5)) {\n                av_log(h, AV_LOG_ERROR, \"Malformed HTTP version string.\\n\");\n                return ff_http_averror(400, AVERROR(EIO));\n            }\n            av_log(h, AV_LOG_TRACE, \"HTTP version string: %s\\n\", version);\n        } else {\n            while (!av_isspace(*p) && *p != '\\0')\n                p++;\n            while (av_isspace(*p))\n                p++;\n            s->http_code = strtol(p, &end, 10);\n\n            av_log(h, AV_LOG_TRACE, \"http_code=%d\\n\", s->http_code);\n\n            if ((ret = check_http_code(h, s->http_code, end)) < 0)\n                return ret;\n        }\n    } else {\n        while (*p != '\\0' && *p != ':')\n            p++;\n        if (*p != ':')\n            return 1;\n\n        *p  = '\\0';\n        tag = line;\n        p++;\n        while (av_isspace(*p))\n            p++;\n        if (!av_strcasecmp(tag, \"Location\")) {\n            if ((ret = parse_location(s, p)) < 0)\n                return ret;\n            *new_location = 1;\n        } else if (!av_strcasecmp(tag, \"Content-Length\") &&\n                   s->filesize == UINT64_MAX) {\n            s->filesize = strtoull(p, NULL, 10);\n        } else if (!av_strcasecmp(tag, \"Content-Range\")) {\n            parse_content_range(h, p);\n        } else if (!av_strcasecmp(tag, \"Accept-Ranges\") &&\n                   !strncmp(p, \"bytes\", 5) &&\n                   s->seekable == -1) {\n            h->is_streamed = 0;\n        } else if (!av_strcasecmp(tag, \"Transfer-Encoding\") &&\n                   !av_strncasecmp(p, \"chunked\", 7)) {\n            s->filesize  = UINT64_MAX;\n            s->chunksize = 0;\n        } else if (!av_strcasecmp(tag, \"WWW-Authenticate\")) {\n            ff_http_auth_handle_header(&s->auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, \"Authentication-Info\")) {\n            ff_http_auth_handle_header(&s->auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, \"Proxy-Authenticate\")) {\n            ff_http_auth_handle_header(&s->proxy_auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, \"Connection\")) {\n            if (!strcmp(p, \"close\"))\n                s->willclose = 1;\n        } else if (!av_strcasecmp(tag, \"Server\")) {\n            if (!av_strcasecmp(p, \"AkamaiGHost\")) {\n                s->is_akamai = 1;\n            } else if (!av_strncasecmp(p, \"MediaGateway\", 12)) {\n                s->is_mediagateway = 1;\n            }\n        } else if (!av_strcasecmp(tag, \"Content-Type\")) {\n            av_free(s->mime_type);\n            s->mime_type = av_strdup(p);\n        } else if (!av_strcasecmp(tag, \"Set-Cookie\")) {\n            if (parse_cookie(s, p, &s->cookie_dict))\n                av_log(h, AV_LOG_WARNING, \"Unable to parse '%s'\\n\", p);\n        } else if (!av_strcasecmp(tag, \"Icy-MetaInt\")) {\n            s->icy_metaint = strtoull(p, NULL, 10);\n        } else if (!av_strncasecmp(tag, \"Icy-\", 4)) {\n            if ((ret = parse_icy(s, tag, p)) < 0)\n                return ret;\n        } else if (!av_strcasecmp(tag, \"Content-Encoding\")) {\n            if ((ret = parse_content_encoding(h, p)) < 0)\n                return ret;\n        }\n    }\n    return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 975,
    "line_new": 976,
    "critical_vars": [
      "s->chunksize"
    ],
    "function": "http_read_header",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n\n    s->chunksize = UINT64_MAX;\n\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; /* we can in fact _not_ seek */\n\n    // add any new cookies into the existing cookie string\n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n\n    return err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1009,
    "line_new": 1010,
    "critical_vars": [
      "off"
    ],
    "function": "http_connect",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_connect(URLContext *h, const char *path, const char *local_path,\n                        const char *hoststr, const char *auth,\n                        const char *proxyauth, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    int post, err;\n    char headers[HTTP_HEADERS_SIZE] = \"\";\n    char *authstr = NULL, *proxyauthstr = NULL;\n    uint64_t off = s->off;\n    int len = 0;\n    const char *method;\n    int send_expect_100 = 0;\n\n    /* send http header */\n    post = h->flags & AVIO_FLAG_WRITE;\n\n    if (s->post_data) {\n        /* force POST method and disable chunked encoding when\n         * custom HTTP post data is set */\n        post            = 1;\n        s->chunked_post = 0;\n    }\n\n    if (s->method)\n        method = s->method;\n    else\n        method = post ? \"POST\" : \"GET\";\n\n    authstr      = ff_http_auth_create_response(&s->auth_state, auth,\n                                                local_path, method);\n    proxyauthstr = ff_http_auth_create_response(&s->proxy_auth_state, proxyauth,\n                                                local_path, method);\n    if (post && !s->post_data) {\n        send_expect_100 = s->send_expect_100;\n        /* The user has supplied authentication but we don't know the auth type,\n         * send Expect: 100-continue to get the 401 response including the\n         * WWW-Authenticate header, or an 100 continue if no auth actually\n         * is needed. */\n        if (auth && *auth &&\n            s->auth_state.auth_type == HTTP_AUTH_NONE &&\n            s->http_code != 401)\n            send_expect_100 = 1;\n    }\n\n#if FF_API_HTTP_USER_AGENT\n    if (strcmp(s->user_agent_deprecated, DEFAULT_USER_AGENT)) {\n        av_log(s, AV_LOG_WARNING, \"the user-agent option is deprecated, please use user_agent option\\n\");\n        s->user_agent = av_strdup(s->user_agent_deprecated);\n    }\n#endif\n    /* set default headers if needed */\n    if (!has_header(s->headers, \"\\r\\nUser-Agent: \"))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"User-Agent: %s\\r\\n\", s->user_agent);\n    if (!has_header(s->headers, \"\\r\\nAccept: \"))\n        len += av_strlcpy(headers + len, \"Accept: */*\\r\\n\",\n                          sizeof(headers) - len);\n    // Note: we send this on purpose even when s->off is 0 when we're probing,\n    // since it allows us to detect more reliably if a (non-conforming)\n    // server supports seeking by analysing the reply headers.\n    if (!has_header(s->headers, \"\\r\\nRange: \") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Range: bytes=%\"PRIu64\"-\", s->off);\n        if (s->end_off)\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n                               \"%\"PRId64, s->end_off - 1);\n        len += av_strlcpy(headers + len, \"\\r\\n\",\n                          sizeof(headers) - len);\n    }\n    if (send_expect_100 && !has_header(s->headers, \"\\r\\nExpect: \"))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Expect: 100-continue\\r\\n\");\n\n    if (!has_header(s->headers, \"\\r\\nConnection: \")) {\n        if (s->multiple_requests)\n            len += av_strlcpy(headers + len, \"Connection: keep-alive\\r\\n\",\n                              sizeof(headers) - len);\n        else\n            len += av_strlcpy(headers + len, \"Connection: close\\r\\n\",\n                              sizeof(headers) - len);\n    }\n\n    if (!has_header(s->headers, \"\\r\\nHost: \"))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Host: %s\\r\\n\", hoststr);\n    if (!has_header(s->headers, \"\\r\\nContent-Length: \") && s->post_data)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Content-Length: %d\\r\\n\", s->post_datalen);\n\n    if (!has_header(s->headers, \"\\r\\nContent-Type: \") && s->content_type)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Content-Type: %s\\r\\n\", s->content_type);\n    if (!has_header(s->headers, \"\\r\\nCookie: \") && s->cookies) {\n        char *cookies = NULL;\n        if (!get_cookies(s, &cookies, path, hoststr) && cookies) {\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n                               \"Cookie: %s\\r\\n\", cookies);\n            av_free(cookies);\n        }\n    }\n    if (!has_header(s->headers, \"\\r\\nIcy-MetaData: \") && s->icy)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Icy-MetaData: %d\\r\\n\", 1);\n\n    /* now add in custom headers */\n    if (s->headers)\n        av_strlcpy(headers + len, s->headers, sizeof(headers) - len);\n\n    snprintf(s->buffer, sizeof(s->buffer),\n             \"%s %s HTTP/1.1\\r\\n\"\n             \"%s\"\n             \"%s\"\n             \"%s\"\n             \"%s%s\"\n             \"\\r\\n\",\n             method,\n             path,\n             post && s->chunked_post ? \"Transfer-Encoding: chunked\\r\\n\" : \"\",\n             headers,\n             authstr ? authstr : \"\",\n             proxyauthstr ? \"Proxy-\" : \"\", proxyauthstr ? proxyauthstr : \"\");\n\n    av_log(h, AV_LOG_DEBUG, \"request: %s\\n\", s->buffer);\n\n    if ((err = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n        goto done;\n\n    if (s->post_data)\n        if ((err = ffurl_write(s->hd, s->post_data, s->post_datalen)) < 0)\n            goto done;\n\n    /* init input buffer */\n    s->buf_ptr          = s->buffer;\n    s->buf_end          = s->buffer;\n    s->line_count       = 0;\n    s->off              = 0;\n    s->icy_data_read    = 0;\n    s->filesize         = UINT64_MAX;\n    s->willclose        = 0;\n    s->end_chunked_post = 0;\n    s->end_header       = 0;\n    if (post && !s->post_data && !send_expect_100) {\n        /* Pretend that it did work. We didn't read any header yet, since\n         * we've still to send the POST data, but the code calling this\n         * function will check http_code after we return. */\n        s->http_code = 200;\n        err = 0;\n        goto done;\n    }\n\n    /* wait for header */\n    err = http_read_header(h, new_location);\n    if (err < 0)\n        goto done;\n\n    if (*new_location)\n        s->off = off;\n\n    err = (off == s->off) ? 0 : -1;\ndone:\n    av_freep(&authstr);\n    av_freep(&proxyauthstr);\n    return err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1178,
    "line_new": 1179,
    "critical_vars": [
      "target_end"
    ],
    "function": "http_buf_read",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        uint64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1179,
    "critical_vars": [
      "target_end",
      "s->chunksize"
    ],
    "function": "http_buf_read",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1250,
    "line_new": 1249,
    "critical_vars": [
      "s->chunksize"
    ],
    "function": "http_read_stream",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n\n    if (!s->hd)\n        return AVERROR_EOF;\n\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n\n    if (s->chunksize != UINT64_MAX) {\n        if (!s->chunksize) {\n            char line[32];\n\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    /* skip CR LF from last chunk */\n\n                s->chunksize = strtoull(line, NULL, 16);\n\n                av_log(h, AV_LOG_TRACE,\n                       \"Chunked encoding data size: %\"PRIu64\"'\\n\",\n                        s->chunksize);\n\n                if (!s->chunksize)\n                    return 0;\n                else if (s->chunksize == UINT64_MAX) {\n                    av_log(h, AV_LOG_ERROR, \"Invalid chunk size %\"PRIu64\"\\n\",\n                           s->chunksize);\n                    return AVERROR(EINVAL);\n                }\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif /* CONFIG_ZLIB */\n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        uint64_t target = h->is_streamed ? 0 : s->off;\n\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRIu64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRIu64\".\\n\", target);\n            return read_ret;\n        }\n\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n\n    return read_ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1341,
    "critical_vars": [
      "remaining"
    ],
    "function": "store_icy",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    /* until next metadata packet */\n    int remaining = s->icy_metaint - s->icy_data_read;\n\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n\n    if (!remaining) {\n        /* The metadata packet is variable sized. It has a 1 byte header\n         * which sets the length of the packet (divided by 16). If it's 0,\n         * the metadata doesn't change. After the packet, icy_metaint bytes\n         * of normal data follows. */\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n\n    return FFMIN(size, remaining);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1346,
    "critical_vars": [
      "remaining"
    ],
    "function": "store_icy",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    /* until next metadata packet */\n    uint64_t remaining;\n\n    if (s->icy_metaint < s->icy_data_read)\n        return AVERROR_INVALIDDATA;\n    remaining = s->icy_metaint - s->icy_data_read;\n\n    if (!remaining) {\n        /* The metadata packet is variable sized. It has a 1 byte header\n         * which sets the length of the packet (divided by 16). If it's 0,\n         * the metadata doesn't change. After the packet, icy_metaint bytes\n         * of normal data follows. */\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n\n    return FFMIN(size, remaining);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1458,
    "line_new": 1464,
    "critical_vars": [
      "old_off"
    ],
    "function": "http_seek_internal",
    "filename": "FFmpeg/CVE-2016-10190/CVE-2016-10190_CWE-119_2a05c8f813de6f2278827734bf8102291e7484aa_http.c.diff",
    "function_code": "static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    uint64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == UINT64_MAX && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n\n    /* we save the old context in case the seek fails */\n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n\n    /* if it fails, continue on old connection */\n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 160,
    "critical_vars": [
      "bpp"
    ],
    "function": "xwd_decode_frame",
    "filename": "FFmpeg/CVE-2017-9991/CVE-2017-9991_CWE-119_441026fcb13ac23aa10edc312bdacb6445a0ad06_xwddec.c.diff",
    "function_code": "static int xwd_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    AVFrame *p = data;\n    const uint8_t *buf = avpkt->data;\n    int i, ret, buf_size = avpkt->size;\n    uint32_t version, header_size, vclass, ncolors;\n    uint32_t xoffset, be, bpp, lsize, rsize;\n    uint32_t pixformat, pixdepth, bunit, bitorder, bpad;\n    uint32_t rgb[3];\n    uint8_t *ptr;\n    GetByteContext gb;\n\n    if (buf_size < XWD_HEADER_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, buf, buf_size);\n    header_size = bytestream2_get_be32u(&gb);\n\n    version = bytestream2_get_be32u(&gb);\n    if (version != XWD_VERSION) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported version\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (buf_size < header_size || header_size < XWD_HEADER_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid header size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    pixformat     = bytestream2_get_be32u(&gb);\n    pixdepth      = bytestream2_get_be32u(&gb);\n    avctx->width  = bytestream2_get_be32u(&gb);\n    avctx->height = bytestream2_get_be32u(&gb);\n    xoffset       = bytestream2_get_be32u(&gb);\n    be            = bytestream2_get_be32u(&gb);\n    bunit         = bytestream2_get_be32u(&gb);\n    bitorder      = bytestream2_get_be32u(&gb);\n    bpad          = bytestream2_get_be32u(&gb);\n    bpp           = bytestream2_get_be32u(&gb);\n    lsize         = bytestream2_get_be32u(&gb);\n    vclass        = bytestream2_get_be32u(&gb);\n    rgb[0]        = bytestream2_get_be32u(&gb);\n    rgb[1]        = bytestream2_get_be32u(&gb);\n    rgb[2]        = bytestream2_get_be32u(&gb);\n    bytestream2_skipu(&gb, 8);\n    ncolors       = bytestream2_get_be32u(&gb);\n    bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20));\n\n    av_log(avctx, AV_LOG_DEBUG,\n           \"pixformat %\"PRIu32\", pixdepth %\"PRIu32\", bunit %\"PRIu32\", bitorder %\"PRIu32\", bpad %\"PRIu32\"\\n\",\n           pixformat, pixdepth, bunit, bitorder, bpad);\n    av_log(avctx, AV_LOG_DEBUG,\n           \"vclass %\"PRIu32\", ncolors %\"PRIu32\", bpp %\"PRIu32\", be %\"PRIu32\", lsize %\"PRIu32\", xoffset %\"PRIu32\"\\n\",\n           vclass, ncolors, bpp, be, lsize, xoffset);\n    av_log(avctx, AV_LOG_DEBUG,\n           \"red %0\"PRIx32\", green %0\"PRIx32\", blue %0\"PRIx32\"\\n\",\n           rgb[0], rgb[1], rgb[2]);\n\n    if (pixformat > XWD_Z_PIXMAP) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid pixmap format\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (pixdepth == 0 || pixdepth > 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid pixmap depth\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (xoffset) {\n        avpriv_request_sample(avctx, \"xoffset %\"PRIu32\"\", xoffset);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (be > 1) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid byte order\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bitorder > 1) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bitmap bit order\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bunit != 8 && bunit != 16 && bunit != 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bitmap unit\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bpad != 8 && bpad != 16 && bpad != 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bitmap scan-line pad\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bpp == 0 || bpp > 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bits per pixel\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncolors > 256) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of entries in colormap\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0)\n        return ret;\n\n    rsize = FFALIGN(avctx->width * bpp, bpad) / 8;\n    if (lsize < rsize) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bytes per scan-line\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) {\n        av_log(avctx, AV_LOG_ERROR, \"input buffer too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (pixformat != XWD_Z_PIXMAP) {\n        avpriv_report_missing_feature(avctx, \"Pixmap format %\"PRIu32, pixformat);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_NONE;\n    switch (vclass) {\n    case XWD_STATIC_GRAY:\n    case XWD_GRAY_SCALE:\n        if (bpp != 1 && bpp != 8)\n            return AVERROR_INVALIDDATA;\n        if (bpp == 1 && pixdepth == 1) {\n            avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;\n        } else if (bpp == 8 && pixdepth == 8) {\n            avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n        }\n        break;\n    case XWD_STATIC_COLOR:\n    case XWD_PSEUDO_COLOR:\n        if (bpp == 8)\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    case XWD_TRUE_COLOR:\n    case XWD_DIRECT_COLOR:\n        if (bpp != 16 && bpp != 24 && bpp != 32)\n            return AVERROR_INVALIDDATA;\n        if (bpp == 16 && pixdepth == 15) {\n            if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F)\n                avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE;\n            else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00)\n                avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE;\n        } else if (bpp == 16 && pixdepth == 16) {\n            if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F)\n                avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE;\n            else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800)\n                avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE;\n        } else if (bpp == 24) {\n            if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)\n                avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24;\n            else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)\n                avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24;\n        } else if (bpp == 32) {\n            if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)\n                avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA;\n            else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)\n                avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA;\n        }\n        bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE);\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid visual class\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        avpriv_request_sample(avctx,\n                              \"Unknown file: bpp %\"PRIu32\", pixdepth %\"PRIu32\", vclass %\"PRIu32\"\",\n                              bpp, pixdepth, vclass);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    p->key_frame = 1;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        uint32_t *dst = (uint32_t *)p->data[1];\n        uint8_t red, green, blue;\n\n        for (i = 0; i < ncolors; i++) {\n\n            bytestream2_skipu(&gb, 4); // skip colormap entry number\n            red    = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 1);\n            green  = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 1);\n            blue   = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 3); // skip bitmask flag and padding\n\n            dst[i] = red << 16 | green << 8 | blue;\n        }\n    }\n\n    ptr = p->data[0];\n    for (i = 0; i < avctx->height; i++) {\n        bytestream2_get_bufferu(&gb, ptr, rsize);\n        bytestream2_skipu(&gb, lsize - rsize);\n        ptr += p->linesize[0];\n    }\n\n    *got_frame       = 1;\n\n    return buf_size;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 169,
    "line_new": 169,
    "critical_vars": [
      "value"
    ],
    "function": "sdp_parse_fmtp_config_h264",
    "filename": "FFmpeg/CVE-2017-14767/CVE-2017-14767_CWE-119_c42a1388a6d1bfd8001bf6a4241d8ca27e49326d_rtpdec_h264.c.diff",
    "function_code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n         * Packetization Mode:\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n         *                      and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (*value == 0 || value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 2741,
    "line_new": 2741,
    "critical_vars": [
      "c->chunk_size"
    ],
    "function": "http_receive_data",
    "filename": "FFmpeg/CVE-2016-10192/CVE-2016-10192_CWE-119_a5d25faa3f4b18dac737fdb35d0dd68eb0dc2156_ffserver.c.diff",
    "function_code": "static int http_receive_data(HTTPContext *c)\n{\n    HTTPContext *c1;\n    int len, loop_run = 0;\n\n    while (c->chunked_encoding && !c->chunk_size &&\n           c->buffer_end > c->buffer_ptr) {\n        /* read chunk header, if present */\n        len = recv(c->fd, c->buffer_ptr, 1, 0);\n\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n            return 0;\n        } else if (len == 0) {\n            /* end of connection : close it */\n            goto fail;\n        } else if (c->buffer_ptr - c->buffer >= 2 &&\n                   !memcmp(c->buffer_ptr - 1, \"\\r\\n\", 2)) {\n            c->chunk_size = strtol(c->buffer, 0, 16);\n            if (c->chunk_size <= 0) { // end of stream or invalid chunk size\n                c->chunk_size = 0;\n                goto fail;\n            }\n            c->buffer_ptr = c->buffer;\n            break;\n        } else if (++loop_run > 10)\n            /* no chunk header, abort */\n            goto fail;\n        else\n            c->buffer_ptr++;\n    }\n\n    if (c->buffer_end > c->buffer_ptr) {\n        len = recv(c->fd, c->buffer_ptr,\n                   FFMIN(c->chunk_size, c->buffer_end - c->buffer_ptr), 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n        } else if (len == 0)\n            /* end of connection : close it */\n            goto fail;\n        else {\n            av_assert0(len <= c->chunk_size);\n            c->chunk_size -= len;\n            c->buffer_ptr += len;\n            c->data_count += len;\n            update_datarate(&c->datarate, c->data_count);\n        }\n    }\n\n    if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {\n        if (c->buffer[0] != 'f' ||\n            c->buffer[1] != 'm') {\n            http_log(\"Feed stream has become desynchronized -- disconnecting\\n\");\n            goto fail;\n        }\n    }\n\n    if (c->buffer_ptr >= c->buffer_end) {\n        FFServerStream *feed = c->stream;\n        /* a packet has been received : write it in the store, except\n         * if header */\n        if (c->data_count > FFM_PACKET_SIZE) {\n            /* XXX: use llseek or url_seek\n             * XXX: Should probably fail? */\n            if (lseek(c->feed_fd, feed->feed_write_index, SEEK_SET) == -1)\n                http_log(\"Seek to %\"PRId64\" failed\\n\", feed->feed_write_index);\n\n            if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {\n                http_log(\"Error writing to feed file: %s\\n\", strerror(errno));\n                goto fail;\n            }\n\n            feed->feed_write_index += FFM_PACKET_SIZE;\n            /* update file size */\n            if (feed->feed_write_index > c->stream->feed_size)\n                feed->feed_size = feed->feed_write_index;\n\n            /* handle wrap around if max file size reached */\n            if (c->stream->feed_max_size &&\n                feed->feed_write_index >= c->stream->feed_max_size)\n                feed->feed_write_index = FFM_PACKET_SIZE;\n\n            /* write index */\n            if (ffm_write_write_index(c->feed_fd, feed->feed_write_index) < 0) {\n                http_log(\"Error writing index to feed file: %s\\n\",\n                         strerror(errno));\n                goto fail;\n            }\n\n            /* wake up any waiting connections */\n            for(c1 = first_http_ctx; c1; c1 = c1->next) {\n                if (c1->state == HTTPSTATE_WAIT_FEED &&\n                    c1->stream->feed == c->stream->feed)\n                    c1->state = HTTPSTATE_SEND_DATA;\n            }\n        } else {\n            /* We have a header in our hands that contains useful data */\n            AVFormatContext *s = avformat_alloc_context();\n            AVIOContext *pb;\n            AVInputFormat *fmt_in;\n            int i;\n\n            if (!s)\n                goto fail;\n\n            /* use feed output format name to find corresponding input format */\n            fmt_in = av_find_input_format(feed->fmt->name);\n            if (!fmt_in)\n                goto fail;\n\n            pb = avio_alloc_context(c->buffer, c->buffer_end - c->buffer,\n                                    0, NULL, NULL, NULL, NULL);\n            if (!pb)\n                goto fail;\n\n            pb->seekable = 0;\n\n            s->pb = pb;\n            if (avformat_open_input(&s, c->stream->feed_filename, fmt_in, NULL) < 0) {\n                av_freep(&pb);\n                goto fail;\n            }\n\n            /* Now we have the actual streams */\n            if (s->nb_streams != feed->nb_streams) {\n                avformat_close_input(&s);\n                av_freep(&pb);\n                http_log(\"Feed '%s' stream number does not match registered feed\\n\",\n                         c->stream->feed_filename);\n                goto fail;\n            }\n\n            for (i = 0; i < s->nb_streams; i++) {\n                LayeredAVStream *fst = feed->streams[i];\n                AVStream *st = s->streams[i];\n                avcodec_parameters_to_context(fst->codec, st->codecpar);\n                avcodec_parameters_from_context(fst->codecpar, fst->codec);\n            }\n\n            avformat_close_input(&s);\n            av_freep(&pb);\n        }\n        c->buffer_ptr = c->buffer;\n    }\n\n    return 0;\n fail:\n    c->stream->feed_opened = 0;\n    close(c->feed_fd);\n    /* wake up any waiting connections to stop waiting for feed */\n    for(c1 = first_http_ctx; c1; c1 = c1->next) {\n        if (c1->state == HTTPSTATE_WAIT_FEED &&\n            c1->stream->feed == c->stream->feed)\n            c1->state = HTTPSTATE_SEND_DATA_TRAILER;\n    }\n    return -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 611,
    "critical_vars": [
      "src->linesize[plane]"
    ],
    "function": "copy_fields",
    "filename": "FFmpeg/CVE-2013-4263/CVE-2013-4263_CWE-119_e43a0a232dbf6d3c161823c2e07c52e76227a1bc_vf_fieldmatch.c.diff",
    "function_code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 109,
    "critical_vars": [
      "frame->linesize[plane]"
    ],
    "function": "filter_frame",
    "filename": "FFmpeg/CVE-2013-4263/CVE-2013-4263_CWE-119_e43a0a232dbf6d3c161823c2e07c52e76227a1bc_vf_fieldorder.c.diff",
    "function_code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    BoxBlurContext *s = ctx->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int plane;\n    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);\n    int w[4] = { inlink->w, cw, cw, inlink->w };\n    int h[4] = { in->height, ch, ch, in->height };\n\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n\n    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)\n        hblur(out->data[plane], out->linesize[plane],\n              in ->data[plane], in ->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n\n    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)\n        vblur(out->data[plane], out->linesize[plane],\n              out->data[plane], out->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n\n    av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 583,
    "critical_vars": [
      "chroma_h_shift",
      "chroma_planes",
      "transparency",
      "chroma_v_shift"
    ],
    "function": "read_header",
    "filename": "FFmpeg/CVE-2013-7011/CVE-2013-7011_CWE-119_547d690d676064069d44703a1917e0dab7e33445_ffv1dec.c.diff",
    "function_code": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        colorspace     = get_symbol(c, state, 0); //YUV cs type\n        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   colorspace    != f->colorspace\n                || bits_per_raw_sample != f->avctx->bits_per_raw_sample\n                || chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->colorspace     = colorspace;\n        f->avctx->bits_per_raw_sample = bits_per_raw_sample;\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 600,
    "critical_vars": [
      "f->chroma_planes"
    ],
    "function": "read_header",
    "filename": "FFmpeg/CVE-2013-7011/CVE-2013-7011_CWE-119_547d690d676064069d44703a1917e0dab7e33445_ffv1dec.c.diff",
    "function_code": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 282,
    "critical_vars": [
      "c->format"
    ],
    "function": "cdxl_decode_frame",
    "filename": "FFmpeg/CVE-2017-9996/CVE-2017-9996_CWE-119_1e42736b95065c69a7481d0cf55247024f54b660_cdxl.c.diff",
    "function_code": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n        avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n        return AVERROR_INVALIDDATA;\n    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n        if (c->palette_size != (1 << (c->bpp - 1)))\n            return AVERROR_INVALIDDATA;\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n        avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",\n                              encoding, c->bpp, c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n    *got_frame = 1;\n\n    return buf_size;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 387,
    "critical_vars": [
      "c->log2_cblk_width",
      "c->log2_cblk_height"
    ],
    "function": "get_cox",
    "filename": "FFmpeg/CVE-2013-7018/CVE-2013-7018_CWE-119_9a271a9368eaabf99e6c2046103acb33957e63b7_jpeg2000dec.c.diff",
    "function_code": "static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n{\n    uint8_t byte;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    /*  nreslevels = number of resolution levels\n                   = number of decomposition level +1 */\n    c->nreslevels = bytestream2_get_byteu(&s->g) + 1;\n    if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {\n        av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* compute number of resolution levels to decode */\n    if (c->nreslevels < s->reduction_factor)\n        c->nreslevels2decode = 1;\n    else\n        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n\n    c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n    c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height\n\n    if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||\n        c->log2_cblk_width + c->log2_cblk_height > 12) {\n        av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {\n        avpriv_request_sample(s->avctx, \"cblk size > 64\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    c->cblk_style = bytestream2_get_byteu(&s->g);\n    if (c->cblk_style != 0) { // cblk style\n        av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);\n    }\n    c->transform = bytestream2_get_byteu(&s->g); // DWT transformation type\n    /* set integer 9/7 DWT in case of BITEXACT flag */\n    if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))\n        c->transform = FF_DWT97_INT;\n\n    if (c->csty & JPEG2000_CSTY_PREC) {\n        int i;\n        for (i = 0; i < c->nreslevels; i++) {\n            byte = bytestream2_get_byte(&s->g);\n            c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx\n            c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy\n        }\n    } else {\n        memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));\n        memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 709,
    "critical_vars": [
      "size_bmp"
    ],
    "function": "parse_video_info",
    "filename": "FFmpeg/CVE-2018-1999011/CVE-2018-1999011_CWE-119_2b46ebdbff1d8dec7a3d8ea280a612b91a582869_asfdec_o.c.diff",
    "function_code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; // ASF-specific Format Data size\n    uint32_t size_bmp; // BMP_HEADER-specific Format Data size\n    unsigned int tag;\n\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); // skip reserved flags\n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n\n    if (size_bmp > BMP_HEADER_SIZE &&\n        size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 446,
    "line_new": 446,
    "critical_vars": [
      "c->framebuf_stride"
    ],
    "function": "g2m_init_buffers",
    "filename": "FFmpeg/CVE-2013-7022/CVE-2013-7022_CWE-119_e07ac727c1cc9eed39e7f9117c97006f719864bd_g2meet.c.diff",
    "function_code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 238,
    "critical_vars": [
      "prev_pkt[channel_id].size",
      "prev_pkt[channel_id].read",
      "size"
    ],
    "function": "rtmp_packet_read_one_chunk",
    "filename": "FFmpeg/CVE-2016-10191/CVE-2016-10191_CWE-119_7d57ca4d9a75562fa32e40766211de150f8b3ee7_rtmppkt.c.diff",
    "function_code": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {\n        av_log(NULL, AV_LOG_ERROR, \"RTMP packet size mismatch %d != %d\\n\",\n                size,\n                prev_pkt[channel_id].size);\n        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);\n        prev_pkt[channel_id].read = 0;\n    }\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       p->data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 392,
    "critical_vars": [
      "src_end",
      "src"
    ],
    "function": "kempf_decode_tile",
    "filename": "FFmpeg/CVE-2013-4264/CVE-2013-4264_CWE-119_2960576378d17d71cc8dccc926352ce568b5eec1_g2meet.c.diff",
    "function_code": "static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n                             const uint8_t *src, int src_size)\n{\n    int width, height;\n    int hdr, zsize, npal, tidx = -1, ret;\n    int i, j;\n    const uint8_t *src_end = src + src_size;\n    uint8_t pal[768], transp[3];\n    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n    int sub_type;\n    int nblocks, cblocks, bstride;\n    int bits, bitbuf, coded;\n    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n                   tile_y * c->tile_height * c->framebuf_stride;\n\n    if (src_size < 2)\n        return AVERROR_INVALIDDATA;\n\n    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n\n    hdr = *src++;\n    sub_type = hdr >> 5;\n    if (sub_type == 0) {\n        int j;\n        memcpy(transp, src, 3);\n        src += 3;\n        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n            for (i = 0; i < width; i++)\n                memcpy(dst + i * 3, transp, 3);\n        return 0;\n    } else if (sub_type == 1) {\n        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n    }\n\n    if (sub_type != 2) {\n        memcpy(transp, src, 3);\n        src += 3;\n    }\n    npal = *src++ + 1;\n    memcpy(pal, src, npal * 3); src += npal * 3;\n    if (sub_type != 2) {\n        for (i = 0; i < npal; i++) {\n            if (!memcmp(pal + i * 3, transp, 3)) {\n               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize)\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;\n        }\n    }\n\n    memset(c->jpeg_tile, 0, c->tile_stride * height);\n    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                    c->jpeg_tile, c->tile_stride,\n                    c->kempf_flags, bstride, nblocks, 0);\n\n    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                      c->jpeg_tile, c->tile_stride,\n                      width, height, pal, npal, tidx);\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 392,
    "critical_vars": [
      "src_end",
      "zsize",
      "src",
      "sub_type"
    ],
    "function": "kempf_decode_tile",
    "filename": "FFmpeg/CVE-2013-4264/CVE-2013-4264_CWE-119_2960576378d17d71cc8dccc926352ce568b5eec1_g2meet.c.diff",
    "function_code": "static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n                             const uint8_t *src, int src_size)\n{\n    int width, height;\n    int hdr, zsize, npal, tidx = -1, ret;\n    int i, j;\n    const uint8_t *src_end = src + src_size;\n    uint8_t pal[768], transp[3];\n    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n    int sub_type;\n    int nblocks, cblocks, bstride;\n    int bits, bitbuf, coded;\n    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n                   tile_y * c->tile_height * c->framebuf_stride;\n\n    if (src_size < 2)\n        return AVERROR_INVALIDDATA;\n\n    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n\n    hdr = *src++;\n    sub_type = hdr >> 5;\n    if (sub_type == 0) {\n        int j;\n        memcpy(transp, src, 3);\n        src += 3;\n        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n            for (i = 0; i < width; i++)\n                memcpy(dst + i * 3, transp, 3);\n        return 0;\n    } else if (sub_type == 1) {\n        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n    }\n\n    if (sub_type != 2) {\n        memcpy(transp, src, 3);\n        src += 3;\n    }\n    npal = *src++ + 1;\n    memcpy(pal, src, npal * 3); src += npal * 3;\n    if (sub_type != 2) {\n        for (i = 0; i < npal; i++) {\n            if (!memcmp(pal + i * 3, transp, 3)) {\n               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;\n        }\n    }\n\n    memset(c->jpeg_tile, 0, c->tile_stride * height);\n    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                    c->jpeg_tile, c->tile_stride,\n                    c->kempf_flags, bstride, nblocks, 0);\n\n    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                      c->jpeg_tile, c->tile_stride,\n                      width, height, pal, npal, tidx);\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1337,
    "critical_vars": [
      "s->has_alpha"
    ],
    "function": "vp8_lossy_decode_frame",
    "filename": "FFmpeg/CVE-2017-9994/CVE-2017-9994_CWE-119_6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef_webp.c.diff",
    "function_code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1338,
    "critical_vars": [
      "avctx->pix_fmt"
    ],
    "function": "vp8_lossy_decode_frame",
    "filename": "FFmpeg/CVE-2017-9994/CVE-2017-9994_CWE-119_6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef_webp.c.diff",
    "function_code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n    }\n    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 88,
    "line_new": 88,
    "critical_vars": [
      "pixel_ptr"
    ],
    "function": "rpza_decode_stream",
    "filename": "FFmpeg/CVE-2013-7009/CVE-2013-7009_CWE-119_3819db745da2ac7fb3faacb116788c32f4753f34_rpza.c.diff",
    "function_code": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = -4;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                ADVANCE_BLOCK()\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                ADVANCE_BLOCK();\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        /* Fill block with 16 colors */\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            ADVANCE_BLOCK();\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            break;\n\n        /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 334,
    "critical_vars": [
      "y"
    ],
    "function": "decompress_i",
    "filename": "FFmpeg/CVE-2017-9995/CVE-2017-9995_CWE-119_7ac5067146613997bb38442cb022d7f41321a706_scpr.c.diff",
    "function_code": "static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int cx = 0, cx1 = 0, k = 0, clr = 0;\n    int run, r, g, b, off, y = 0, x = 0, z, ret;\n    unsigned backstep = linesize - avctx->width;\n    const int cxshift = s->cxshift;\n    unsigned lx, ly, ptype;\n\n    reinit_tables(s);\n    bytestream2_skip(gb, 2);\n    init_rangecoder(&s->rc, gb);\n\n    while (k < avctx->width + 1) {\n        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = r >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = g >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = b >> cxshift;\n\n        ret = decode_value(s, s->run_model[0], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        clr = (b << 16) + (g << 8) + r;\n        k += run;\n        while (run-- > 0) {\n            if (y >= avctx->height)\n                return AVERROR_INVALIDDATA;\n\n            dst[y * linesize + x] = clr;\n            lx = x;\n            ly = y;\n            x++;\n            if (x >= avctx->width) {\n                x = 0;\n                y++;\n            }\n        }\n    }\n    off = -linesize - 1;\n    ptype = 0;\n\n    while (x < avctx->width && y < avctx->height) {\n        ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n        if (ret < 0)\n            return ret;\n        if (ptype == 0) {\n            ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = r >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = g >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n            if (ret < 0)\n                return ret;\n\n            clr = (b << 16) + (g << 8) + r;\n        }\n        if (ptype > 5)\n            return AVERROR_INVALIDDATA;\n        ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        switch (ptype) {\n        case 0:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 1:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = dst[ly * linesize + lx];\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            clr = dst[ly * linesize + lx];\n            break;\n        case 2:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                clr = dst[y * linesize + x + off + 1];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 4:\n            while (run-- > 0) {\n                uint8_t *odst = (uint8_t *)dst;\n\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                r = odst[(ly * linesize + lx) * 4] +\n                    odst[((y * linesize + x) + off - z) * 4 + 4] -\n                    odst[((y * linesize + x) + off - z) * 4];\n                g = odst[(ly * linesize + lx) * 4 + 1] +\n                    odst[((y * linesize + x) + off - z) * 4 + 5] -\n                    odst[((y * linesize + x) + off - z) * 4 + 1];\n                b = odst[(ly * linesize + lx) * 4 + 2] +\n                    odst[((y * linesize + x) + off - z) * 4 + 6] -\n                    odst[((y * linesize + x) + off - z) * 4 + 2];\n                clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 5:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                clr = dst[y * linesize + x + off - z];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        }\n\n        if (avctx->bits_per_coded_sample == 16) {\n            cx1 = (clr & 0x3F00) >> 2;\n            cx = (clr & 0xFFFFFF) >> 16;\n        } else {\n            cx1 = (clr & 0xFC00) >> 4;\n            cx = (clr & 0xFFFFFF) >> 18;\n        }\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 264,
    "critical_vars": [
      "c",
      "x"
    ],
    "function": "decode_unit",
    "filename": "FFmpeg/CVE-2017-9995/CVE-2017-9995_CWE-119_2171dfae8c065878a2e130390eb78cf2947a5b69_scpr.c.diff",
    "function_code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 230,
    "line_new": 230,
    "critical_vars": [
      "szName",
      "szExt",
      "*ext"
    ],
    "function": "FFD_CanHandleURL",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_ffmpeg_demux.c.diff",
    "function_code": "static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)\n{\n\tBool has_audio, has_video;\n\ts32 i;\n\tAVFormatContext *ctx;\n\tAVOutputFormat *fmt_out;\n\tBool ret = GF_FALSE;\n\tchar *ext, szName[1024], szExt[20];\n\tconst char *szExtList;\n\tFFDemux *ffd;\n\tif (!plug || !url)\n\t\treturn GF_FALSE;\n\t/*disable RTP/RTSP from ffmpeg*/\n\tif (!strnicmp(url, \"rtsp://\", 7)) return GF_FALSE;\n\tif (!strnicmp(url, \"rtspu://\", 8)) return GF_FALSE;\n\tif (!strnicmp(url, \"rtp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"plato://\", 8)) return GF_FALSE;\n\tif (!strnicmp(url, \"udp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"tcp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"data:\", 5)) return GF_FALSE;\n\n\tffd = (FFDemux*)plug->priv;\n\n\tif (strlen(url) >= sizeof(szName))\n\t\treturn GF_FALSE;\n\n\tstrcpy(szName, url);\n\text = strrchr(szName, '#');\n\tif (ext) ext[0] = 0;\n\text = strrchr(szName, '?');\n\tif (ext) ext[0] = 0;\n\n\text = strrchr(szName, '.');\n\tif (ext && strlen(ext) > 19) ext = NULL;\n\n\tif (ext && strlen(ext) > 1 && strlen(ext) <= sizeof(szExt)) {\n\t\tstrcpy(szExt, &ext[1]);\n\t\tstrlwr(szExt);\n#ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS\n\t\tif (strstr(\"ts m2t mts dmb trp\", szExt) ) return GF_FALSE;\n#endif\n\n\t\t/*note we forbid ffmpeg to handle files we support*/\n\t\tif (!strcmp(szExt, \"mp4\") || !strcmp(szExt, \"mpg4\") || !strcmp(szExt, \"m4a\") || !strcmp(szExt, \"m21\")\n\t\t        || !strcmp(szExt, \"m4v\") || !strcmp(szExt, \"m4a\")\n\t\t        || !strcmp(szExt, \"m4s\") || !strcmp(szExt, \"3gs\")\n\t\t        || !strcmp(szExt, \"3gp\") || !strcmp(szExt, \"3gpp\") || !strcmp(szExt, \"3gp2\") || !strcmp(szExt, \"3g2\")\n\t\t        || !strcmp(szExt, \"mp3\")\n\t\t        || !strcmp(szExt, \"ac3\")\n\t\t        || !strcmp(szExt, \"amr\")\n\t\t        || !strcmp(szExt, \"bt\") || !strcmp(szExt, \"wrl\") || !strcmp(szExt, \"x3dv\")\n\t\t        || !strcmp(szExt, \"xmt\") || !strcmp(szExt, \"xmta\") || !strcmp(szExt, \"x3d\")\n\n\t\t        || !strcmp(szExt, \"jpg\") || !strcmp(szExt, \"jpeg\") || !strcmp(szExt, \"png\")\n\t\t   ) return GF_FALSE;\n\n\t\t/*check any default stuff that should work with ffmpeg*/\n\t\t{\n\t\t\tu32 i;\n\t\t\tfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {\n\t\t\t\tif (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tffd_parse_options(ffd, url);\n\n\tctx = NULL;\n\tif (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {\n\t\tAVInputFormat *av_in = NULL;\n\t\t/*some extensions not supported by ffmpeg*/\n\t\tif (ext && !strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\n\t\tif (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\tif (!ctx) goto exit;\n\tif (av_find_stream_info(ctx) <0) goto exit;\n\n\t/*figure out if we can use codecs or not*/\n\thas_video = has_audio = GF_FALSE;\n\tfor(i = 0; i < (s32)ctx->nb_streams; i++) {\n\t\tAVCodecContext *enc = ctx->streams[i]->codec;\n\t\tswitch(enc->codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif (!has_audio) has_audio = GF_TRUE;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tif (!has_video) has_video= GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!has_audio && !has_video) goto exit;\n\tret = GF_TRUE;\n#if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)\n\tfmt_out = guess_stream_format(NULL, url, NULL);\n#else\n\tfmt_out = av_guess_format(NULL, url, NULL);\n#endif\n\tif (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);\n\telse {\n\t\text = strrchr(szName, '.');\n\t\tif (ext) {\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\n\t\t\tszExtList = gf_modules_get_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\");\n\t\t\tif (!szExtList) {\n\t\t\t\tgf_service_register_mime(plug, \"application/x-ffmpeg\", szExt, \"Other Movies (FFMPEG)\");\n\t\t\t} else if (!strstr(szExtList, szExt)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *buf;\n\t\t\t\tlen = (u32) (strlen(szExtList) + strlen(szExt) + 10);\n\t\t\t\tbuf = (char*)gf_malloc(sizeof(char)*len);\n\t\t\t\tsprintf(buf, \"\\\"%s \", szExt);\n\t\t\t\tstrcat(buf, &szExtList[1]);\n\t\t\t\tgf_modules_set_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\", buf);\n\t\t\t\tgf_free(buf);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ctx) av_close_input_file(ctx);\n#else\n\tif (ctx) avformat_close_input(&ctx);\n#endif\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 913,
    "critical_vars": [
      "the_url",
      "evt->navigate.to_url"
    ],
    "function": "GPAC_EventProc",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "Bool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrcpy(the_url, evt->navigate.to_url);\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 913,
    "critical_vars": [
      "the_url",
      "evt->navigate.to_url"
    ],
    "function": "GPAC_EventProc",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "Bool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1103,
    "critical_vars": [
      "sepIdx"
    ],
    "function": "set_cfg_option",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "void set_cfg_option(char *opt_string)\n{\n\tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];\n\tsep = strchr(opt_string, ':');\n\tif (!sep) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep - opt_string;\n\t\tif (sepIdx >= sizeof(szSec)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - Section name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\n\t\tstrncpy(szSec, opt_string, sepIdx);\n\t\tszSec[sepIdx] = 0;\n\t}\n\tsep ++;\n\tsep2 = strchr(sep, '=');\n\tif (!sep2) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep2 - sep;\n\t\tif (sepIdx >= sizeof(szKey)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - key name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrncpy(szKey, sep, sepIdx);\n\t\tszKey[sepIdx] = 0;\n\t\tif (strlen(sep2 + 1) >= sizeof(szVal)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - value is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szVal, sep2+1);\n\t}\n\n\tif (!stricmp(szKey, \"*\")) {\n\t\tif (stricmp(szVal, \"null\")) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tgf_cfg_del_section(cfg_file, szSec);\n\t\treturn;\n\t}\n\n\tif (!stricmp(szVal, \"null\")) {\n\t\tszVal[0]=0;\n\t}\n\tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1683,
    "critical_vars": [
      "the_url",
      "url_arg"
    ],
    "function": "mp4client_main",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tstrcpy(the_url, url_arg);\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) strcpy(the_url, gf_dm_sess_get_cache_name(sess));\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrcpy(the_url, \"MP4Client \"GPAC_FULL_VERSION);\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1697,
    "critical_vars": [
      "url_arg"
    ],
    "function": "mp4client_main",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_main.c.diff",
    "function_code": "int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 649,
    "critical_vars": [
      "ext"
    ],
    "function": "gf_sm_load_init",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_scene_manager.c.diff",
    "function_code": "GF_Err gf_sm_load_init(GF_SceneLoader *load)\n{\n\tGF_Err e = GF_NOT_SUPPORTED;\n\tchar *ext, szExt[50];\n\t/*we need at least a scene graph*/\n\tif (!load || (!load->ctx && !load->scene_graph)\n#ifndef GPAC_DISABLE_ISOM\n\t        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )\n#endif\n\t   ) return GF_BAD_PARAM;\n\n\tif (!load->type) {\n#ifndef GPAC_DISABLE_ISOM\n\t\tif (load->isom) {\n\t\t\tload->type = GF_SM_LOAD_MP4;\n\t\t} else\n#endif\n\t\t{\n\t\t\text = (char *)strrchr(load->fileName, '.');\n\t\t\tif (!ext) return GF_NOT_SUPPORTED;\n\t\t\tif (!stricmp(ext, \".gz\")) {\n\t\t\t\tchar *anext;\n\t\t\t\text[0] = 0;\n\t\t\t\tanext = (char *)strrchr(load->fileName, '.');\n\t\t\t\text[0] = '.';\n\t\t\t\text = anext;\n\t\t\t}\n\t\t\tif (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] invalid extension in file name %s\\n\", load->fileName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\t\t\tif (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;\n\t\t\telse if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;\n\t\t\telse if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;\n#ifndef GPAC_DISABLE_LOADER_XMT\n\t\t\telse if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\telse if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;\n#endif\n\t\t\telse if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;\n\t\t\telse if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;\n\t\t\telse if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;\n\t\t\telse if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;\n\t\t\telse if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;\n\t\t\telse if (strstr(szExt, \"xml\")) {\n\t\t\t\tchar *rtype = gf_xml_get_root_type(load->fileName, &e);\n\t\t\t\tif (rtype) {\n\t\t\t\t\tif (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;\n\t\t\t\t\telse if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\t\t\telse if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;\n\t\t\t\t\telse if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;\n\n\t\t\t\t\tgf_free(rtype);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!load->type) return e;\n\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tswitch (load->type) {\n#ifndef GPAC_DISABLE_LOADER_BT\n\tcase GF_SM_LOAD_BT:\n\tcase GF_SM_LOAD_VRML:\n\tcase GF_SM_LOAD_X3DV:\n\t\treturn gf_sm_load_init_bt(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_XMT\n\tcase GF_SM_LOAD_XMTA:\n\tcase GF_SM_LOAD_X3D:\n\t\treturn gf_sm_load_init_xmt(load);\n#endif\n\n#ifndef GPAC_DISABLE_SVG\n\tcase GF_SM_LOAD_SVG:\n\tcase GF_SM_LOAD_XSR:\n\tcase GF_SM_LOAD_DIMS:\n\t\treturn gf_sm_load_init_svg(load);\n\n\tcase GF_SM_LOAD_XBL:\n\t\te = gf_sm_load_init_xbl(load);\n\n\t\tload->process = gf_sm_load_run_xbl;\n\t\tload->done = gf_sm_load_done_xbl;\n\t\treturn e;\n#endif\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_SM_LOAD_SWF:\n\t\treturn gf_sm_load_init_swf(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_ISOM\n\tcase GF_SM_LOAD_MP4:\n\t\treturn gf_sm_load_init_isom(load);\n#endif\n\n#ifndef GPAC_DISABLE_QTVR\n\tcase GF_SM_LOAD_QT:\n\t\treturn gf_sm_load_init_qt(load);\n#endif\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\treturn GF_NOT_SUPPORTED;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2359,
    "critical_vars": [
      "fileName"
    ],
    "function": "cat_multiple_files",
    "filename": "gpac/CVE-2018-20761/CVE-2018-20761_CWE-119_35ab4475a7df9b2a4bcab235e379c0c3ec543658_fileimport.c.diff",
    "function_code": "GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tCATEnum cat_enum;\n\tchar *sep;\n\n\tcat_enum.dest = dest;\n\tcat_enum.import_flags = import_flags;\n\tcat_enum.force_fps = force_fps;\n\tcat_enum.frames_per_sample = frames_per_sample;\n\tcat_enum.tmp_dir = tmp_dir;\n\tcat_enum.force_cat = force_cat;\n\tcat_enum.align_timelines = align_timelines;\n\tcat_enum.allow_add_in_command = allow_add_in_command;\n\n\tif (strlen(fileName) >= sizeof(cat_enum.szPath)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", fileName));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tstrcpy(cat_enum.szPath, fileName);\n\tsep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);\n\tif (!sep) sep = strrchr(cat_enum.szPath, '/');\n\tif (!sep) {\n\t\tstrcpy(cat_enum.szPath, \".\");\n\t\tif (strlen(fileName) >= sizeof(cat_enum.szRad1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", fileName));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tstrcpy(cat_enum.szRad1, fileName);\n\t} else {\n\t\tif (strlen(sep + 1) >= sizeof(cat_enum.szRad1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", (sep + 1)));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tstrcpy(cat_enum.szRad1, sep+1);\n\t\tsep[0] = 0;\n\t}\n\tsep = strchr(cat_enum.szRad1, '*');\n\tif (strlen(sep + 1) >= sizeof(cat_enum.szRad2)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", (sep + 1)));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tstrcpy(cat_enum.szRad2, sep+1);\n\tsep[0] = 0;\n\tsep = strchr(cat_enum.szRad2, '%');\n\tif (!sep) sep = strchr(cat_enum.szRad2, '#');\n\tif (!sep) sep = strchr(cat_enum.szRad2, ':');\n\tstrcpy(cat_enum.szOpt, \"\");\n\tif (sep) {\n\t\tif (strlen(sep) >= sizeof(cat_enum.szOpt)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Invalid option: %s.\\n\", sep));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tstrcpy(cat_enum.szOpt, sep);\n\t\tsep[0] = 0;\n\t}\n\treturn gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 405,
    "critical_vars": [
      "esd"
    ],
    "function": "*gf_hinter_track_new",
    "filename": "gpac/CVE-2021-31261/CVE-2021-31261_CWE-119_cd3738dea038dbd12e603ad48cd7373ae0440f65_isom_hinter.c.diff",
    "function_code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 406,
    "critical_vars": [
      "esd"
    ],
    "function": "*gf_hinter_track_new",
    "filename": "gpac/CVE-2021-31261/CVE-2021-31261_CWE-119_cd3738dea038dbd12e603ad48cd7373ae0440f65_isom_hinter.c.diff",
    "function_code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esd)\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2416,
    "critical_vars": [
      "op->layer_count"
    ],
    "function": "gf_isom_oinf_read_entry",
    "filename": "gpac/CVE-2018-7752/CVE-2018-7752_CWE-119_90dc7f853d31b0a4e9441cba97feccf36d8b69a4_avc_ext.c.diff",
    "function_code": "GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > ARRAY_LENGTH(op->layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2388,
    "critical_vars": [
      "sps->poc_cycle_length"
    ],
    "function": "gf_media_avc_read_sps",
    "filename": "gpac/CVE-2018-7752/CVE-2018-7752_CWE-119_90dc7f853d31b0a4e9441cba97feccf36d8b69a4_av_parsers.c.diff",
    "function_code": "s32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\tAVC_SPS *sps;\n\tu32 ChromaArrayType = 0;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\tGF_BitStream *bs;\n\tchar *sps_data_without_emulation_bytes = NULL;\n\tu32 sps_data_without_emulation_bytes_size = 0;\n\n\t/*SPS still contains emulation bytes*/\n\tsps_data_without_emulation_bytes = gf_malloc(sps_size*sizeof(char));\n\tsps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);\n\tbs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\tprofile_idc = gf_bs_read_int(bs, 8);\n\n\tpcomp = gf_bs_read_int(bs, 8);\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\tgoto exit;\n\n\tlevel_idc = gf_bs_read_int(bs, 8);\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = bs_get_ue(bs) + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >=32) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (sps_id < 0) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tchroma_format_idc = ChromaArrayType = 1;\n\tsps = &avc->sps[sps_id];\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\tgoto exit;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = bs_get_ue(bs);\n\t\tChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = bs_get_ue(bs);\n\t\tchroma_bd = bs_get_ue(bs);\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int(bs, 1);\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tu32 k;\n\t\t\tfor (k=0; k<8; k++) {\n\t\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k<6 ? 16 : 64;\n\t\t\t\t\tfor (z=0; z<sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = bs_get_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = bs_get_ue(bs) + 4;\n\tsps->poc_type = bs_get_ue(bs);\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = bs_get_ue(bs) + 4;\n\t} else if(sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int(bs, 1);\n\t\tsps->offset_for_non_ref_pic = bs_get_se(bs);\n\t\tsps->offset_for_top_to_bottom_field = bs_get_se(bs);\n\t\tsps->poc_cycle_length = bs_get_ue(bs);\n\t\tif (sps->poc_cycle_length > ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t\tfor(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);\n\t}\n\tif (sps->poc_type > 2) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tsps->max_num_ref_frames = bs_get_ue(bs); \n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(bs, 1); \n\tmb_width = bs_get_ue(bs) + 1;\n\tmb_height= bs_get_ue(bs) + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int(bs, 1);\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2-sps->frame_mbs_only_flag) * mb_height * 16;\n\t\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 1); /*direct_8x8_inference_flag*/\n\t\n\tif (gf_bs_read_int(bs, 1)) { /*crop*/\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2, SubHeightC = 2;\n\t\t} else if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2, SubHeightC = 1;\n\t\t} else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1, SubHeightC = 1;\n\t\t}\n\n\t\tif (ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC==-1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2-sps->frame_mbs_only_flag;\n\t\t} else {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2-sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = bs_get_ue(bs); /*crop_left*/\n\t\tcr = bs_get_ue(bs); /*crop_right*/\n\t\tct = bs_get_ue(bs); /*crop_top*/\n\t\tcb = bs_get_ue(bs); /*crop_bottom*/\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t} \n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int(bs, 1);\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(bs, 8);\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int(bs, 16); /*AR num*/\n\t\t\t\tsps->vui.par_den = gf_bs_read_int(bs, 16); /*AR den*/\n\t\t\t} else if (aspect_ratio_idc<14) {\n\t\t\t\tsps->vui.par_num = avc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif(sps->vui.overscan_info_present_flag)\t\t\n\t\t\tgf_bs_read_int(bs, 1);\t\t/* overscan_appropriate_flag */\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int(bs, 3);\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int(bs, 1);\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sps->vui.colour_description_present_flag) { \n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int(bs, 8);  \n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\t/* chroma_location_info_present_flag */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_top_field */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_bottom_field */\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.time_scale = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int(bs, 1); \n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int(bs, 1);\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc==83) || (profile_idc==86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\t/*inter_layer_deblocking_filter_control_present_flag=*/\tgf_bs_read_int(bs, 1);\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int(bs, 2);\n\t\t\tif (ChromaArrayType == 1 || ChromaArrayType == 2) {\n\t\t\t\t/*chroma_phase_x_plus1_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\tif( ChromaArrayType  ==  1 ) {\n\t\t\t\t/*chroma_phase_y_plus1*/ gf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif( ChromaArrayType > 0 ) {\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_x_plus1_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_y_plus1*/gf_bs_read_int(bs, 2);\n\t\t\t\t}\n\t\t\t\t/*seq_scaled_ref_layer_left_offset*/ bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_top_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_right_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_bottom_offset*/bs_get_se(bs);\n\t\t\t}\n\t\t\tif (/*seq_tcoeff_level_prediction_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\t\t/*adaptive_tcoeff_level_prediction_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\t/*slice_header_restriction_flag*/gf_bs_read_int(bs, 1);\n\n\t\t\t/*svc_vui_parameters_present*/\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\tu32 i, vui_ext_num_entries_minus1;\n\t\t\t\tvui_ext_num_entries_minus1 = bs_get_ue(bs);\n\n\t\t\t\tfor (i=0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\t/*u8 vui_ext_dependency_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\t/*u8 vui_ext_quality_id =*/ gf_bs_read_int(bs, 4);\n\t\t\t\t\t/*u8 vui_ext_temporal_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\t/*u32 vui_ext_num_units_in_tick = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u32 vui_ext_time_scale = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u8 vui_ext_fixed_frame_rate_flag = */gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif ( vui_ext_nal_hrd_parameters_present_flag ||  vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t/*vui_ext_low_delay_hrd_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\t/*vui_ext_pic_struct_present_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc==118) || (profile_idc==128)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] MVC not supported - skipping parsing end of Subset SPS\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(sps_data_without_emulation_bytes);\n\treturn sps_id;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 115,
    "critical_vars": [
      "count"
    ],
    "function": "disrsi_",
    "filename": "torque/CVE-2014-0749/CVE-2014-0749_CWE-119_3ed749263abe3d69fa3626d142a5789dcb5a5684_disrsi_.c.diff",
    "function_code": "int disrsi_(\n\n  int       stream,\n  int      *negate,\n  unsigned *value,\n  unsigned  count)\n\n  {\n  int  c;\n  unsigned locval;\n  unsigned ndigs;\n  char  *cp;\n  char  scratch[DIS_BUFSIZ+1];\n\n  assert(negate != NULL);\n  assert(value != NULL);\n  assert(count);\n  assert(stream >= 0);\n  assert(dis_getc != NULL);\n  assert(dis_gets != NULL);\n\n  memset(scratch, 0, DIS_BUFSIZ+1);\n  if (dis_umaxd == 0)\n    disiui_();\n\n  if (count >= dis_umaxd)\n    {\n    if (count > dis_umaxd)\n      goto overflow;\n\n    if (memcmp(scratch, dis_umax, dis_umaxd) > 0)\n      goto overflow;\n    }\n\n  switch (c = (*dis_getc)(stream))\n    {\n\n    case '-':\n\n    case '+':\n\n      *negate = c == '-';\n\n      if ((*dis_gets)(stream, scratch, count) != (int)count)\n        {\n        return(DIS_EOD);\n        }\n\n      if (count >= dis_umaxd)\n        {\n        if (count > dis_umaxd)\n          goto overflow;\n\n        if (memcmp(scratch, dis_umax, dis_umaxd) > 0)\n          goto overflow;\n        }\n\n      cp = scratch;\n\n      locval = 0;\n\n      do\n        {\n        if (((c = *cp++) < '0') || (c > '9'))\n          {\n          return(DIS_NONDIGIT);\n          }\n\n        locval = 10 * locval + c - '0';\n        }\n      while (--count);\n\n      *value = locval;\n\n      return (DIS_SUCCESS);\n\n      break;\n\n    case '0':\n\n      return (DIS_LEADZRO);\n\n      break;\n\n    case '1':\n\n    case '2':\n\n    case '3':\n\n    case '4':\n\n    case '5':\n\n    case '6':\n\n    case '7':\n\n    case '8':\n\n    case '9':\n\n      ndigs = c - '0';\n\n      if (count > 1)\n        {\n        if ((*dis_gets)(stream, scratch + 1, count - 1) != (int)count - 1)\n          {\n          return(DIS_EOD);\n          }\n\n        cp = scratch;\n\n        if (count >= dis_umaxd)\n          {\n          if (count > dis_umaxd)\n            break;\n\n          *cp = c;\n\n          if (memcmp(scratch, dis_umax, dis_umaxd) > 0)\n            break;\n          }\n\n        while (--count)\n          {\n          if (((c = *++cp) < '0') || (c > '9'))\n            {\n            return(DIS_NONDIGIT);\n            }\n\n          ndigs = 10 * ndigs + c - '0';\n          }\n        }    /* END if (count > 1) */\n\n      return(disrsi_(stream, negate, value, ndigs));\n\n      /*NOTREACHED*/\n\n      break;\n\n    case - 1:\n\n      return(DIS_EOD);\n\n      /*NOTREACHED*/\n\n      break;\n\n    case -2:\n\n      return(DIS_EOF);\n\n      /*NOTREACHED*/\n\n      break;\n\n    default:\n\n      return(DIS_NONDIGIT);\n\n      /*NOTREACHED*/\n\n      break;\n    }\n\n  *negate = FALSE;\n\noverflow:\n\n  *value = UINT_MAX;\n\n  return(DIS_OVERFLOW);\n  }  /* END disrsi_() */",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 185,
    "line_new": 185,
    "critical_vars": [
      "i"
    ],
    "function": "safe_fprintf",
    "filename": "libarchive/CVE-2016-8687/CVE-2016-8687_CWE-119_e37b620fe8f14535d737e89a4dcabaed4517bf1a_util.c.diff",
    "function_code": "safe_fprintf(FILE *f, const char *fmt, ...)\n{\n\tchar fmtbuff_stack[256]; /* Place to format the printf() string. */\n\tchar outbuff[256]; /* Buffer for outgoing characters. */\n\tchar *fmtbuff_heap; /* If fmtbuff_stack is too small, we use malloc */\n\tchar *fmtbuff;  /* Pointer to fmtbuff_stack or fmtbuff_heap. */\n\tint fmtbuff_length;\n\tint length, n;\n\tva_list ap;\n\tconst char *p;\n\tunsigned i;\n\twchar_t wc;\n\tchar try_wc;\n\n\t/* Use a stack-allocated buffer if we can, for speed and safety. */\n\tfmtbuff_heap = NULL;\n\tfmtbuff_length = sizeof(fmtbuff_stack);\n\tfmtbuff = fmtbuff_stack;\n\n\t/* Try formatting into the stack buffer. */\n\tva_start(ap, fmt);\n\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\tva_end(ap);\n\n\t/* If the result was too large, allocate a buffer on the heap. */\n\twhile (length < 0 || length >= fmtbuff_length) {\n\t\tif (length >= fmtbuff_length)\n\t\t\tfmtbuff_length = length+1;\n\t\telse if (fmtbuff_length < 8192)\n\t\t\tfmtbuff_length *= 2;\n\t\telse if (fmtbuff_length < 1000000)\n\t\t\tfmtbuff_length += fmtbuff_length / 4;\n\t\telse {\n\t\t\tlength = fmtbuff_length;\n\t\t\tfmtbuff_heap[length-1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tfree(fmtbuff_heap);\n\t\tfmtbuff_heap = malloc(fmtbuff_length);\n\n\t\t/* Reformat the result into the heap buffer if we can. */\n\t\tif (fmtbuff_heap != NULL) {\n\t\t\tfmtbuff = fmtbuff_heap;\n\t\t\tva_start(ap, fmt);\n\t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\t\t\tva_end(ap);\n\t\t} else {\n\t\t\t/* Leave fmtbuff pointing to the truncated\n\t\t\t * string in fmtbuff_stack. */\n\t\t\tlength = sizeof(fmtbuff_stack) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Note: mbrtowc() has a cleaner API, but mbtowc() seems a bit\n\t * more portable, so we use that here instead. */\n\tif (mbtowc(NULL, NULL, 1) == -1) { /* Reset the shift state. */\n\t\t/* mbtowc() should never fail in practice, but\n\t\t * handle the theoretical error anyway. */\n\t\tfree(fmtbuff_heap);\n\t\treturn;\n\t}\n\n\t/* Write data, expanding unprintable characters. */\n\tp = fmtbuff;\n\ti = 0;\n\ttry_wc = 1;\n\twhile (*p != '\\0') {\n\n\t\t/* Convert to wide char, test if the wide\n\t\t * char is printable in the current locale. */\n\t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {\n\t\t\tlength -= n;\n\t\t\tif (iswprint(wc) && wc != L'\\\\') {\n\t\t\t\t/* Printable, copy the bytes through. */\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\toutbuff[i++] = *p++;\n\t\t\t} else {\n\t\t\t\t/* Not printable, format the bytes. */\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\ti += (unsigned)bsdtar_expand_char(\n\t\t\t\t\t    outbuff, i, *p++);\n\t\t\t}\n\t\t} else {\n\t\t\t/* After any conversion failure, don't bother\n\t\t\t * trying to convert the rest. */\n\t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);\n\t\t\ttry_wc = 0;\n\t\t}\n\n\t\t/* If our output buffer is full, dump it and keep going. */\n\t\tif (i > (sizeof(outbuff) - 128)) {\n\t\t\toutbuff[i] = '\\0';\n\t\t\tfprintf(f, \"%s\", outbuff);\n\t\t\ti = 0;\n\t\t}\n\t}\n\toutbuff[i] = '\\0';\n\tfprintf(f, \"%s\", outbuff);\n\n\t/* If we allocated a heap-based formatting buffer, free it now. */\n\tfree(fmtbuff_heap);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2130,
    "critical_vars": [
      "rar->dictionary_size"
    ],
    "function": "parse_codes",
    "filename": "libarchive/CVE-2016-4302/CVE-2016-4302_CWE-119_05caadc7eedbef471ac9610809ba683f0c698700_archive_read_support_format_rar.c.diff",
    "function_code": "parse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size, &g_szalloc))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1388,
    "critical_vars": [
      "numbers[argc++]"
    ],
    "function": "parse_device",
    "filename": "libarchive/CVE-2016-4301/CVE-2016-4301_CWE-119_a550daeecf6bc689ade371349892ea17b5b97c77_archive_read_support_format_mtree.c.diff",
    "function_code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1388,
    "critical_vars": [
      "argc"
    ],
    "function": "parse_device",
    "filename": "libarchive/CVE-2016-4301/CVE-2016-4301_CWE-119_a550daeecf6bc689ade371349892ea17b5b97c77_archive_read_support_format_mtree.c.diff",
    "function_code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tif (argc >= MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 72,
    "critical_vars": [
      "next_len"
    ],
    "function": "cac_cac1_get_certificate",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* get the size */\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* in the old CAC-1, 0x63 means 'more data' in addition to 'pin failed' */\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\t/* we've either finished reading, or hit an error, break */\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 80,
    "critical_vars": [
      "len"
    ],
    "function": "cac_cac1_get_certificate",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* get the size */\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tlen = MIN(left, 100);\n\tfor (; left > 0;) { /* Increments for readability in the end of the function */\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* in the old CAC-1, 0x63 means 'more data' in addition to 'pin failed' */\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\t/* we've either finished reading, or hit an error, break */\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\t/* Adjust the lengths */\n\t\tleft -= len;\n\t\tout_ptr += len;\n\t\tlen = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 131,
    "critical_vars": [
      "val_len"
    ],
    "function": "cac_read_binary",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *val = NULL;\n\tu8 *cert_ptr;\n\tsize_t val_len;\n\tsize_t len, cert_len;\n\tu8 cert_type;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_log(card->ctx, \n\t\t\t\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\tidx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\tidx, count);\n\tfree(priv->cache_buf);\n\tpriv->cache_buf = NULL;\n\tpriv->cache_buf_len = 0;\n\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\tif (val_len < 1) {\n\t\tr = SC_ERROR_INVALID_DATA;\n\t\tgoto done;\n\t}\n\n\tcert_type = val[0];\n\tcert_ptr = val + 1;\n\tcert_len = val_len - 1;\n\n\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\tif (r)\n\t\t\tgoto done;\n\t} else if (cert_len > 0) {\n\t\tpriv->cache_buf = malloc(cert_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = cert_len;\n\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tif (len && priv->cache_buf)\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (val)\n\t\tfree(val);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 133,
    "critical_vars": [
      "val_len"
    ],
    "function": "cac_read_binary",
    "filename": "OpenSC/CVE-2019-19481/CVE-2019-19481_CWE-119_b75c002cfb1fd61cd20ec938ff4937d7b1a94278_card-cac1.c.diff",
    "function_code": "static int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *val = NULL;\n\tu8 *cert_ptr;\n\tsize_t val_len = 0;\n\tsize_t len, cert_len;\n\tu8 cert_type;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_log(card->ctx, \n\t\t\t\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\tidx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\tidx, count);\n\tfree(priv->cache_buf);\n\tpriv->cache_buf = NULL;\n\tpriv->cache_buf_len = 0;\n\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\tif (val_len < 1) {\n\t\tr = SC_ERROR_INVALID_DATA;\n\t\tgoto done;\n\t}\n\n\tcert_type = val[0];\n\tcert_ptr = val + 1;\n\tcert_len = val_len - 1;\n\n\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\tif (r)\n\t\t\tgoto done;\n\t} else if (cert_len > 0) {\n\t\tpriv->cache_buf = malloc(cert_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = cert_len;\n\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tif (len && priv->cache_buf)\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (val)\n\t\tfree(val);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 152,
    "line_new": 152,
    "critical_vars": [
      "len"
    ],
    "function": "read_file",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_egk-tool.c.diff",
    "function_code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 954,
    "critical_vars": [
      "out_len"
    ],
    "function": "decrypt_response",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-epass2003.c.diff",
    "function_code": "decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len || *out_len < cipher_len - 2)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 980,
    "critical_vars": [
      "len"
    ],
    "function": "epass2003_sm_unwrap_apdu",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-epass2003.c.diff",
    "function_code": "epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tlen = plain->resplen;\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 411,
    "line_new": 411,
    "critical_vars": [
      "len"
    ],
    "function": "tcos_select_file",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-tcos.c.diff",
    "function_code": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 435,
    "critical_vars": [
      "file->name",
      "d",
      "len"
    ],
    "function": "tcos_select_file",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-tcos.c.diff",
    "function_code": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 342,
    "critical_vars": [
      "buf",
      "line"
    ],
    "function": "util_acl_to_str",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_util.c.diff",
    "function_code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 342,
    "critical_vars": [
      "buf",
      "sizeof",
      "line"
    ],
    "function": "util_acl_to_str",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_util.c.diff",
    "function_code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 797,
    "line_new": 797,
    "critical_vars": [
      "priv->cac_id_len",
      "serial->len"
    ],
    "function": "cac_get_serial_nr_from_CUID",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-cac.c.diff",
    "function_code": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 334,
    "line_new": 335,
    "critical_vars": [
      "bufsize"
    ],
    "function": "read_public_key",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_cryptoflex-tool.c.diff",
    "function_code": "static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 385,
    "line_new": 386,
    "critical_vars": [
      "bufsize"
    ],
    "function": "read_private_key",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_cryptoflex-tool.c.diff",
    "function_code": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 211,
    "critical_vars": [
      "i"
    ],
    "function": "gemsafe_get_cert_len",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_pkcs15-gemsafeV1.c.diff",
    "function_code": "static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 631,
    "critical_vars": [
      "sec_attr_len"
    ],
    "function": "sc_file_set_sec_attr",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_sc.c.diff",
    "function_code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 522,
    "critical_vars": [
      "bufLen"
    ],
    "function": "muscle_list_files",
    "filename": "OpenSC/CVE-2018-16419/CVE-2018-16419_CWE-119_360e95d45ac4123255a4c796db96337f332160ad_card-muscle.c.diff",
    "function_code": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid = fs->cache.array[x].objectId.id;\n\t\tif (bufLen < 2)\n\t\t\tbreak;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount += 2;\n\t\t\tbufLen -= 2;\n\t\t}\n\t}\n\treturn count;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 573,
    "critical_vars": [
      "zero_bits"
    ],
    "function": "decode_bit_string",
    "filename": "OpenSC/CVE-2019-15945/CVE-2019-15945_CWE-119_412a6142c27a5973c61ba540e33cdc22d5608e68_asn1.c.diff",
    "function_code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\t/* 1st octet of input:  ABCDEFGH, where A is the MSB */\n\t\t/* 1st octet of output: HGFEDCBA, where A is the LSB */\n\t\t/* first bit in bit string is the LSB in first resulting octet */\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 574,
    "critical_vars": [
      "zero_bits"
    ],
    "function": "decode_bit_string",
    "filename": "OpenSC/CVE-2019-15945/CVE-2019-15945_CWE-119_412a6142c27a5973c61ba540e33cdc22d5608e68_asn1.c.diff",
    "function_code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint i, count = 0;\n\tint zero_bits;\n\tsize_t octets_left;\n\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\n\tzero_bits = *in & 0x07;\n\toctets_left = inlen - 1;\n\tin++;\n\tmemset(outbuf, 0, outlen);\n\n\twhile (octets_left) {\n\t\t/* 1st octet of input:  ABCDEFGH, where A is the MSB */\n\t\t/* 1st octet of output: HGFEDCBA, where A is the LSB */\n\t\t/* first bit in bit string is the LSB in first resulting octet */\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 623,
    "critical_vars": [
      "data_size"
    ],
    "function": "bz3_decode_block",
    "filename": "bzip3/CVE-2023-29420/CVE-2023-29420_CWE-119_bb06deb85f1c249838eb938e0dab271d4194f8fa_libbz3.c.diff",
    "function_code": "BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    // Read the header.\n    u32 crc32 = read_neutral_s32(buffer);\n    s32 bwt_idx = read_neutral_s32(buffer + 4);\n\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (bwt_idx == -1) {\n        if (data_size - 8 > 64 || data_size < 8) {\n            state->last_error = BZ3_ERR_MALFORMED_HEADER;\n            return -1;\n        }\n\n        memmove(buffer, buffer + 8, data_size - 8);\n\n        if (crc32sum(1, buffer, data_size - 8) != crc32) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n\n        return data_size - 8;\n    }\n\n    s8 model = buffer[8];\n    s32 lzp_size = -1, rle_size = -1, p = 0;\n\n    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);\n\n    p += 2;\n\n    data_size -= p * 4 + 1;\n\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Decode the data.\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    begin(state->cm_state);\n    state->cm_state->in_queue = b1 + p * 4 + 1;\n    state->cm_state->input_ptr = 0;\n    state->cm_state->input_max = data_size;\n\n    s32 size_src;\n\n    if (model & 2)\n        size_src = lzp_size;\n    else if (model & 4)\n        size_src = rle_size;\n    else\n        size_src = orig_size;\n\n    decode_bytes(state->cm_state, b2, size_src);\n    swap(b1, b2);\n\n    if (bwt_idx >= size_src) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Undo BWT\n    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    swap(b1, b2);\n\n    // Undo LZP\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n        if (size_src == -1) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        swap(b1, b2);\n    }\n\n    if (model & 4) {\n        int err = mrled(b1, b2, orig_size, size_src);\n        if(err) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        size_src = orig_size;\n        swap(b1, b2);\n    }\n\n    state->last_error = BZ3_OK;\n\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (b1 != buffer) memcpy(buffer, b1, size_src);\n\n    if (crc32 != crc32sum(1, buffer, size_src)) {\n        state->last_error = BZ3_ERR_CRC;\n        return -1;\n    }\n\n    return size_src;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 143,
    "critical_vars": [
      "outfilename",
      "argv[2]",
      "snum"
    ],
    "function": "main",
    "filename": "openjpeg/CVE-2018-7648/CVE-2018-7648_CWE-119_cc3824767bde397fedb8a1ae4786a222ba860c8d_opj_mj2_extract.c.diff",
    "function_code": "main(int argc, char *argv[])\n{\n  int i, c;\n  FILE *ifp = 0, *ofp = 0;\n  const char *ifp_filename = \"<stdin>\";\n  const char *ofp_filename = \"<stdout>\";\n  const char *set_font_name = 0;\n  struct font_reader fr;\n  uint32_t rfork_len;\n  int raw = 0, macbinary = 1, applesingle = 0, appledouble = 0, binhex = 0;\n\n  Clp_Parser *clp =\n    Clp_NewParser(argc, (const char * const *)argv, sizeof(options) / sizeof(options[0]), options);\n  program_name = Clp_ProgramName(clp);\n\n  /* interpret command line arguments using CLP */\n  while (1) {\n    int opt = Clp_Next(clp);\n    switch (opt) {\n\n     case RAW_OPT:\n      raw = 1;\n      macbinary = applesingle = appledouble = binhex = 0;\n      break;\n\n     case MACBINARY_OPT:\n      macbinary = 1;\n      raw = applesingle = appledouble = binhex = 0;\n      break;\n\n     case APPLESINGLE_OPT:\n      applesingle = 1;\n      raw = macbinary = appledouble = binhex = 0;\n      break;\n\n     case APPLEDOUBLE_OPT:\n      appledouble = 1;\n      raw = macbinary = applesingle = binhex = 0;\n      break;\n\n     case BINHEX_OPT:\n      binhex = 1;\n      raw = macbinary = applesingle = appledouble = 0;\n      break;\n\n     output_file:\n     case OUTPUT_OPT:\n      if (ofp)\n\tfatal_error(\"output file already specified\");\n      if (strcmp(clp->vstr, \"-\") == 0)\n\tofp = stdout;\n      else {\n\tofp_filename = clp->vstr;\n\tofp = fopen(ofp_filename, \"wb\");\n\tif (!ofp) fatal_error(\"%s: %s\", ofp_filename, strerror(errno));\n      }\n      break;\n\n     case FILENAME_OPT:\n      if (set_font_name)\n\tfatal_error(\"Macintosh font filename already specified\");\n      set_font_name = clp->vstr;\n      break;\n\n     case HELP_OPT:\n      usage();\n      exit(0);\n      break;\n\n     case VERSION_OPT:\n      printf(\"t1mac (LCDF t1utils) %s\\n\", VERSION);\n      printf(\"Copyright (C) 2000-2010 Eddie Kohler et al.\\n\\\nThis is free software; see the source for copying conditions.\\n\\\nThere is NO warranty, not even for merchantability or fitness for a\\n\\\nparticular purpose.\\n\");\n      exit(0);\n      break;\n\n     case Clp_NotOption:\n      if (ifp && ofp)\n\tfatal_error(\"too many arguments\");\n      else if (ifp)\n\tgoto output_file;\n      if (strcmp(clp->vstr, \"-\") == 0)\n\tifp = stdin;\n      else {\n\tifp_filename = clp->vstr;\n\tifp = fopen(clp->vstr, \"r\");\n\tif (!ifp) fatal_error(\"%s: %s\", clp->vstr, strerror(errno));\n      }\n      break;\n\n     case Clp_Done:\n      goto done;\n\n     case Clp_BadOption:\n      short_usage();\n      exit(1);\n      break;\n\n    }\n  }\n\n done:\n  if (!ifp) ifp = stdin;\n  if (!ofp) ofp = stdout;\n\n#if defined(_MSDOS) || defined(_WIN32)\n  /* As we are processing a PFB (binary) output */\n  /* file, we must set its file mode to binary. */\n  _setmode(_fileno(ofp), _O_BINARY);\n#endif\n\n  /* prepare font reader */\n  fr.output_ascii = t1mac_output_ascii;\n  fr.output_binary = t1mac_output_binary;\n  fr.output_end = t1mac_output_end;\n\n  /* prepare resource fork file */\n  rfork_f = tmpfile();\n  if (!rfork_f)\n    fatal_error(\"cannot open temorary file: %s\", strerror(errno));\n  for (i = 0; i < RFORK_HEADERLEN; i++)\n    putc(0, rfork_f);\n  init_current_post();\n\n  /* peek at first byte to see if it is the PFB marker 0x80 */\n  c = getc(ifp);\n  ungetc(c, ifp);\n\n  /* do the file */\n  if (c == PFB_MARKER)\n    process_pfb(ifp, ifp_filename, &fr);\n  else if (c == '%')\n    process_pfa(ifp, ifp_filename, &fr);\n  else\n    fatal_error(\"%s does not start with font marker (`%%' or 0x80)\", ifp_filename);\n  if (ifp != stdin)\n    fclose(ifp);\n\n  /* check if anything was read */\n  if (nrsrc == 0)\n    error(\"no POST resources written -- are you sure this was a font?\");\n\n  /* output large B/W icon */\n  output_new_rsrc(\"ICN#\", 256, 32, (const char *)icon_bw_data, 256);\n  /* output FREF */\n  output_new_rsrc(\"FREF\", 256, 32, \"LWFN\\0\\0\\0\", 7);\n  /* output BNDL */\n  output_new_rsrc(\"BNDL\", 256, 32, \"T1UT\\0\\0\\0\\1FREF\\0\\0\\0\\0\\1\\0ICN#\\0\\0\\0\\0\\1\\0\", 28);\n  /* output other icons */\n  output_new_rsrc(\"icl8\", 256, 32, (const char *)icon_8_data, 1024);\n  output_new_rsrc(\"icl4\", 256, 32, (const char *)icon_4_data, 512);\n  output_new_rsrc(\"ics#\", 256, 32, (const char *)small_icon_bw_data, 64);\n  output_new_rsrc(\"ics8\", 256, 32, (const char *)small_icon_8_data, 256);\n  output_new_rsrc(\"ics4\", 256, 32, (const char *)small_icon_4_data, 128);\n  /* output T1UT (signature) */\n  output_new_rsrc(\"T1UT\", 0, 0, \"DConverted by t1mac (t1utils) \\251Eddie Kohler http://www.lcdf.org/type/\", 69);\n\n  /* finish off resource file */\n  rfork_len = complete_rfork();\n\n  /* prepare font name */\n  if (!set_font_name && font_name) {\n    int part = 0, len = 0;\n    char *x, *s;\n    for (x = s = font_name; *s; s++)\n      if (isupper(*s) || isdigit(*s)) {\n\t*x++ = *s;\n\tpart++;\n\tlen = 1;\n      } else if (islower(*s)) {\n\tif (len < (part <= 1 ? 5 : 3))\n\t  *x++ = *s;\n\tlen++;\n      }\n    *x++ = 0;\n    set_font_name = font_name;\n  } else if (!set_font_name)\n    set_font_name = \"Unknown Font\";\n\n  /* now, output the file */\n  if (macbinary)\n    output_macbinary(rfork_f, rfork_len, set_font_name, ofp);\n  else if (raw)\n    output_raw(rfork_f, rfork_len, ofp);\n  else if (applesingle || appledouble)\n    output_applesingle(rfork_f, rfork_len, set_font_name, ofp, appledouble);\n  else if (binhex)\n    output_binhex(rfork_f, rfork_len, set_font_name, ofp);\n  else\n    fatal_error(\"strange output format\");\n  fclose(rfork_f);\n\n  if (ofp != stdout)\n    fclose(ofp);\n  return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 858,
    "critical_vars": [
      "image->numcomps"
    ],
    "function": "color_cmyk_to_rgb",
    "filename": "openjpeg/CVE-2016-4796/CVE-2016-4796_CWE-119_162f6199c0cd3ec1c6c6dc65e41b2faab92b2d91_color.c.diff",
    "function_code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif(image->numcomps < 4) return;\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -> RGB : RGB results from 0 to 255 */\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 858,
    "critical_vars": [
      "image->comps[0].dx",
      "image->numcomps",
      "image->comps[0].dy"
    ],
    "function": "color_cmyk_to_rgb",
    "filename": "openjpeg/CVE-2016-4796/CVE-2016-4796_CWE-119_162f6199c0cd3ec1c6c6dc65e41b2faab92b2d91_color.c.diff",
    "function_code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif (\n\t\t\t(image->numcomps < 4)\n\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx) || (image->comps[0].dx != image->comps[3].dx)\n\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy) || (image->comps[0].dy != image->comps[3].dy)\n\t\t\t) {\n\t\tfprintf(stderr,\"%s:%d:color_cmyk_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n\t}\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -> RGB : RGB results from 0 to 255 */\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1185,
    "line_new": 1186,
    "critical_vars": [
      "l_data_size"
    ],
    "function": "opj_tcd_code_block_enc_allocate_data",
    "filename": "openjpeg/CVE-2016-10504/CVE-2016-10504_CWE-119_397f62c0a838e15d667ef50e27d5d011d2c79c04_tcd.c.diff",
    "function_code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n    /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */\n    /* TODO: is there a theoretical upper-bound for the compressed code */\n    /* block size ? */\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 700,
    "critical_vars": [
      "l_tile->x1",
      "l_tile->x0"
    ],
    "function": "opj_tcd_init_tile",
    "filename": "openjpeg/CVE-2016-5157/CVE-2016-5157_CWE-119_e078172b1c3f98d2219c37076b238fb759c751ea_tcd.c.diff",
    "function_code": "static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block, opj_event_mgr_t* manager)\n{\n\tOPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;\n\tOPJ_UINT32 compno, resno, bandno, precno, cblkno;\n\topj_tcp_t * l_tcp = 00;\n\topj_cp_t * l_cp = 00;\n\topj_tcd_tile_t * l_tile = 00;\n\topj_tccp_t *l_tccp = 00;\n\topj_tcd_tilecomp_t *l_tilec = 00;\n\topj_image_comp_t * l_image_comp = 00;\n\topj_tcd_resolution_t *l_res = 00;\n\topj_tcd_band_t *l_band = 00;\n\topj_stepsize_t * l_step_size = 00;\n\topj_tcd_precinct_t *l_current_precinct = 00;\n\topj_image_t *l_image = 00;\n\tOPJ_UINT32 p,q;\n\tOPJ_UINT32 l_level_no;\n\tOPJ_UINT32 l_pdx, l_pdy;\n\tOPJ_UINT32 l_gain;\n\tOPJ_INT32 l_x0b, l_y0b;\n\tOPJ_UINT32 l_tx0, l_ty0;\n\t/* extent of precincts , top left, bottom right**/\n\tOPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n\t/* number of precinct for a resolution */\n\tOPJ_UINT32 l_nb_precincts;\n\t/* room needed to store l_nb_precinct precinct for a resolution */\n\tOPJ_UINT32 l_nb_precinct_size;\n\t/* number of code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks;\n\t/* room needed to store l_nb_code_blocks code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks_size;\n\t/* size of data for a tile */\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_cp = p_tcd->cp;\n\tl_tcp = &(l_cp->tcps[p_tile_no]);\n\tl_tile = p_tcd->tcd_image->tiles;\n\tl_tccp = l_tcp->tccps;\n\tl_tilec = l_tile->comps;\n\tl_image = p_tcd->image;\n\tl_image_comp = p_tcd->image->comps;\n\t\n\tp = p_tile_no % l_cp->tw;       /* tile coordinates */\n\tq = p_tile_no / l_cp->tw;\n\t/*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\t\n\t/* 4 borders of the tile rescale on the image if necessary */\n\tl_tx0 = l_cp->tx0 + p * l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n\tl_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n\tl_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx), l_image->x1);\n\t/* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n\tif ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {\n\t\topj_event_msg(manager, EVT_ERROR, \"Tile X coordinates are not supported\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tl_ty0 = l_cp->ty0 + q * l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n\tl_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n\tl_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy), l_image->y1);\n\t/* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n\tif ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {\n\t\topj_event_msg(manager, EVT_ERROR, \"Tile Y coordinates are not supported\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\n\t/* testcase 1888.pdf.asan.35.988 */\n\tif (l_tccp->numresolutions == 0) {\n\t\topj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t/*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\t\n\t/*tile->numcomps = image->numcomps; */\n\tfor (compno = 0; compno < l_tile->numcomps; ++compno) {\n\t\t/*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n\t\tl_image_comp->resno_decoded = 0;\n\t\t/* border of each l_tile component (global) */\n\t\tl_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n\t\tl_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n\t\t/*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\t\t\n\t\t/* compute l_data_size with overflow check */\n\t\tl_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t\t/* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */\n\t\tif ((l_data_size > 0U) && ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0))) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t\t\n\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\t\tl_tilec->numresolutions = l_tccp->numresolutions;\n\t\tif (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n\t\t\tl_tilec->minimum_num_resolutions = 1;\n\t\t}\n\t\telse {\n\t\t\tl_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;\n\t\t}\n\t\t\n\t\tl_tilec->data_size_needed = l_data_size;\n\t\tif (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tl_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);\n\t\t\n\t\tif (l_tilec->resolutions == 00) {\n\t\t\tl_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n\t\t\tif (! l_tilec->resolutions ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\t/*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t\tmemset(l_tilec->resolutions,0,l_data_size);\n\t\t}\n\t\telse if (l_data_size > l_tilec->resolutions_size) {\n\t\t\topj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec->resolutions, l_data_size);\n\t\t\tif (! new_resolutions) {\n\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n\t\t\t\topj_free(l_tilec->resolutions);\n\t\t\t\tl_tilec->resolutions = NULL;\n\t\t\t\tl_tilec->resolutions_size = 0;\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_tilec->resolutions = new_resolutions;\n\t\t\t/*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n\t\t\tmemset(((OPJ_BYTE*) l_tilec->resolutions)+l_tilec->resolutions_size,0,l_data_size - l_tilec->resolutions_size);\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t}\n\t\t\n\t\tl_level_no = l_tilec->numresolutions;\n\t\tl_res = l_tilec->resolutions;\n\t\tl_step_size = l_tccp->stepsizes;\n\t\tif (l_tccp->qmfbid == 0) {\n\t\t\tl_gain_ptr = &opj_dwt_getgain_real;\n\t\t}\n\t\telse {\n\t\t\tl_gain_ptr  = &opj_dwt_getgain;\n\t\t}\n\t\t/*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\t\t\n\t\tfor (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n\t\t\t/*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n\t\t\tOPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n\t\t\tOPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n\t\t\tOPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\t\t\t\n\t\t\t--l_level_no;\n\t\t\t\n\t\t\t/* border for each resolution level (global) */\n\t\t\tl_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n\t\t\t/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n\t\t\t/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n\t\t\tl_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\t\t\t\n\t\t\tl_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n\t\t\tl_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\n\t\t\tif ((l_res->pw != 0U) && ((((OPJ_UINT32)-1) / l_res->pw) < l_res->ph)) {\n\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_nb_precincts = l_res->pw * l_res->ph;\n\n\t\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) < l_nb_precincts) {\n\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n\t\t\tif (resno == 0) {\n\t\t\t\ttlcbgxstart = l_tl_prc_x_start;\n\t\t\t\ttlcbgystart = l_tl_prc_y_start;\n\t\t\t\t/*brcbgxend = l_br_prc_x_end;*/\n\t\t\t\t/* brcbgyend = l_br_prc_y_end;*/\n\t\t\t\tcbgwidthexpn = l_pdx;\n\t\t\t\tcbgheightexpn = l_pdy;\n\t\t\t\tl_res->numbands = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n\t\t\t\ttlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n\t\t\t\t/*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n\t\t\t\t/*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n\t\t\t\tcbgwidthexpn = l_pdx - 1;\n\t\t\t\tcbgheightexpn = l_pdy - 1;\n\t\t\t\tl_res->numbands = 3;\n\t\t\t}\n\t\t\t\n\t\t\tcblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n\t\t\tcblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n\t\t\tl_band = l_res->bands;\n\t\t\t\n\t\t\tfor (bandno = 0; bandno < l_res->numbands; ++bandno) {\n\t\t\t\tOPJ_INT32 numbps;\n\t\t\t\t/*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\t\t\t\t\n\t\t\t\tif (resno == 0) {\n\t\t\t\t\tl_band->bandno = 0 ;\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl_band->bandno = bandno + 1;\n\t\t\t\t\t/* x0b = 1 if bandno = 1 or 3 */\n\t\t\t\t\tl_x0b = l_band->bandno&1;\n\t\t\t\t\t/* y0b = 1 if bandno = 2 or 3 */\n\t\t\t\t\tl_y0b = (OPJ_INT32)((l_band->bandno)>>1);\n\t\t\t\t\t/* l_band border (global) */\n\t\t\t\t\tl_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b << l_level_no), (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/** avoid an if with storing function pointer */\n\t\t\t\tl_gain = (*l_gain_ptr) (l_band->bandno);\n\t\t\t\tnumbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n\t\t\t\tl_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size->expn)))) * fraction;\n\t\t\t\tl_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits - 1;      /* WHY -1 ? */\n\t\t\t\t\n\t\t\t\tif (!l_band->precincts && (l_nb_precincts > 0U)) {\n\t\t\t\t\tl_band->precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory to handle band precints\\n\");\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n\t\t\t\t\tmemset(l_band->precincts,0,l_nb_precinct_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\telse if (l_band->precincts_data_size < l_nb_precinct_size) {\n\t\t\t\t\t\n\t\t\t\t\topj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band->precincts,/*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! new_precincts) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory to handle band precints\\n\");\n\t\t\t\t\t\topj_free(l_band->precincts);\n\t\t\t\t\t\tl_band->precincts = NULL;\n\t\t\t\t\t\tl_band->precincts_data_size = 0;\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tl_band->precincts = new_precincts;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n\t\t\t\t\tmemset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size,0,l_nb_precinct_size - l_band->precincts_data_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_current_precinct = l_band->precincts;\n\t\t\t\tfor (precno = 0; precno < l_nb_precincts; ++precno) {\n\t\t\t\t\tOPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n\t\t\t\t\tOPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) * (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) * (1 << cbgheightexpn);\n\t\t\t\t\tOPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n\t\t\t\t\t/*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\t\t\t\t\t\n\t\t\t\t\t/* precinct size (global) */\n\t\t\t\t\t/*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\t\t\t\t\t\n\t\t\t\t\tl_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n\t\t\t\t\tl_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n\t\t\t\t\tl_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n\t\t\t\t\tl_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n\t\t\t\t\t/*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\t\t\t\t\t\n\t\t\t\t\ttlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n\t\t\t\t\ttlcblkystart = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n\t\t\t\t\tbrcblkxend = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n\t\t\t\t\tbrcblkyend = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n\t\t\t\t\tl_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >> cblkwidthexpn);\n\t\t\t\t\tl_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >> cblkheightexpn);\n\t\t\t\t\t\n\t\t\t\t\tl_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n\t\t\t\t\tl_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\t\t\t\t\t\n\t\t\t\t\tif (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! l_current_precinct->cblks.blocks ) {\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(l_current_precinct->cblks.blocks,0,l_nb_code_blocks_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n\t\t\t\t\t\tvoid *new_blocks = opj_realloc(l_current_precinct->cblks.blocks, l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! new_blocks) {\n\t\t\t\t\t\t\topj_free(l_current_precinct->cblks.blocks);\n\t\t\t\t\t\t\tl_current_precinct->cblks.blocks = NULL;\n\t\t\t\t\t\t\tl_current_precinct->block_size = 0;\n\t\t\t\t\t\t\topj_event_msg(manager, EVT_ERROR, \"Not enough memory for current precinct codeblock element\\n\");\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = new_blocks;\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) + l_current_precinct->block_size\n\t\t\t\t\t\t\t\t\t ,0\n\t\t\t\t\t\t\t\t\t ,l_nb_code_blocks_size - l_current_precinct->block_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->incltree) {\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree, l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->incltree)     {\n\t\t\t\t\t\topj_event_msg(manager, EVT_WARNING, \"No incltree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree, l_current_precinct->cw, l_current_precinct->ch, manager);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\topj_event_msg(manager, EVT_WARNING, \"No imsbtree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\t\t\t\t\t\tOPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isEncoder) {\n\t\t\t\t\t\t\topj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++l_current_precinct;\n\t\t\t\t} /* precno */\n\t\t\t\t++l_band;\n\t\t\t\t++l_step_size;\n\t\t\t} /* bandno */\n\t\t\t++l_res;\n\t\t} /* resno */\n\t\t++l_tccp;\n\t\t++l_tilec;\n\t\t++l_image_comp;\n\t} /* compno */\n\treturn OPJ_TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1060,
    "line_new": 1060,
    "critical_vars": [
      "ctx"
    ],
    "function": "iakerb_gss_export_sec_context",
    "filename": "krb5/CVE-2015-2698/CVE-2015-2698_CWE-119_3db8dfec1ef50ddd78d6ba9503185995876a39fd_iakerb.c.diff",
    "function_code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 5097,
    "critical_vars": [
      "buf"
    ],
    "function": "get_matching_data",
    "filename": "krb5/CVE-2017-15088/CVE-2017-15088_CWE-119_fbb687db1088ddd894d975996e5f6a4252b9a2b4_pkinit_crypto_openssl.c.diff",
    "function_code": "get_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    /* Get the subject name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->subject_dn = strdup(buf);\n    if (md->subject_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the issuer name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->issuer_dn = strdup(buf);\n    if (md->issuer_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 5100,
    "critical_vars": [
      "ret"
    ],
    "function": "get_matching_data",
    "filename": "krb5/CVE-2017-15088/CVE-2017-15088_CWE-119_fbb687db1088ddd894d975996e5f6a4252b9a2b4_pkinit_crypto_openssl.c.diff",
    "function_code": "get_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n    if (ret)\n        goto cleanup;\n    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n    if (ret)\n        goto cleanup;\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 312,
    "line_new": 312,
    "critical_vars": [
      "argReg"
    ],
    "function": "dex_parse_debug_item",
    "filename": "radare2/CVE-2017-6319/CVE-2017-6319_CWE-119_ad55822430a03fe075221b543efb434567e9e431_bin_dex.c.diff",
    "function_code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1446,
    "line_new": 1446,
    "critical_vars": [
      "p"
    ],
    "function": "r_core_cmd_subst_i",
    "filename": "radare2/CVE-2017-9761/CVE-2017-9761_CWE-119_00e8f205475332d7842d0f0d1481eeab4e83017c_cmd.c.diff",
    "function_code": "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {\n\tconst char *quotestr = \"`\";\n\tconst char *tick = NULL;\n\tchar *ptr, *ptr2, *str;\n\tchar *arroba = NULL;\n\tint i, ret = 0, pipefd;\n\tbool usemyblock = false;\n\tint scr_html = -1;\n\tint scr_color = -1;\n\tbool eos = false;\n\tbool haveQuote = false;\n\n\tif (!cmd) {\n\t\treturn 0;\n\t}\n\tcmd = r_str_trim_head_tail (cmd);\n\n\t/* quoted / raw command */\n\tswitch (*cmd) {\n\tcase '.':\n\t\tif (cmd[1] == '\"') { /* interpret */\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t\tbreak;\n\tcase '\"':\n\t\tfor (; *cmd; ) {\n\t\t\tint pipefd = -1;\n\t\t\tut64 oseek = UT64_MAX;\n\t\t\tchar *line, *p;\n\t\t\thaveQuote = *cmd == '\"';\n\t\t\tif (haveQuote) {\n\t\t\t//\t*cmd = 0;\n\t\t\t\tcmd++;\n\t\t\t\tp = cmd[0] ? find_eoq (cmd + 1) : NULL;\n\t\t\t\tif (!p || !*p) {\n\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*p++ = 0;\n\t\t\t\tif (!*p) {\n\t\t\t\t\teos = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar *sc = strchr (cmd, ';');\n\t\t\t\tif (sc) {\n\t\t\t\t\t*sc = 0;\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\tif (!sc) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd = sc + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[0]) {\n\t\t\t\t// workaround :D\n\t\t\t\tif (p[0] == '@') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t}\n\t\t\t\t\thaveQuote = q != NULL;\n\t\t\t\t\toseek = core->offset;\n\t\t\t\t\tr_core_seek (core,\n\t\t\t\t\t\t     r_num_math (core->num, p + 2), 1);\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = strchr (p + 1, ';');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p && *p && p[1] == '>') {\n\t\t\t\t\tstr = p + 2;\n\t\t\t\t\twhile (*str == '>') {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_flush ();\n\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, p[2] == '>');\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = strdup (cmd);\n\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n\t\t\tif (p && *p && p[1] == '|') {\n\t\t\t\tstr = p + 2;\n\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n\t\t\t} else {\n\t\t\t\tr_cmd_call (core->rcmd, line);\n\t\t\t}\n\t\t\tfree (line);\n\t\t\tif (oseek != UT64_MAX) {\n\t\t\t\tr_core_seek (core, oseek, 1);\n\t\t\t\toseek = UT64_MAX;\n\t\t\t}\n\t\t\tif (pipefd != -1) {\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (eos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (haveQuote) {\n\t\t\t\tif (*p == ';') {\n\t\t\t\t\tcmd = p + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (*p == '\"') {\n\t\t\t\t\t\tcmd = p + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tcmd = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd = p + 1;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '(':\n\t\tif (cmd[1] != '*') {\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t}\n\n// TODO must honor \" and `\n\t/* comments */\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, '#', quotestr);\n\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t}\n\n\t/* multiple commands */\n\t// TODO: must honor \" and ` boundaries\n\t//ptr = strrchr (cmd, ';');\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n\t\tif (colon && ptr) {\n\t\t\tint ret ;\n\t\t\t*ptr = '\\0';\n\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcmd = ptr + 1;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t*ptr = ';';\n\t\t\treturn ret;\n\t\t\t//r_cons_flush ();\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* pipe console to shell process */\n\t//ptr = strchr (cmd, '|');\n\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n\tif (ptr) {\n\t\tchar *ptr2 = strchr (cmd, '`');\n\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n\t\t\tif (!tick || (tick && tick > ptr)) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tcmd = r_str_clean (cmd);\n\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n\t\t\t\t\t// TODO: should be disable scr.color in pd| ?\n\t\t\t\t\teprintf (\"Usage: <r2command> | <program|H|>\\n\");\n\t\t\t\t\teprintf (\" pd|?   - show this help\\n\");\n\t\t\t\t\teprintf (\" pd|    - disable scr.html and scr.color\\n\");\n\t\t\t\t\teprintf (\" pd|H   - enable scr.html, respect scr.color\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t} else if (!strcmp (ptr + 1, \"H\")) { // \"|H\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n\t\t\t\t\tint value = core->num->value;\n\t\t\t\t\tif (*cmd) {\n\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_io_system (core->io, ptr + 1);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = value;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else { // \"|\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* bool conditions */\n\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n\t//ptr = strchr (cmd, '&');\n\twhile (ptr && ptr[1] == '&') {\n\t\t*ptr = '\\0';\n\t\tret = r_cmd_call (core->rcmd, cmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"command error(%s)\\n\", cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++);\n\t\tptr = strchr (cmd, '&');\n\t}\n\n\t/* Out Of Band Input */\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\n\tptr = strstr (cmd, \"?*\");\n\tif (ptr) {\n\t\tchar *prech = ptr - 1;\n\t\tif (*prech != '~') {\n\t\t\tptr[1] = 0;\n\t\t\tif (*cmd != '#' && strlen (cmd) < 5) {\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\trecursive_help (core, cmd);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n\t\t\t\tif (scr_html != -1) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tptr = strchr (cmd, '<');\n\tif (ptr) {\n\t\tptr[0] = '\\0';\n\t\tif (r_cons_singleton()->is_interactive) {\n\t\t\tif (ptr[1] == '<') {\n\t\t\t\t/* this is a bit mess */\n\t\t\t\t//const char *oprompt = strdup (r_line_singleton ()->prompt);\n\t\t\t\t//oprompt = \">\";\n\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = malloc (1);\n\t\t\t\tif (core->oobi) {\n\t\t\t\t\tcore->oobi[0] = '\\0';\n\t\t\t\t}\n\t\t\t\tcore->oobi_len = 0;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar buf[1024];\n\t\t\t\t\tint ret;\n\t\t\t\t\twrite (1, \"> \", 2);\n\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n\t\t\t\t\tif (feof (stdin)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n\t\t\t\t\tret = strlen (buf);\n\t\t\t\t\tcore->oobi_len += ret;\n\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n\t\t\t\t\tif (core->oobi) {\n\t\t\t\t\t\tif (!strcmp (buf, str)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_line_set_prompt (oprompt);\n\t\t\t} else {\n\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\tif (!*str) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n\t\t\t\tif (!core->oobi) {\n\t\t\t\t\teprintf (\"cannot open file\\n\");\n\t\t\t\t} else if (ptr == cmd) {\n\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot slurp with << in non-interactive mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\nnext:\n#endif\n\t// TODO must honor \" and `\n\t/* pipe console to file */\n\tptr = strchr (cmd, '>');\n\tif (ptr) {\n\t\tint fdn = 1;\n\t\tint pipecolor = r_config_get_i (core->config, \"scr.pipecolor\");\n\t\tint use_editor = false;\n\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n\t\t*ptr = '\\0';\n\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n\t\tif (!*str) {\n\t\t\teprintf (\"No output?\\n\");\n\t\t\tgoto next2;\n\t\t}\n\t\t/* r_cons_flush() handles interactive output (to the terminal)\n\t\t * differently (e.g. asking about too long output). This conflicts\n\t\t * with piping to a file. Disable it while piping. */\n\t\tif (ptr > (cmd + 1) && ISWHITECHAR (ptr[-2])) {\n\t\t\tchar *fdnum = ptr - 1;\n\t\t\tif (*fdnum == 'H') { // \"H>\"\n\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\tpipecolor = true;\n\t\t\t\t*fdnum = 0;\n\t\t\t} else {\n\t\t\t\tif (IS_DIGIT(*fdnum)) {\n\t\t\t\t\tfdn = *fdnum - '0';\n\t\t\t\t}\n\t\t\t\t*fdnum = 0;\n\t\t\t}\n\t\t}\n\t\tr_cons_set_interactive (false);\n\t\tif (!strcmp (str, \"-\")) {\n\t\t\tuse_editor = true;\n\t\t\tstr = r_file_temp (\"dumpedit\");\n\t\t\tr_config_set (core->config, \"scr.color\", \"false\");\n\t\t}\n\t\tif (fdn > 0) {\n\t\t\tpipefd = r_cons_pipe_open (str, fdn, ptr[1] == '>');\n\t\t\tif (pipefd != -1) {\n\t\t\t\tif (!pipecolor) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\t\t\t}\n\t\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t}\n\t\tr_cons_set_last_interactive ();\n\t\tif (!pipecolor) {\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t}\n\t\tif (use_editor) {\n\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\t\t\tif (editor && *editor) {\n\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n\t\t\t\tr_file_rm (str);\n\t\t\t} else {\n\t\t\t\teprintf (\"No cfg.editor configured\\n\");\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t\tfree (str);\n\t\t}\n\t\tif (scr_html != -1) {\n\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\treturn ret;\n\t}\nnext2:\n\t/* sub commands */\n\tptr = strchr (cmd, '`');\n\tif (ptr) {\n\t\tint empty = 0;\n\t\tint oneline = 1;\n\t\tif (ptr[1] == '`') {\n\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n\t\t\toneline = 0;\n\t\t\tempty = 1;\n\t\t}\n\t\tptr2 = strchr (ptr + 1, '`');\n\t\tif (empty) {\n\t\t\t/* do nothing */\n\t\t} else if (!ptr2) {\n\t\t\teprintf (\"parse: Missing backtick in expression.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tint value = core->num->value;\n\t\t\t*ptr = '\\0';\n\t\t\t*ptr2 = '\\0';\n\t\t\tif (ptr[1] == '!') {\n\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n\t\t\t} else {\n\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n\t\t\t}\n\t\t\tif (!str) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t// ignore contents if first char is pipe or comment\n\t\t\tif (*str == '|' || *str == '*') {\n\t\t\t\teprintf (\"r_core_cmd_subst_i: invalid backticked command\\n\");\n\t\t\t\tfree (str);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (oneline && str) {\n\t\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\t\tif (str[i] == '\\n') {\n\t\t\t\t\t\tstr[i] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr = r_str_append (str, ptr2 + 1);\n\t\t\tcmd = r_str_append (strdup (cmd), str);\n\t\t\tcore->num->value = value;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\tfree (cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t// TODO must honor \" and `\n\tcore->fixedblock = false;\n\n\tif (r_str_endswith (cmd, \"~?\") && cmd[2] == '\\0') {\n\t\tr_cons_grep_help ();\n\t\treturn true;\n\t}\n\tif (*cmd != '.') {\n\t\tr_cons_grep_parsecmd (cmd, quotestr);\n\t}\n\n\t/* temporary seek commands */\n\tif (*cmd!= '(' && *cmd != '\"') {\n\t\tptr = strchr (cmd, '@');\n\t\tif (ptr == cmd + 1 && *cmd == '?') {\n\t\t\tptr = NULL;\n\t\t}\n\t} else {\n\t\tptr = NULL;\n\t}\n\n\tcore->tmpseek = ptr? true: false;\n\tint rc = 0;\n\tif (ptr) {\n\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n\t\tut64 addr = UT64_MAX;\n\t\tconst char *tmpbits = NULL;\n\t\tconst char *offstr = NULL;\n\t\tut64 tmpbsz = core->blocksize;\n\t\tchar *tmpeval = NULL;\n\t\tut64 tmpoff = core->offset;\n\t\tchar *tmpasm = NULL;\n\t\tint tmpfd = -1;\n\t\tint sz, len;\n\t\tut8 *buf;\n\n\t\t*ptr = '\\0';\n\t\tfor (ptr++; *ptr == ' '; ptr++) {\n\t\t\t//nothing to see here\n\t\t}\n\t\tif (*ptr && ptr[1] == ':') {\n\t\t\t/* do nothing here */\n\t\t} else {\n\t\t\tptr--;\n\t\t}\n\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n\t\t\tstrchr (ptr + 2, '@'): NULL;\nrepeat_arroba:\n\t\tif (arroba) {\n\t\t\t*arroba = 0;\n\t\t}\n\t\tif (ptr[1] == '?') {\n\t\t\thelpCmdAt (core);\n\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n\t\t\tusemyblock = true;\n\t\t\tswitch (ptr[0]) {\n\t\t\tcase 'f': // \"@f:\" // slurp file in block\n\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n\t\t\t\tif (f) {\n\t\t\t\t\tbuf = malloc (sz);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tfree (core->block);\n\t\t\t\t\t\tcore->block = buf;\n\t\t\t\t\t\tcore->blocksize = sz;\n\t\t\t\t\t\tmemcpy (core->block, f, sz);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n\t\t\t\t\t}\n\t\t\t\t\tfree (f);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"@r:\" // regname\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tut64 regval;\n\t\t\t\t\tchar *mander = strdup (ptr + 2);\n\t\t\t\t\tchar *sep = findSeparator (mander);\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tchar ch = *sep;\n\t\t\t\t\t\t*sep = 0;\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n\t\t\t\t\t\t*sep = ch;\n\t\t\t\t\t\tchar *numexpr = r_str_newf (\"0x%\"PFMT64x\"%s\", regval, sep);\n\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n\t\t\t\t\t\tfree (numexpr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_seek (core, regval, 1);\n\t\t\t\t\tfree (mander);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"@b:\" // bits\n\t\t\t\ttmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n\t\t\t\tr_config_set_i (core->config, \"asm.bits\",\n\t\t\t\t\tr_num_math (core->num, ptr + 2));\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"@i:\"\n\t\t\t\t{\n\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n\t\t\t\t\tif (addr) {\n\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"@e:\"\n\t\t\t\ttmpeval = parse_tmp_evals (core, ptr + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'x': // \"@x:\" // hexpairs\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n\t\t\t\t\t\tr_core_block_size (core, R_ABS(len));\n\t\t\t\t\t\tmemcpy (core->block, buf, core->blocksize);\n\t\t\t\t\t\tcore->fixedblock = true;\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot allocate\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid @x: syntax\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k': // \"@k\"\n\t\t\t\t {\n\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n\t\t\t\t\tif (out) {\n\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"@o:3\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\ttmpfd = core->io->raised;\n\t\t\t\t\tr_io_raise (core->io, atoi (ptr + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a': // \"@a:\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n\t\t\t\t\ttmpasm = strdup (r_config_get (core->config, \"asm.arch\"));\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q++ = 0;\n\t\t\t\t\t\ttmpbits = r_config_get (core->config, \"asm.bits\");\n\t\t\t\t\t\tr_config_set (core->config, \"asm.bits\", q);\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set (core->config, \"asm.arch\", ptr + 2);\n\t\t\t\t\t// TODO: handle asm.bits\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Usage: pd 10 @a:arm:32\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"@s:\"\n\t\t\t\tlen = strlen (ptr + 2);\n\t\t\t\tr_core_block_size (core, len);\n\t\t\t\tmemcpy (core->block, ptr + 2, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\t*ptr = '@';\n\t\t\tgoto next_arroba; //ignore; //return ret;\n\t\t}\nignore:\n\t\tptr = r_str_trim_head (ptr + 1);\n\t\tptr--;\n\n\t\tcmd = r_str_clean (cmd);\n\t\tif (ptr2) {\n\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t    !memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t    !memcmp (ptr2 + 1, \"0x\", 2)) {\n\t\t\t\t/* 0xXXXX:0xYYYY */\n\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n\t\t\t\t/* XXXX:YYYY */\n\t\t\t} else {\n\t\t\t\t*ptr2 = '\\0';\n\t\t\t\tif (!ptr2[1]) {\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n\t\t\t}\n\t\t}\n\n\t\toffstr = r_str_trim_head (ptr + 1);\n\n\t\taddr = r_num_math (core->num, offstr);\n\t\tif (isalpha ((unsigned char)ptr[1]) && !addr) {\n\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tchar ch = *offstr;\n\t\t\tif (ch == '-' || ch == '+') {\n\t\t\t\taddr = core->offset + addr;\n\t\t\t}\n\t\t}\nnext_arroba:\n\t\tif (arroba) {\n\t\t\tptr = arroba;\n\t\t\tarroba = NULL;\n\t\t\tgoto repeat_arroba;\n\t\t}\n\t\tif (ptr[1] == '@') {\n\t\t\t// TODO: remove temporally seek (should be done by cmd_foreach)\n\t\t\tif (ptr[2] == '@') {\n\t\t\t\tchar *rule = ptr + 3;\n\t\t\t\twhile (*rule && *rule == ' ') rule++;\n\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n\t\t\t} else {\n\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n\t\t\t}\n\t\t\t//ret = -1; /* do not run out-of-foreach cmd */\n\t\t} else {\n\t\t\tbool tmpseek = false;\n\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n\t\t\t\t\"io.buffer.from\", \"lines.from\", \"search.from\", \"zoom.from\", NULL };\n\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n\t\t\t\t\"io.buffer.to\", \"lines.to\", \"search.to\", \"zoom.to\", NULL };\n\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n\n\t\t\t// @..\n\t\t\tif (ptr[1] == '.' && ptr[2] == '.') {\n\t\t\t\tchar *range = ptr + 3;\n\t\t\t\tchar *p = strchr (range, ' ');\n\t\t\t\tif (!p) {\n\t\t\t\t\teprintf (\"Usage: / ABCD @..0x1000 0x3000\\n\");\n\t\t\t\t\tfree (tmpeval);\n\t\t\t\t\tfree (tmpasm);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\t*p = '\\x00';\n\t\t\t\tut64 from = r_num_math (core->num, range);\n\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n\t\t\t\t// save current ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n\t\t\t\t}\n\t\t\t\t// set new ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n\t\t\t\t}\n\t\t\t\ttmpseek = true;\n\t\t\t}\n\t\t\tif (usemyblock) {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tcore->offset = addr;\n\t\t\t\t}\n\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t} else {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tif (!ptr[1] || r_core_seek (core, addr, 1)) {\n\t\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmpseek) {\n\t\t\t\t// restore ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ptr2) {\n\t\t\t*ptr2 = '!';\n\t\t\tr_core_block_size (core, tmpbsz);\n\t\t}\n\t\tif (tmpasm) {\n\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n\t\t\ttmpasm = NULL;\n\t\t}\n\t\tif (tmpfd != -1) {\n\t\t\tr_io_raise (core->io, tmpfd);\n\t\t}\n\t\tif (tmpbits) {\n\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n\t\t\ttmpbits = NULL;\n\t\t}\n\t\tif (tmpeval) {\n\t\t\tr_core_cmd0 (core, tmpeval);\n\t\t\tR_FREE (tmpeval);\n\t\t}\n\t\tr_core_seek (core, tmpoff, 1);\n\t\t*ptr = '@';\n\t\trc = ret;\n\t\tgoto beach;\n\t}\n\n\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\nbeach:\n\tif (scr_html != -1) {\n\t\tr_cons_flush ();\n\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t}\n\tif (scr_color != -1) {\n\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t}\n\tcore->fixedblock = false;\n\treturn rc;\nfail:\n\trc = -1;\n\tgoto beach;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 400,
    "critical_vars": [
      "*obj"
    ],
    "function": "cmd_info",
    "filename": "radare2/CVE-2017-9761/CVE-2017-9761_CWE-119_00e8f205475332d7842d0f0d1481eeab4e83017c_cmd_info.c.diff",
    "function_code": "static int cmd_info(void *data, const char *input) {\n\tRCore *core = (RCore *) data;\n\tbool newline = r_config_get_i (core->config, \"scr.interactive\");\n\tRBinObject *o = r_bin_cur_object (core->bin);\n\tRCoreFile *cf = core->file;\n\tint i, va = core->io->va || core->io->debug;\n\tint mode = 0; //R_CORE_BIN_SIMPLE;\n\tint is_array = 0;\n\tSdb *db;\n\n\tfor (i = 0; input[i] && input[i] != ' '; i++)\n\t\t;\n\tif (i > 0) {\n\t\tswitch (input[i - 1]) {\n\t\tcase '*': mode = R_CORE_BIN_RADARE; break;\n\t\tcase 'j': mode = R_CORE_BIN_JSON; break;\n\t\tcase 'q': mode = R_CORE_BIN_SIMPLE; break;\n\t\t}\n\t}\n\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tif (strlen (input + 1) > 1) {\n\t\t\tis_array = 1;\n\t\t}\n\t}\n\tif (is_array) {\n\t\tr_cons_printf (\"{\");\n\t}\n\tif (!*input) {\n\t\tcmd_info_bin (core, va, mode);\n\t}\n\t/* i* is an alias for iI* */\n\tif (!strcmp (input, \"*\")) {\n\t\tinput = \"I*\";\n\t}\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\twhile (*input) {\n\t\tswitch (*input) {\n\t\tcase 'b': // \"ib\"\n\t\t{\n\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tbaddr = r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\t// XXX: this will reload the bin using the buffer.\n\t\t\t// An assumption is made that assumes there is an underlying\n\t\t\t// plugin that will be used to load the bin (e.g. malloc://)\n\t\t\t// TODO: Might be nice to reload a bin at a specified offset?\n\t\t\tr_core_bin_reload (core, NULL, baddr);\n\t\t\tr_core_block_read (core);\n\t\t\tnewline = false;\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t\tdb = o? o->kv: NULL;\n\t\t\t//:eprintf (\"db = %p\\n\", db);\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'v':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, input + 3);\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tr_core_bin_export_info_rad (core);\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\tcase ' ':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, input + 2);\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\0':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, \"*\");\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\teprintf (\"Usage: ik [sdb-query]\\n\");\n\t\t\t\teprintf (\"Usage: ik*    # load all header information\\n\");\n\t\t\t}\n\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t{\n\t\t\tif (!cf) {\n\t\t\t\teprintf (\"Core file not open\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst char *fn = input[1] == ' '? input + 2: cf->desc->name;\n\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\tr_core_bin_load (core, fn, baddr);\n\t\t}\n\t\tbreak;\n\t\t\t#define RBININFO(n,x,y,z)\\\n\t\t\t\tif (is_array) {\\\n\t\t\t\t\tif (is_array == 1) { is_array++;\\\n\t\t\t\t\t} else { r_cons_printf (\",\");}\\\n\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\",n);\\\n\t\t\t\t}\\\n\t\t\t\tif (z) { playMsg (core, n, z);}\\\n\t\t\t\tr_core_bin_info (core, x, mode, va, NULL, y);\n\t\tcase 'A':\n\t\t\tnewline = false;\n\t\t\tif (input[1] == 'j') {\n\t\t\t\tr_cons_printf (\"{\");\n\t\t\t\tr_bin_list_archs (core->bin, 'j');\n\t\t\t\tr_cons_printf (\"}\\n\");\n\t\t\t} else {\n\t\t\t\tr_bin_list_archs (core->bin, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E': RBININFO (\"exports\", R_CORE_BIN_ACC_EXPORTS, NULL, 0); break;\n\t\tcase 'Z': RBININFO (\"size\", R_CORE_BIN_ACC_SIZE, NULL, 0); break;\n\t\tcase 'S':\n\t\t\t//we comes from ia or iS\n\t\t\tif ((input[1] == 'm' && input[2] == 'z') || !input[1]) {\n\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, NULL, 0);\n\t\t\t} else {  //iS entropy,sha1\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (mode == R_CORE_BIN_RADARE || mode == R_CORE_BIN_JSON || mode == R_CORE_BIN_SIMPLE) {\n\t\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, input + 2,\n\t\t\t\t\t\tobj? r_list_length (obj->sections): 0);\n\t\t\t\t} else {\n\t\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, input + 1,\n\t\t\t\t\t\tobj? r_list_length (obj->sections): 0);\n\t\t\t\t}\n\t\t\t\t//we move input until get '\\0'\n\t\t\t\twhile (*(++input)) ;\n\t\t\t\t//input-- because we are inside a while that does input++\n\t\t\t\t// oob read if not input--\n\t\t\t\tinput--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tif (input[1] == 'H') { // \"iHH\"\n\t\t\t\tRBININFO (\"header\", R_CORE_BIN_ACC_HEADER, NULL, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 'h': RBININFO (\"fields\", R_CORE_BIN_ACC_FIELDS, NULL, 0); break;\n\t\tcase 'l': \n\t\t\t  {\n\t\t\t\t  RBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\t  RBININFO (\"libs\", R_CORE_BIN_ACC_LIBS, NULL, obj? r_list_length (obj->libs): 0); \n\t\t\t  }\n\t\t\t  break;\n\t\tcase 'L':\n\t\t{\n\t\t\tchar *ptr = strchr (input, ' ');\n\t\t\tint json = input[1] == 'j'? 'j': 0;\n\n\t\t\tif (ptr && ptr[1]) {\n\t\t\t\tconst char *plugin_name = ptr + 1;\n\t\t\t\tif (is_array) {\n\t\t\t\t\tr_cons_printf (\"\\\"plugin\\\": \");\n\t\t\t\t}\n\t\t\t\tr_bin_list_plugin (core->bin, plugin_name, json);\n\t\t\t} else {\n\t\t\t\tr_bin_list (core->bin, json);\n\t\t\t}\n\n\t\t\tnewline = false;\n\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t\tcase 's':\n\t\t\tif (input[1] == '.') {\n\t\t\t\tut64 addr = core->offset + (core->print->cur_enabled? core->print->cur: 0);\n\t\t\t\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\t\t\t\tif (f) {\n\t\t\t\t\tif (f->offset == addr || !f->offset) {\n\t\t\t\t\t\tr_cons_printf (\"%s\", f->name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d\", f->name, (int) (addr - f->offset));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tRBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, NULL, obj? r_list_length (obj->symbols): 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 'R': \n\t\t\tif  (input[1] == '*') {\n\t\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\t} else if (input[1] == 'j') {\n\t\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\t}\n\t\t\tRBININFO (\"resources\", R_CORE_BIN_ACC_RESOURCES, NULL, 0); \n\t\t\tbreak;\n\t\tcase 'r': RBININFO (\"relocs\", R_CORE_BIN_ACC_RELOCS, NULL, 0); break;\n\t\tcase 'd': RBININFO (\"dwarf\", R_CORE_BIN_ACC_DWARF, NULL, -1); break;\n\t\tcase 'i': {\n\t\t\t\t  RBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\t  RBININFO (\"imports\", R_CORE_BIN_ACC_IMPORTS, NULL,\n\t\t\t\t\t\t  obj? r_list_length (obj->imports): 0);\n\t\t\t  }\n\t\t\t  break;\n\t\tcase 'I': RBININFO (\"info\", R_CORE_BIN_ACC_INFO, NULL, 0); break;\n\t\tcase 'e': RBININFO (\"entries\", R_CORE_BIN_ACC_ENTRIES, NULL, 0); break;\n\t\tcase 'M': RBININFO (\"main\", R_CORE_BIN_ACC_MAIN, NULL, 0); break;\n\t\tcase 'm': RBININFO (\"memory\", R_CORE_BIN_ACC_MEM, NULL, 0); break;\n\t\tcase 'V': RBININFO (\"versioninfo\", R_CORE_BIN_ACC_VERSIONINFO, NULL, 0); break;\n\t\tcase 'C': RBININFO (\"signature\", R_CORE_BIN_ACC_SIGNATURE, NULL, 0); break;\n\t\tcase 'z':\n\t\t\tif (input[1] == 'z') { //izz\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '*':\n\t\t\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q': //izzq\n\t\t\t\t\tif (input[3] == 'q') { //izzqq\n\t\t\t\t\t\tmode = R_CORE_BIN_SIMPLEST;\n\t\t\t\t\t\tinput++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmode = R_CORE_BIN_SIMPLE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmode = R_CORE_BIN_PRINT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinput++;\n\t\t\t\tRBININFO (\"strings\", R_CORE_BIN_ACC_RAW_STRINGS, NULL, 0);\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (input[1] == 'q') {\n\t\t\t\t\tmode = (input[2] == 'q')\n\t\t\t\t\t? R_CORE_BIN_SIMPLEST\n\t\t\t\t\t: R_CORE_BIN_SIMPLE;\n\t\t\t\t\tinput++;\n\t\t\t\t}\n\t\t\t\tif (obj) {\n\t\t\t\t\tRBININFO (\"strings\", R_CORE_BIN_ACC_STRINGS, NULL,\n\t\t\t\t\t\tobj? r_list_length (obj->strings): 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // for r2 `ic`\n\t\t\tif (input[1] == '?') {\n\t\t\t\teprintf (\"Usage: ic[ljq*] [class-index or name]\\n\");\n\t\t\t} else if (input[1] == ' ' || input[1] == 'q' || input[1] == 'j' || input[1] == 'l') {\n\t\t\t\tRBinClass *cls;\n\t\t\t\tRBinSymbol *sym;\n\t\t\t\tRListIter *iter, *iter2;\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (obj) {\n\t\t\t\t\tif (input[2]) {\n\t\t\t\t\t\tint idx = -1;\n\t\t\t\t\t\tconst char * cls_name = NULL;\n\t\t\t\t\t\tif (r_num_is_valid_input (core->num, input + 2)) {\n\t\t\t\t\t\t\tidx = r_num_math (core->num, input + 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char * first_char = input + ((input[1] == ' ') ? 1 : 2);\n\t\t\t\t\t\t\tint not_space = strspn (first_char, \" \");\n\t\t\t\t\t\t\tif (first_char[not_space]) {\n\t\t\t\t\t\t\t\tcls_name = first_char + not_space;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n\t\t\t\t\t\t\tif ((idx >= 0 && idx != count++) ||\n\t\t\t\t\t\t\t   (cls_name && strcmp (cls_name, cls->name) != 0)){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch (input[1]) {\n\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"f sym.%s @ 0x%\"PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\t\t\tsym->name, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \" \": \"\";\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%\"PFMT64d, comma, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'j':\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tr_cons_printf (\"\\\"class\\\":\\\"%s\\\"\", cls->name);\n\t\t\t\t\t\t\t\tr_cons_printf (\",\\\"methods\\\":[\");\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \",\": \"\";\n\n\t\t\t\t\t\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\t\t\t\t\t\tchar *flags = r_core_bin_method_flags_str (sym, R_CORE_BIN_JSON);\n\t\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"vaddr\\\":%\"PFMT64d \"}\",\n\t\t\t\t\t\t\t\t\t\t\tcomma, sym->name, flags, sym->vaddr);\n\t\t\t\t\t\t\t\t\t\tR_FREE (flags);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"vaddr\\\":%\"PFMT64d \"}\",\n\t\t\t\t\t\t\t\t\t\t\tcomma, sym->name, sym->vaddr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tr_cons_printf (\"class %s\\n\", cls->name);\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tchar *flags = r_core_bin_method_flags_str (sym, 0);\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" method %s %s %s\\n\",\n\t\t\t\t\t\t\t\t\t\tsym->vaddr, cls->name, flags, sym->name);\n\t\t\t\t\t\t\t\t\tR_FREE (flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayMsg (core, \"classes\", r_list_length (obj->classes));\n\t\t\t\t\t\tif (input[1] == 'l' && obj) { // \"icl\"\n\t\t\t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \" \": \"\";\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%\"PFMT64d, comma, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!r_list_empty (cls->methods)) {\n\t\t\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tRBININFO (\"classes\", R_CORE_BIN_ACC_CLASSES, NULL, r_list_length (obj->classes));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tint len = obj? r_list_length (obj->classes): 0;\n\t\t\t\tRBININFO (\"classes\", R_CORE_BIN_ACC_CLASSES, NULL, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (input[1] != ' ' || !demangle (core, input + 2)) {\n\t\t\t\teprintf (\"|Usage: iD lang symbolname\\n\");\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 'a':\n\t\t\tswitch (mode) {\n\t\t\tcase R_CORE_BIN_RADARE: cmd_info (core, \"iIiecsSmz*\"); break;\n\t\t\tcase R_CORE_BIN_JSON: cmd_info (core, \"iIiecsSmzj\"); break;\n\t\t\tcase R_CORE_BIN_SIMPLE: cmd_info (core, \"iIiecsSmzq\"); break;\n\t\t\tdefault: cmd_info (core, \"IiEecsSmz\"); break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': {\n\t\t\tconst char *help_message[] = {\n\t\t\t\t\"Usage: i\", \"\", \"Get info from opened file (see rabin2's manpage)\",\n\t\t\t\t\"Output mode:\", \"\", \"\",\n\t\t\t\t\"'*'\", \"\", \"Output in radare commands\",\n\t\t\t\t\"'j'\", \"\", \"Output in json\",\n\t\t\t\t\"'q'\", \"\", \"Simple quiet output\",\n\t\t\t\t\"Actions:\", \"\", \"\",\n\t\t\t\t\"i|ij\", \"\", \"Show info of current file (in JSON)\",\n\t\t\t\t\"iA\", \"\", \"List archs\",\n\t\t\t\t\"ia\", \"\", \"Show all info (imports, exports, sections..)\",\n\t\t\t\t\"ib\", \"\", \"Reload the current buffer for setting of the bin (use once only)\",\n\t\t\t\t\"ic\", \"\", \"List classes, methods and fields\",\n\t\t\t\t\"iC\", \"\", \"Show signature info (entitlements, ...)\",\n\t\t\t\t\"id\", \"\", \"Debug information (source lines)\",\n\t\t\t\t\"iD\", \" lang sym\", \"demangle symbolname for given language\",\n\t\t\t\t\"ie\", \"\", \"Entrypoint\",\n\t\t\t\t\"iE\", \"\", \"Exports (global symbols)\",\n\t\t\t\t\"ih\", \"\", \"Headers (alias for iH)\",\n\t\t\t\t\"iHH\", \"\", \"Verbose Headers in raw text\",\n\t\t\t\t\"ii\", \"\", \"Imports\",\n\t\t\t\t\"iI\", \"\", \"Binary info\",\n\t\t\t\t\"ik\", \" [query]\", \"Key-value database from RBinObject\",\n\t\t\t\t\"il\", \"\", \"Libraries\",\n\t\t\t\t\"iL \", \"[plugin]\", \"List all RBin plugins loaded or plugin details\",\n\t\t\t\t\"im\", \"\", \"Show info about predefined memory allocation\",\n\t\t\t\t\"iM\", \"\", \"Show main address\",\n\t\t\t\t\"io\", \" [file]\", \"Load info from file (or last opened) use bin.baddr\",\n\t\t\t\t\"ir\", \"\", \"Relocs\",\n\t\t\t\t\"iR\", \"\", \"Resources\",\n\t\t\t\t\"is\", \"\", \"Symbols\",\n\t\t\t\t\"iS \", \"[entropy,sha1]\", \"Sections (choose which hash algorithm to use)\",\n\t\t\t\t\"iV\", \"\", \"Display file version info\",\n\t\t\t\t\"iz|izj\", \"\", \"Strings in data sections (in JSON/Base64)\",\n\t\t\t\t\"izz\", \"\", \"Search for Strings in the whole binary\",\n\t\t\t\t\"iZ\", \"\", \"Guess size of binary program\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tr_core_cmd_help (core, help_message);\n\t\t}\n\t\t\tgoto done;\n\t\tcase '*':\n\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\tgoto done;\n\t\tcase 'q':\n\t\t\tmode = R_CORE_BIN_SIMPLE;\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tgoto done;\n\t\tcase 'j':\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tif (is_array > 1) {\n\t\t\t\tmode |= R_CORE_BIN_ARRAY;\n\t\t\t}\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tbreak;\n\t\t}\n\t\tinput++;\n\t\tif ((*input == 'j' || *input == 'q') && !input[1]) {\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tif (is_array) {\n\t\tr_cons_printf (\"}\\n\");\n\t}\n\tif (newline) {\n\t\tr_cons_newline ();\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 708,
    "critical_vars": [
      "shdr->sh_size"
    ],
    "function": "*store_versioninfo_gnu_verdef",
    "filename": "radare2/CVE-2017-16357/CVE-2017-16357_CWE-119_0b973e28166636e0ff1fad80baa0385c9c09c53a_elf.c.diff",
    "function_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 840,
    "critical_vars": [
      "shdr->sh_size"
    ],
    "function": "*store_versioninfo_gnu_verneed",
    "filename": "radare2/CVE-2017-16357/CVE-2017-16357_CWE-119_0b973e28166636e0ff1fad80baa0385c9c09c53a_elf.c.diff",
    "function_code": "static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tint i, cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tbprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 0)\n\t\tgoto beach;\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j)\n\t\tvvn.vn_cnt = READ16 (vstart, j)\n\t\tvvn.vn_file = READ32 (vstart, j)\n\t\tvvn.vn_aux = READ32 (vstart, j)\n\t\tvvn.vn_next = READ32 (vstart, j)\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tst32 vnaux = entry->vn_aux;\n\t\tif (vnaux < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tvstart += vnaux;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) * aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k)\n\t\t\tvaux.vna_flags = READ16 (vstart, k)\n\t\t\tvaux.vna_other = READ16 (vstart, k)\n\t\t\tvaux.vna_name = READ32 (vstart, k)\n\t\t\tvaux.vna_next = READ32 (vstart, k)\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof(name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tbprintf (\"Invalid vn_next\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 15,
    "critical_vars": [
      "tbuf"
    ],
    "function": "*load_bytes",
    "filename": "radare2/CVE-2017-6194/CVE-2017-6194_CWE-119_72794dc3523bbd5bb370de3c5857cb736c387e18_bin_bflt.c.diff",
    "function_code": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 166,
    "line_new": 170,
    "critical_vars": [
      "*got_table"
    ],
    "function": "*relocs",
    "filename": "radare2/CVE-2017-6194/CVE-2017-6194_CWE-119_72794dc3523bbd5bb370de3c5857cb736c387e18_bin_bflt.c.diff",
    "function_code": "static RList *relocs(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)free);\n\tint i, len, n_got, amount;\n\tif (!list || !obj) {\n\t\tr_list_free (list);\n\t\treturn NULL;\n\t}\n\tif (obj->hdr->flags & FLAT_FLAG_GOTPIC) {\n\t\tn_got = get_ngot_entries (obj);\n\t\tif (n_got) {\n\t\t\tamount = n_got *  sizeof (ut32);\n\t\t\tif (amount < n_got || amount > UT32_MAX) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tstruct reloc_struct_t *got_table = calloc (\n\t\t\t\t1, n_got * sizeof (struct reloc_struct_t));\n\t\t\tif (got_table) {\n\t\t\t\tut32 offset = 0;\n\t\t\t\tfor (i = 0; i < n_got ; offset += 4, i++) {\n\t\t\t\t\tut32 got_entry;\n\t\t\t\t\tif (obj->hdr->data_start + offset + 4 > obj->size ||\n\t\t\t\t\t    obj->hdr->data_start + offset + 4 < offset) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlen = r_buf_read_at (obj->b, obj->hdr->data_start + offset,\n\t\t\t\t\t\t\t\t(ut8 *)&got_entry, sizeof (ut32));\n\t\t\t\t\tif (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgot_table[i].addr_to_patch = got_entry;\n\t\t\t\t\tgot_table[i].data_offset = got_entry + BFLT_HDR_SIZE;\n\t\t\t\t}\n\t\t\t\tobj->n_got = n_got;\n\t\t\t\tobj->got_table = got_table;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (obj->hdr->reloc_count > 0) {\n\t\tint n_reloc = obj->hdr->reloc_count; \n\n\t\tamount = n_reloc * sizeof (struct reloc_struct_t);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tgoto out_error;\t\n\t\t}\n\t\tstruct reloc_struct_t *reloc_table = calloc (1, amount + 1);\n\t\tif (!reloc_table) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tamount = n_reloc * sizeof (ut32);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tut32 *reloc_pointer_table = calloc (1, amount + 1);\n\t\tif (!reloc_pointer_table) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (obj->hdr->reloc_start + amount > obj->size ||\n\t\t    obj->hdr->reloc_start + amount < amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tlen = r_buf_read_at (obj->b, obj->hdr->reloc_start,\n\t\t\t\t     (ut8 *)reloc_pointer_table, amount);\n\t\tif (len != amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tfor (i = 0; i < obj->hdr->reloc_count; i++) {\n\t\t\t//XXX it doesn't take endian as consideration when swapping\n\t\t\tut32 reloc_offset =\n\t\t\t\tr_swap_ut32 (reloc_pointer_table[i]) +\n\t\t\t\tBFLT_HDR_SIZE;\n\n\t\t\tif (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) {\n\t\t\t\tut32 reloc_fixed, reloc_data_offset;\n\t\t\t\tif (reloc_offset + sizeof (ut32) > obj->size ||\n\t\t\t\t    reloc_offset + sizeof (ut32) < reloc_offset) {\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tlen = r_buf_read_at (obj->b, reloc_offset,\n\t\t\t\t\t\t     (ut8 *)&reloc_fixed,\n\t\t\t\t\t\t     sizeof (ut32));\n\t\t\t\tif (len != sizeof (ut32)) {\n\t\t\t\t\teprintf (\"problem while reading relocation entries\\n\");\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\treloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE;\n\t\t\t\treloc_table[i].addr_to_patch = reloc_offset;\n\t\t\t\treloc_table[i].data_offset = reloc_data_offset;\n\t\n\t\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\t\tif (reloc) {\n\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\treloc->paddr = reloc_table[i].addr_to_patch;\n\t\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\t\tr_list_append (list, reloc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (reloc_pointer_table);\n\t\tobj->reloc_table = reloc_table;\n\t}\n\treturn list;\nout_error:\n\tr_list_free (list);\n\treturn NULL;\t\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1811,
    "critical_vars": [
      "remaining"
    ],
    "function": "X509_cmp_time",
    "filename": "openssl/CVE-2015-1789/CVE-2015-1789_CWE-119_f48b83b4fb7d6689584cf25f61ca63a4891f5b11_x509_vfy.c.diff",
    "function_code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j, remaining;\n\n    p = buff1;\n    remaining = ctm->length;\n    str = (char *)ctm->data;\n    /*\n     * Note that the following (historical) code allows much more slack in the\n     * time format than RFC5280. In RFC5280, the representation is fixed:\n     * UTCTime: YYMMDDHHMMSSZ\n     * GeneralizedTime: YYYYMMDDHHMMSSZ\n     */\n    if (ctm->type == V_ASN1_UTCTIME) {\n        /* YYMMDDHHMM[SS]Z or YYMMDDHHMM[SS](+-)hhmm */\n        int min_length = sizeof(\"YYMMDDHHMMZ\") - 1;\n        int max_length = sizeof(\"YYMMDDHHMMSS+hhmm\") - 1;\n        if (remaining < min_length || remaining > max_length)\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n        remaining -= 10;\n    } else {\n        /* YYYYMMDDHHMM[SS[.fff]]Z or YYYYMMDDHHMM[SS[.f[f[f]]]](+-)hhmm */\n        int min_length = sizeof(\"YYYYMMDDHHMMZ\") - 1;\n        int max_length = sizeof(\"YYYYMMDDHHMMSS.fff+hhmm\") - 1;\n        if (remaining < min_length || remaining > max_length)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n        remaining -= 12;\n    }\n\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        /* SS (seconds) */\n        if (remaining < 2)\n            return 0;\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        remaining -= 2;\n        /*\n         * Skip any (up to three) fractional seconds...\n         * TODO(emilia): in RFC5280, fractional seconds are forbidden.\n         * Can we just kill them altogether?\n         */\n        if (remaining && *str == '.') {\n            str++;\n            remaining--;\n            for (i = 0; i < 3 && remaining; i++, str++, remaining--) {\n                if (*str < '0' || *str > '9')\n                    break;\n            }\n        }\n\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n\n    /* We now need either a terminating 'Z' or an offset. */\n    if (!remaining)\n        return 0;\n    if (*str == 'Z') {\n        if (remaining != 1)\n            return 0;\n        offset = 0;\n    } else {\n        /* (+-)HHMM */\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        /* Historical behaviour: the (+-)hhmm offset is forbidden in RFC5280. */\n        if (remaining != 5)\n            return 0;\n        if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||\n            str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1814,
    "critical_vars": [
      "i"
    ],
    "function": "X509_cmp_time",
    "filename": "openssl/CVE-2015-1789/CVE-2015-1789_CWE-119_f48b83b4fb7d6689584cf25f61ca63a4891f5b11_x509_vfy.c.diff",
    "function_code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        /* Skip any fractional seconds... */\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 250,
    "critical_vars": [
      "rdata->rbuf.buf"
    ],
    "function": "dtls1_buffer_record",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\n\t/* Limit the size of the queue to prevent DOS attacks */\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\t\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\t\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\n\titem->data = rdata;\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Store bio_dgram_sctp_rcvinfo struct */\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tif (rdata->rbuf.buf != NULL)\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(-1);\n\t\t}\n\n\t/* insert should not fail, since duplicates are dropped */\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tif (rdata->rbuf.buf != NULL)\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(-1);\n\t\t}\n\n\treturn(1);\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 317,
    "critical_vars": [
      "s->s3->rrec.seq_num",
      "s->d1->processed_rcds",
      "s"
    ],
    "function": "dtls1_process_buffered_records",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n\n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 321,
    "critical_vars": [
      "s->s3->rrec.seq_num",
      "s->d1->processed_rcds",
      "s"
    ],
    "function": "dtls1_process_buffered_records",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                s->s3->rrec.seq_num)<0)\n                return -1;\n            }\n        }\n\n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 566,
    "critical_vars": [
      "s"
    ],
    "function": "dtls1_get_record",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n\treturn(1);\n\n\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 570,
    "critical_vars": [
      "s"
    ],
    "function": "dtls1_get_record",
    "filename": "openssl/CVE-2015-0206/CVE-2015-0206_CWE-119_103b171d8fc282ef435f8de9afbf7782e312961f_d1_pkt.c.diff",
    "function_code": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tif(dtls1_process_buffered_records(s)<0)\n\t\treturn -1;\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tif(dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num)<0)\n\t\t\t\treturn -1;\n\t\t\tdtls1_record_bitmap_update(s, bitmap);/* Mark receipt of record. */\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\tdtls1_record_bitmap_update(s, bitmap);/* Mark receipt of record. */\n\n\treturn(1);\n\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 205,
    "critical_vars": [
      "frag"
    ],
    "function": "dtls1_clear_queues",
    "filename": "openssl/CVE-2014-8176/CVE-2014-8176_CWE-119_470990fee0182566d439ef7e82d1abf18b7085d7_d1_lib.c.diff",
    "function_code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 205,
    "critical_vars": [
      "rdata"
    ],
    "function": "dtls1_clear_queues",
    "filename": "openssl/CVE-2014-8176/CVE-2014-8176_CWE-119_470990fee0182566d439ef7e82d1abf18b7085d7_d1_lib.c.diff",
    "function_code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n\t\tOPENSSL_free(item->data);\n\t\tpitem_free(item);\n\t\t}\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1226,
    "critical_vars": [
      "nbytes"
    ],
    "function": "mget",
    "filename": "file/CVE-2014-2270/CVE-2014-2270_CWE-119_447558595a3650db2886cd2f416ad0beba965801_softmagic.c.diff",
    "function_code": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (nbytes < offset || nbytes < (offset + 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t (p->hs[1]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t (p->hs[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t (p->hl[3]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t (p->hl[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t (p->hl[2]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (nbytes < (offset + 1)) /* should alway be true */\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (nbytes < (offset + 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (nbytes < (offset + 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (nbytes < (offset + 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (nbytes < (offset + m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(m->desc, \"%u\"), offset) == -1)\n\t\t\t\treturn -1;\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\treturn -1;\n\t\t\tfree(rbuf);\n\t\t}\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1227,
    "critical_vars": [
      "offset",
      "nbytes"
    ],
    "function": "mget",
    "filename": "file/CVE-2014-2270/CVE-2014-2270_CWE-119_447558595a3650db2886cd2f416ad0beba965801_softmagic.c.diff",
    "function_code": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t\t (p->hs[1])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[0]<<8)|\n\t\t\t\t\t\t (p->hs[1]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t\t (p->hs[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (short)((p->hs[1]<<8)|\n\t\t\t\t\t\t (p->hs[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t\t (p->hl[3])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n\t\t\t\t\t\t (p->hl[1]<<16)|\n\t\t\t\t\t\t (p->hl[2]<<8)|\n\t\t\t\t\t\t (p->hl[3]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t\t (p->hl[0])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n\t\t\t\t\t\t (p->hl[2]<<16)|\n\t\t\t\t\t\t (p->hl[1]<<8)|\n\t\t\t\t\t\t (p->hl[0]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) &\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) |\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) ^\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) +\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) -\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) *\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) /\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t\t (p->hl[2])) %\n\t\t\t\t\t\t off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n\t\t\t\t\t\t (p->hl[0]<<16)|\n\t\t\t\t\t\t (p->hl[3]<<8)|\n\t\t\t\t\t\t (p->hl[2]));\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (OFFSET_OOB(nbytes, offset, 0))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (OFFSET_OOB(nbytes, offset, 0))\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(m->desc, \"%u\"), offset) == -1)\n\t\t\t\treturn -1;\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\treturn -1;\n\t\t\tfree(rbuf);\n\t\t}\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (OFFSET_OOB(nbytes, offset, 0))\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 830,
    "critical_vars": [
      "nelements"
    ],
    "function": "cdf_read_property_info",
    "filename": "file/CVE-2014-0238/CVE-2014-0238_CWE-119_f97486ef5dc3e8735440edc4fc8808c63e1a3ef0_cdf.c.diff",
    "function_code": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 967,
    "critical_vars": [
      "len"
    ],
    "function": "mconvert",
    "filename": "file/CVE-2014-9652/CVE-2014-9652_CWE-119_59e63838913eee47f5c120a6c53d4565af638158_softmagic.c.diff",
    "function_code": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s)) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t */ \n\t\t\tlen = sizeof(p->s) - sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 967,
    "critical_vars": [
      "sz"
    ],
    "function": "mconvert",
    "filename": "file/CVE-2014-9652/CVE-2014-9652_CWE-119_59e63838913eee47f5c120a6c53d4565af638158_softmagic.c.diff",
    "function_code": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s)) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t */ \n\t\t\tlen = sizeof(p->s) - sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 419,
    "line_new": 419,
    "critical_vars": [
      "len"
    ],
    "function": "file_check_mem",
    "filename": "file/CVE-2015-8865/CVE-2015-8865_CWE-119_6713ca45e7757297381f4b4cdb9cf5e624a9ad36_funcs.c.diff",
    "function_code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len = 20 + level) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif /* ENABLE_CONDITIONALS */\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 532,
    "line_new": 533,
    "critical_vars": [
      "ss"
    ],
    "function": "cdf_read_short_sector_chain",
    "filename": "file/CVE-2012-1571/CVE-2012-1571_CWE-119_1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b_cdf.c.diff",
    "function_code": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 355,
    "critical_vars": [
      "pos"
    ],
    "function": "cdf_read_short_sector",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_cdf.c.diff",
    "function_code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 355,
    "critical_vars": [
      "pos",
      "len"
    ],
    "function": "cdf_read_short_sector",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_cdf.c.diff",
    "function_code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 133,
    "critical_vars": [
      "root_storage"
    ],
    "function": "cdf_file_property_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const cdf_directory_t *root_storage)\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms) && root_storage)\n\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_FLOAT:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_f) == -1)\n                                return -1;\n                        break;\n                case CDF_DOUBLE:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_d) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (str == NULL && info[i].pi_id ==\n\t\t\t\t    CDF_PROPERTY_NAME_OF_APPLICATION) {\n\t\t\t\t\tstr = cdf_app_to_mime(vbuf, app2mime);\n\t\t\t\t}\n\t\t\t}\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n\t\t\t\tchar tbuf[64];\n                                if (tp < 1000000000000000LL) {\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec, tbuf);\n                                        if (c != NULL &&\n\t\t\t\t\t    (ec = strchr(c, '\\n')) != NULL)\n\t\t\t\t\t\t*ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 239,
    "critical_vars": [
      "clsid"
    ],
    "function": "cdf_file_property_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const uint64_t clsid[2])\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms))\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_FLOAT:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_f) == -1)\n                                return -1;\n                        break;\n                case CDF_DOUBLE:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %g\", buf,\n                            info[i].pi_d) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (str == NULL && info[i].pi_id ==\n\t\t\t\t    CDF_PROPERTY_NAME_OF_APPLICATION) {\n\t\t\t\t\tstr = cdf_app_to_mime(vbuf, app2mime);\n\t\t\t\t}\n\t\t\t}\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n\t\t\t\tchar tbuf[64];\n                                if (tp < 1000000000000000LL) {\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec, tbuf);\n                                        if (c != NULL &&\n\t\t\t\t\t    (ec = strchr(c, '\\n')) != NULL)\n\t\t\t\t\t\t*ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 279,
    "critical_vars": [
      "str"
    ],
    "function": "cdf_file_summary_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const uint64_t clsid[2])\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);\n\t\tif (str)\n                        if (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\treturn -2;\n        }\n\n        m = cdf_file_property_info(ms, info, count, clsid);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 279,
    "critical_vars": [
      "root_storage"
    ],
    "function": "cdf_file_summary_info",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n        m = cdf_file_property_info(ms, info, count, root_storage);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 384,
    "critical_vars": [
      "ms",
      "&scn",
      "i",
      "root_storage->d_storage_uuid",
      "&h"
    ],
    "function": "file_trycdf",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "file_trycdf(struct magic_set *ms, int fd, const unsigned char *buf,\n    size_t nbytes)\n{\n        cdf_info_t info;\n        cdf_header_t h;\n        cdf_sat_t sat, ssat;\n        cdf_stream_t sst, scn;\n        cdf_dir_t dir;\n        int i;\n        const char *expn = \"\";\n        const char *corrupt = \"corrupt: \";\n\n        info.i_fd = fd;\n        info.i_buf = buf;\n        info.i_len = nbytes;\n        if (ms->flags & MAGIC_APPLE)\n                return 0;\n        if (cdf_read_header(&info, &h) == -1)\n                return 0;\n#ifdef CDF_DEBUG\n        cdf_dump_header(&h);\n#endif\n\n        if ((i = cdf_read_sat(&info, &h, &sat)) == -1) {\n                expn = \"Can't read SAT\";\n                goto out0;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_ssat(&info, &h, &sat, &ssat)) == -1) {\n                expn = \"Can't read SSAT\";\n                goto out1;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_dir(&info, &h, &sat, &dir)) == -1) {\n                expn = \"Can't read directory\";\n                goto out2;\n        }\n\n        const cdf_directory_t *root_storage;\n        if ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,\n\t    &root_storage)) == -1) {\n                expn = \"Cannot read short stream\";\n                goto out3;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n#ifdef notdef\n\tif (root_storage) {\n\t\tif (NOTMIME(ms)) {\n\t\t\tchar clsbuf[128];\n\t\t\tif (file_printf(ms, \"CLSID %s, \",\n\t\t\t    format_clsid(clsbuf, sizeof(clsbuf),\n\t\t\t    root_storage->d_storage_uuid)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n        if ((i = cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n            &scn)) == -1) {\n                if (errno == ESRCH) {\n                        corrupt = expn;\n                        expn = \"No summary info\";\n                } else {\n                        expn = \"Cannot read summary info\";\n                }\n                goto out4;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_summary_info(&h, &scn);\n#endif\n        if ((i = cdf_file_summary_info(ms, &h, &scn,\n\t    root_storage->d_storage_uuid)) < 0)\n                expn = \"Can't expand summary_info\";\n\n\tif (i == 0) {\n\t\tconst char *str = NULL;\n\t\tcdf_directory_t *d;\n\t\tchar name[__arraycount(d->d_name)];\n\t\tsize_t j, k;\n\n\t\tfor (j = 0; str == NULL && j < dir.dir_len; j++) {\n\t\t\td = &dir.dir_tab[j];\n\t\t\tfor (k = 0; k < sizeof(name); k++)\n\t\t\t\tname[k] = (char)cdf_tole2(d->d_name[k]);\n\t\t\tstr = cdf_app_to_mime(name,\n\t\t\t    NOTMIME(ms) ? name2desc : name2mime);\n\t\t}\n\t\tif (NOTMIME(ms)) {\n\t\t\tif (str != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", str) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (str == NULL)\n\t\t\t\tstr = \"vnd.ms-office\";\n\t\t\tif (file_printf(ms, \"application/%s\", str) == -1)\n\t\t\t\treturn -1;\n\t\t\ti = 1;\n\t\t}\n\t}\n        free(scn.sst_tab);\nout4:\n        free(sst.sst_tab);\nout3:\n        free(dir.dir_tab);\nout2:\n        free(ssat.sat_tab);\nout1:\n        free(sat.sat_tab);\nout0:\n\tif (i == -1) {\n\t    if (NOTMIME(ms)) {\n\t\tif (file_printf(ms,\n\t\t    \"Composite Document File V2 Document\") == -1)\n\t\t    return -1;\n\t\tif (*expn)\n\t\t    if (file_printf(ms, \", %s%s\", corrupt, expn) == -1)\n\t\t\treturn -1;\n\t    } else {\n\t\tif (file_printf(ms, \"application/CDFV2-corrupt\") == -1)\n\t\t    return -1;\n\t    }\n\t    i = 1;\n\t}\n        return i;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 386,
    "critical_vars": [
      "ms",
      "&scn",
      "root_storage",
      "i",
      "&h"
    ],
    "function": "file_trycdf",
    "filename": "file/CVE-2014-0207/CVE-2014-0207_CWE-119_6d209c1c489457397a5763bca4b28e43aac90391_readcdf.c.diff",
    "function_code": "file_trycdf(struct magic_set *ms, int fd, const unsigned char *buf,\n    size_t nbytes)\n{\n        cdf_info_t info;\n        cdf_header_t h;\n        cdf_sat_t sat, ssat;\n        cdf_stream_t sst, scn;\n        cdf_dir_t dir;\n        int i;\n        const char *expn = \"\";\n        const char *corrupt = \"corrupt: \";\n\n        info.i_fd = fd;\n        info.i_buf = buf;\n        info.i_len = nbytes;\n        if (ms->flags & MAGIC_APPLE)\n                return 0;\n        if (cdf_read_header(&info, &h) == -1)\n                return 0;\n#ifdef CDF_DEBUG\n        cdf_dump_header(&h);\n#endif\n\n        if ((i = cdf_read_sat(&info, &h, &sat)) == -1) {\n                expn = \"Can't read SAT\";\n                goto out0;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_ssat(&info, &h, &sat, &ssat)) == -1) {\n                expn = \"Can't read SSAT\";\n                goto out1;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n        if ((i = cdf_read_dir(&info, &h, &sat, &dir)) == -1) {\n                expn = \"Can't read directory\";\n                goto out2;\n        }\n\n        const cdf_directory_t *root_storage;\n        if ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,\n\t    &root_storage)) == -1) {\n                expn = \"Cannot read short stream\";\n                goto out3;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n#ifdef notdef\n\tif (root_storage) {\n\t\tif (NOTMIME(ms)) {\n\t\t\tchar clsbuf[128];\n\t\t\tif (file_printf(ms, \"CLSID %s, \",\n\t\t\t    format_clsid(clsbuf, sizeof(clsbuf),\n\t\t\t    root_storage->d_storage_uuid)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n        if ((i = cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n            &scn)) == -1) {\n                if (errno == ESRCH) {\n                        corrupt = expn;\n                        expn = \"No summary info\";\n                } else {\n                        expn = \"Cannot read summary info\";\n                }\n                goto out4;\n        }\n#ifdef CDF_DEBUG\n        cdf_dump_summary_info(&h, &scn);\n#endif\n        if ((i = cdf_file_summary_info(ms, &h, &scn, root_storage)) < 0)\n            expn = \"Can't expand summary_info\";\n\n\tif (i == 0) {\n\t\tconst char *str = NULL;\n\t\tcdf_directory_t *d;\n\t\tchar name[__arraycount(d->d_name)];\n\t\tsize_t j, k;\n\n\t\tfor (j = 0; str == NULL && j < dir.dir_len; j++) {\n\t\t\td = &dir.dir_tab[j];\n\t\t\tfor (k = 0; k < sizeof(name); k++)\n\t\t\t\tname[k] = (char)cdf_tole2(d->d_name[k]);\n\t\t\tstr = cdf_app_to_mime(name,\n\t\t\t    NOTMIME(ms) ? name2desc : name2mime);\n\t\t}\n\t\tif (NOTMIME(ms)) {\n\t\t\tif (str != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", str) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (str == NULL)\n\t\t\t\tstr = \"vnd.ms-office\";\n\t\t\tif (file_printf(ms, \"application/%s\", str) == -1)\n\t\t\t\treturn -1;\n\t\t\ti = 1;\n\t\t}\n\t}\n        free(scn.sst_tab);\nout4:\n        free(sst.sst_tab);\nout3:\n        free(dir.dir_tab);\nout2:\n        free(ssat.sat_tab);\nout1:\n        free(sat.sat_tab);\nout0:\n\tif (i == -1) {\n\t    if (NOTMIME(ms)) {\n\t\tif (file_printf(ms,\n\t\t    \"Composite Document File V2 Document\") == -1)\n\t\t    return -1;\n\t\tif (*expn)\n\t\t    if (file_printf(ms, \", %s%s\", corrupt, expn) == -1)\n\t\t\treturn -1;\n\t    } else {\n\t\tif (file_printf(ms, \"application/CDFV2-corrupt\") == -1)\n\t\t    return -1;\n\t    }\n\t    i = 1;\n\t}\n        return i;\n}",
    "label": "False"
  }
]